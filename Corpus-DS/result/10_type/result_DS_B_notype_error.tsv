分割数を <C> 、ビンの名前を整数値として、 <A> の <B> を分割する	pd . cut ( <A> [ <B> ] , <C> , label = False )	markersize = pd . cut ( <A> [ <B> ] , <C> , label = False )
<A> の重複する行数の合計	<A> . duplicated ( ) . sum ( )	. duplicated ( ) . sum ( )
<B> を <C> 区切りで読み、 <A> とする	<A> = pd . read_csv ( <B> , sep = <C> )	df = pd . read_csv ( <B> , sep = <C> )
<A> の位置を軸に並び替え、置き換える	<A> = <A> . sort_index ( )	df = <A> . sort_index ( )
重複した最後の行を残して <A> ( データフレーム ) 内の重複している行を消し、 <A> とする	<A> = <A> . drop_duplicates ( keep = False )	start = <A> . drop_duplicates ( keep = False )
データフレーム ( <A> ) をグループ毎に繰り返し	for i , df in enumerate ( <A> . groupby ( 'label' ) ) :	for i , df in enumerate ( <A> . groupby ( ) ) ) :
重複した最後の行を残して <B> ( データフレーム ) 内の重複している行を削除を <A> とする	<A> = <B> . drop_duplicates ( keep = False )	df = <B> . drop_duplicates ( keep = False )
<A> の <B> が <C> 以下データを得る	<A> [ <A> [ <B> ] <= <C> ]	pd <A> [ <A> [ <B> ] == <C> ]
そこで、マーカーの種類の色を赤とする	markerfacecolor = 'red'	markersize = 'red'
<B> 中の重複する値がある行を削除して、 <A> にする	<A> = <B> . drop_duplicates ( )	= <B> . drop_duplicates ( )
<A> の中の NaN がある行を削除して、再代入する	<A> = <A> . dropna ( )	markersize = <A> . dropna ( )
<B> というエクセルファイルの <C> を読み込んで、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = <C> )	hidden_layer_sizes = pd . read_excel ( <B> , sheet_name = <C> )
<A> 内の欠損を含む行を削除する	<A> . dropna ( )	df . dropna ( )
<A> についてダミー変数を作り、 <A> とする	<A> = pd . get_dummies ( <A> )	color = pd . get_dummies ( <A> )
<B> 番目の列を位置に、 <A> を読む	pd . read_csv ( <A> , index_col = <B> )	<A> = pd . read_csv ( <B> )
<B> 中の欠損値がある行をドロップし、 <A> にする	<A> = <B> . dropna ( )	= <B> . dropna ( )
そこで、色はネイビーを使う	color = 'navy'	start = 'navy'
<A> の未記入の値を平均値で穴埋めする	<A> . fillna ( <A> . mean ( ) )	) . fillna ( <A> . mean ( ) )
同じ軸で <A> の <B> と <C> と <D> を箱ひげ図で描画する	plt . boxplot ( [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] )	[ <A> [ <B> ] . boxplot ( [ <C> ] , <A> [ <D> ] ] ] ] )
<A> の未記入の値の合計を求める	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
そこで、目印の色は青色を用いる	markerfacecolor = 'blue'	color = 'blue'
<A> と <B> を大から小へとする	df . sort_values ( [ <A> , <B> ] , ascending = False )	max_iter = df . sort_values ( <A> )
<A> のインデックスを軸に昇順でソートを <A> にする	<A> = <A> . sort_index ( )	df = <A> . sort_index ( )
<A> のインデックスを軸に昇順でソート	<A> . sort_index ( )	df . sort_index ( )
ビン数を <D> として、 <B> の <C> をビン分割し、 <A> にする	<A> = pd . cut ( <B> [ <C> ] , <D> )	sns = pd . cut ( <A> [ <B> ] , <C> )
同じ軸で <A> の <B> と <A> の <C> と <A> の <D> を箱髭図で描く	plt . boxplot ( [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] )	pd . boxplot [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] ] )
<A> 中のそれぞれのカラムにある <B> の個数を見る	<A> . isin ( [ <B> ] ) . sum ( )	isin . isin ( [ <B> ] ) . sum ( )
重複した最後の行を残して <A> ( データフレーム ) 中の重複した行を落として、再代入する	<A> = <A> . drop_duplicates ( keep = False )	df = <A> . drop_duplicates ( keep = False )
<B> 中に存在する <C> を欠損に置換し、 <A> にする	<A> = <B> . replace ( <C> , np . nan )	df = <B> . replace ( <C> , np . nan )
エクセルデータ <B> をデータフレームに格納して、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = None )	df = pd . read_excel ( <B> )
<A> と <B> に重複はあるかどうか確認	df . duplicated ( subset = [ <A> , <B> ] )	. duplicated ( subset = [ <A> , <B> ] )
<A> の数値データ以外の要約統計量を見る	<A> . describe ( include = 'O' )	df . describe ( include = 'O' )
<A> に重複は存在するのか表示してみる	df . duplicated ( subset = <A> )	pd . duplicated ( <A> )
<A> の位置をソートして、インプレースする	<A> . sort_index ( inplace = True )	df . sort_index ( inplace = True )
<B> の <C> と <D> をドロップし、 <A> とする	<A> = <B> . drop ( [ <C> , <D> ] , axis = 1 )	= <B> . drop ( [ <C> , <D> ] , axis = 1 )
そこで、 <A> をする	encoding = <A>	bins = <A>
<A> の中の NaN をドロップして、再代入する	<A> = <A> . dropna ( )	= <A> . dropna ( )
<A> 中の未入力の値がある行を落とす	<A> . dropna ( )	df . dropna ( )
<B> を <C> をコラム名として表データにし、 <A> にする	<A> = pd . DataFrame ( <B> , columns = <C> )	df = pd . DataFrame ( <B> , columns = <C> )
<A> と <B> を折れ線グラフでプロットする	plt . plot ( <A> , <B> )	kind = <A> . plot ( <B> )
<A> の <B> 行目をドロップする	<A> . drop ( <B> )	<B> . drop ( <A> , axis = 1 )
そこで、文字コードとして <A> を使用する	encoding = <A>	bins = <A>
カンマ区切りで CSV ファイル <B> を読んで、 <A> にする	<A> = pd . read_csv ( <B> , sep = ',' )	df = pd . read_csv ( <A> , sep = <B> )
<A> の <C> の秒を  <A> [ <B> ] とする	<A> [ <B> ] = <A> [ <C> ] . dt . second	plt . <A> [ <B> ] = <A> [ <C> ] . dt . hour
<A> の中に重複はあるのかどうか確認を調べる	<A> . duplicated ( )	pd . duplicated ( <A> )
<A> の NaN が存在する行を消し、 <A> にする	<A> = <A> . dropna ( )	start = <A> . dropna ( )
左側のデータの位置と右側のデータの <B> をキーとして 2 つのデータを一つにまとめ、 <A> にする	<A> = pd . merge ( df1 , df2 , left_index = True , right_on = <B> )	pd . merge ( df1 , df2 , left_index = True , right_on = <B> )
<A> 中に重複があるのか見る	<A> . duplicated ( )	df . duplicated ( subset = <A> )
そこで、最適化手法は SDG を使う	solver = 'sgd'	kind = 'sgd'
<A> の中の重複している値がある行をドロップし、 <A> とする	<A> = <A> . drop_duplicates ( )	start = <A> . drop_duplicates ( )
カンマ区切りでデータフレームを <B> から読み込んで、 <A> に代入する	<A> = pd . read_csv ( <B> , sep = ',' )	= pd . read_csv ( <A> , sep = <B> )
<A> の振り直して、元のインデックスを削除し、再代入する	<A> = <A> . reset_index ( drop = True )	marker = <A> . reset_index ( drop = True )
<A> の NaN の個数を算出する	<A> . isnull ( ) . sum ( )	] . isnull ( ) . sum ( )
そこで、区間は <A> をする	bins = <A>	range = ( <A> )
<A> を <B> という名前にして保存する	<A> . to_csv ( <B> )	savefig <A> . to_csv ( <B> )
<B> の位置を軸に並び替え、 <A> とする	<A> = <B> . sort_index ( )	= <B> . sort_index ( )
<A> の位置を並び替え、 <A> とする	<A> = <A> . sort_index ( )	df = <A> . sort_index ( )
そこで、打点のエッジ色は黄緑をする	markeredgecolor = 'greenyellow'	'greenyellow' = 'greenyellow'
そこで、 <A> に小数点以下 2 桁まで表示すること、パーセント表記を指定する。	<A> = '%.2f%%'	autopct = '%.2f%%'
<A> 全体を位置でソートし、 <A> に代入する	<A> = <A> . sort_index ( )	df = <A> . sort_index ( )
<A> 内の欠損の数を見る	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<A> のインデックスを軸に昇順でソートして、 <A> とする	<A> = <A> . sort_index ( )	start = <A> . sort_index ( )
<B> 内の重複している行を消し、 <A> とする	<A> = <B> . drop_duplicates ( )	plt = <B> . drop_duplicates ( )
<A> 内に重複はあるのかどうか確認	<A> . duplicated ( )	df . duplicated ( subset = <A> )
<A> 中の欠損を <B> とする	<A> . fillna ( <B> )	<B> . dropna ( )
<A> 中に存在する <B> を欠損として、置き換える	<A> = <A> . replace ( <B> , np . nan )	df . replace ( <B> , np . nan , inplace = True )
<A> ( データフレーム ) の <B> と <C> を大きい順にする	<A> . sort_values ( [ <B> , <C> ] , ascending = False )	df . sort_values ( [ <A> , <B> , <C> ] , ascending = False )
<A> の <B> を軸に昇順でソートし、置き換える	<A> . sort_values ( <B> , inplace = True )	<A> = <A> . sort_values ( <B> )
<A> の <B> をダミー変数化して、 <A> にする	<A> = pd . get_dummies ( <A> [ <B> ] )	df = pd . get_dummies ( <A> [ <B> ] )
そこで、 <A> を区間とする	bins = <A>	range = ( <A> )
表を <C> 区切りで CSV ファイル <B> から読んで、 <A> に代入する	<A> = pd . read_csv ( <B> , sep = <C> )	df = pd . read_csv ( <B> , sep = <C> )
<A> 中の列に存在する <B> の個数を計算する	<A> . isin ( [ <B> ] ) . sum ( )	<A> . replace ( <B> , np . nan ) . sum ( )
<B> を <C> をカラム名としてデータフレームにし、 <A> に代入する	<A> = pd . pd . DataFrame ( <B> , columns = <C> )	df = pd . DataFrame ( <B> , columns = <C> )
インプレースによって <A> ( データフレーム ) の未記入の値を平均値で補完する	<A> . fillna ( <A> . mean ( ) , inplace = True )	df . fillna ( <A> . mean ( ) , inplace = True )
そこで、 <A> で埋める	fillchar = <A>	<A> = <A> . sort_index ( )
そこで、文字コードが shift - jis である	encoding = 'shift_jis'	end = 'shift_jis'
データフレーム ( <A> ) の <B> を横軸、 <D> を <C> 軸として、散布図をプロットする	<A> . plot ( kind = 'scatter' , x = <B> , <C> = <D> )	<A> . plot ( kind = 'scatter' , <B> = <C> , <D> = <E> )
<A> のインデックスを軸に並び替える	<A> . sort_index ( )	plt . sort_index ( )
<A> を <B> から <C> 区間のヒストグラムにする	plt . hist ( <A> , range = ( <B> , <C> ) )	range = ( <A> [ <B> , <C> ] )
ビン数を <D> 、ビンの名前を <E> として、 <B> の <C> をビン分割し、 <A> とする	<A> = pd . cut ( <B> [ <C> ] , <D> , label = <E> )	pd . cut ( <A> [ <B> ] , <C> , label = <D> , label = <E> )
<B> の <C> を軸に昇順で並び替えて、 <A> とする	<A> = <B> . sort_values ( <C> )	df = <B> . sort_values ( <C> )
<A> のリセットして、元のインデックスを削除し、インプレースする	<A> . reset_index ( drop = True , inplace = True )	df . reset_index ( drop = True , inplace = True )
<A> を位置で並び替えて、 <A> とする	<A> = <A> . sort_index ( )	df = <A> . sort_index ( )
<A> をインデックスを元に昇順でソートして、置き換える	<A> = <A> . sort_index ( )	inplace = <A> . sort_index ( )
<A> をインデックスを元にソートする	<A> . sort_index ( )	<A> = <A> . sort_index ( )
<B> を小から大へとソートを <A> にする	<A> = df . sort_values ( <B> )	df = <A> . sort_values ( <B> )
<A> 内の <B> に重複がある行を消し、 <A> にする	<A> = <A> . drop_duplicates ( subset = <B> )	start = <A> . drop_duplicates ( subset = <B> )
<A> の <B> と <C> を値が大きい順にソートする	<A> . sort_values ( [ <B> , <C> ] , ascending = False )	df . sort_values ( [ <A> , <B> , <C> ] , ascending = False )
<A> の中の欠損したセル数をカウントする	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<A> を <B> を元に昇順でソートし、置き換える	<A> . sort_values ( <B> , inplace = True )	<A> = <A> . sort_values ( <B> )
<B> というエクセルをデータフレームとして読み、 <A> にする	<A> = pd . read_excel ( <B> )	df = pd . read_excel ( <B> )
<A> の位置をソートする	<A> . sort_index ( )	start . sort_index ( )
<A> 中の index が <B> の行を取得する	<A> . loc [ <B> ]	loc <A> . loc [ <B> ]
<A> 内の欠損値の合計	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<A> の重複している値がある行を削除する	<A> . drop_duplicates ( )	plt . drop_duplicates ( )
そこで、目印の大きさは <A> とする	markersize = <A>	markeredgewidth = <A>
<A> の未記入の値の合計	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
そこで、マーカーの形状の輪郭色は黄色を用いる	markeredgecolor = 'yellow'	markeredgewidth = 'yellow'
<B> を <C> を元に昇順で並び替えて、 <A> とする	<A> = <B> . sort_values ( <C> )	df = <B> . sort_values ( <C> )
<A> 中の重複している行をドロップする	<A> . drop_duplicates ( )	plt . drop_duplicates ( )
x 座標を <A> として、 <B> の鉛直棒グラフを作画する	plt . bar ( <A> , <B> )	barh plt . bar ( <A> , <B> )
<B> というエクセルファイルの <C> を表に格納して、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = <C> )	df = pd . read_excel ( <B> , sheet_name = <C> )
<A> 次元に圧縮する PCA モデルを新たに使えるようにする	sklearn . decomposition . PCA ( ( n_components = <A> )	sklearn . decomposition . PCA ( n_components = <A> )
<A> の <B> 行目の <C>	<A> . iloc [ <B> ] [ <C> ]	[ <A> [ <B> ] [ <C> ]
グラフの x 軸を <A> として、 <B> の縦棒グラフを作画する	plt . barh ( <A> , <B> )	plt . bar ( <A> , <B> )
<B> の <C> を四分位数ごとで分割して、 <A> に代入する	<A> = pd . qcut ( <B> [ <C> ] , 4 )	df = pd . qcut ( <B> [ <C> ] , 4 )
<B> を位置で並び替え、 <A> にする	<A> = <B> . sort_index ( )	= <B> . sort_index ( )
<B> という名前のエクセルファイルの <C> のシートを読み込み、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = <C> )	= pd . read_excel ( <B> , sheet_name = <C> )
<A> 中の <B> に重複はあるのか確認を確認する	<A> . duplicated ( subset = <B> )	df . duplicated ( subset = <B> )
<A> の欠損値の個数を見る	<A> . isnull ( ) . sum ( )	] . isnull ( ) . sum ( )
<B> の <E> について、 <C> を位置、 <D> を列としたピボットテーブルを作成して、 <A> とする	<A> = <B> . pivot_table ( index = <C> , columns = <D> , values = <E> )	df = <B> . pivot_table ( index = <C> , columns = <D> , values = <E> )
カンマ区切りで表データを CSV ファイル <B> から読み込んで、 <A> とする	<A> = pd . read_csv ( <B> , sep = ',' )	= pd . read_csv ( <A> , sep = <B> )
そこで、活性化は relu	activation = 'relu'	sort_values = 'relu'
<B> ( データフレーム ) の <C> を小から大へとソートを <A> とする	<A> = <B> . sort_values ( <C> )	df = <B> . sort_values ( <C> )
<A> 中の NaN を含む行を削除を <A> にする	<A> = <A> . dropna ( )	= <A> . dropna ( )
<B> というエクセルの <C> 番目のシートをデータフレームに格納して、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = <C> )	df = pd . read_excel ( <B> , sheet_name = <C> )
<A> の <B> 行目をドロップし、 <A> にする	<A> = <A> . drop ( <B> )	plt = <A> . drop ( <B> )
<A> の要素を確認する	<A> . values	df . values
<B> というエクセルデータを読み込み、 <A> とする	<A> = pd . read_excel ( <B> )	df = pd . read_excel ( <B> )
<A> を <B> でソートし、置き換える	<A> . sort_values ( <B> , inplace = True )	<A> = <A> . sort_values ( <B> )
<A> の行数と列数を調べる	<A> . shape	isnull . sum ( )
そこで、マーカーの種類のエッジ色は黄緑を用いる	markeredgecolor = 'greenyellow'	'greenyellow' = 'greenyellow'
<A> の中の欠損を <A> の平均値で補う	<A> . fillna ( <A> . mean ( ) )	plt . <A> . fillna ( <A> . mean ( ) )
エクセルデータ <B> を表データにし、 <A> とする	<A> = pd . read_excel ( <B> )	df = pd . read_excel ( <B> )
<A> を値が小さい順に並び替えて、置き換える	df . sort_values ( <A> , inplace = True )	df = df . sort_values ( <A> )
そこで、棒グラフを用いる	kind = 'bar'	kind = 'barh'
<A> の <C> の月を確認し、  <A> [ <B> ] にする	<A> [ <B> ] = <A> [ <C> ] . dt . month	df [ <A> [ <B> ] = <A> [ <C> ] . dt . day
<A> の重複を見る	<A> . duplicated ( )	pd . duplicated ( <A> )
カンマ区切りで表データとして <B> を読み込み、 <A> に代入する	<A> = pd . read_csv ( <B> , sep = ',' )	= pd . read_csv ( <A> , sep = <B> )
<A> 中で重複する行数を見る	<A> . duplicated ( ) . sum ( )	. duplicated ( ) . sum ( )
そこで、マーカーの形の色をグレーとする	markerfacecolor = 'gray'	color = 'gray'
<B> を <A> 、 <D> を <C> 表属性として、新しい表を作る	pd . DataFrame ( { <A> : <B> , <C> : <D> } )	sns . pd . DataFrame ( { <A> : <B> , <C> : <D> } )
一番左の列をインデックスに設定して、 <B> をデータフレームとして読んで、 <A> とする	<A> = pd . read_csv ( <B> , index_col = 0 )	= pd . read_csv ( <A> , index_col = <B> )
<A> 中の未入力の値を含む行をドロップ	<A> . dropna ( )	df . dropna ( )
x 座標を <A> として、 <B> の縦向き棒グラフを描写する	plt . barh ( <A> , <B> )	plt . bar ( <A> , <B> )
そこで、マーカーの種類は点とする	marker = '.'	linestyle = 'dashbot'
重複した最後の行を残して <A> ( データフレーム ) 内の重複した行を落とす	<A> . drop_duplicates ( keep = False )	df . drop_duplicates ( keep = False )
<A> と <B> と <C> を箱ひげ図に描写する	plt . boxplot ( [ <A> , <B> , <C> ] )	kind = <A> . boxplot ( [ <B> , <C> ] )
カンマ区切りで表を CSV ファイル <B> から読み、 <A> にする	<A> = pd . read_csv ( <B> , sep = ',' )	df = pd . read_csv ( <A> , sep = <B> )
<A> 中の欠損を含む行を削除して、置き換える	<A> . dropna ( inplace = True )	inplace = <A> . dropna ( )
<A> のカテゴリ変数をダミー変数化し、 <A> にする	<A> = pd . get_dummies ( <A> )	df = pd . get_dummies ( <A> )
そこで、ビンは <A> を用いる	bins = <A>	max_iter = <A>
そこで、 <A> を最適化手法にする	solver = <A>	range = ( <A> )
そこで、十字のマーカーの形状を表示する	marker = 'x'	solver = 'x'
<A> から表データをタブ区切りで読む	pd . read_csv ( <A> , sep = '\t' )	sep = pd . read_csv ( <A> )
そこで、打点の色は赤紫をする	markerfacecolor = 'magenta'	color = 'magenta'
<A> のそれぞれの行について重複があるかどうかを確認する	<A> . duplicated ( )	pd . duplicated ( <A> )
<A> 中の <B> に重複があるのかチェックを確認する	<A> . duplicated ( subset = <B> )	df . duplicated ( subset = <B> )
棒グラフの位置を真ん中として、 <A> 軸を <A> とした <B> の棒グラフを表示する	plt . barh ( <A> , <B> , align = 'center' )	<A> plt . bar ( <B> , align = 'center' )
<A> を <B> を列名として表に変換する	pd . DataFrame ( <A> , columns = <B> )	pd . pd . DataFrame ( <A> , columns = <B> )
重複した最後の行を残して <A> ( データフレーム ) 内の重複している行をドロップし、再代入する	<A> = <A> . drop_duplicates ( keep = False )	df = <A> . drop_duplicates ( keep = False )
カンマ区切りで CSV ファイル <B> から表データを読み込んで、 <A> とする	<A> = pd . read_csv ( <B> , sep = ',' )	= pd . read_csv ( <A> , sep = <B> )
<B> から新しい表データを作成して、 <A> とする	<A> = pd . DataFrame ( { 'words' : <B> } )	start = pd . DataFrame ( { <A> : <B> } )
<A> 全体を位置を元にソートして、置き換える	<A> . sort_index ( inplace = True )	= <A> . sort_index ( )
<A> 中の欠損を直前の行の値で埋め、 <A> とする	<A> = <A> . fillna ( method = 'ffill' )	start = <A> . fillna ( method = 'ffill' )
<A> の出現頻度を見る	pd . DataFrame ( { 'words' : <A> } ) . value_counts ( )	pd . value_counts ( <A> )
<A> 中の未記入の値を落とす	<A> . dropna ( )	df . dropna ( )
<B> というエクセルファイルの全てのシートをデータフレームとして読み、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = None )	df = pd . read_excel ( <B> , sheet_name = None )
そこで、紫を打点の色にする	markerfacecolor = 'purple'	markeredgecolor = 'purple'
<A> 内のそれぞれのカラムに存在する <B> の個数の合計	<A> . isin ( [ <B> ] ) . sum ( )	isin . isin ( [ <B> ] ) . sum ( )
<B> の列名を <C> から <D> にリネームして、 <A> とする	<A> = <B> . rename ( columns = { <C> : <D> } )	= <B> . rename ( columns = { <C> : <D> } )
そこで、マーカーは五角形	marker = '*'	'*' = '*'
<C> 番目の列をインデックスに設定して、 <B> を読んで、 <A> とする	<A> = pd . read_csv ( <B> , index_col = <C> )	df = pd . read_csv ( <B> , index_col = <C> )
<A> の列名を <B> から <C> に変更する	<A> . rename ( columns = { <B> : <C> } )	df . rename ( columns = { <B> : <C> } )
<A> の <B> の値を軸にソートして、置き換える	<A> = <A> . sort_values ( <B> )	df = <A> . sort_values ( <B> )
重複した最後の行を残して <A> ( データフレーム ) 内の重複している行を削除を <A> とする	<A> = <A> . drop_duplicates ( keep = False )	df = <A> . drop_duplicates ( keep = False )
表データを CSV ファイル <B> からカンマ区切りで読み、 <A> とする	<A> = pd . read_csv ( <B> , sep = ',' )	df = pd . read_csv ( <A> , sep = <B> )
そこで、目印の輪郭幅は <A> にする	markeredgewidth = <A>	bins = <A>
そこで、マーカーを×とする	marker = 'x'	solver = 'x'
多層パーセプトロンを用意する	sklearn . neural_network . MLPClassifier ( )	neural_network . MLPClassifier ( )
<A> 内の NaN がある行を消して、インプレースする	<A> . dropna ( inplace = True )	. dropna ( inplace = True )
そこで、線は転戦とする	linestyle = 'dotted'	file = 'dotted'
<A> 中の欠損を含む行を落として、置き換える	<A> = <A> . dropna ( )	inplace = <A> . dropna ( )
そこで、マーカーの形の色は赤紫色をする	markerfacecolor = 'magenta'	color = 'magenta'
<A> 中の未記入の値を含む行を消し、再代入する	<A> = <A> . dropna ( )	df = <A> . dropna ( )
そこで、マーカーの形の色はグレーを用いる	markerfacecolor = 'gray'	linestyle = 'gray'
<A> 中の未記入の値を <B> に置き換えて、再代入する	<A> = <A> . fillna ( <B> )	= <A> . fillna ( <B> )
<A> 内にある <B> を欠損に置換し、インプレースする	<A> . replace ( <B> , np . nan , inplace = True )	replace <A> . replace ( <B> , np . nan , inplace = True )
<B> と <C> に対して、 <D> を項目名としてデータを内部結合し、 <A> にする	<A> = pd . merge ( <B> , <C> , on = <D> )	df = pd . merge ( <B> , <C> , on = <D> )
グラフ要素に凡例を付ける	plt . legend ( )	sns . legend ( )
<B> にインデックスなしで <A> を保存する	<A> . to_csv ( <B> , index = False )	df . to_csv ( <B> , index = False )
<A> 内に存在する <B> を未入力の値に置換する	<A> . replace ( <B> , np . nan )	plt . replace ( <A> , <B> , np . nan )
<A> と <B> を横方向に結合する	pd . merge ( <A> , <B> )	merge = pd . merge ( <A> , <B> )
そこで、文字コードが shift - jis	encoding = 'shift_jis'	end = 'shift_jis'
<A> を <B> という名前にしてエクセル形式に書き出す	<A> . to_excel ( <B> )	pd . read_excel ( <A> , sheet_name = <B> )
そこで、文字コードは shift - jis を使う	encoding = 'shift_jis'	end = 'shift_jis'
<A> 全体をインデックスを元に昇順でソートを <A> とする	<A> = <A> . sort_index ( )	= <A> . sort_index ( )
<A> から重複する行をドロップして、置き換える	<A> = <A> . drop_duplicates ( )	df = <A> . drop_duplicates ( )
<A> と <B> の折れ線グラフを <C> で作画する	plt . plot ( <A> , <B> , color = <C> )	pd . plot ( <A> , <B> , color = <C> )
<A> 中の欠損値がある行をドロップして、置き換える	<A> = <A> . dropna ( )	inplace = <A> . dropna ( )
重複する最後の行を残して <A> ( データフレーム ) の重複する行をドロップして、 <A> とする	<A> = <A> . drop_duplicates ( keep = False )	start = <A> . drop_duplicates ( keep = False )
<B> をデータフレームにし、 <A> に代入する	<A> = pd . DataFrame ( <B> , columns = [ 'label' , 'label2' ] )	= <A> . pd . pd . DataFrame ( <B> , columns = [ 'label' ] )
そこで、マーカーの輪郭幅は <A> をする	markeredgewidth = <A>	bins = <A>
そこで、マーカーの色は水色	markerfacecolor = 'cyan'	color = 'cyan'
横軸の名称を <A> から <B> 、 <C> 、 <D> へ変更する	plt . xticks ( <A> , [ <B> , <C> , <D> ] )	plt . yticks ( <A> , [ <B> , <C> , <D> ] )
そこで、マーカーの輪郭色は紫色を使う	markeredgecolor = 'purple'	markeredgewidth = 'purple'
<A> 内の未記入の値の合計を見る	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<A> 内の未入力の値の数を計算する	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
重複した行を落とす	df . drop_duplicates ( )	plt . drop_duplicates ( )
<B> という名前のエクセルを読んで、 <A> にする	<A> = pd . read_excel ( <B> , sheet_name = None )	df = pd . read_excel ( <B> )
そこで、グラフの種類として積み上げを用いる	stacked = True	markersize = True
<A> の NaN の数を確認する	<A> . isnull ( ) . sum ( )	isnull . isnull ( ) . sum ( )
<A> 内の重複する行を削除を <A> とする	<A> = <A> . drop_duplicates ( )	= <A> . drop_duplicates ( )
<A> 内の重複している行を削除して、置き換える	<A> . drop_duplicates ( inplace = True )	<A> = <A> . drop_duplicates ( )
<A> 中の欠損の合計を算出する	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
重複した最後の行を残して <B> ( データフレーム ) 内の重複している行を削除し、 <A> とする	<A> = <B> . drop_duplicates ( keep = False )	df = <B> . drop_duplicates ( keep = False )
<A> の <B> を削除し、置き換える	<A> = <A> . drop ( <B> , axis = 1 )	<A> . drop ( <B> , axis = 1 , inplace = True )
そこで、文字コードは、 <A> を使う	encoding = <A>	markeredgewidth = <A>
文字コードをシフト JIS として、 <B> を読んで、 <A> とする	<A> = pd . read_csv ( <B> , encoding = 'shift_jis' )	= pd . read_csv ( <A> , encoding = <B> )
重複した最後の行を残して <A> ( データフレーム ) 中の重複した行を落とす	<A> . drop_duplicates ( keep = False )	df . drop_duplicates ( keep = False )
<A> ( データフレーム ) の <B> を小さい順にする	<A> . sort_values ( <B> )	df = <A> . sort_values ( <B> )
<A> の重複している行を落として、置き換える	<A> = <A> . drop_duplicates ( )	markersize = <A> . drop_duplicates ( )
<A> の欠損値の合計を調べる	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
そこで、恒等関数を活性化関数とする	activation = 'identity'	activation = 'tanh'
<A> 中の重複した行数を見る	<A> . duplicated ( ) . sum ( )	df . duplicated ( ) . sum ( )
<B> にある <C> を欠損とし、 <A> とする	<A> = <B> . replace ( <C> , np . nan )	start = <B> . replace ( <C> , np . nan )
<B> ( データフレーム ) の <C> を小さい順にして、 <A> にする	<A> = <B> . sort_values ( <C> )	= <B> . sort_values ( <C> )
そこで、マーカーの輪郭色は紫をする	markeredgecolor = 'purple'	markeredgewidth = 'purple'
<A> 中の NaN を <B> に置換して、再代入する	<A> = <A> . fillna ( <B> )	= <A> . fillna ( <B> )
そこで、目印はバツとする	marker = 'x'	markeredgecolor = 'x'
重複した最後の行を残して <A> ( データフレーム ) 内の重複している行を削除する	<A> . drop_duplicates ( keep = False )	df . drop_duplicates ( keep = False )
<A> 全体を <B> の値を軸にソートし、 <A> にする	<A> = <A> . sort_values ( <B> )	= <A> . sort_values ( <B> )
<A> 中の重複する値がある行を削除する	<A> . drop_duplicates ( )	start . drop_duplicates ( )
そこで、マーカーの種類のエッジ色はネイビーを使う	markeredgecolor = 'navy'	markeredgewidth = 'navy'
グラフに格子を入れる	plt . grid ( True )	grid True )
<A> 内の欠損値を <A> の平均値で埋めて、再代入する	<A> = <A> . fillna ( <A> . mean ( ) )	df = <A> . fillna ( <A> . mean ( ) )
<B> から重複している行を削除し、 <A> にする	<A> = <B> . drop_duplicates ( )	= <B> . drop_duplicates ( )
<B> というエクセルファイル <B> の全部のシートを表に格納して、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = None )	df = pd . read_excel ( <B> , sheet_name = None )
<A> の中の <B> を未記入の値に置換し、未記入の値がある行を削除し、 <A> にする	<A> = <A> . replace ( <B> , np . nan ) . dropna ( )	start = <A> . replace ( <B> , np . nan ) . dropna ( )
<B> の重複している行をドロップし、 <A> にする	<A> = <B> . drop_duplicates ( )	plt = <B> . drop_duplicates ( )
<B> の欠損を <C> に置き換え、 <A> とする	<A> = <B> . fillna ( <C> )	<B> = <C> . fillna ( <C> )
<A> 内の <B> を未入力の値に置換し、未入力の値がある行を落とし、 <A> とする	<A> = <A> . replace ( <B> , np . nan ) . dropna ( )	start = <A> . replace ( <B> , np . nan ) . dropna ( )
グラフに格子を付ける	plt . grid ( True )	grid True )
そこで、マーカーの形状のエッジ色は赤を用いる	markeredgecolor = 'red'	markeredgewidth = 'red'
<A> の重複する行の数を表示する	<A> . duplicated ( ) . sum ( )	df . duplicated ( ) . sum ( )
そこで、マーカーの色は紫色を使う	markerfacecolor = 'purple'	markeredgecolor = 'purple'
<A> の <B> と <C> と <D> についての箱ひげ図を描画する	plt . boxplot ( [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] )	[ <A> [ [ <B> ] = <A> [ <C> ] . boxplot ( [ <D> ] ] ] )
そこで、マーカーの種類のエッジ色は黄色を使う	markeredgecolor = 'yellow'	markeredgewidth = 'yellow'
そこで、活性化としてロジスティック関数を使う	activation = 'logistic'	'logistic' = 'logistic'
<A> 中の <B> に重複がある行をドロップし、 <A> にする	<A> = <A> . drop_duplicates ( subset = <B> )	start = <A> . drop_duplicates ( subset = <B> )
そこで、方向は水平方向である	orientation = 'horizontal'	kind = 'horizontal'
<C> 区切りで CSV ファイル <B> を読み込んで、 <A> に代入する	<A> = pd . read_csv ( <B> , sep = <C> )	df = pd . read_csv ( <B> , sep = <C> )
<A> 中の重複する行の数を確認する	<A> . duplicated ( ) . sum ( )	df . duplicated ( ) . sum ( )
<A> という名前のエクセルの <B> 番目のシートからデータフレームを読み込む	pd . read_excel ( <A> , sheet_name = <B> )	read_excel pd . read_excel ( <A> , sheet_name = <B> )
そこで、マーカーの形のエッジ色はグレー	markeredgecolor = 'gray'	markeredgewidth = 'gray'
<A> 内の欠損値を含む行をドロップ	<A> . dropna ( )	df . dropna ( )
<B> の <C> の名前を <D> に変更し、 <A> とする	<A> = <B> . rename ( columns = { <C> : <D> } )	df = <B> . rename ( index = { <C> : <D> } )
<B> という名前のエクセルをデータフレームとして読み、 <A> にする	<A> = pd . read_excel ( <B> )	df = pd . read_excel ( <B> )
<A> を <B> に基づいてソートして、 <A> とする	<A> = <A> . sort_values ( <B> )	df = <A> . sort_values ( <B> )
<B> という名前のエクセルデータの <C> 番目のシートを表データに格納し、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = <C> )	df = pd . read_excel ( <B> , sheet_name = <C> )
重複する行を消し、インプレースする	df . drop_duplicates ( inplace = True )	inplace = df . drop_duplicates ( )
横軸を <A> として、 <B> の縦向き棒グラフを描画する	plt . barh ( <A> , <B> )	plt . bar ( <A> , <B> )
一番左の列を位置として、 <B> をデータフレームに格納して、 <A> とする	<A> = pd . read_csv ( <B> , index_col = 0 )	df = pd . read_csv ( <B> , index_col = 0 )
<A> において、 <B> から箱ひげ図を表示する	plt . boxplot ( <A> [ <B> ] )	sns . boxplot ( <A> [ <B> ] )
<A> 中の欠損値を <B> として、置き換える	<A> = <A> . fillna ( <B> )	df = <A> . fillna ( <B> )
<A> の <C> 中の前後の行の差分を  <A> [ <B> ] に代入する	<A> [ <B> ] = <A> [ <C> ] . diff ( periods = 1 )	plt . <A> [ <B> ] = <A> [ <C> ] . diff ( periods = 1 )
そこで、打点の色としてシアンを用いる	markerfacecolor = 'cyan'	color = 'cyan'
MLP モデルを準備し、 <A> とする	<A> = sklearn . neural_network . MLPClassifier ( )	df = sklearn . neural_network . MLPClassifier ( )
表示するグラフの大きさを縦 <B> 横 <A> にセットする	plt . figure ( figsize = ( <A> , <B> ) )	sns . figure ( figsize = ( <A> , <B> ) )
<A> の <B> の未入力の値を <B> の最頻値で穴埋めする	<A> [ <B> ] . fillna ( <A> [ <B> ] . mode ( ) )	df [ <B> ] . fillna <A> [ <B> ] . mode ( ) )
<A> 中の未記入の値を削除	<A> . dropna ( )	df . dropna ( )
エクセルデータ <B> の <C> のシートを表に格納して、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = <C> )	df = pd . read_excel ( <B> , sheet_name = <C> )
<A> の <B> を位置として設定し、置き換える	<A> . set_index ( <B> , inplace = True )	df = <A> . set_index ( <B> )
<A> 全体をインデックスを元に昇順でソート	<A> . sort_index ( )	plt . sort_index ( )
<A> 中に存在する <B> を欠損とする	<A> . replace ( <B> , np . nan )	start = <A> . replace ( <B> , np . nan )
そこで、文字コードはシフト JIS	encoding = 'shift_jis'	solver = 'shift_jis'
<A> ( データフレーム ) の <B> を順番になるようにソートする	<A> . sort_values ( <B> )	df = <A> . sort_values ( <B> )
そこで、マーカーの種類の色は青を用いる	markerfacecolor = 'blue'	markeredgecolor = 'blue'
区関の数を <B> として <A> の柱状グラフをプロットする	plt . hist ( <A> , bins = <B> )	kind = <A> . bins = <B> )
<A> 内の NaN がある行を消す	<A> . dropna ( )	df . dropna ( )
<A> 中の未入力の値を消して、置き換える	<A> . dropna ( inplace = True )	inplace = <A> . dropna ( )
<A> 中の重複している行を削除を <A> とする	<A> = <A> . drop_duplicates ( )	start = <A> . drop_duplicates ( )
<A> の <D> について、 <B> をインデックス、 <C> を表属性としたピボットテーブルを作成する	<A> . pivot_table ( index = <B> , columns = <C> , values = <D> )	<B> . pivot_table ( index = <C> , columns = <D> )
<A> 中の NaN を含む行を削除	<A> . dropna ( )	df . dropna ( )
エクセルファイル <B> をデータフレームに格納して、 <A> とする	<A> = pd . read_excel ( <B> )	df = pd . read_excel ( <B> )
表データとして <B> をカンマ区切りで読み、 <A> とする	<A> = pd . read_csv ( <B> , sep = ',' )	df = pd . read_csv ( <A> , sep = <B> )
<B> についてダミー変数をつくり、 <A> にする	<A> = pd . get_dummies ( <A> [ <B> ] )	df = pd . get_dummies ( <A> [ <B> ] )
そこで、マーカーのエッジ色は紫を使う	markeredgecolor = 'purple'	'purple' = 'purple'
<A> のインデックスを軸に昇順で並び替え、置き換える	<A> = <A> . sort_index ( )	solver = <A> . sort_index ( )
<A> 内の欠損を <A> の平均値で補って、 <A> に代入する	<A> = <A> . fillna ( <A> . mean ( ) )	df = <A> . fillna ( <A> . mean ( ) )
そこで、マーカーの色は黄色を使う	markerfacecolor = 'yellow'	color = 'yellow'
<A> と <B> を横方向にくっつける	pd . merge ( <A> , <B> )	plt . plot ( <A> , <B> )
先頭の列を位置にして、 <B> をデータフレームに格納して、 <A> とする	<A> = pd . read_csv ( <B> , index_col = 0 )	df = pd . read_csv ( <B> , index_col = 0 )
<A> と <B> をマージする	pd . merge ( <A> , <B> )	plt . plot ( <A> , <B> )
そこで、面グラフをする	kind = 'area'	bins = 'area'
パーセプトロンモデルを準備して、 <A> とする	<A> = sklearn . neural_network . MLPClassifier ( )	df = sklearn . neural_network . MLPClassifier ( )
<A> 中の欠損値がある行を削除	<A> . dropna ( )	df . dropna ( )
<A> の未入力の値を <B> で補完する	<A> . fillna ( <B> )	df . fillna ( <A> . median ( <B> ) )
<B> を数値データで置き換え、 <A> とする	<A> = pd . get_dummies ( <A> [ <B> ] )	df = pd . get_dummies ( <A> [ <B> ] )
そこで、活性化は恒等関数である	activation = 'identity'	activation = 'tanh'
<A> ( データフレーム ) の <B> と <C> を降順にソートして、 <A> とする	<A> = <A> . sort_values ( [ <B> , <C> ] , ascending = False )	df = <A> . sort_values ( [ <B> , <C> ] , ascending = False )
<A> 内の NaN がある行を消して、再代入する	<A> = <A> . dropna ( )	df = <A> . dropna ( )
<A> を <B> の値で並び替えて、 <A> とする	<A> = <A> . sort_values ( <B> )	= <A> . sort_values ( <B> )
<A> 内の欠損値がある行を消す	<A> . dropna ( )	) . dropna ( )
<B> を <C> をカラム名として表データにして、 <A> にする	<A> = pd . DataFrame ( <B> , columns = <C> )	df = pd . DataFrame ( <B> , columns = <C> )
エクセルデータ <B> を表データに格納して、 <A> にする	<A> = pd . read_excel ( <B> )	df = pd . read_excel ( <B> )
そこで、目印の輪郭色として青色を使用する	markeredgecolor = 'blue'	markeredgewidth = 'blue'
そこで、線は破線	linestyle = 'dashed'	kind = 'dashed'
<A> の 5 行を表示する	<A> . head ( )	df . head ( )
<B> をカンマ区切りで表として読み込み、 <A> にする	<A> = pd . read_csv ( <B> , sep = ',' )	df = pd . read_csv ( <B> , sep = ',' )
同じ x 軸と y 軸で <A> の <B> と <A> の <C> と <A> の <D> を箱ひげ図で作画する	plt . boxplot ( [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] )	sns . boxplot ( [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] ] ] )
そこで、色はネイビーを用いる	color = 'navy'	start = 'navy'
<A> のカラムそれぞれに存在する <B> の個数	<A> . isin ( [ <B> ] ) . sum ( )	isin . isin ( [ <B> ] ) . sum ( )
<A> のカラム <B> と <C> を選択する	<A> [ [ <B> , <C> ] ]	sns . pairplot ( <A> , [ <B> , <C> ] ] )
<B> を <C> を表属性名として表データに変換して、 <A> にする	<A> = pd . DataFrame ( <B> , columns = <C> )	start <A> = pd . pd . DataFrame ( <B> , columns = <C> )
多層パーセプトロンモデルを用意する	sklearn . neural_network . MLPClassifier ( )	neural_network . MLPClassifier ( )
<B> の中の NaN をドロップして、 <A> とする	<A> = <B> . dropna ( )	= <B> . dropna ( )
<A> 中の列にある <B> の個数を調べる	<A> . isin ( [ <B> ] ) . sum ( )	df . isin ( [ <B> ] ) . sum ( )
<A> の度数分布図を <B> から <C> の間で表示する	plt . hist ( <A> , range = ( <B> , <C> ) )	<C> plt . hist ( <A> , range = ( <B> , <C> ) )
<A> 内の欠損値が存在する行を落として、インプレースする	<A> . dropna ( inplace = True )	. dropna ( inplace = True )
そこで、ヘッダー行を含まない	encoding = 'shift_jis'	index = 'shift_jis'
<A> の中の未入力の値の合計を求める	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<A> の重複する行数	<A> . duplicated ( ) . sum ( )	df . duplicated ( ) . sum ( )
文字コードを shift_jis として、 <B> を読み込み、 <A> とする	<A> = pd . read_csv ( <B> , encoding = 'shift_jis' )	= pd . read_csv ( <A> , encoding = <B> )
<B> を one - hot 表現に変換し、 <A> に代入する	<A> = pd . get_dummies ( <A> [ <B> ] )	= pd . get_dummies ( <A> [ <B> ] )
<A> の <B> に重複があるかどうか	<A> . duplicated ( subset = <B> )	df . duplicated ( subset = <B> )
表データを CSV ファイル <B> から読み、 <A> に代入する	<A> = pd . read_csv ( <B> )	df = pd . read_csv ( <B> )
そこで、種類は積み上げをする	stacked = True	encoding = True
分割数を <D> として、 <B> の <C> をビン分割して、 <A> とする	<A> = pd . cut ( <B> [ <C> ] , <D> )	byteorder = pd . cut ( <B> [ <C> ] , <D> , label = False )
<A> についての箱ひげ図を作図する	plt . boxplot ( <A> )	plt . hist ( <A> )
<A> の中の欠損値が存在する行を落として、再代入する	<A> = <A> . dropna ( )	inplace = <A> . dropna ( )
<A> の <B> の値を軸に並び替えて、再代入する	<A> = <A> . sort_values ( <B> )	plt = <A> . sort_values ( <B> )
<A> を位置に基づいてソートし、インプレースする	<A> . sort_index ( inplace = True )	solver = <A> . sort_index ( )
<A> の行の名前を <B> から <C> に変更し、置き換える	<A> = <A> . rename ( index = { <B> : <C> } )	df . rename ( index = { <B> : <C> } , inplace = True )
<B> 内に存在する <C> を未入力の値に置換し、 <A> とする	<A> = <B> . replace ( <C> , np . nan )	df = <B> . replace ( <C> , np . nan )
横軸を <A> として、 <B> の鉛直棒グラフを表示する	plt . barh ( <A> , <B> )	bar plt . bar ( <A> , <B> )
左側のデータフレームに合わせてデータを結合し、 <A> にする	<A> = pd . merge ( df1 , df2 , how = 'left' )	df = pd . merge ( df1 , df2 , how = 'left' )
<A> 中の未入力の値を <B> として、再代入する	<A> = <A> . fillna ( <B> )	plt = <A> . fillna ( <B> )
そこで、目印の輪郭色は紫色を用いる	markeredgecolor = 'purple'	markeredgewidth = 'purple'
<B> というエクセルデータの全てのシートを読み、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = None )	df = pd . read_excel ( <B> , sheet_name = None )
<A> のオブジェクトデータの統計情報	<A> . describe ( include = 'O' )	marker = <A> . describe ( )
<A> と <B> を値が大きい順にソート	df . sort_values ( [ <A> , <B> ] , ascending = False )	<A> . sort_values ( [ <B> ] , ascending = False )
そこで、 <A> をエンコーディングとする	encoding = <A>	pd . read_csv ( <A> , encoding = 'shift_jis' )
<A> を <B> をカラム名としてデータフレームに変換する	pd . DataFrame ( <A> , columns = <B> )	DataFrame . pd . pd . DataFrame ( <A> , columns = <B> )
<A> を <B> を列名として表データに変換する	pd . pd . DataFrame ( <A> , columns = <B> )	pd . pd . DataFrame ( <A> , columns = [ 'label' ] )
重複する最後の行を残して <A> ( データフレーム ) 中の重複する行を削除	<A> . drop_duplicates ( keep = False )	<B> . drop_duplicates ( keep = False )
<A> 中の未記入の値を含む行を消して、 <A> にする	<A> = <A> . dropna ( )	start = <A> . dropna ( )
<A> 中にある <B> を欠損とする	<A> . replace ( <B> , np . nan )	start . replace ( <A> , <B> , np . nan )
<A> 中の NaN が存在する行を削除して、置き換える	<A> . dropna ( inplace = True )	inplace = <A> . dropna ( )
<B> を <C> 区切りで表データとして読み込んで、 <A> にする	<A> = pd . read_csv ( <B> , sep = <C> )	df = pd . read_csv ( <B> , sep = <C> )
そこで、四角形の目印を使用する	marker = 's'	solver = 's'
<A> の NaN を <B> に置換して、置き換える	<A> = <A> . fillna ( <B> )	markersize = <A> . fillna ( <B> )
<B> と <C> をマージして、 <A> とする	<A> = pd . merge ( <B> , <C> )	errors = pd . concat ( [ <B> , <C> ] , axis = 1 )
<B> という名前のエクセルの <C> を読み込み、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = <C> )	df = pd . read_excel ( <B> , sheet_name = <C> )
<A> と <B> を横方向に連結する	pd . concat ( [ <A> , <B> ] , axis = 1 )	plt . boxplot ( [ <A> , <B> ] )
そこで、フォントサイズを <A> とする	fontsize = <A>	bins = <A>
そこで、タブは空白 <A> 文字分とする	tabsize = <A>	<A> = pd . read_csv ( <A> , encoding = '\t' )
そこで、活性化関数として恒等関数を使う	activation = 'identity'	activation = 'tanh'
<A> の列名を <B> から <C> に、 <D> から <E> に変更し、置き換える	<A> . rename ( columns = { <B> : <C> , <D> : <E> } , inplace = True )	marker = <A> . rename ( columns = { <B> : <C> , <D> : <E> } )
両方の列を使って <B> ( データフレーム ) と <C> を一つにまとめて、 <A> とする	<A> = pd . merge ( <B> , <C> , how = 'outer' )	start = <A> . sort_values ( [ <B> , <C> ] , ascending = False )
重複している最後の行を残して <B> ( データフレーム ) 中の重複している行をドロップを <A> とする	<A> = <B> . drop_duplicates ( keep = False )	df = <B> . drop_duplicates ( keep = False )
そこで、マーカーの種類の色は紫とする	markerfacecolor = 'purple'	'purple' = 'purple'
そこで、 relu を活性化とする	activation = 'relu'	markeredgecolor = 'relu'
<A> 中の欠損の合計を求める	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<B> の未入力の値を <C> に置き換えて、 <A> とする	<A> = <B> . fillna ( <C> )	= <B> . fillna ( <C> )
<A> 中の欠損値がある行を削除を <A> とする	<A> = <A> . dropna ( )	start = <A> . dropna ( )
<A> 内の欠損値の数を求める	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
横軸を <A> として、 <B> の棒グラフを描く	plt . barh ( <A> , <B> )	bar plt . bar ( <A> , <B> )
<A> 中の <B> に重複があるか表示する	<A> . duplicated ( subset = <B> )	df . duplicated ( subset = <B> )
<B> というエクセルファイルの <C> のシートを表データに格納して、 <A> にする	<A> = pd . read_excel ( <B> , sheet_name = <C> )	df = pd . read_excel ( <B> , sheet_name = <C> )
<A> の未記入の値を直前の行の値で補い、 <A> に代入する	<A> = <A> . fillna ( method = 'ffill' )	method = <A> . fillna ( method = 'ffill' )
そこで、ネイビーを打点の色とする	markerfacecolor = 'navy'	color = 'navy'
同じ軸で <A> <B> と <A> <C> と <A> <D> を箱ひげ図で描画する	plt . boxplot ( [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] )	pd . boxplot [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] ] )
<B> のインデックスを昇順でソートして、 <A> とする	<A> = <B> . sort_index ( )	= <B> . sort_index ( )
そこで、目印のエッジ色はグレーである	markeredgecolor = 'gray'	markeredgewidth = 'gray'
そこで、マーカーの色は黄色を用いる	markerfacecolor = 'yellow'	color = 'yellow'
<A> 内の NaN がある行を削除	<A> . dropna ( )	df . dropna ( )
同じ軸のセットで <A> の <B> と <C> と <D> を箱ひげ図で作図する	plt . boxplot ( [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] )	pd . merge ( <A> [ <B> ] , <C> , <A> [ <D> ] ] ] ] ] )
<A> の中の重複する値がある行を取り除き、インプレースする	<A> . drop_duplicates ( inplace = True )	inplace = <A> . drop_duplicates ( )
<A> の NaN をその最頻値で穴埋めする	<A> . fillna ( <A> . mode ( ) )	plt . fillna ( <A> . mode ( ) )
<B> の重複している行を削除し、 <A> にする	<A> = <B> . drop_duplicates ( )	plt = <B> . drop_duplicates ( )
<A> の振り直して、元の位置を削除する	<A> . reset_index ( drop = True )	marker = <A> . reset_index ( drop = True )
<A> 内の NaN の合計を算出する	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<B> という名前のエクセル <B> のシート全てをデータフレームに格納して、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = None )	df = pd . read_excel ( <B> , sheet_name = None )
<A> 内の欠損を含む行を削除して、再代入する	<A> = <A> . dropna ( )	= <A> . dropna ( )
<A> の <B> の未記入の値を <B> の最頻値で穴埋めする	<A> [ <B> ] . fillna ( <A> [ <B> ] . mode ( ) )	<B> <A> [ <A> . fillna ( <B> ] . mode ( ) ) )
<A> ( データフレーム ) の <B> と <C> を値が大きい順にソート	<A> . sort_values ( [ <B> , <C> ] , ascending = False )	ascending = <A> . sort_values ( [ <B> , <C> ] , ascending = False )
そこで、目印を星とする	marker = '*'	'*' = '*'
<A> の中の欠損の数	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<B> 中の重複する行を落として、 <A> にする	<A> = <B> . drop_duplicates ( )	= <B> . drop_duplicates ( )
<A> 内の重複している行を削除する	<A> . drop_duplicates ( )	) . drop_duplicates ( )
そこで、目印の輪郭は <A> をする	markeredgewidth = <A>	bins = <A>
<B> ( データフレーム ) の <C> と <D> を大から小へとソートを <A> とする	<A> = <B> . sort_values ( [ <C> , <D> ] , ascending = False )	df = <B> . sort_values ( [ <C> , <D> ] , ascending = False )
<B> 中の欠損を含む行を削除し、 <A> とする	<A> = <B> . dropna ( )	= <B> . dropna ( )
<A> 内の欠損を <B> に置き換えて、 <A> とする	<A> = <A> . fillna ( <B> )	= <A> . fillna ( <B> )
重複する行をドロップして、置き換える	df . drop_duplicates ( inplace = True )	= df . drop_duplicates ( )
<A> 内の <B> を欠損に置換し、欠損がある行を落とし、再代入する	<A> = <A> . replace ( <B> , np . nan ) . dropna ( )	= <A> . replace ( <B> , np . nan ) . dropna ( )
そこで、マーカーのエッジ色は黄緑色をする	markeredgecolor = 'greenyellow'	'greenyellow' = 'greenyellow'
そこで、クロスのマーカーの形を使用する	marker = 'x'	markersize = 'x'
<A> の中の欠損値を <B> に置換し、 <A> とする	<A> = <A> . fillna ( <B> )	fillna <A> = <A> . fillna ( <B> ) )
<A> 内のカラムそれぞれにある <B> の個数を確認する	<A> . isin ( [ <B> ] ) . sum ( )	isin . isin ( [ <B> ] ) . sum ( )
<A> の中の NaN がある行を削除し、置き換える	<A> . dropna ( inplace = True )	inplace = <A> . dropna ( )
そこで、目印のエッジ色として青色を用いる	markeredgecolor = 'blue'	markeredgewidth = 'blue'
<A> の <B> を NaN に置換し、 NaN がある行を削除して、 <A> とする	<A> = <A> . replace ( <B> , np . nan ) . dropna ( )	start = <A> . replace ( <B> , np . nan ) . dropna ( )
重複している行をドロップを <A> とする	<A> = df . drop_duplicates ( )	= <A> . drop_duplicates ( )
<A> の位置をソート	<A> . sort_index ( )	start . sort_index ( )
<A> の未記入の値を <B> で穴埋めする	<A> . fillna ( <B> )	df . fillna ( <A> . median ( <B> ) )
エクセルデータ <B> のシート全部をデータフレームに格納して、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = None )	df = pd . read_excel ( <B> , sheet_name = None )
<A> の <B> を四分位数ごとで分割する	pd . qcut ( <A> [ <B> ] , 4 )	for pd . qcut ( <A> [ <B> ] )
横軸を <A> とした <B> の縦棒グラフを表示する	plt . barh ( <A> , <B> )	plt . bar ( <A> , <B> )
<A> 内の <B> と <C> に重複はあるかチェックを確認する	<A> . duplicated ( subset = [ <B> , <C> ] )	pd . duplicated ( subset = [ <A> , <B> , <C> ] )
そこで、セパレータとして <A> を使う	sep = <A>	bins = <A>
<B> ( データフレーム ) の <C> を順にし、 <A> に代入する	<A> = <B> . sort_values ( <C> )	df = <B> . sort_values ( <C> )
<B> 内の欠損値を含む行をドロップを <A> にする	<A> = <B> . dropna ( )	= <B> . dropna ( )
グラフ幅を <C> として、 <A> 軸を <A> とした <B> の棒グラフを描画する	plt . bar ( <A> , <B> , width = <C> )	<A> plt . bar ( <B> , width = <C> )
x 座標を <A> として、 <B> の鉛直棒グラフを表示する	plt . bar ( <A> , <B> )	barh plt . bar ( <A> , <B> )
そこで、 <A> に小数点以下 2 桁まで表現すること、パーセントを指定する。	<A> = '%.2f%%'	autopct = '%.2f%%'
表データを <B> からタブ区切りで読み込んで、 <A> とする	<A> = pd . read_csv ( <B> , sep = '\t' )	start = pd . read_csv ( <A> , sep = <B> )
<A> のインデックス名を <B> から <C> に変更し、再代入する	<A> = <A> . rename ( index = { <B> : <C> } )	df = <A> . rename ( index = { <B> : <C> } )
<A> を <B> から <C> 範囲のヒストグラムにする	plt . hist ( <A> , range = ( <B> , <C> ) )	hist plt . hist ( <A> , range = ( <B> , <C> ) )
<A> 中の <B> に重複があるのか確認する	<A> . duplicated ( subset = <B> )	pd . duplicated ( <A> subset = <B> )
両方の列を使って <A> ( データフレーム ) と <B> をマージする	pd . merge ( <A> , <B> , how = 'outer' )	<A> pd . merge ( <B> , how = 'outer' )
<A> 内の <B> を NaN に置換し、 NaN がある行を消し、置き換える	<A> = <A> . replace ( <B> , np . nan ) . dropna ( )	df = <A> . replace ( <B> , np . nan ) . dropna ( )
そこで、マーカーの形の輪郭色はシアンにする	markeredgecolor = 'cyan'	markeredgewidth = 'cyan'
<A> 内の欠損したセル数を数える	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<A> 中の未記入の値を含む行を消す	<A> . dropna ( )	df . dropna ( )
<A> を転置する	<A> . T	plt . hist ( <A> )
そこで、クロスをマーカーにする	marker = 'x'	solver = 'x'
そこで、活性化は、 relu をする	activation = 'relu'	linestyle = 'relu'
重複した最後の行を残して <A> ( データフレーム ) 内の重複している行を落とし、置き換える	<A> . drop_duplicates ( keep = False , inplace = True )	inplace = <A> . drop_duplicates ( keep = True )
<A> 中の <B> に重複は存在するのかチェックする	<A> . duplicated ( subset = <B> )	<B> . duplicated ( subset = <B> )
<A> に重複があるかどうかチェック	<A> . duplicated ( )	pd . duplicated ( <A> )
そこで、目印のエッジ色は黄緑色を使う	markeredgecolor = 'greenyellow'	'greenyellow' = 'greenyellow'
<A> の行ごとに重複がある場合	if <A> . duplicated ( ) :	if df . duplicated ( ) :
<A> 中の欠損がある行を削除	<A> . dropna ( )	df . dropna ( )
<A> 中の <B> を欠損に置換し、欠損がある行を削除して、再代入する	<A> = <A> . replace ( <B> , np . nan ) . dropna ( )	= <A> . replace ( <B> , np . nan ) . dropna ( )
<A> を位置を元にソートを <A> とする	<A> = <A> . sort_index ( )	= <A> . sort_index ( )
同じグラフ内で <A> の <B> と <C> と <D> を箱ひげ図で作画する	plt . boxplot ( [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] )	pd . merge ( <A> [ <B> ] , <C> , <A> [ <D> ] ] ] ] ] )
<A> 内にある <B> を欠損に置換し、再代入する	<A> = <A> . replace ( <B> , np . nan )	df = <A> . replace ( <B> , np . nan )
<A> 内の欠損を直前の行の値で埋め、 <A> に代入する	<A> = <A> . fillna ( method = 'ffill' )	start = <A> . fillna ( method = 'ffill' )
<A> 中の NaN が存在する行を削除し、再代入する	<A> = <A> . dropna ( )	df = <A> . dropna ( )
<B> の中の <C> に重複がある行を落として、 <A> とする	<A> = <B> . drop_duplicates ( subset = <C> )	df = <B> . drop_duplicates ( subset = <C> )
グラフの x 軸を <A> として、 <B> の棒グラフを描写する	plt . bar ( <A> , <B> )	barh plt . bar ( <A> , <B> )
<A> の <B> の日にちを調べる	<A> [ <B> ] . dt . day	[ <A> [ <B> ] . dt . day
そこで、マーカーの形状の色として紫色を用いる	markerfacecolor = 'purple'	markeredgecolor = 'purple'
<B> 中の欠損値を <C> で埋めて、 <A> とする	<A> = <B> . fillna ( <C> )	<B> = <C> . fillna ( <C> )
<A> の <B> に重複がある行を削除して、 <A> とする	<A> = <A> . drop_duplicates ( subset = <B> )	start = <A> . drop_duplicates ( subset = <B> )
<A> 中の欠損値を <A> の平均値で補って、 <A> に代入する	<A> = <A> . fillna ( <A> . mean ( ) )	df = <A> . fillna ( <A> . mean ( ) )
<A> を <B> の値を元に昇順でソートし、置き換える	<A> = <A> . sort_values ( <B> )	df . sort_values ( <B> , inplace = True )
そこで、活性化は、 relu を使う	activation = 'relu'	linestyle = 'relu'
そこで、マーカーの形状のエッジ色は水色を用いる	markeredgecolor = 'cyan'	markeredgewidth = 'cyan'
データフレームを <B> から読み、 <A> とする	<A> = pd . read_csv ( <B> )	df = pd . read_csv ( <B> )
柱状グラフとして	plt . hist ( X )	plt . hist ( df [ 'A' ] )
そこで、目印の色は青色をする	markerfacecolor = 'blue'	color = 'blue'
<A> を y 軸、 <B> を x 軸として、散布図をプロットする	plt . scatter ( <A> , <B> )	scatter plt . scatter ( <A> , <B> )
<B> からカンマ区切りで表を読み込み、 <A> とする	<A> = pd . read_csv ( <B> , sep = ',' )	df = pd . read_csv ( <B> , sep = ',' )
そこで、グラフの種類は、箱ひげ図を用いる	kind = 'box'	linestyle = 'dashed'
<A> 内に重複はあるのか確認を調べる	<A> . duplicated ( )	duplicated . duplicated ( subset = <A> )
<A> についてダミー変数を生成する	pd . get_dummies ( df [ <A> ] )	<A> . pd . get_dummies ( <A> )
そこで、マーカーの種類の輪郭色としてネイビーを使用する	markeredgecolor = 'navy'	markeredgewidth = 'navy'
エクセル <B> からデータフレームに読み込み、 <A> とする	<A> = pd . read_excel ( <B> )	df = pd . read_excel ( <B> )
<A> 内の欠損が存在する行を落とし、再代入する	<A> = <A> . dropna ( )	df = <A> . dropna ( )
<A> と <B> に重複があるのならば	if df . duplicated ( subset = [ <A> , <B> ] ) :	markeredgecolor . duplicated ( subset = [ <A> , <B> ] ) :
<A> 内の重複している行数を見る	<A> . duplicated ( ) . sum ( )	df . duplicated ( ) . sum ( )
<A> の中の重複を見る	<A> . duplicated ( )	df . duplicated ( subset = <A> )
<A> 中に存在する <B> を未入力の値に置換して、置き換える	<A> = <A> . replace ( <B> , np . nan )	df . replace ( <A> , <B> , np . nan , inplace = True )
<A> の重複した行の合計を見る	<A> . duplicated ( ) . sum ( )	. duplicated ( ) . sum ( )
フォントを日本語表示にセットする。	sns . set ( font = 'IPAexGothic' , style = 'white' )	pd . set ( font = 'IPAexGothic' , style = 'white' )
<A> の <B> の名前を <C> にリネームする	<A> . rename ( columns = { <B> : <C> } )	df . rename ( index = { <B> : <C> } )
<A> ( データフレーム ) の <B> を順にして、置き換える	<A> = <A> . sort_values ( <B> )	df . sort_values ( <B> , inplace = True )
<A> を <B> で並べ直す	<A> . sort_values ( by = <B> )	<A> . sort_values ( <B> )
エクセルファイル <B> の <C> 番目のシートをデータフレームに格納して、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = <C> )	df = pd . read_excel ( <B> , sheet_name = <C> )
<A> ( データフレーム ) の <B> を小さい順にし、インプレースする	<A> . sort_values ( <B> , inplace = True )	df . sort_values ( <B> , inplace = True )
<A> 中の NaN を <B> に置換して、 <A> に代入する	<A> = <A> . fillna ( <B> )	plt = <A> . fillna ( <B> )
そこで、六角ビニング図を使う	kind = 'hexbin'	bins = 'hexbin'
<A> の欠損を数える	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<A> にある <B> を欠損として、置き換える	<A> = <A> . replace ( <B> , np . nan )	<A> . replace ( <B> , np . nan , inplace = True )
重複した最後の行を残して <A> ( データフレーム ) 内の重複している行を落として、 <A> にする	<A> = <A> . drop_duplicates ( keep = False )	start = <A> . drop_duplicates ( keep = False )
<A> 内の未記入の値の合計	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
そこで、マーカーの色は赤色を使う	markerfacecolor = 'red'	markeredgecolor = 'red'
<B> の中の <C> を欠損値に置換し、欠損値がある行をドロップを <A> とする	<A> = <B> . replace ( <C> , np . nan ) . dropna ( )	<B> <A> = <C> . replace ( <C> , np . nan ) . dropna ( )
<A> のヒストグラムをビンの数を <B> として表示する	plt . hist ( <A> , bins = <B> )	<A> . bins = <B> )
<B> 内の <C> を欠損値に置換し、欠損値がある行をドロップして、 <A> とする	<A> = <B> . replace ( <C> , np . nan ) . dropna ( )	= <B> . replace ( <C> , np . nan ) . dropna ( )
一番左の列をインデックスに設定して、 <B> を表に格納して、 <A> とする	<A> = pd . read_csv ( <B> , index_col = 0 )	= pd . read_csv ( <A> , index_col = <B> )
<A> から <B> という名前のエクセルファイルにする	<A> . to_excel ( <B> )	pd . read_excel ( <A> , sheet_name = <B> )
<A> ( データフレーム ) の <B> を順にして、置き換える	<A> . sort_values ( <B> , inplace = True )	df . sort_values ( <B> , inplace = True )
<A> を <B> から <C> のヒストグラムにする	plt . hist ( <A> , range = ( <B> , <C> ) )	pd . hist ( <A> [ <B> , <C> ] )
<A> 内の <B> , <C> , <D> 行目の <E> , <C> 列目を取得する	<A> . iloc [ [ <B> , <C> , <D> ] , [ <E> , <C> ] ]	df . sort_values ( [ <A> [ <B> , <C> , <D> ] ] ) ]
<A> の <B> の月	<A> [ <B> ] . dt . month	df [ <A> [ <B> ] . dt . day
そこで、マーカーの色は黄緑をする	markerfacecolor = 'greenyellow'	color = 'greenyellow'
そこで、マーカーの色としてマゼンタを使う	markerfacecolor = 'magenta'	color = 'magenta'
<B> の欠損値を落とし、 <A> にする	<A> = <B> . dropna ( )	= <B> . dropna ( )
そこで、転戦を線とする	linestyle = 'dotted'	file = 'dotted'
<A> 中の欠損の個数を確認する	<A> . isnull ( ) . sum ( )	] . isnull ( ) . sum ( )
<A> と <B> を降順にする	df . sort_values ( [ <A> , <B> ] , ascending = False )	<A> . sort_values ( [ <B> ] , ascending = False )
<A> についてダミー変数を生成し、 <A> とする	<A> = pd . get_dummies ( <A> )	df = pd . get_dummies ( <A> )
表を <B> からカンマ区切りで読んで、 <A> に代入する	<A> = pd . read_csv ( <B> , sep = ',' )	= pd . read_csv ( <A> , sep = <B> )
<A> 中の欠損の合計を確認する	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<A> を <B> を列名としてデータフレームに変換する	pd . pd . DataFrame ( <A> , columns = <B> )	pd . pd . pd . DataFrame ( <A> , columns = <B> )
先頭の列をインデックスとして、 <B> をデータフレームに格納して、 <A> とする	<A> = pd . read_csv ( <B> , index_col = 0 )	df = pd . read_csv ( <B> , index_col = 0 )
そこで、中央寄せをアライメントとする	align = 'center'	bins = 'center'
<B> というエクセルデータの全てのシートから読んで、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = None )	df = pd . read_excel ( <B> , sheet_name = None )
そこで、活性化は、恒等関数を用いる	activation = 'identity'	activation = 'tanh'
<A> 内の <B> と <C> に重複は存在するのかチェックする	<A> . duplicated ( subset = [ <B> , <C> ] )	pd . duplicated ( subset = [ <A> , <B> , <C> ] )
そこで、目印の色は黄緑色である	markerfacecolor = 'greenyellow'	color = 'greenyellow'
<A> の <B> と <C> と <D> についての箱ひげ図を描く	plt . boxplot ( [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] )	[ <A> [ <B> ] . boxplot ( [ <C> ] , <A> [ <D> ] ] ] ] )
<A> の未入力の値の個数を計算する	<A> . isnull ( ) . sum ( )	] . isnull ( ) . sum ( )
<A> の欠損が存在する行をドロップする	<A> . dropna ( )	start . dropna ( )
<B> のインデックス名を <C> から <D> に変更して、 <A> とする	<A> = <B> . rename ( index = { <C> : <D> } )	= <B> . rename ( index = { <C> : <D> } )
<A> の <B> の名前を <C> に変更する	<A> . rename ( columns = { <B> : <C> } )	df . rename ( index = { <B> : <C> } )
そこで、マーカーのエッジ色として紫を用いる	markeredgecolor = 'purple'	'purple' = 'purple'
<A> という列を削除し、置き換える	df . drop ( <A> , axis = 1 , inplace = True )	df = df . drop ( <A> , axis = 1 )
そこで、マーカーの輪郭線は <A> を用いる	markeredgewidth = <A>	bins = <A>
<A> 全体を <B> の値に基づいてソートして、置き換える	<A> . sort_values ( <B> , inplace = True )	df = <A> . sort_values ( <B> )
左側のデータフレームを全て残してデータを結合し、 <A> に代入する	<A> = pd . merge ( df1 , df2 , how = 'left' )	df = pd . merge ( df1 , df2 , how = 'left' )
<A> ( データフレーム ) の <B> を小から大へとソートする	<A> . sort_values ( <B> )	plt . sort_values ( <A> , <B> )
<A> の欠損を直前の行の値で補って、 <A> に代入する	<A> = <A> . fillna ( method = 'ffill' )	method = <A> . fillna ( method = 'ffill' )
<A> の <B> と <C> を降順に並び替え、 <A> に代入する	<A> = <A> . sort_values ( [ <B> , <C> ] , ascending = False )	df = <A> . sort_values ( [ <B> , <C> ] , ascending = False )
そこで、カラーマップとしてアクセントを用いる	colormap = 'Accent'	'Accent' = 'Accent'
<A> 中の欠損が存在する行を削除を <A> とする	<A> = <A> . dropna ( )	start = <A> . dropna ( )
<A> の欠損を平均値で穴埋めして置き換える	<A> . fillna ( <A> . mean ( ) , inplace = True )	inplace = <A> . fillna ( <A> . mean ( ) )
<A> の <B> と <C> と <D> についての箱ひげ図を描写する	plt . boxplot ( [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] )	[ <A> [ [ <B> ] = <A> [ <C> ] . boxplot ( [ <D> ] ] ] )
<A> を y 軸、 <B> を x 座標として、線グラフを描く	plt . plot ( <A> , <B> )	pd . plt ( <A> , <B> )
<A> をインデックスに沿ってソートし、 <A> とする	<A> = <A> . sort_index ( )	df = <A> . sort_index ( )
<B> を <C> を表属性名として表データにし、 <A> とする	<A> = pd . DataFrame ( <B> , columns = <C> )	df = pd . DataFrame ( <B> , columns = <C> )
<A> の行と列を入れ替える	<A> . T	pd . read_excel ( <A> )
そこで、 <A> に小数点以下 2 桁まで出力すること、パーセントを指定する。	<A> = '%.2f%%'	autopct = '%.2f%%'
<A> 中の未入力の値がある行を削除を <A> とする	<A> = <A> . dropna ( )	start = <A> . dropna ( )
<A> 内の欠損値を含む行を消して、インプレースする	<A> . dropna ( inplace = True )	. dropna ( inplace = True )
<A> をインデックスを元に昇順で並び替えて、 <A> とする	<A> = <A> . sort_index ( )	= <A> . sort_index ( )
そこで、目印の大きさは <A> を使う	markersize = <A>	markeredgewidth = <A>
最も適切な位置に凡例を表示する	plt . legend ( loc = 'best' )	sns . legend ( loc = 'best' )
<A> のインデックスを昇順で並び替えて、置き換える	<A> = <A> . sort_index ( )	inplace = <A> . sort_index ( )
<B> というエクセルファイル <B> を表に格納し、 <A> にする	<A> = pd . read_excel ( <B> , sheet_name = None )	pd . read_excel ( <A> , sheet_name = <B> )
<A> 中の未記入の値を <B> に置換し、再代入する	<A> = <A> . fillna ( <B> )	df = <A> . fillna ( <B> )
そこで、マーカーの色は紺色をする	markerfacecolor = 'navy'	color = 'navy'
重複した最後の行を残して <A> ( データフレーム ) 中の重複した行を削除する	<A> . drop_duplicates ( keep = False )	<B> . drop_duplicates ( keep = False )
<A> 全体をインデックスに沿ってソートし、置き換える	<A> . sort_index ( inplace = True )	solver = <A> . sort_index ( )
<B> の未入力の値を直前の行の値で補って、 <A> とする	<A> = <B> . fillna ( method = 'ffill' )	= <B> . fillna ( method = 'ffill' )
そこで、目印の輪郭色として紺色を使用する	markeredgecolor = 'navy'	markeredgewidth = 'navy'
<A> の <B> の値を昇順で並び替えて、置き換える	<A> . sort_values ( <B> , inplace = True )	df = <A> . sort_values ( <B> )
<A> の欠損をその最頻値で補完する	<A> . fillna ( <A> . mode ( ) )	pd . fillna ( <A> . mode ( ) )
重複する最後の行を残して <B> ( データフレーム ) 中の重複する行を削除を <A> とする	<A> = <B> . drop_duplicates ( keep = False )	df = <B> . drop_duplicates ( keep = False )
分割数を <D> として、 <B> の <C> を分割して、 <A> とする	<A> = pd . cut ( <B> [ <C> ] , <D> )	pd . cut ( <A> [ <B> ] , <C> , label = <D> )
<C> 番目の列を位置として、 <B> をデータフレームに格納して、 <A> に代入する	<A> = pd . read_csv ( <B> , index_col = <C> )	df = pd . read_csv ( <B> , index_col = <C> )
そこで、バツのマーカーを表示する	marker = 'x'	markeredgewidth = 'x'
そこで、マーカーの形のエッジ色として黄緑色を使用する	markeredgecolor = 'greenyellow'	'greenyellow' = 'greenyellow'
そこで、 <A> に小数点 2 位まで出力することを指定し、パーセント表記を指定する。	<A> = '%.2f%%'	autopct = '%.2f%%'
そこで、活性化関数は、恒等関数を用いる	activation = 'identity'	activation = 'tanh'
<A> 内に重複はあるのか確認する	<A> . duplicated ( )	duplicated . duplicated ( subset = <A> )
<A> の <B> を四分位数ごとでビン分割する	pd . qcut ( <A> [ <B> ] , 4 )	<A> . pd . qcut ( <A> [ <B> ] , 4 )
そこで、マーカーの形の色を黄色とする	markerfacecolor = 'yellow'	markeredgecolor = 'yellow'
そこで、マーカーの形の色として黄緑色を使う	markerfacecolor = 'greenyellow'	markeredgecolor = 'greenyellow'
<A> の <B> の NaN を <B> の平均値で補完する	<A> [ <B> ] . fillna ( <A> [ <B> ] . mean ( ) )	fillna <A> [ <B> ] . mean ( ) )
<A> の <B> をインデックスとして設定し、インプレースする	<A> . set_index ( <B> , inplace = True )	pd . set_index ( <A> , <B> , inplace = True )
エンコーディングを shift_jis として、 <B> を読み、 <A> に代入する	<A> = pd . read_csv ( <B> , encoding = 'shift_jis' )	encoding = pd . read_csv ( <A> , encoding = 'shift_jis' )
<A> の NaN の個数を表示する	<A> . isnull ( ) . sum ( )	] . isnull ( ) . sum ( )
<A> 中で重複している行数	<A> . duplicated ( ) . sum ( )	df . duplicated ( ) . sum ( )
<A> の欠損を表示する	<A> . isnull ( ) . sum ( )	isnull . isnull ( ) . sum ( )
重複した最後の行を残して <A> ( データフレーム ) 内の重複している行を消す	<A> . drop_duplicates ( keep = False )	df . drop_duplicates ( keep = False )
一番左の列をインデックスとして、 <B> をデータフレームに格納して、 <A> とする	<A> = pd . read_csv ( <B> , index_col = 0 )	df = pd . read_csv ( <B> , index_col = 0 )
重複している行を削除を <A> にする	<A> = <A> . drop_duplicates ( )	df = df . drop_duplicates ( )
そこで、打点の色は紫を使う	markerfacecolor = 'purple'	'purple' = 'purple'
そこで、目印の色を水色とする	markerfacecolor = 'cyan'	color = 'cyan'
<A> 全体を位置を元にソートし、 <A> とする	<A> = <A> . sort_index ( )	= <A> . sort_index ( )
そこで、マーカーの形の輪郭色としてシアンを使う	markeredgecolor = 'cyan'	markeredgewidth = 'cyan'
<A> のリセットして、元のインデックスを削除する	<A> . reset_index ( drop = True )	marker = <A> . reset_index ( drop = True )
<A> 中の未記入の値が存在する行を落として、 <A> とする	<A> = <A> . dropna ( )	start = <A> . dropna ( )
<A> の重複している値がある行を取り除き、 <A> にする	<A> = <A> . drop_duplicates ( )	start = <A> . drop_duplicates ( )
そこで、 <A> を区間にする	bins = <A>	range = ( <A> )
<A> を柱状図にする	plt . hist ( <A> )	plt . hist ( df [ <A> ] )
<A> の中の未入力の値を直前の行の値で埋め、 <A> にする	<A> = <A> . fillna ( method = 'ffill' )	method = <A> . fillna ( method = 'ffill' )
そこで、目印のエッジ色は黄緑色を用いる	markeredgecolor = 'greenyellow'	'greenyellow' = 'greenyellow'
<A> の <B> と <C> を逆順にソートし、再代入する	<A> = <A> . sort_values ( [ <B> , <C> ] , ascending = False )	df = <A> . sort_values ( [ <B> , <C> ] , ascending = False )
ヘッダーなしで <A> を読み込む	pd . read_csv ( <A> , header = None )	pd . read_csv ( <A> , encoding = 'shift_jis' )
<A> を <B> で並べ直し、 <A> にする	<A> = <A> . sort_values ( by = <B> )	<A> = pd . read_csv ( <B> )
<B> と <C> を横方向にくっつけ、 <A> に代入する	<A> = pd . merge ( <B> , <C> )	df = pd . merge ( <B> , <C> )
<A> 中の <B> に重複がある行を削除を <A> にする	<A> = <A> . drop_duplicates ( subset = <B> )	start = <A> . drop_duplicates ( subset = <B> )
一番左の列を位置と設定して、 <B> からデータフレームとを読み込んで、 <A> に代入する	<A> = pd . read_csv ( <B> , index_col = 0 )	= pd . read_csv ( <A> , index_col = <B> )
表データを <C> 区切りで <B> から読んで、 <A> にする	<A> = pd . read_csv ( <B> , sep = <C> )	sep = pd . read_csv ( <A> , sep = <C> )
<A> ( データフレーム ) の <B> を昇順にソートして、置き換える	<A> = <A> . sort_values ( <B> )	df . sort_values ( <B> , inplace = True )
<A> を <B> の値を元に昇順でソートを <A> とする	<A> = <A> . sort_values ( <B> )	= <A> . sort_values ( <B> )
<B> を表としてカンマ区切りで読み込み、 <A> にする	<A> = pd . read_csv ( <B> , sep = ',' )	df = pd . read_csv ( <A> , sep = <B> )
<A> 中で重複する行の合計を調べる	<A> . duplicated ( ) . sum ( )	. duplicated ( ) . sum ( )
カンマ区切りで CSV ファイル <B> をデータフレームとして読み込み、 <A> に代入する	<A> = pd . read_csv ( <B> , sep = ',' )	= pd . read_csv ( <A> , sep = <B> )
<B> の NaN が存在する行を落として、 <A> とする	<A> = <B> . dropna ( )	= <B> . dropna ( )
<A> 全体を <B> の値に基づいてソートして、 <A> とする	<A> = <A> . sort_values ( <B> )	df = <A> . sort_values ( <B> )
<A> 内の未記入の値を含む行を落とす	<A> . dropna ( )	df . dropna ( )
エクセルファイル <B> の <C> をデータフレームとして読み、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = <C> )	pd . read_excel ( <A> , sheet_name = <B> )
ヘッダーなしで <B> を読み込んで、 <A> とする	<A> = pd . read_csv ( <B> , header = None )	df = pd . read_csv ( <B> , encoding = 'shift_jis' )
エクセルファイル <A> の <B> からデータフレームを読み込む	pd . read_excel ( <A> , sheet_name = <B> )	<A> . to_excel ( <B> )
<A> 中の未入力の値がある行を落とし、 <A> に代入する	<A> = <A> . dropna ( )	start = <A> . dropna ( )
<A> の <B> についての中央値を取得する	<A> [ <B> ] . median ( )	df [ <B> <A> [ <B> ] . median ( ) )
<A> と <B> に重複はあるかどうか確認する	df . duplicated ( subset = [ <A> , <B> ] )	. duplicated ( subset = [ <A> , <B> ] )
重複している最後の行を残して <A> ( データフレーム ) の重複している行を落とす	<A> . drop_duplicates ( keep = False )	keep . drop_duplicates ( keep = False )
<A> の欠損値の数	<A> . isnull ( ) . sum ( )	isnull . isnull ( ) . sum ( )
<A> 中に重複が存在するのか表示する	<A> . duplicated ( )	pd . duplicated ( <A> )
<B> というエクセルファイルの <C> のシートをデータフレームとして読み、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = <C> )	df = pd . read_excel ( <B> , sheet_name = <C> )
そこで、目印の色は水色を用いる	markerfacecolor = 'cyan'	color = 'cyan'
そこで、マーカーの種類の色は紫を用いる	markerfacecolor = 'purple'	markeredgecolor = 'purple'
<A> を <B> を元に昇順でソートして、再代入する	<A> = <A> . sort_values ( <B> )	= <A> . sort_values ( <B> )
<A> の欠損値をその平均値で穴埋めする	<A> . fillna ( <A> . mean ( ) )	pd . fillna ( <A> . mean ( ) )
<A> の <B> が <C> のデータを得る	<A> [ <A> [ <B> ] == <C> ]	pd <A> [ <A> [ <B> ] == <C> ]
<A> 内の重複を見る	<A> . duplicated ( )	pd . duplicated ( <A> )
そこで、目印のエッジ色は紺色をする	markeredgecolor = 'navy'	max_iter = 'navy'
<A> ( データフレーム ) の <B> と <C> を大から小へとソートし、 <A> とする	<A> = <A> . sort_values ( [ <B> , <C> ] , ascending = False )	df = <A> . sort_values ( [ <B> , <C> ] , ascending = False )
同じグラフ内で <A> の <B> と <A> の <C> と <A> の <D> を箱髭図で作画する	plt . boxplot ( [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] )	color = <A> [ <B> ] . boxplot ( [ <C> ] , <A> [ <D> ] ] ] ] )
<A> の <B> に重複がある行を落とし、インプレースする	<A> . drop_duplicates ( subset = <B> , inplace = True )	. drop_duplicates ( subset = <B> , inplace = True )
そこで、マーカーのエッジ色として黄緑色を使う	markeredgecolor = 'greenyellow'	'greenyellow' = 'greenyellow'
<B> をインデックスで並び替え、 <A> とする	<A> = <B> . sort_index ( )	= <B> . sort_index ( )
<A> において、 <B> と <C> と <D> の関係性を一気に作画する	sns . pairplot ( <A> [ [ <B> , <C> , <D> ] ] )	sns . pairplot ( <A> [ <B> , <C> , <D> ] ] )
<A> の <B> と <C> を大きい順に並び替えて、 <A> にする	<A> = <A> . sort_values ( [ <B> , <C> ] , ascending = False )	df = <A> . sort_values ( [ <B> , <C> ] , ascending = False )
<A> の中の欠損の合計を調べる	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<B> というエクセルの <C> のシートから読み込んで、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = <C> )	hidden_layer_sizes = pd . read_excel ( <B> , sheet_name = <C> )
新しいカラムを <A> に追加し、 <B> とする	<A> [ <B> ] = [ 0 ] * len ( <A> )	hidden_layer_sizes = [ <A> , <B> ] )
<B> を <C> の値に沿ってソートして、 <A> にする	<A> = <B> . sort_values ( <C> )	df = <B> . sort_values ( <C> )
<A> 内の <B> と <C> に重複があるのかどうか表示してみる	<A> . duplicated ( subset = [ <B> , <C> ] )	plt . duplicated ( subset = [ <A> , <B> , <C> ] )
重複した最後の行を残して <B> ( データフレーム ) 中の重複している行を落として、 <A> とする	<A> = <B> . drop_duplicates ( keep = False )	df = <B> . drop_duplicates ( keep = False )
<B> をインデックスで並び替えて、 <A> とする	<A> = <B> . sort_index ( )	= <B> . sort_index ( )
<A> のインデックスを軸に昇順でソートし、置き換える	<A> = <A> . sort_index ( )	inplace = <A> . sort_index ( )
<A> の <B> の名前を <C> にリネームし、置き換える	<A> = <A> . rename ( index = { <B> : <C> } )	<A> . rename ( index = { <B> : <C> } , inplace = True )
<A> 内の未入力の値の数	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<A> 内の欠損が存在する行をドロップを <A> とする	<A> = <A> . dropna ( )	start = <A> . dropna ( )
<B> と <C> を横に結合して、 <A> とする	<A> = pd . merge ( <B> , <C> )	df = pd . merge ( <B> , <C> )
とりあえず <A> の内容を調べる	<A> . head ( )	df . head ( )
分割数を <C> 、ビンの名前をインデックスとして、 <A> の <B> を分割する	pd . cut ( <A> [ <B> ] , <C> , label = False )	markersize = pd . cut ( <A> [ <B> ] , <C> , label = False )
<B> 全体を <C> で並び替え、 <A> とする	<A> = <B> . sort_values ( <C> )	<B> = <C> . sort_values ( <C> )
そこで、 <A> を目印の大きさにする	markersize = <A>	markeredgewidth = <A>
<A> の要約統計量	<A> . describe ( )	df . sort_values ( <A> )
<A> 内の欠損値の合計を求める	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<A> 内の <B> と <C> に重複があるかチェックを表示する	<A> . duplicated ( subset = [ <B> , <C> ] )	pd . duplicated ( subset = [ <A> , <B> , <C> ] )
<B> という名前のエクセルの <C> 番目のシートからデータフレームを読み込んで、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = <C> )	hidden_layer_sizes = pd . read_excel ( <B> , sheet_name = <C> )
重複した最後の行を残して <A> ( データフレーム ) の重複している行を落とし、置き換える	<A> = <A> . drop_duplicates ( keep = False )	inplace = <A> . drop_duplicates ( keep = True )
グラフの x 軸を <A> とした <B> の縦向き棒グラフを描画する	plt . barh ( <A> , <B> )	bar plt . bar ( <A> , <B> )
そこで、マーカーの種類の色はグレーを用いる	markerfacecolor = 'gray'	'gray' = 'gray'
<B> 全体を <C> の値を元に昇順でソートを <A> とする	<A> = <B> . sort_values ( <C> )	df = <B> . sort_values ( <C> )
一番左の列をインデックスと設定して、 <B> からデータフレームとを読み込み、 <A> にする	<A> = pd . read_csv ( <B> , index_col = 0 )	df = pd . read_csv ( <B> , index_col = 0 )
<A> 内のそれぞれのカラムに存在する <B> の個数の合計を算出する	<A> . isin ( [ <B> ] ) . sum ( )	isin . isin ( [ <B> ] ) . sum ( )
<A> 中に重複はあるのか確認する	<A> . duplicated ( )	pd . duplicated ( <A> )
そこで、クロスのマーカーの形状を表示する	marker = 'x'	markersize = 'x'
<A> 中の NaN を消し、インプレースする	<A> . dropna ( inplace = True )	inplace = <A> . dropna ( )
<B> をデータフレームとして読み込んで、 <A> とする	<A> = pd . read_csv ( <B> )	df = pd . read_csv ( <B> )
<A> を位置で並び替えて、置き換える	<A> . sort_index ( inplace = True )	= <A> . sort_index ( )
<A> 中の欠損値を落として、インプレースする	<A> . dropna ( inplace = True )	df . dropna ( inplace = True )
<A> 中の <B> を欠損値に置換し、欠損値が存在する行を消して、置き換える	<A> . replace ( <B> , np . nan ) . dropna ( inplace = True )	start = <A> . replace ( <B> , np . nan ) . dropna ( )
<A> ( データフレーム ) の <B> を数値データで置き換えて、 <A> とする	<A> = pd . get_dummies ( <A> [ <B> ] )	= pd . get_dummies ( <A> [ <B> ] )
<A> をインデックスを軸にソートする	<A> . sort_index ( )	df . sort_index ( )
そこで、マーカーを五角形とする	marker = '*'	'*' = '*'
重複した最後の行を残して <A> ( データフレーム ) 中の重複している行をドロップを <A> に代入する	<A> = <A> . drop_duplicates ( keep = False )	df = <A> . drop_duplicates ( keep = False )
一番左の列をインデックスにして、 <B> からデータフレームとを読み込み、 <A> に代入する	<A> = pd . read_csv ( <B> , index_col = 0 )	df = pd . read_csv ( <B> , index_col = 0 )
左側のデータのインデックスと右側のデータの <D> を項目名として、 <B> と <C> をマージして、 <A> とする	<A> = pd . merge ( <B> , <C> , left_index = True , right_on = <D> )	df = pd . merge ( <B> , <C> , left_index = True , right_on = <D> )
先頭の列をインデックスと設定して、 <B> を表データに格納し、 <A> とする	<A> = pd . read_csv ( <B> , index_col = 0 )	df = pd . read_csv ( <B> , index_col = 0 )
<A> の列名を <B> から <C> にリネームし、再代入する	<A> = <A> . rename ( columns = { <B> : <C> } )	markersize = <A> . rename ( columns = { <B> : <C> } )
<A> の中の NaN の合計	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<A> のカラム名を <B> から <C> に、 <D> から <E> にリネームして、 <A> とする	<A> = <A> . rename ( columns = { <B> : <C> , <D> : <E> } )	start = <A> . rename ( columns = { <B> : <C> , <D> : <E> } )
<A> の位置を軸に並び替え、 <A> とする	<A> = <A> . sort_index ( )	df = <A> . sort_index ( )
<A> 内の欠損を <B> に置き換える	<A> . fillna ( <B> )	df . fillna ( <B> , inplace = True )
<A> において、全ての要素が <C> のカラムを作り、 <B> とする	<A> [ <B> ] = [ <C> ] * len ( <A> )	df [ <B> ] = [ <C> ] * len ( <A> )
グラフ要素に凡例を追加する	plt . legend ( )	color = )
<A> 内の index が <B> の行	<A> . loc [ <B> ]	loc <A> . loc [ <B> ]
<A> 中の未記入の値の合計を求める	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
そこで、バツ印のマーカーを使用する	marker = 'x'	markeredgewidth = 'x'
<A> を項目名としてデータを内部結合する	pd . merge ( df1 , df2 , on = <A> )	df1 = pd . merge ( <A> )
<B> のインデックスを軸に並び替え、 <A> とする	<A> = <B> . sort_index ( )	= <B> . sort_index ( )
そこで、線の種類を破線とする	linestyle = 'dashed'	kind = 'dashed'
<A> を <B> を列名として表にする	pd . pd . DataFrame ( <A> , columns = <B> )	pd . DataFrame ( <A> , columns = <B> )
そこで、マーカーの色は黄緑色である	markerfacecolor = 'greenyellow'	color = 'greenyellow'
<A> を位置を元に昇順で並び替え、置き換える	<A> = <A> . sort_index ( )	inplace = <A> . sort_index ( )
<A> の中の <B> に重複があるか確認する	<A> . duplicated ( subset = <B> )	df . duplicated ( subset = <B> )
同じグラフ内で <A> の <B> と <A> の <C> と <A> の <D> を箱ひげ図で作画する	plt . boxplot ( [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] )	pd . merge ( <A> [ <B> ] , <C> , <A> [ <D> ] ] ] ] ] )
<A> を小から大へとして、置き換える	df = df . sort_values ( <A> )	<A> = <A> . sort_values ( )
<A> の重複する行を削除し、置き換える	<A> = <A> . drop_duplicates ( )	= <A> . drop_duplicates ( )
<A> 番まで列が表示できるように変更する	pd . set_option ( 'display.max_columns' , <A> )	max_iter = pd . set_option ( <A> )
<B> を <C> をカラム名として表に変換し、 <A> にする	<A> = pd . pd . DataFrame ( <B> , columns = <C> )	df = pd . pd . DataFrame ( <B> , columns = <C> )
<B> の <E> について、 <C> を位置、 <D> をコラムとしたピボットテーブルを作成し、 <A> とする	<A> = <B> . pivot_table ( index = <C> , columns = <D> , values = <E> )	df = <B> . pivot_table ( index = <C> , columns = <D> , values = <E> )
<A> 全体をインデックスに基づいてソートして、置き換える	<A> = <A> . sort_index ( )	= <A> . sort_index ( )
<B> 中の欠損値を落とし、 <A> とする	<A> = <B> . dropna ( )	= <B> . dropna ( )
<A> と <B> を値が大きい順にする	df . sort_values ( [ <A> , <B> ] , ascending = False )	<A> . sort_values ( [ <B> ] , ascending = False )
<A> を <B> という名前でエクセルファイルに書き込む	<A> . to_excel ( <B> )	pd . read_excel ( <A> , sheet_name = <B> )
同じ軸で <A> の <B> と <C> と <D> をボックスチャートで描く	plt . boxplot ( [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] )	pd . boxplot [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] ] )
<A> の NaN が存在する行を落として、 <A> とする	<A> = <A> . dropna ( )	start = <A> . dropna ( )
<A> 中の NaN の合計	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
片方のテーブルにしかないデータも全て残して <B> ( データフレーム ) と <C> を一つにまとめて、 <A> とする	<A> = pd . merge ( <B> , <C> , how = 'outer' )	how = pd . merge ( <A> , <B> , <C> , how = 'outer' )
<A> の <B> の値をソートを <A> とする	<A> = <A> . sort_values ( <B> )	df = <A> . sort_values ( <B> )
<B> 全体を位置を元にソートして、 <A> とする	<A> = <B> . sort_index ( )	= <B> . sort_index ( )
<A> の <B> と <C> に重複がある場合	if <A> . duplicated ( subset = [ <B> , <C> ] ) :	sns . duplicated ( subset = [ <A> , <B> , <C> ] ) :
<A> の重複した行をドロップ	<A> . drop_duplicates ( )	) . drop_duplicates ( )
<A> の NaN を含む行をドロップを <A> に代入する	<A> = <A> . dropna ( )	= <A> . dropna ( )
<B> からデータフレームをカンマ区切りで読み込み、 <A> に代入する	<A> = pd . read_csv ( <B> , sep = ',' )	df = pd . read_csv ( <B> , sep = ',' )
<A> の <C> の秒を確認し、  <A> [ <B> ] にする	<A> [ <B> ] = <A> [ <C> ] . dt . second	<A> [ <B> ] = <A> [ <C> ] . dt . day )
<A> の <B> が <C> より大きいデータを取得する	<A> [ <A> [ <B> ] >  <C> ]	pd <A> [ <A> [ <B> ] > <C> ]
列番号 <C> をインデックスと設定して、 <B> をデータフレームとして読み、 <A> とする	<A> = pd . read_csv ( <B> , index_col = <C> )	df = pd . read_csv ( <B> , index_col = <C> )
<A> の未記入の値を平均値で補完する	<A> . fillna ( <A> . mean ( ) )	) . fillna ( <A> . mean ( ) )
<A> 内に存在する <B> を未入力の値に置換し、置き換える	<A> . replace ( <B> , np . nan , inplace = True )	df . replace ( <A> , <B> , np . nan , inplace = True )
<B> を one - hot 表現にし、 <A> に代入する	<A> = pd . get_dummies ( <A> [ <B> ] )	= pd . get_dummies ( <A> [ <B> ] )
そこで、マーカーの形のエッジ色は水色にする	markeredgecolor = 'cyan'	markeredgewidth = 'cyan'
<A> 内の未記入の値がある行を落として、 <A> にする	<A> = <A> . dropna ( )	start = <A> . dropna ( )
重複した最後の行を残して <B> ( データフレーム ) の重複している行を削除して、 <A> にする	<A> = <B> . drop_duplicates ( keep = False )	df = <B> . drop_duplicates ( keep = False )
重複している最後の行を残して <A> ( データフレーム ) の重複している行を落として、置き換える	<A> = <A> . drop_duplicates ( keep = False )	inplace = <A> . drop_duplicates ( keep = True )
<A> 中の <B> を NaN に置換し、 NaN が存在する行を落とす	<A> . replace ( <B> , np . nan ) . dropna ( )	replace <A> . replace ( <B> , np . nan ) . dropna ( )
<A> の各行に重複があるかどうか	<A> . duplicated ( )	pd . duplicated ( <A> )
<A> のカラム名を <B> から <C> に、 <D> から <E> にリネームして、インプレースする	<A> . rename ( columns = { <B> : <C> , <D> : <E> } , inplace = True )	marker . rename ( columns = { <B> : <C> , <D> : <E> } , inplace = True )
カンマ区切りで表を CSV ファイル <B> から読み込んで、 <A> にする	<A> = pd . read_csv ( <B> , sep = ',' )	= pd . read_csv ( <A> , sep = <B> )
多層パーセプトロンモデルを初期化する	sklearn . neural_network . MLPClassifier ( )	neural_network . MLPClassifier ( )
エクセルファイル <B> の <C> を読んで、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = <C> )	hidden_layer_sizes = pd . read_excel ( <B> , sheet_name = <C> )
<A> の NaN を <A> の平均値で埋める	<A> . fillna ( <A> . mean ( ) )	) . fillna ( <A> . mean ( ) )
<A> の未記入の値をその中央値で補完する	<A> . fillna ( <A> . median ( ) )	pd . fillna ( <A> . median ( ) )
エクセルデータ <B> からデータフレームを読んで、 <A> とする	<A> = pd . read_excel ( <B> )	df = pd . read_excel ( <B> )
<A> をインデックスで並び替え、置き換える	<A> = <A> . sort_index ( )	inplace = <A> . sort_index ( )
<A> の位置を軸にソートし、再代入する	<A> = <A> . sort_index ( )	df = <A> . sort_index ( )
<A> 中の重複する行を削除を <A> とする	<A> = <A> . drop_duplicates ( )	= <A> . drop_duplicates ( )
<B> というエクセルファイルの全部のシートからデータフレームを読み、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = None )	df = pd . read_excel ( <B> , sheet_name = None )
そこで、目印の色は水色	markerfacecolor = 'cyan'	color = 'cyan'
<A> を <B> の値を元にソートして、再代入する	<A> = <A> . sort_values ( <B> )	= <A> . sort_values ( <B> )
そこで、目印の色はグレーである	markerfacecolor = 'gray'	color = 'gray'
<A> 内の欠損値を落とし、インプレースする	<A> . dropna ( inplace = True )	inplace = <A> . dropna ( )
エクセルデータ <A> をデータフレームに格納する	pd . read_excel ( <A> , sheet_name = None )	pd . read_excel ( <A> )
多層パーセプトロンを準備して、 <A> とする	<A> = sklearn . neural_network . MLPClassifier ( )	df = sklearn . neural_network . MLPClassifier ( )
<B> と <C> を縦向きに結合して、 <A> とする	<A> = pd . concat ( [ <B> , <C> ] )	df = pd . concat ( [ <B> , <C> ] )
グラフの x 軸を <A> として、 <B> の鉛直棒グラフを作画する	plt . bar ( <A> , <B> )	plt . barh ( <A> , <B> )
そこで、目印の輪郭色は紺色を使う	markeredgecolor = 'navy'	markeredgewidth = 'navy'
日本語をグラフ中で表示できるようにする	sns . set ( font = 'IPAexGothic' , style = 'white' )	for i , style = 'white' )
<A> の中の欠損の数を求める	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<A> 内の <B> に重複が存在するのか確認する	<A> . duplicated ( subset = <B> )	df . duplicated ( subset = <B> )
<B> の中の未入力の値を直前の行の値で埋め、 <A> とする	<A> = <B> . fillna ( method = 'ffill' )	= <B> . fillna ( method = 'ffill' )
<A> を <B> に BOM 付きで保存する	<A> . to_csv ( <B> , encoding = 'utf_8_sig' )	df . sort_values ( <B> , encoding = 'utf_8_sig' )
<B> 内の NaN が存在する行を削除し、 <A> とする	<A> = <B> . dropna ( )	= <B> . dropna ( )
そこで、打点の輪郭色は黄緑にする	markeredgecolor = 'greenyellow'	'greenyellow' = 'greenyellow'
重複した最後の行を残して <A> ( データフレーム ) 中の重複した行を削除を <A> にする	<A> = <A> . drop_duplicates ( keep = False )	start = <A> . drop_duplicates ( keep = False )
同じ軸のセットで <A> の <B> と <A> の <C> と <A> の <D> を箱ひげ図で表示する	plt . boxplot ( [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] )	sns . boxplot ( [ <A> [ <B> ] , <A> [ <C> , <A> [ <D> ] ] ] )
エクセルファイル <B> を読み込んでデータフレームにし、 <A> にする	<A> = pd . read_excel ( <B> )	df = pd . read_excel ( <B> )
<A> 内の <B> に重複があるかどうか調べる	<A> . duplicated ( subset = <B> )	df . duplicated ( subset = <B> )
<A> の下 <B> 行を確認する	<A> . tail ( <B> )	df . tail ( <B> )
そこで、マーカーの輪郭色は紺色を使う	markeredgecolor = 'navy'	markeredgewidth = 'navy'
<A> の中の未記入の値を <B> に置き換えて、置き換える	<A> = <A> . fillna ( <B> )	df = <A> . fillna ( <B> )
<A> に重複があるか確認	df . duplicated ( subset = <A> )	pd . duplicated ( <A> )
<A> 内で重複した行の合計を調べる	<A> . duplicated ( ) . sum ( )	df . duplicated ( ) . sum ( )
そこで、マーカーの種類の色は黄色	markerfacecolor = 'yellow'	markeredgecolor = 'yellow'
<B> 中の NaN を <C> とし、 <A> とする	<A> = <B> . fillna ( <C> )	plt = <B> . fillna ( <C> )
<A> の <B> を位置に設定して、再代入する	<A> = <A> . set_index ( <B> )	plt = <A> . set_index ( <B> )
<B> をインデックスでソートし、 <A> に代入する	<A> = <B> . sort_index ( )	= <B> . sort_index ( )
そこで、黄緑をマーカーの形状のエッジ色とする	markeredgecolor = 'greenyellow'	'greenyellow' = 'greenyellow'
そこで、マーカーのエッジ色は水色にする	markeredgecolor = 'cyan'	markeredgewidth = 'cyan'
<A> 中の NaN の数を見る	<A> . isnull ( ) . sum ( )	isnull . isnull ( ) . sum ( )
<B> の <C> の値をソートし、 <A> にする	<A> = <B> . sort_values ( <C> )	<B> <A> = <C> . sort_values ( <C> )
先頭の列を位置として、 <B> を読んで、 <A> とする	<A> = pd . read_csv ( <B> , index_col = 0 )	pd . read_csv ( <A> , index_col = <B> )
エクセルファイル <B> の全てのシートからデータフレームを読み、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = None )	df = pd . read_excel ( <B> , sheet_name = None )
<A> 中の <B> に重複がある行を削除する	<A> . drop_duplicates ( subset = <B> )	start = <A> . drop_duplicates ( subset = <B> )
同じグラフ内で <A> の <B> と <C> と <D> を箱ひげ図で作図する	plt . boxplot ( [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] )	pd . merge ( <A> [ <B> ] , <C> , <A> [ <D> ] ] ] ] ] )
カンマ区切りで CSV ファイル <A> を読む	pd . read_csv ( <A> , sep = ',' )	',' = pd . read_csv ( <A> )
<A> の未入力の値を直前の行の値で補って、 <A> とする	<A> = <A> . fillna ( method = 'ffill' )	start = <A> . fillna ( method = 'ffill' )
<A> 内の重複をチェックする	<A> . duplicated ( )	pd . duplicated ( <A> )
そこで、マーカーの輪郭線は <A> を使う	markeredgewidth = <A>	bins = <A>
<A> に重複があるかどうかを検出する	<A> . duplicated ( )	pd . duplicated ( <A> )
<A> 中の欠損を削除して、置き換える	<A> = <A> . dropna ( )	inplace = <A> . dropna ( )
<A> と <B> を折れ線グラフで表示する	plt . plot ( <A> , <B> )	kind = <A> . plot ( <B> )
重複している行をドロップ	df . drop_duplicates ( )	plt . drop_duplicates ( )
<A> の中の重複する値がある行を取り除く	<A> . drop_duplicates ( )	start . drop_duplicates ( )
<B> を <C> をコラム名としてデータフレームにし、 <A> にする	<A> = pd . pd . DataFrame ( <B> , columns = <C> )	byteorder <A> = pd . pd . DataFrame ( <B> , columns = <C> )
<A> の NaN が存在する行を消し、置き換える	<A> . dropna ( inplace = True )	inplace = <A> . dropna ( )
<A> 中の NaN がある行を消し、インプレースする	<A> . dropna ( inplace = True )	. dropna ( inplace = True )
<A> の重複している行をドロップして、インプレースする	<A> . drop_duplicates ( inplace = True )	inplace = <A> . drop_duplicates ( )
グラフの日本語フォントを有効にする	sns . set ( font = 'IPAexGothic' , style = 'white' )	plt . set ( font = 'IPAexGothic' )
<A> の <B> に重複がある行を削除する	<A> . drop_duplicates ( subset = <B> )	start = <A> . drop_duplicates ( subset = <B> )
<B> を小から大へとソートを <A> に代入する	<A> = <A> . sort_values ( <B> )	df = <A> . sort_values ( <B> )
そこで、マーカーの種類の輪郭色はネイビーをする	markeredgecolor = 'navy'	markeredgewidth = 'navy'
<A> 内の重複している行を落とす	<A> . drop_duplicates ( )	plt . drop_duplicates ( )
<A> から箱ひげ図をプロットする	plt . boxplot ( <A> )	plt . hist ( <A> )
<A> を <B> にインデックスなしで保存する	<A> . to_csv ( <B> , index = False )	df . to_csv ( <B> , index = False )
<A> を位置を元に並び替える	<A> . sort_index ( )	df . sort_index ( )
棒グラフの項目名を <A> から <B> 、 <C> 、 <D> に変える	plt . xticks ( <A> , [ <B> , <C> , <D> ] )	sns . xticks ( <A> [ <B> , <C> , <D> ] )
<A> の未記入の値をその平均値で補完する	<A> . fillna ( <A> . mean ( ) )	) . fillna ( <A> . mean ( ) )
<A> 内 ] [ でもの	<A> [ <A> . duplicated ( ) ]	[ <A> . duplicated ( ) ]
<B> の重複している値がある行を削除し、 <A> とする	<A> = <B> . drop_duplicates ( )	= <B> . drop_duplicates ( )
<B> を <C> を表属性名として表に変換して、 <A> にする	<A> = pd . pd . DataFrame ( <B> , columns = <C> )	byteorder <A> = pd . pd . DataFrame ( <B> , columns = <C> )
<A> の <B> 行目から最後までを見る	<A> [ <B> : ]	df [ <B> : ]
そこで、五角形のマーカーの形状を表示する	marker = '*'	'*' = '*'
<A> から <B> というエクセルファイルにする	<A> . to_excel ( <B> )	pd . read_excel ( <A> , sheet_name = <B> )
そこで、マーカーの種類の色は青色を用いる	markerfacecolor = 'blue'	markeredgecolor = 'blue'
<A> 中の重複しているデータを抽出する	<A> [ <A> . duplicated ( ) ]	[ <A> . duplicated ( ) ]
<B> を小から大へと並び替えて、 <A> とする	<A> = df . sort_values ( <B> )	<A> = <A> . sort_values ( <B> )
<A> の未入力の値をドロップし、インプレースする	<A> . dropna ( inplace = True )	inplace = <A> . dropna ( )
<A> の <B> を消して、 <A> とする	<A> = <A> . drop ( <B> , axis = 1 )	plt = <A> . drop ( <B> , axis = 1 )
そこで、菱形のマーカーの形状を使用する	marker = 'D'	markeredgewidth = 'D'
<A> ( データフレーム ) の <B> と <C> を降順にソートし、再代入する	<A> = <A> . sort_values ( [ <B> , <C> ] , ascending = False )	df = <A> . sort_values ( [ <B> , <C> ] , ascending = False )
<A> 中の欠損を <B> とし、 <A> とする	<A> = <A> . fillna ( <B> )	start = <A> . fillna ( <B> )
そこで、赤をマーカーの色とする	markerfacecolor = 'red'	markeredgecolor = 'red'
<A> 中の <B> を未記入の値に置換し、未記入の値がある行を削除する	<A> . replace ( <B> , np . nan ) . dropna ( )	replace <A> . replace ( <B> , np . nan ) . dropna ( )
<A> の <B> と <C> を逆順にソートして、 <A> に代入する	<A> = <A> . sort_values ( [ <B> , <C> ] , ascending = False )	df = <A> . sort_values ( [ <B> , <C> ] , ascending = False )
<A> 中の欠損の合計	<A> . isnull ( ) . sum ( )	df . isnull ( ) . sum ( )
<A> 中の欠損値をドロップして、 <A> とする	<A> = <A> . dropna ( )	start = <A> . dropna ( )
<A> を位置を軸にソートする	<A> . sort_index ( )	plt . sort_index ( )
<A> 内に重複があるのかどうか確認する	<A> . duplicated ( )	df . duplicated ( subset = <A> )
一番左の列をインデックスと設定して、 <B> からデータフレームとを読み、 <A> とする	<A> = pd . read_csv ( <B> , index_col = 0 )	df = pd . read_csv ( <B> , index_col = 0 )
重複する最後の行を残して <A> ( データフレーム ) 内の重複する行を消す	<A> . drop_duplicates ( keep = False )	df . drop_duplicates ( keep = False )
<A> の中の NaN をドロップして、置き換える	<A> . dropna ( inplace = True )	inplace = <A> . dropna ( )
そこで、バッファリングしない	buffering = -1	encoding = 'shift_jis'
そこで、マーカーの形の色として紫色を使用する	markerfacecolor = 'purple'	markeredgecolor = 'purple'
<B> の全ての列の重複する値がある行を取り除き、 <A> とする	<A> = <B> . drop_duplicates ( )	= <B> . drop_duplicates ( )
<A> を <B> を列名として表データにする	pd . pd . DataFrame ( <A> , columns = <B> )	pd . DataFrame ( <A> , columns = <B> )
<A> の未入力の値の個数	<A> . isnull ( ) . sum ( )	] . isnull ( ) . sum ( )
<A> 全体を位置を軸にソートし、置き換える	<A> . sort_index ( inplace = True )	df = <A> . sort_index ( )
<A> 中の NaN を <A> の平均値で埋めて、 <A> とする	<A> = <A> . fillna ( <A> . mean ( ) )	df = <A> . fillna ( <A> . mean ( ) )
<A> のインデックス名を <B> から <C> に変更して、 <A> に代入する	<A> = <A> . rename ( index = { <B> : <C> } )	<B> <A> . rename ( index = { <C> : <D> } , inplace = True )
<A> のカラム名を <B> から <C> に、 <D> から <E> にリネームする	<A> . rename ( columns = { <B> : <C> , <D> : <E> } )	df . rename ( columns = { <B> : <C> , <D> : <E> } )
<B> の <C> と <D> を降順に並び替え、 <A> とする	<A> = <B> . sort_values ( [ <C> , <D> ] , ascending = False )	df = <B> . sort_values ( [ <C> , <D> ] , ascending = False )
<A> の <B> に重複がある行を落とし、再代入する	<A> = <A> . drop_duplicates ( subset = <B> )	df = <A> . drop_duplicates ( subset = <B> )
<A> ( データフレーム ) の <B> と <C> を大から小へとソート	<A> . sort_values ( [ <B> , <C> ] , ascending = False )	df . sort_values ( [ <A> , <B> , <C> ] , ascending = False )
<A> の <B> を軸に昇順で並び替えて、 <A> とする	<A> = <A> . sort_values ( <B> )	= <A> . sort_values ( <B> )
<B> から <C> の範囲で <A> のヒストグラムを表示する	plt . hist ( <A> , range = ( <B> , <C> ) )	range = ( <A> , <B> , <C> ) )
<A> 内の <B> を NaN に置換し、 NaN がある行をドロップする	<A> . replace ( <B> , np . nan ) . dropna ( )	df . replace ( <A> , <B> , np . nan ) . dropna ( )
<A> 中の欠損を含む行を削除し、 <A> とする	<A> = <A> . dropna ( )	start = <A> . dropna ( )
<A> 全体を位置に基づいてソートして、インプレースする	<A> . sort_index ( inplace = True )	solver . sort_index ( inplace = True )
<A> 中の <B> を未記入の値に置換し、未記入の値がある行を落として、再代入する	<A> = <A> . replace ( <B> , np . nan ) . dropna ( )	start = <A> . replace ( <B> , np . nan ) . dropna ( )
<A> の行の重複を判定する	<A> . duplicated ( )	] . duplicated ( )
重複している最後の行を残して <A> ( データフレーム ) の重複している行を落とし、インプレースする	<A> . drop_duplicates ( keep = False , inplace = True )	df . drop_duplicates ( keep = False , inplace = True )
<A> を位置を元に並び替え、 <A> とする	<A> = <A> . sort_index ( )	= <A> . sort_index ( )
<A> の <B> が <C> より多いデータを得る	<A> [ <A> [ <B> ] >  <C> ]	pd <A> [ <A> [ <B> ] > <C> ]
<A> 内の欠損が存在する行を落として、置き換える	<A> . dropna ( inplace = True )	inplace = <A> . dropna ( )
そこで、赤紫色をマーカーの色とする	markerfacecolor = 'magenta'	color = 'magenta'
<A> 中の欠損値が存在する行を落とし、 <A> にする	<A> = <A> . dropna ( )	start = <A> . dropna ( )
<A> 内に重複があるか見る	<A> . duplicated ( )	pd . duplicated ( <A> )
そこで、線は破線を使う	linestyle = 'dashed'	kind = 'dashed'
<A> をインデックスを軸にソート	<A> . sort_index ( )	df . sort_index ( )
<A> 中の欠損がある行をドロップする	<A> . dropna ( )	df . dropna ( )
列番号 <C> をインデックスと設定して、 <B> からデータフレームとを読み、 <A> とする	<A> = pd . read_csv ( <B> , index_col = <C> )	df = pd . read_csv ( <B> , index_col = <C> )
<A> 中の NaN を含む行を落とす	<A> . dropna ( )	df . dropna ( )
<A> 中の NaN を含む行を落とし、 <A> とする	<A> = <A> . dropna ( )	start = <A> . dropna ( )
そこで、マーカーの形状のエッジ色として赤を使用する	markeredgecolor = 'red'	markeredgewidth = 'red'
<A> を位置でソートして、 <A> とする	<A> = <A> . sort_index ( )	df = <A> . sort_index ( )
<A> についてダミー変数をつくって、 <A> にする	<A> = pd . get_dummies ( <A> )	df = pd . get_dummies ( <A> )
<A> の欠損値を削除	<A> . dropna ( )	df . dropna ( )
そこで、マーカーを十字とする	marker = 'x'	solver = 'x'
<A> に重複があるのかどうか調べる	df . duplicated ( subset = <A> )	pd . duplicated ( <A> )
<A> 中の NaN が存在する行を落として、置き換える	<A> = <A> . dropna ( )	inplace = <A> . dropna ( )
<A> 中の欠損値をドロップする	<A> . dropna ( )	df . dropna ( )
<A> の <B> の名前を <C> に変更し、置き換える	<A> = <A> . rename ( columns = { <B> : <C> } )	<A> . rename ( index = { <B> : <C> } , inplace = True )
<A> の欠損値の個数	<A> . isnull ( ) . sum ( )	] . isnull ( ) . sum ( )
<A> と <B> と <C> から箱ひげ図を描画する	plt . boxplot ( [ <A> , <B> , <C> ] )	kind = plt . boxplot ( [ <A> , <B> , <C> ] )
<A> の欠損値を <A> の平均値で補い、置き換える	<A> . fillna ( <A> . mean ( ) , inplace = True )	fillna <A> . mean ( ) , inplace = True )
そこで、打点の輪郭色は水色を用いる	markeredgecolor = 'cyan'	markeredgewidth = 'cyan'
<A> の未入力の値を <B> に置換して、再代入する	<A> = <A> . fillna ( <B> )	plt = <A> . fillna ( <B> )
<A> の未記入の値を直前の行の値で埋め、 <A> とする	<A> = <A> . fillna ( method = 'ffill' )	start = <A> . fillna ( method = 'ffill' )
<B> 中に存在する <C> を欠損として、 <A> とする	<A> = <B> . replace ( <C> , np . nan )	start = <B> . replace ( <C> , np . nan )
<A> の <B> の名前を <C> に、 <D> の名前を <E> に変更して、置き換える	<A> = <A> . rename ( columns = { <B> : <C> , <D> : <E> } )	df . rename ( columns = { <B> : <C> , <D> : <E> } , inplace = True )
<A> の中の欠損を <A> の平均値で補って、再代入する	<A> = <A> . fillna ( <A> . mean ( ) )	df = <A> . fillna ( <A> . mean ( ) )
エクセルファイル <B> のシート全部からデータフレームを読んで、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = None )	df = pd . read_excel ( <B> , sheet_name = None )
<A> 中の欠損を落とし、インプレースする	<A> . dropna ( inplace = True )	inplace = <A> . dropna ( )
グラフの x 軸を <A> として、 <B> の鉛直棒グラフを描写する	plt . barh ( <A> , <B> )	bar plt . bar ( <A> , <B> )
<A> の <B> と <C> に重複があるのか表示してみる	<A> . duplicated ( subset = [ <B> , <C> ] )	plt . duplicated ( subset = [ <A> , <B> , <C> ] )
<A> 中の未記入の値を <A> の平均値で埋めて、 <A> とする	<A> = <A> . fillna ( <A> . mean ( ) )	start = <A> . fillna ( <A> . mean ( ) )
<B> 次元に圧縮する PCA モデルを新たに使えるようにして、 <A> とする	<A> = sklearn . decomposition . PCA ( ( n_components = <B> )	start = <B> . decomposition . PCA ( n_components = sklearn )
<A> の欠損を <B> に置き換え、 <A> に代入する	<A> = <A> . fillna ( <B> )	df = <A> . fillna ( <B> )
<A> を <B> をカラム名としてデータフレームにする	pd . pd . DataFrame ( <A> , columns = <B> )	pd . DataFrame ( <A> , columns = <B> )
<A> 内の欠損値がある行を消し、置き換える	<A> . dropna ( inplace = True )	inplace = <A> . dropna ( )
<A> の内容をチェックを表示する	<A> . head ( )	df . head ( )
<A> の <B> を欠損に置換し、欠損がある行を消し、置き換える	<A> . replace ( <B> , np . nan ) . dropna ( inplace = True )	df = <A> . replace ( <B> , np . nan ) . dropna ( )
カンマ区切りで CSV ファイル <A> から表データを読み込む	pd . read_csv ( <A> , sep = ',' )	sep = pd . read_csv ( <A> )
そこで、マーカーの形状の色を赤紫色とする	markerfacecolor = 'magenta'	color = 'magenta'
そこで、グラフの種類は積み上げをする	stacked = True	markersize = True
一番左の列を位置として、 <B> から読み込んで、 <A> とする	<A> = pd . read_csv ( <B> , index_col = 0 )	pd . read_csv ( <A> , index_col = <B> )
<A> のインデックスを軸にソート	<A> . sort_index ( )	plt . sort_index ( )
<A> 内の重複している行をドロップする	<A> . drop_duplicates ( )	plt . drop_duplicates ( )
同じ軸のセットで <A> の <B> と <A> の <C> と <A> の <D> を箱ひげ図で描画する	plt . boxplot ( [ <A> [ <B> ] , <A> [ <C> ] , <A> [ <D> ] ] )	[ <A> = <B> ] . boxplot ( [ <C> ] , <A> [ <D> ] ] ] ] )
<A> 内の <B> を NaN に置換し、 NaN がある行を消し、置き換える	<A> . replace ( <B> , np . nan ) . dropna ( inplace = True )	df = <A> . replace ( <B> , np . nan ) . dropna ( )
日本語をグラフで表示できるようにする	sns . set ( font = 'IPAexGothic' , style = 'white' )	pd . set ( font = 'IPAexGothic' , style = 'white' )
<B> 中の欠損を含む行を消し、 <A> にする	<A> = <B> . dropna ( )	= <B> . dropna ( )
<B> というエクセルデータを読み、 <A> とする	<A> = pd . read_excel ( <B> , sheet_name = None )	df = pd . read_excel ( <B> )
そこで、エンコーディングは <A> とする	encoding = <A>	markeredgewidth = <A>
表示するグラフのサイズを横 <A> 縦 <B> に指定する	plt . figure ( figsize = ( <A> , <B> ) )	pd . figure ( figsize = ( <A> , <B> ) )
そこで、マーカーの形の色を紫色とする	markerfacecolor = 'purple'	markeredgecolor = 'purple'
エクセルデータ <B> をデータフレームに読み、 <A> に代入する	<A> = pd . read_excel ( <B> )	df = pd . read_excel ( <B> )
