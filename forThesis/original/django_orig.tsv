from threading import local	from threading import local into default name space.
import warnings	import module warnings.
from django . conf import settings	from django.conf import settings into default name space.
from django . core import signals	from django.core import signals into default name space.
from django . core . cache . backends . base import (  InvalidCacheBackendError , CacheKeyWarning , BaseCache )	from django.core.cache.backends.base import InvalidCacheBackendError, CacheKeyWarning and BaseCache into default name space.
from django . core . exceptions import ImproperlyConfigured	from django.core.exceptions import ImproperlyConfigured into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
from django . utils . module_loading import import_string	from django.utils.module_loading import import_string into default name space.
__all__ = [  'get_cache' , 'cache' , 'DEFAULT_CACHE_ALIAS' , 'InvalidCacheBackendError' ,  'CacheKeyWarning' , 'BaseCache' ,  ]	__all__ is an list containing 6 elements: 'get_cache', 'cache', 'DEFAULT_CACHE_ALIAS', 'InvalidCacheBackendError',
DEFAULT_CACHE_ALIAS = 'default'	'CacheKeyWarning' and 'BaseCache'   DEFAULT_CACHE_ALIAS is a string 'default'.
if DEFAULT_CACHE_ALIAS not in settings . CACHES :	if DEFAULT_CACHE_ALIAS is not contained in settings.CACHES,
raise ImproperlyConfigured ( 'You must define a '%s' cache' % DEFAULT_CACHE_ALIAS )	raise an exception ImproperlyConfigured with string 'You must define a '%s' cache' as argument, with '%s' replaced with DEFAULT_CACHE_ALIAS converted into a string.
def get_cache ( backend , ** kwargs ) :	define the function get_cache with backend and dictionary pair of elements kwargs as arguments.
cache = _create_cache ( backend , ** kwargs )	and stacklevel set to 2 as arguments.   call the _create_cache with backend and dictionary kwargs as arguments, substitute the result for cache.
signals . request_finished . connect ( cache . close )	call the function signals.request_finished.connect with argument cache.close.
return cache	return cache.
def _create_cache ( backend , ** kwargs ) :	define the function _create_cache with backend and dictionary pair of elements kwargs as arguments.
try :	try,
try :	try,
conf = settings . CACHES [ backend ]	substitute value under the backend key of settings.CACHES dictionary for conf.
except KeyError :	if KeyError exception is caught,
try :	try,
import_string ( backend )	call the function import_string with argument backend.
except ImportError as e :	if ImportError, renamed to e, exception is caught,
raise InvalidCacheBackendError ( 'Could not find backend '%s': %s' % (  backend , e ) )	raise and exception InvalidCacheBackendError with string 'Could not find backend '%s': %s' as argument, replace '%s' with backend and e, respectively.
location = kwargs . pop ( 'LOCATION' , '' )	remove 'LOCATION' key from kwargs dictionary and put it into location, or use an empty string if key doesnt exists.
params = kwargs	substitute kwargs for params.
else :	if not,
params = conf . copy ( )	call the function conf.copy, substitute it for params.
params . update ( kwargs )	call the function params.update with argument kwargs.
backend = params . pop ( 'BACKEND' )	remove 'BACKEND' key from params dictionary and put it into backend.
location = params . pop ( 'LOCATION' , '' )	remove 'LOCATION' key from kwargs dictionary and put it into location, or use an empty string if key doesnt exists.
backend_cls = import_string ( backend )	call the import_string with argument backend, substitute it for backend_cls.
except ImportError as e :	if ImportError, renamed to e, is caught,
raise InvalidCacheBackendError (  'Could not find backend '%s': %s' % ( backend , e ) )	aise and exception InvalidCacheBackendError with string 'Could not find backend '%s': %s' as argument, replace '%s' with backend and e, respectively.
return backend_cls ( location , params )	evaluate the function backend_cls with location and params as arguments, return the result.
class CacheHandler ( object ) :	derive the class CacheHandler from the object base class.
def __init__ ( self ) :	define the __init__ method with argument self.
self . _caches = local ( )	call the function local, substitute the result for self._caches.
def __getitem__ ( self , alias ) :	define the __getitem__ method with self and alias arguments.
try :	try,
return self . _caches . caches [ alias ]	return value under the alias key of self._caches.caches dictionary.
except AttributeError :	except if AttributeError is caught,
self . _caches . caches = { }	self._caches.caches is an empty dictionary.
except KeyError :	except if KeyError exception is caught,
pass	do nothing.
if alias not in settings . CACHES :	if alias is not contained in setting.CACHES,
raise InvalidCacheBackendError (  'Could not find config for '%s' in settings.CACHES' % alias  )	raise and exception InvalidCacheBackendError with string 'Could not find config for '%s' in settings.CACHES' as argument, replace '%s' with alias.
cache = _create_cache ( alias )	call the function _create_cache with argument alias.
self . _caches . caches [ alias ] = cache	substitute cache for value under the alias key of self._caches.caches dictionary.
return cache	reuturn cache.
def all ( self ) :	define the method all with argument self.
return getattr ( self . _caches , 'caches' , { } ) . values ( )	get attribute 'caches' from the self._caches if exists, otherwise get an empty dictionary, call the values method on the return value, return it.
caches = CacheHandler ( )	call the CacheHandler function, substitute the result for caches.
class DefaultCacheProxy ( object ) :	derive the class DefaultCacheProxy from the base class object.
def __getattr__ ( self , name ) :	define the method __getattr__ with self and name as arguments.
return getattr ( caches [ DEFAULT_CACHE_ALIAS ] , name )	get attribute name from value under the DEFAULT_CACHE_ALIAS key of caches dictionary, return it.
def __setattr__ ( self , name , value ) :	define the method __setattr__ with self, name and value as arguments.
return setattr ( caches [ DEFAULT_CACHE_ALIAS ] , name , value )	set the attribute name from value under the DEFAULT_CACHE_ALIAS key of caches dictionary to value, return it.
def __delattr__ ( self , name ) :	define the method __delattr__ with self and name as arguments.
return delattr ( caches [ DEFAULT_CACHE_ALIAS ] , name )	delete the attribute name from the cache dictionary under the DEFAULT_CACHE_ALIAS key.
def __contains__ ( self , key ) :	define the method __contains__ with self and key as arguments.
return key in caches [ DEFAULT_CACHE_ALIAS ]	if key if contained in value under the DEFAULT_CACHE_ALIAS key of caches dictionary, return boolean True, otherwise return False.
def __eq__ ( self , other ) :	define the method __eq__ with self and other as arguments.
return caches [ DEFAULT_CACHE_ALIAS ] == other	if value under the DEFAULT_CACHE_ALIAS key of caches dictionary equals to other, return boolean True, otherwise return False.
def __ne__ ( self , other ) :	define the method __ne__ with self and other as arguments.
return caches [ DEFAULT_CACHE_ALIAS ] != other	if value under the DEFAULT_CACHE_ALIAS key of caches dictionary is not equal to other, return boolean True, otherwise return False.
cache = DefaultCacheProxy ( )	call the DefaultCacheProxy function, substitute it for cache.
def close_caches ( ** kwargs ) :	define the function close_caches with dictionary pair of elements kwargs as argument.
for cache in caches . all ( ) :	for every cache in return value of the function caches.all.
cache . close ( )	call the function cache.close.
signals . request_finished . connect ( close_caches )	call the function signals.request_finished.connect with argument close_caches.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import time	import module time.
import warnings	import module warnings.
from django . core . exceptions import ImproperlyConfigured , DjangoRuntimeWarning	from django.core.exceptions import ImproperlyConfigured and DjangoRuntimeWarning into default name space.
from django . utils . module_loading import import_string	from django.utils.module_loading import import_string into default name space.
class InvalidCacheBackendError ( ImproperlyConfigured ) :	derive class InvalidCacheBackendError from the ImproperlyConfigured base class.
pass	do nothing.
class CacheKeyWarning ( DjangoRuntimeWarning ) :	derive class CacheKeyWarning from the DjangoRuntimeWarning base class.
pass	do nothing.
DEFAULT_TIMEOUT = object ( )	DEFAULT_TIMEOUT is a instance of the class object.
MEMCACHE_MAX_KEY_LENGTH = 250	MEMCACHE_MAX_KEY_LENGTH is integer 250.
def default_key_func ( key , key_prefix , version ) :	define the function default_key_func with 3 arguments, key, key_prefix and version.
return '%s:%s:%s' % ( key_prefix , version , key )	convert key_prefix, version and key into strings, concatenate them respectively, with character ':' as delimiter, return the result.
def get_key_func ( key_func ) :	define the function get_key_func with argument key_func.
if key_func is not None :	if key_func is not of None type,
if callable ( key_func ) :	if key_function is callable object,
return key_func	return key_func.
else :	if not,
return import_string ( key_func )	evaluate the function import_string with key_func as argument, return the result.
return default_key_func	return default_key_func.
class BaseCache ( object ) :	derive the class BaseCache from the object base class.
def __init__ ( self , params ) :	define the initialization function __init__ with self class instance and params as arguments.
timeout = params . get ( 'timeout' , params . get ( 'TIMEOUT' , 300 ) )	call the params.get method with string 'TIMEOUT' and integer 300 as arguments, use the string 'timeout' and previous result as the arguments for the call to the params.get method, substitute the result for timeout.
if timeout is not None :	if timeout is not None,
try :	try,
timeout = int ( timeout )	convert timeout into an integer.
except ( ValueError , TypeError ) :	if ValueError or TypeError exceptions occurred,
timeout = 300	timeout is integer 300.
self . default_timeout = timeout	substitute timeout for self.default_timeout.
options = params . get ( 'OPTIONS' , { } )	call the params.get with string 'OPTIONS' and empty dictionary as arguments, substitute the result for options.
max_entries = params . get ( 'max_entries' , options . get ( 'MAX_ENTRIES' , 300 ) )	call the options.get method with string 'MAX_ENTRIES' and integer 300 as arguments, use the string 'max_entries' and previous result as the arguments for the call to the params.get method, substitute the result for max_entries.
try :	try,
self . _max_entries = int ( max_entries )	convert max_entries into a string, substitute it for self._max_entries.
except ( ValueError , TypeError ) :	if ValueError or TypeError exceptions occurred,
self . _max_entries = 300	self._max_entries is integer 300.
cull_frequency = params . get ( 'cull_frequency' , options . get ( 'CULL_FREQUENCY' , 3 ) )	call the options.get method with string 'CULL_FREQUENCY' and integer 3 as arguments, use the string 'cull_frequency' and previous result as the arguments for the call to the params.get method, substitute the result for cull_frequency.
try :	try,
self . _cull_frequency = int ( cull_frequency )	convert cull_frequency into an integer and substitute it for self._cull_frequency.
except ( ValueError , TypeError ) :	if ValueError or TypeError exceptions occurred,
self . _cull_frequency = 3	self._cull_frequency is integer 3.
self . key_prefix = params . get ( 'KEY_PREFIX' , '' )	call the params.get method with string 'KEY_PREFIX' and an empty string as arguments, substitute the result for self._key_prefix.
self . version = params . get ( 'VERSION' , 1 )	call the params.get method wit string 'VERSION' and integer 1 as arguments, substitute the result for self.version.
self . key_func = get_key_func ( params . get ( 'KEY_FUNCTION' , None ) )	call the method params.get with 2 arguments, string 'KEY_FUNCTION' and None, use the result as the argument for the call to the function get_key_func, substitute the result for the self.key_func.
def get_backend_timeout ( self , timeout = DEFAULT_TIMEOUT ) :	define the method get_backend_timeout with self class instance and timeout set to DEFAULT_TIMEOUT as arguments,
if timeout == DEFAULT_TIMEOUT :	if timeout equals to DEFAULT_TIMEOUT,
timeout = self . default_timeout	substitute self.default_timeout for timeout.
elif timeout == 0 :	else if timeout equals to integer 0,
timeout = - 1	timeout is a integer -1.
return None if timeout is None else time . time ( ) + timeout	if timeouts is None return None, otherwise return the sum of function time.time return value and timeout.
def make_key ( self , key , version = None ) :	define the function make_key with self class instance, key and version set to None as arguments.
if version is None :	if version is None,
version = self . version	substitute self.version for version.
new_key = self . key_func ( key , self . key_prefix , version )	call the method self.key_function with key, self.key_prefix and version as arguments, substitute the result for new_key.
return new_key	return new_key.
def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :	define the method add with 5 arguments, self, key, value, timeout defaulting to DEFAULT_TIMEOUT and version defaulting to None.
raise NotImplementedError ( 'subclasses of BaseCache must provide an add() method' )	raise an exception of class NotImplementedError with string 'subclasses of BaseCache must provide an add() method' as argument.
def get ( self , key , default = None , version = None ) :	define the method get with 4 arguments, self, key, default set to None and version set to None.
raise NotImplementedError ( 'subclasses of BaseCache must provide a get() method' )	raise an exception of class NotImplementedError, with string 'subclasses of BaseCache must provide a get() method' as argument.
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :	define the method set with 5 arguments, self, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
raise NotImplementedError ( 'subclasses of BaseCache must provide a set() method' )	raise an exception of class NotImplementedError, with string 'subclasses of BaseCache must provide a set() method' as argument.
def delete ( self , key , version = None ) :	define delete method with self class instance, key and version set to None, as arguments.
raise NotImplementedError ( 'subclasses of BaseCache must provide a delete() method' )	raise an exception of class NotImplementedError, with string 'subclasses of BaseCache must provide a delete() method' as argument.
def get_many ( self , keys , version = None ) :	define the get_many method with self class instance, keys and version set to None as arguments.
d = { }	d is an empty dictionary.
for k in keys :	for every k in keys,
val = self . get ( k , version = version )	call the self.get method with k and version set to version as arguments, substitute the result for val.
if val is not None :	if val is not None,
d [ k ] = val	substitute val for value under the k key of dictionary d.
return d	return d.
def has_key ( self , key , version = None ) :	define method has_key with self class instance, key and version set to None as arguments.
return self . get ( key , version = version ) is not None	call the self.get method with key and version set to version as arguments, return it if it is not None.
def incr ( self , key , delta = 1 , version = None ) :	define the method incr with 4 arguments, self class instance, key, delta defaulting to integer 1 and version defaulting to None.
value = self . get ( key , version = version )	call the method self.get with key and version set to version as arguments, substitute the result for value.
if value is None :	if value is None,
raise ValueError ( 'Key '%s' not found' % key )	raise an exception of class ValueError, with string 'Key '%s' not found' as argument, where '%s' is substituted for key.
new_value = value + delta	add value and delta together, substitute the result for new_value.
self . set ( key , new_value , version = version )	call the self.set method with key, new_value and version set to version as arguments.
return new_value	return new_value.
def decr ( self , key , delta = 1 , version = None ) :	define the method decr with arguments self, key, delta defaulting to integer 1 and version defaulting to None.
return self . incr ( key , - delta , version = version )	call the self.incr method with key, negative delta and version set to version as arguments.
def __contains__ ( self , key ) :	define the private method __contains__ with self class instance and key as arguments.
return self . has_key ( key )	evaluate the self.has_key method with key as argument, return the result.
def set_many ( self , data , timeout = DEFAULT_TIMEOUT , version = None ) :	define the method set_many with arguments, self, data, timeout defaulting to DEFAULT_TIMEOUT and version set to None.
for key , value in data . items ( ) :	for every key and value in data.items method return value,
self . set ( key , value , timeout = timeout , version = version )	call the method self.set with arguments key, value, timeout set to timeout, version set to version.
def delete_many ( self , keys , version = None ) :	define the method delete_many with arguments self, keys and version defaulting to None.
for key in keys :	for every key in keys,
self . delete ( key , version = version )	call the delete method with key and version set to version as arguments.
def clear ( self ) :	define the method clear with self class instance as the argument,
raise NotImplementedError ( 'subclasses of BaseCache must provide a clear() method' )	raise an exception NotImplementedError with string 'subclasses of BaseCache must provide a clear() method' as argument.
def validate_key ( self , key ) :	define the method validate_key with self class instance and key as arguments.
if len ( key ) > MEMCACHE_MAX_KEY_LENGTH :	if length of key is greater than MEMCACHE_MAX_KEY_LENGTH,
warnings . warn ( 'Cache key will cause errors if used with memcached: '  '%s (longer than %s)' % ( key , MEMCACHE_MAX_KEY_LENGTH ) ,  CacheKeyWarning )	substitute '%s' in string 'Cache key will cause errors if used with memcached: %s (longer than %s)' with key,
for char in key :	and MEMCACHE_MAX_KEY_LENGTH, call the function warnings.warn with previous string and CacheKeyWarning as arguments.   for every char in key,
if ord ( char ) < 33 or ord ( char ) == 127 :	if ascii value of char is smaller than integer 33 or is equal to integer 127,
warnings . warn ( 'Cache key contains characters that will cause '  'errors if used with memcached: %r' % key ,  CacheKeyWarning )	substitute '%r' in string 'Cache key contains characters that will cause errors if used with memcached: %r' with key,
def incr_version ( self , key , delta = 1 , version = None ) :	call the function warnings.warn with previous string and CacheKeyWarning as arguments.   define the method incr_version with 4 arguments, self, key, delta defaulting to integer 1 and version defaulting to None.
if version is None :	if version is None,
version = self . version	substitute self.version for version.
value = self . get ( key , version = version )	call the self.get method with arguments key and version set to version, substitute the result for value.
if value is None :	if value is None,
raise ValueError ( 'Key '%s' not found' % key )	raise an exception of the class ValueError with string 'Key '%s' not found' as argument, '%s' is substituted for key.
self . set ( key , value , version = version + delta )	call the method self.set with key, value, version incremented by delta, as arguments.
self . delete ( key , version = version )	call the self.delete method with key and version set to version as arguments.
return version + delta	sum version and delta together, return the result.
def decr_version ( self , key , delta = 1 , version = None ) :	define the method decr_version with 4 arguments, self, key, delta defaulting to integer 1 and version defaulting to None.
return self . incr_version ( key , - delta , version )	call the method self.incr_version with key, negative delta and version as arguments.
def close ( self , ** kwargs ) :	define the close method with 2 arguments, self and dictionary of argument pairs kwargs.
pass	do nothing.
import base64	import module base64.
from datetime import datetime	from datetime import datetime into default name space.
try :	try,
from django . utils . six . moves import cPickle as pickle	from django.utils.six.moves import cPickle as pickle, into default namespace.
except ImportError :	if ImportError exception occurred,
import pickle	import pickle.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT	from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.
from django . db import connections , transaction , router , DatabaseError	from django.db import connections, transaction, router and DatabaseError into default name space.
from django . db . backends . utils import typecast_timestamp	from django.db.backends.utils import typecast_timestamp into default name space.
from django . utils import timezone , six	from django.utils import timezone and six into default name space.
from django . utils . encoding import force_bytes	from django.utils.encoding import force_bytes into default name space.
class Options ( object ) :	derive class Options from the base class object.
def __init__ ( self , table ) :	define the initialization method __init__ with self class instance and table as arguments.
self . db_table = table	substitute table for self.db_table.
self . app_label = 'django_cache'	self.app_label is a string 'django_cache'.
self . model_name = 'cacheentry'	self.model_name is a string 'cacheentry'.
self . verbose_name = 'cache entry'	self.verbose_name is a string 'cache entry'.
self . verbose_name_plural = 'cache entries'	self.verbose_name_plural is a string 'cache entries'.
self . object_name = 'CacheEntry'	self.object_name is a string 'CacheEntry'.
self . abstract = False	self.abstract is boolean False.
self . managed = True	self.managed is boolean True.
self . proxy = False	self.proxy is boolean False.
class BaseDatabaseCache ( BaseCache ) :	derive class BaseDatabaseCache from BaseCache base class.
def __init__ ( self , table , params ) :	define the initialization method __init__ with self, table and params as arguments.
BaseCache . __init__ ( self , params )	call the BaseCache.__init__ method with self class instance and params as the arguments.
self . _table = table	substitute table for self._table.
class CacheEntry ( object ) :	derive CacheEntry class from the object base class.
_meta = Options ( table )	_meta is class Options class instance initialized with table argument.
self . cache_model_class = CacheEntry	substitute CacheEntry for self.cache_model_class.
class DatabaseCache ( BaseDatabaseCache ) :	derive DatabaseCache from the BaseDatabaseCache base class.
def get ( self , key , default = None , version = None ) :	define the method get with 4 arguments, self class instance, key, default set to None and version set to None.
key = self . make_key ( key , version = version )	call the method self.make_key Whit key and version set to version as arguments, substitute the result for key.
self . validate_key ( key )	call the method self.validate_key with argument key.
db = router . db_for_read ( self . cache_model_class )	call the method router.db_for_read with self.cache_model_class as argument, substitute the result for db.
table = connections [ db ] . ops . quote_name ( self . _table )	call the ops.quote_name method with argument self._table on the value under the db key of connections dictionary, substitute the result for table.
with connections [ db ] . cursor ( ) as cursor :	call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
cursor . execute ( 'SELECT cache_key, value, expires FROM %s '  'WHERE cache_key = %%s' % table , [ key ] )	call the method cursor.execute with string 'SELECT cache_key, value, expires FROM %s WHERE cache_key = %%s' as argument,
row = cursor . fetchone ( )	substitute the '%s' with table and list containing key, respectively.   call the cursor.fetchone method, substitute the result for row.
if row is None :	if row is None,
return default	return default.
now = timezone . now ( )	call the timezone.now function, substitute the result for now.
expires = row [ 2 ]	substitute third element of row list for expires.
if connections [ db ] . features . needs_datetime_string_cast and not isinstance ( expires , datetime ) :	if features.needs_datetime_string_cast field of the object represented stored under the db key of connections dictionary is true,
expires = typecast_timestamp ( str ( expires ) )	and expires is not an instance of datetime.   convert expires to a string, use it as argument for the call to the function typecast_timestamp, substitute the result for expires.
if expires < now :	if expires is lesser than now,
db = router . db_for_write ( self . cache_model_class )	call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.
with connections [ db ] . cursor ( ) as cursor :	call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
cursor . execute ( 'DELETE FROM %s '  'WHERE cache_key = %%s' % table , [ key ] )	call the method cursor.execute with string 'DELETE FROM %s WHERE cache_key = %%s' as argument,
return default	substitute the '%s' with table and list containing key, respectively.   return default.
value = connections [ db ] . ops . process_clob ( row [ 1 ] )	call the method ops.process_clob with second element of row as argument, on the object under the db key of connections dictionary, substitute the result for value.
return pickle . loads ( base64 . b64decode ( force_bytes ( value ) ) )	call the function force_bytes with argument value, use the result as an argument for the call to the method base64.b64decode,
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :	use the result as the argument for the function call to the pickle.loads, return the result.   define the method set with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
self . validate_key ( key )	call the method self.validate_key with key as argument.
self . _base_set ( 'set' , key , value , timeout )	call the method self._base_set with string 'set', key, value and timeout as arguments.
def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :	define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
self . validate_key ( key )	call the method self.validate_key with key as argument.
return self . _base_set ( 'add' , key , value , timeout )	call the method self._base_set with string 'add', key, value and timeout as arguments, return the result.
def _base_set ( self , mode , key , value , timeout = DEFAULT_TIMEOUT ) :	define the protected method _base_set with 4 arguments, self class instance, key, value and timeout set to DEFAULT_TIMEOUT.
timeout = self . get_backend_timeout ( timeout )	call the method self.get_backend_timeout with argument timeout, substitute the result for timeout.
db = router . db_for_write ( self . cache_model_class )	call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.
table = connections [ db ] . ops . quote_name ( self . _table )	call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.
with connections [ db ] . cursor ( ) as cursor :	call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
cursor . execute ( 'SELECT COUNT(*) FROM %s' % table )	call the method cursor.execute with string 'SELECT COUNT(*) FROM %s' as argument, substitute the '%s' with table.
num = cursor . fetchone ( ) [ 0 ]	fetch one record from the database cursor points at, substitute the first element of return value for num.
now = timezone . now ( )	call the timezone.now function, substitute the result for now.
now = now . replace ( microsecond = 0 )	call the function now.replace with microseconds set to integer 0, substitute the result for now.
if timeout is None :	if timeout is None,
exp = datetime . max	substitute the datetime.max for exp.
elif settings . USE_TZ :	otherwise is settings.USE_TI is true,
exp = datetime . utcfromtimestamp ( timeout )	call the function datetime.utcfromtimestamp with argument timeout, substitute it for exp.
else :	if not,
exp = datetime . fromtimestamp ( timeout )	call the function datetime.fromtimestamp with argument timeout, substitute it for exp.
exp = exp . replace ( microsecond = 0 )	call the exp.replace with microsecond set to integer 0, substitute the result for exp.
if num > self . _max_entries :	if num is greater than self._max_entries,
self . _cull ( db , cursor , now )	call the method self._cull with db, cursor and now as arguments.
pickled = pickle . dumps ( value , pickle . HIGHEST_PROTOCOL )	call the method pickle.dumps with value and pickle.HIGHEST_PROTOCOL as arguments, substitute it for pickled.
b64encoded = base64 . b64encode ( pickled )	call the method base64.b64encode with argument pickled, substitute the result for b64encoded.
if six . PY3 :	if six.PY3 is true,
b64encoded = b64encoded . decode ( 'latin1' )	call the method b64encoded.decode with string 'latin1' as argument, substitute the result for b64encoded.
try :	try,
with transaction . atomic ( using = db ) :	with return value of the function transaction.atomic with using set to db as arguments, perform the following,
cursor . execute ( 'SELECT cache_key, expires FROM %s '  'WHERE cache_key = %%s' % table , [ key ] )	call the method cursor.execute with string 'SELECT cache_key, expires FROM %s WHERE cache_key = %%s' as argument,
result = cursor . fetchone ( )	substitute the '%s' with table and list containing key, respectively.   fetch one entry from the database that cursor points at, substitute it for the result.
if result :	if result is true,
    current_expires = result [ 1 ]	substitute the second element of result for current_expires.
if ( connections [ db ] . features . needs_datetime_string_cast and not  isinstance ( current_expires , datetime ) ) :	if features.needs_datetime_string_cast field of object under the db key of connections dictionary is true and current_expires is not an instance of datetime object.
        current_expires = typecast_timestamp ( str ( current_expires ) )	convert current_expires to a string, use it as the argument for the call to the function typecast_timestamp, substitute the result for current_expires.
exp = connections [ db ] . ops . value_to_db_datetime ( exp )	on the object under the db key of connections dictionary call the method ops.value_to_db_datetime with argument exp, substitute the result for the exp.
if result and ( mode == 'set' or ( mode == 'add' and current_expires < now ) ) :	if mode equals to string 'add' and current_expires is lesser than now, or mode equals to string 'set', and result is true,
    cursor . execute ( 'UPDATE %s SET value = %%s, expires = %%s '  'WHERE cache_key = %%s' % table ,  [ b64encoded , exp , key ] )	call the method cursor.execute with string 'UPDATE %s SET value = %%s, expires = %%s WHERE cache_key = %%s' as argument,
else :	substitute the '%s' with table and 3 elements of a list: b64encoded, exp and key, respectively.   if not,
    cursor . execute ( 'INSERT INTO %s (cache_key, value, expires) '  'VALUES (%%s, %%s, %%s)' % table ,  [ key , b64encoded , exp ] )	call the method cursor.execute with string 'INSERT INTO %s (cache_key, value, expires) VALUES (%%s, %%s, %%s)',
except DatabaseError :	substitute the '%s' with table and 3 elements of a list: b64encoded, exp and key, respectively.   if DatabaseError exception is caught,
return False	return boolean False.
else :	if not,
return True	return boolean True.
def delete ( self , key , version = None ) :	define the method delete with self class instance, key and version set to None as arguments.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
self . validate_key ( key )	call the method self.validate_key with argument key.
db = router . db_for_write ( self . cache_model_class )	call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.
table = connections [ db ] . ops . quote_name ( self . _table )	call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.
with connections [ db ] . cursor ( ) as cursor :	call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
cursor . execute ( 'DELETE FROM %s WHERE cache_key = %%s' % table , [ key ] )	call the method cursor.execute with string 'DELETE FROM %s WHERE cache_key = %%s' as argument,
def has_key ( self , key , version = None ) :	substitute the '%s' with table and list containing key, respectively.   define the method has_key with self class instance, key and version defaulting to None as arguments.
key = self . make_key ( key , version = version )	call the self.make_key with key and version set to version as arguments, substitute the result for key.
self . validate_key ( key )	call the self.validate_key method with argument key.
db = router . db_for_read ( self . cache_model_class )	call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.
table = connections [ db ] . ops . quote_name ( self . _table )	call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.
if settings . USE_TZ :	if settings.USE_TZ is true,
now = datetime . utcnow ( )	call the function datetime.utcnow, substitute the result for now.
else :	if not,
now = datetime . now ( )	call the function datetime.now, substitute the result to now.
now = now . replace ( microsecond = 0 )	call the method now.replace with the argument microsecond set to integer 0, substitute the result for now.
with connections [ db ] . cursor ( ) as cursor :	call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
cursor . execute ( 'SELECT cache_key FROM %s '  'WHERE cache_key = %%s and expires > %%s' % table ,  [ key , connections [ db ] . ops . value_to_db_datetime ( now ) ] )	call the method cursor.execute with string 'SELECT cache_key FROM %s WHERE cache_key = %%s and expires > %%s' as argument,
return cursor . fetchone ( ) is not None	substitute the '%s' with table and list containing return value of the method call ops.value_to_db_datetime with argument now on the object under the db key of connections dictionary, respectively.   if exists return next entry from the database that cursor points at.
def _cull ( self , db , cursor , now ) :	define the protected method _cull with self class instance, db, cursor and now as arguments.
if self . _cull_frequency == 0 :	if self._cull_frequency equals to integer 0.
self . clear ( )	call the self.clear method.
else :	if not,
now = now . replace ( tzinfo = None )	call the method now.replace with argument tzinfo set to None, substitute it for now.
table = connections [ db ] . ops . quote_name ( self . _table )	call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.
cursor . execute ( 'DELETE FROM %s WHERE expires < %%s' % table ,  [ connections [ db ] . ops . value_to_db_datetime ( now ) ] )	call the method cursor.execute with string 'DELETE FROM %s WHERE expires < %%s' as argument,
cursor . execute ( 'SELECT COUNT(*) FROM %s' % table )	substitute the '%s' with table and list containing return value of the method call ops.value_to_db_datetime with argument now on the object under the db key of connections dictionary, respectively.   call the method cursor.execute with string 'SELECT COUNT(*) FROM %s' as argument, substitute the '%s' with table.
num = cursor . fetchone ( ) [ 0 ]	fetch next entry for the database that cursor points into, substitute first element of it for num.
if num > self . _max_entries :	if num is greater than self._max_entries,
cull_num = num // self . _cull_frequency	divide num by self._cull_frequency, floor the result and substitute it for cull_num.
cursor . execute (  connections [ db ] . ops . cache_key_culling_sql ( ) % table ,  [ cull_num ] )	evaluate the method connections[db].ops.cache_key_culling_sql, evaluate the result by table modulus, call the method cursor.execute,
cursor . execute ( 'DELETE FROM %s '  'WHERE cache_key < %%s' % table ,  [ cursor . fetchone ( ) [ 0 ] ] )	with previous result and list containing cull_num, respectively as arguments.   call the method cursor.execute with string 'DELETE FROM %s WHERE cache_key < %%s' as argument,
def clear ( self ) :	substitute the '%s' with table and list containing first element of cursor.fetchone method, respectively.   define the method clear with argument self.
db = router . db_for_write ( self . cache_model_class )	call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.
table = connections [ db ] . ops . quote_name ( self . _table )	call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.
with connections [ db ] . cursor ( ) as cursor :	call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
cursor . execute ( 'DELETE FROM %s' % table )	call the method cursor.execute with string 'DELETE FROM %s' as argument, substitute the '%s' with table.
class CacheClass ( DatabaseCache ) :	derive the class CacheClass from the DatabaseCache base class.
pass	do nothing.
from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT	from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.
class DummyCache ( BaseCache ) :	derive the class DummyCache from the base class BaseCache.
def __init__ ( self , host , * args , ** kwargs ) :	define initialization method __init__ with 4 arguments: self, host, list of arguments args and dictionary of arguments kwargs.
BaseCache . __init__ ( self , * args , ** kwargs )	call the BaseCache initialization method __init__ with 3 arguments self, list of arguments args and dictionary of arguments kwargs.
def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :	define the method add with 5 arguments: self, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute it for key.
self . validate_key ( key )	call the method self.validate_key with argument key.
return True	return boolean True.
def get ( self , key , default = None , version = None ) :	define the method get with 4 arguments: self, key, default set to None and version set to None.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute it for key.
self . validate_key ( key )	call the method self.validate_key with argument key.
return default	return default.
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :	define the method set with 5 arguments: self, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute it for key.
self . validate_key ( key )	call the method self.validate_key with argument key.
def delete ( self , key , version = None ) :	define the method delete with 3 arguments: self, key, and version set to None.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute it for key.
self . validate_key ( key )	call the method self.validate_key with argument key.
def get_many ( self , keys , version = None ) :	define the method get_many with 3 arguments: self, keys, and version set to None.
return { }	return an empty dictionary.
def has_key ( self , key , version = None ) :	define the method has_key with 3 arguments: self, key, and version set to None.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute it for key.
self . validate_key ( key )	call the method self.validate_key with argument key.
return False	return boolean False.
def set_many ( self , data , timeout = DEFAULT_TIMEOUT , version = None ) :	define the method set_many with 4 arguments: self, data, timeout set to DEFAULT_TIMEOUT and version set to None.
pass	do nothing
def delete_many ( self , keys , version = None ) :	define the method delete_many with 3 arguments: self, keys, and version set to None.
pass	do nothing.
def clear ( self ) :	define the method clear with argument self.
pass	do nothing.
class CacheClass ( DummyCache ) :	derive the class CacheClass from the DummyCache base class.
pass	do nothing.
import errno	import module errno.
import glob	import module glob.
import hashlib	import module hashlib.
import io	import module io.
import os	import module os.
import random	import module random.
import tempfile	import module tempfile.
import time	import module time.
import zlib	import module zlib.
from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT	from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.
from django . core . files . move import file_move_safe	from django.core.files.move import file_move_safe into default name space.
from django . utils . encoding import force_bytes	from django.utils.encoding import force_bytes into default name space.
try :	try,
from django . utils . six . moves import cPickle as pickle	from django.utils.six.moves import cPickle as pickle into default name space.
except ImportError :	if ImportError exception is caught,
import pickle	import pickle.
class FileBasedCache ( BaseCache ) :	derive the class FileBasedCache from BaseCache base class.
cache_suffix = '.djcache'	cache_suffix is a string '.djcache'.
def __init__ ( self , dir , params ) :	define the initialization method __init__ with arguments: self class instance, dir and params.
super ( FileBasedCache , self ) . __init__ ( params )	call method __init__ with argument params from the base class of the FileBaseCache.
self . _dir = os . path . abspath ( dir )	get absolute directory path of dir, substitute it for self._dir.
self . _createdir ( )	call the self._createdir method.
def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :	define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
if self . has_key ( key , version ) :	evaluate method self.has_key with key and version as arguments, if the result is true,
return False	return boolean False.
self . set ( key , value , timeout , version )	call the method self.set with key, value, timeout and version as arguments.
return True	return boolean True.
def get ( self , key , default = None , version = None ) :	define the method get with 5 arguments, self class instance, key, default set to None and version set to None.
fname = self . _key_to_file ( key , version )	call the function self._key_to_file with key and version as arguments, substitute it for fname.
if os . path . exists ( fname ) :	if fname file path exists,
try :	try,
with io . open ( fname , 'rb' ) as f :	with return value of the function io.open with fname and string 'rb' as arguments, named as f,
if not self . _is_expired ( f ) :	evaluate self._is_expired method with f as argument, if the result is false,
    return pickle . loads ( zlib . decompress ( f . read ( ) ) )	call f.read function, use the result as the argument for zlib.decompress function call, call the pickle.loads function with the previous result as argument, return the result.
except IOError as e :	if IOError, renamed to e, exception is caught,
if e . errno == errno . ENOENT :	if e.errno equals to errno.ENOENT,
pass	do nothing.
return default	return default.
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :	define the method set with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
self . _createdir ( )	call the self._createdir method.
fname = self . _key_to_file ( key , version )	call the function self._key_to_file with key and version as arguments, substitute it for fname.
self . _cull ( )	call the method self._cull.
fd , tmp_path = tempfile . mkstemp ( dir = self . _dir )	call the method tempfile.mkstemp with dir set to self._dir, substitute result for fd and tmp_path, respectively.
renamed = False	renamed is boolean False.
try :	try,
with io . open ( fd , 'wb' ) as f :	with return value of the function io.open with fname and string 'rb' as arguments, named as f,
expiry = self . get_backend_timeout ( timeout )	call the method self.get_backend_timeout with argument timeout, substitute it for expiry.
f . write ( pickle . dumps ( expiry , - 1 ) )	call the function pickle.dumps with expiry and integer -1 as arguments, use the result as the argument for the call to f.write function.
f . write ( zlib . compress ( pickle . dumps ( value ) , - 1 ) )	call the function pickle.dumps with argument value, use the result and integer -1 as arguments for the call to the function zlib.compress, use the result as an argument for the call to the f.write method.
file_move_safe ( tmp_path , fname , allow_overwrite = True )	call the function file_move_safe with tmp_path, fname, allow_overwrite set to boolean True as arguments.
renamed = True	renamed is boolean True.
finally :	finally perform,
if not renamed :	if renamed is boolean False,
os . remove ( tmp_path )	remove file tmp_path.
def delete ( self , key , version = None ) :	define the method delete with self class instance, key and version defaulting to None as arguments.
self . _delete ( self . _key_to_file ( key , version ) )	call the function self._key_to_file with key and version as arguments, use the result as an argument for the call to the self._delete method.
def _delete ( self , fname ) :	define the method _delete with self and fname as arguments.
if not fname . startswith ( self . _dir ) or not os . path . exists ( fname ) :	if fname doesnt start with self._dir and fname file path doesnt exists,
return	return nothing.
try :	try,
os . remove ( fname )	call the function os.remove with argument fname.
except OSError as e :	if exception OSError, renamed to e, is caught,
if e . errno != errno . ENOENT :	if e.errno does not equals to errno.ENOENT,
raise	raise an exception.
def has_key ( self , key , version = None ) :	define the method has_key with self class instance, key and version defaulting to None as arguments.
fname = self . _key_to_file ( key , version )	call the function self._key_to_file with key and version as arguments, substitute it for fname.
if os . path . exists ( fname ) :	if fname file path exists,
with io . open ( fname , 'rb' ) as f :	with call to the io.open function with fname and string 'rb' as arguments, renamed to f,
return not self . _is_expired ( f )	call the method self._is_expired with argument f, invert the boolean result and return it.
return False	return boolean False.
def _cull ( self ) :	define the method _cull with argument self.
filelist = self . _list_cache_files ( )	call the self._list_cache_files method, substitute the result for filelist.
num_entries = len ( filelist )	num_entries is length of filelist.
if num_entries < self . _max_entries :	if num_entries is lesser than self._max_entries,
return	return nothing.
if self . _cull_frequency == 0 :	if self._cull_frequency equals to integer 0.
return self . clear ( )	evaluate self.clear method and return the result.
filelist = random . sample ( filelist ,  int ( num_entries / self . _cull_frequency ) )	divide num_entries by self._cull_frequency, convert the result to an integer, call the random.sample function with filelist and previous result as arguments, substitute the result for filelist.
for fname in filelist :	for every fname in filelist,
self . _delete ( fname )	call self._delete method with argument fname.
def _createdir ( self ) :	define the method _createdir with argument self.
if not os . path . exists ( self . _dir ) :	if self._dir path doesnt exists,
try :	try,
os . makedirs ( self . _dir , 0o700 )	call os.makedirs function with self._dir and hexadecimal 0o700 as arguments.
except OSError as e :	if OSError, renamed to e, exception is caught,
if e . errno != errno . EEXIST :	if e.errno is not equal to errno.EEXIST,
def _key_to_file ( self , key , version = None ) :	substitute '%s' with self._dir converted to a string.   define the method key_to_file with self class instance, key and version defaulting to None as arguments.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
self . validate_key ( key )	call the method self.validate_key with argument key.
return os . path . join ( self . _dir , '' . join (  [ hashlib . md5 ( force_bytes ( key ) ) . hexdigest ( ) , self . cache_suffix ] ) )	join into a string: md5 hash sum of force_bytes(key) and self.cache_suffix, compose root file path out of self._dir and previous result, return it.
def clear ( self ) :	define the method clear with argument self.
if not os . path . exists ( self . _dir ) :	if self._dir file path does not exists,
return	return nothing.
for fname in self . _list_cache_files ( ) :	if fname is contained in self._list_cache_files method return value,
self . _delete ( fname )	call the self._delete method with argument fname.
def _is_expired ( self , f ) :	define the method _is_expired with self and f as arguments.
exp = pickle . load ( f )	call the function pickle.load with argument f, substitute the result for exp.
if exp is not None and exp < time . time ( ) :	if exp is not None and exp is lesser than return value of the function time.time,
f . close ( )	call close method on a file stream.
self . _delete ( f . name )	call the self._delete method with argument f.name.
return True	return boolean True.
return False	return boolean False.
def _list_cache_files ( self ) :	define the method _list_cache_files with argument self.
if not os . path . exists ( self . _dir ) :	if self._dir file path does not exists,
return [ ]	return an empty list.
filelist = [ os . path . join ( self . _dir , fname ) for fname  in glob . glob1 ( self . _dir , '*%s' % self . cache_suffix ) ]	for every fname in return value of the glob.glob1 function called with 2 arguments: self._dir and ,
return filelist	self.cache_suffix converted to a string, appended to the character '*', call os.path.join with self._dir and fname as arguments,   filelist is a list containing all the previous results.   return filelist.
class CacheClass ( FileBasedCache ) :	derive the class CacheClass from the base class FileBasedCache.
pass	do nothing.
import time	import module time.
try :	try,
from django . utils . six . moves import cPickle as pickle	from django.utils.six.moves import cPickle as pickle into default name space.
except ImportError :	if ImportError exception is caught,
import pickle	import pickle.
from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT	from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.
from django . utils . synch import RWLock	from django.utils.synch import RWLock into default name space.
_caches = { }	__caches is an empty dictionary.
_expire_info = { }	__expire_info is an empty dictionary.
_locks = { }	__locks is an empty dictionary.
class LocMemCache ( BaseCache ) :	derive the class LocMemCache from the base class BaseCache.
def __init__ ( self , name , params ) :	define the initialization method __init__ with 3 arguments: self, name and params.
BaseCache . __init__ ( self , params )	call the __init__ method with self and params arguments from the base class BaseCache.
self . _cache = _caches . setdefault ( name , { } )	call the _caches.setdefault method with name and empty dictionary as arguments, substitute the result for self_cache.
self . _expire_info = _expire_info . setdefault ( name , { } )	call the _expire_info.setdefault method with name and empty dictionary as arguments, substitute the result for self_expire_info.
self . _lock = _locks . setdefault ( name , RWLock ( ) )	call the _lock.setdefault method with name and RWLock() as arguments, substitute the result for self_lock.
def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :	define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
self . validate_key ( key )	call the method self.validate_key with argument key.
pickled = pickle . dumps ( value , pickle . HIGHEST_PROTOCOL )	call the pickle.dumps function with value and pickle.HIGHEST_PROTOCOL as arguments.
with self . _lock . writer ( ) :	call the self._lock.writer method, with the result perform the following,
if self . _has_expired ( key ) :	evaluate self._has_expired with argument key, if the result is True,
self . _set ( key , pickled , timeout )	call the method self._set with key, pickled and timeout as arguments.
return True	return boolean True.
return False	return boolean False.
def get ( self , key , default = None , version = None ) :	define the method get with 4 arguments, self class instance, key, default set to None and version set to None.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
self . validate_key ( key )	call the method self.validate_key with argument key.
pickled = None	substitute None for pickled.
with self . _lock . reader ( ) :	call the self._lock.reader method, with the result perform the following,
if not self . _has_expired ( key ) :	evaluate the method self._has_expired with argument key, if it as False,
pickled = self . _cache [ key ]	substitute value under the key key of self._cache dictionary for pickled.
if pickled is not None :	if pickled is not None.
try :	try,
return pickle . loads ( pickled )	evaluate pickle.loads with argument pickled, return the result.
except pickle . PickleError :	if pickle.PickleError exception is caught,
return default	return default.
with self . _lock . writer ( ) :	call the self._lock.writer method, with the result perform the following,
try :	try,
del self . _cache [ key ]	delete the value under key key of self._cache dictionary.
del self . _expire_info [ key ]	delete the value under key key of self._expire_info.
except KeyError :	if KeyError exception is caught,
pass	do nothing.
return default	return default.
def _set ( self , key , value , timeout = DEFAULT_TIMEOUT ) :	define the method _set with 4 arguments, self class instance, key, value and timeout set to DEFAULT_TIMEOUT.
if len ( self . _cache ) >= self . _max_entries :	if length of self._cache is greater or equal to self._max_entries,
self . _cull ( )	call the self._cull method.
self . _cache [ key ] = value	substitute value for the value under the key key of self._cache dictionary.
self . _expire_info [ key ] = self . get_backend_timeout ( timeout )	call the self.get_backend_timeout with argument timeout, substitute it for the value under the key key of self._expire_info dictionary.
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :	define the method get with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
self . validate_key ( key )	call the method self.validate_key with argument key.
pickled = pickle . dumps ( value , pickle . HIGHEST_PROTOCOL )	call the function pickle.dumps with value and pickle.HIGHEST_PROTOCOL as the arguments, substitute the result for pickled.
with self . _lock . writer ( ) :	call the self._lock.writer method, with the result perform the following,
self . _set ( key , pickled , timeout )	call the method self._set with key, pickled and timeout as arguments.
def incr ( self , key , delta = 1 , version = None ) :	define the method incr with self class instance, key, delta set to integer 1 and version set to None, as arguments.
value = self . get ( key , version = version )	call the self.get method with key and version set to version as arguments, substitute the result for value.
if value is None :	if value is None,
raise ValueError ( 'Key '%s' not found' % key )	raise an ValueError exception with string 'Key '%s' not found' as argument, substitute '%s' with key converted into a string.
new_value = value + delta	new_value is a sum of value and delta.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
pickled = pickle . dumps ( new_value , pickle . HIGHEST_PROTOCOL )	call the function pickle.dumps with value and pickle.HIGHEST_PROTOCOL as the arguments, substitute the result for pickled.
with self . _lock . writer ( ) :	call the self._lock.writer method, with the result perform the following,
self . _cache [ key ] = pickled	substitute pickled for value under the key key of self._cache dictionary.
return new_value	return new_value.
def has_key ( self , key , version = None ) :	define the method has_key with self class instance, key and version defaulting to None as arguments.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
self . validate_key ( key )	call the method self.validate_key with argument key.
with self . _lock . reader ( ) :	call the self._lock.reader method, with the result perform the following,
if not self . _has_expired ( key ) :	if call to the _has_expired method with argument key evaluates to boolean False,
return True	return boolean True.
with self . _lock . writer ( ) :	call the self._lock.writer method, with the result perform the following,
try :	try,
del self . _cache [ key ]	delete the value under the key key of self._cache dictionary.
del self . _expire_info [ key ]	delete the value under the key key of self._expire_info dictionary.
except KeyError :	if KeyError exception is caught,
pass	do nothing.
return False	return boolean False.
def _has_expired ( self , key ) :	define the method _has_expired with self and key as arguments.
exp = self . _expire_info . get ( key , - 1 )	call the method self._expire_info.get with key and integer -1 as arguments, substitute the result for exp.
if exp is None or exp > time . time ( ) :	if exp is None or exp is greater than the return value of the call to the function time.time,
return False	return boolean False.
return True	return boolean True.
def _cull ( self ) :	define the method _cull with argument self.
if self . _cull_frequency == 0 :	if self._cull_frequency equals to integer 0.
self . clear ( )	call self.clear method.
else :	if not,
doomed = [ k for ( i , k ) in enumerate ( self . _cache ) if i % self . _cull_frequency == 0 ]	for every i and k in enumerated values of self._cache, if i is divisible by self._cull_frequency, append k to doomed list.
for k in doomed :	for every k in doomed,
self . _delete ( k )	call the method self._delete with argument k.
def _delete ( self , key ) :	define the method _delete with arguments self and key.
try :	try,
del self . _cache [ key ]	delete the value under the key key of self._cache dictionary.
except KeyError :	if KeyError exception is caught,
pass	do nothing.
try :	try,
del self . _expire_info [ key ]	delete the value under the key key of the self._expire_info dictionary.
except KeyError :	if KeyError exception is caught,
pass	do nothing.
def delete ( self , key , version = None ) :	define the method delete with self class instance, key and version defaulting to None as arguments.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
self . validate_key ( key )	call the method self.validate_key with argument key.
with self . _lock . writer ( ) :	call the self._lock.writer method, with the result perform the following,
self . _delete ( key )	call the method self._delete with argument key.
def clear ( self ) :	define the method clear with argument self.
self . _cache . clear ( )	call the method self._cache.clear.
self . _expire_info . clear ( )	call the method self._expire_info.clear.
class CacheClass ( LocMemCache ) :	derive the class CacheClass from the base class LocMemCache.
pass	do nothing.
import time	import module time.
import pickle	import module pickle.
from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT	from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . deprecation import RenameMethodsBase , RemovedInDjango19Warning	from django.utils.deprecation import RenameMethodsBase and RemovedInDjango19Warning into default name space.
from django . utils . encoding import force_str	from django.utils.encoding import force_str into default name space.
from django . utils . functional import cached_property	from django.utils.functional import cached_property into default name space.
class BaseMemcachedCacheMethods ( RenameMethodsBase ) :	derive the class BaseMemcachedCacheMethods from RenameMethodsBase the base class.
renamed_methods = (  ( '_get_memcache_timeout' , 'get_backend_timeout' , RemovedInDjango19Warning ) ,  )	renamed methods is a tuple containing 3 elements: '_get_memcache_timeout', 'get_backend_timeout' and RemovedInDjango19Warning.
class BaseMemcachedCache ( six . with_metaclass ( BaseMemcachedCacheMethods , BaseCache ) ) :	derive the class BaseMemcachedCache from base class BaseMemcachedCacheMethods and BaseCache.
def __init__ ( self , server , params , library , value_not_found_exception ) :	define the method __init__ with, self, server, params, library, value_not_found_exception as arguments.
super ( BaseMemcachedCache , self ) . __init__ ( params )	call the initialization method with argument params for the base class of the BaseMemcachedCache class.
if isinstance ( server , six . string_types ) :	if server is an instance of six.string_types,
self . _servers = server . split ( ';' )	split server with ';' as delimiter, substitute the result for self._servers.
else :	if not,
self . _servers = server	substitute server for self._servers.
self . LibraryValueNotFoundException = value_not_found_exception	substitute value_not_found_exception for self.LibraryValueNotFoundException.
self . _lib = library	substitute library for self._lib.
self . _options = params . get ( 'OPTIONS' , None )	call the params.get function with string 'OPTIONS' and None as arguments, substitute the result for self._options.
@ property	property decorator,
def _cache ( self ) :	define the method _cache with argument self.
if getattr ( self , '_client' , None ) is None :	if self object has an attribute '_client',
self . _client = self . _lib . Client ( self . _servers )	call the self._lib.Client with argument self._servers, substitute the result for self._client.
return self . _client	return self._client.
def get_backend_timeout ( self , timeout = DEFAULT_TIMEOUT ) :	define the method get_backend_timeout with self and timeout set to DEFAULT_TIMEOUT as arguments.
if timeout == DEFAULT_TIMEOUT :	if timeout equals to DEFAULT_TIMEOUT,
timeout = self . default_timeout	substitute self.default_timeout for timeout.
if timeout is None :	if timeout is None,
return 0	return integer 0.
elif int ( timeout ) == 0 :	else if timeout converted into an integer equals to integer 0,
timeout = - 1	timeout is a integer -1.
if timeout > 2592000 :	if timeout is greater than integer 2592000,
timeout += int ( time . time ( ) )	convert return value of the function time.time to an integer, increment timeout by it.
return int ( timeout )	convert timeout into an integer, return it.
def make_key ( self , key , version = None ) :	define the method make_key with self class instance, key and version defaulting to None as arguments.
return force_str ( super ( BaseMemcachedCache , self ) . make_key ( key , version ) )	call the method make_key with arguments key and version from the base class of the class BaseMemcachedCache, use it as an argument for the call to the function force_str, return the result.
def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :	define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
return self . _cache . add ( key , value , self . get_backend_timeout ( timeout ) )	call the method self._cache.add with key, value, self.get_backend_timeout(timeout) as arguments.
def get ( self , key , default = None , version = None ) :	define the method get with 5 arguments, self class instance, key, default set to None and version set to None.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
val = self . _cache . get ( key )	call the self._cache.get method with argument key, substitute the result for val.
if val is None :	if val is None,
return default	return default.
return val	return val.
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :	define the method set with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
self . _cache . set ( key , value , self . get_backend_timeout ( timeout ) )	call the method self._cache.set with key, value, self.get_backend_timeout(timeout) as arguments.
def delete ( self , key , version = None ) :	define the method delete with self, key and version set to None as arguments.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
self . _cache . delete ( key )	call the method self._cache.delete with argument key.
def get_many ( self , keys , version = None ) :	define the method get_many with self class instance, keys and version defaulting to None as arguments.
new_keys = [ self . make_key ( x , version = version ) for x in keys ]	define the method get_many with 3 arguments, self class instance, keys and version set to None.
ret = self . _cache . get_multi ( new_keys )	call the method self._cache.get_multi with argument new_keys, substitute the result for ret.
if ret :	if ret is true.
_ = { }	_ is an empty dictionary.
m = dict ( zip ( new_keys , keys ) )	zip together new_keys and keys, convert it to dictionary, assign it to m.
for k , v in ret . items ( ) :	for every k and v in return value of the ret.items function,
_ [ m [ k ] ] = v	substitute v for value under the k-th element of m key of _ dictionary.
ret = _	substitute _ for ret.
return ret	return ret.
def close ( self , ** kwargs ) :	define the method close with self and dictionary pairs of elements kwargs.
self . _cache . disconnect_all ( )	call the method self._cache.disconnect_all.
def incr ( self , key , delta = 1 , version = None ) :	define the method incr with self, key, delta defaulting to integer 1 and version defaulting to None as arguments.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
if delta < 0 :	if delta is smaller than integer 0,
return self . _cache . decr ( key , - delta )	evaluate the method self._cache.decr with key and negative delta as arguments, return the result.
try :	try,
val = self . _cache . incr ( key , delta )	call the method self._cache.incr with key and delta as arguments, substitute the result for val.
except self . LibraryValueNotFoundException :	if self.LibraryValueNotFoundException exception is caught,
val = None	val is None.
if val is None :	if val is None,
raise ValueError ( 'Key '%s' not found' % key )	raise an ValueError exception with string 'Key '%s' not found' as argument, substitute '%s' for key.
return val	return val.
def decr ( self , key , delta = 1 , version = None ) :	define the method decr with self, key, delta defaulting to integer 1 and version defaulting to None as arguments.
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
if delta < 0 :	if delta is smaller than integer 0.
return self . _cache . incr ( key , - delta )	evaluate the method self._cache.incr with key and negative delta as arguments, return the result.
try :	try,
val = self . _cache . decr ( key , delta )	call the method self._cache.decr with key and delta as arguments, substitute the result for val.
except self . LibraryValueNotFoundException :	if self.LibraryValueNotFoundException exception is caught,
val = None	val is None.
if val is None :	if val is None,
raise ValueError ( 'Key '%s' not found' % key )	raise an ValueError exception with string 'Key '%s' not found' as argument, substitute '%s' for key.
return val	return val.
def set_many ( self , data , timeout = DEFAULT_TIMEOUT , version = None ) :	define the method set_many with self, data, timeout set to DEFAULT_TIMEOUT and version set to None as arguments.
safe_data = { }	safe_data is an empty dictionary.
for key , value in data . items ( ) :	for every key and value in data.items function return value,
key = self . make_key ( key , version = version )	call the method self.make_key with key and version set to version as arguments, substitute the result for key.
safe_data [ key ] = value	substitute value for value under the key key of safe_data dictionary.
self . _cache . set_multi ( safe_data , self . get_backend_timeout ( timeout ) )	call the method self._cache.set_multi with safe_data, self.get_backend_timeout(timeout) as arguments.
def delete_many ( self , keys , version = None ) :	define the function delete_many with self, keys and version set to None as arguments.
l = lambda x : self . make_key ( x , version = version )	l is lambda function with argument x, that calls the method self.make_key with x and version set to version as arguments.
self . _cache . delete_multi ( map ( l , keys ) )	call the method self_cache.delete_multi with argument list containing keys mapped through function l.
def clear ( self ) :	define the method clear with argument self.
self . _cache . flush_all ( )	call the method self._cache_flush_all.
class MemcachedCache ( BaseMemcachedCache ) :	derive the class MemcachedCache from the BaseMemcachedCache base class.
def __init__ ( self , server , params ) :	define the method __init__ with argument self, server and params.
import memcache	import memcache.
super ( MemcachedCache , self ) . __init__ ( server , params ,  library = memcache ,  value_not_found_exception = ValueError )	call method __init__ from the base class of the class MemcachedCache with arguments: server, params,
@ property	library set to memcache and value_not_found_exception set to ValueError.   property decorator,
def _cache ( self ) :	define the method _cache with self class instance as an argument.
if getattr ( self , '_client' , None ) is None :	if attribute '_client' of the self object is None,
self . _client = self . _lib . Client ( self . _servers , pickleProtocol = pickle . HIGHEST_PROTOCOL )	call the method self._lib.Client with self._servers and pickleProtocol set to pickle.HIGHEST_PROTOCOL as arguments, substitute the result for self._client.
return self . _client	return self._client.
class PyLibMCCache ( BaseMemcachedCache ) :	derive the class PyLibMCCache from BaseMemcachedCache base class.
def __init__ ( self , server , params ) :	define the method __init__ with self, server and params as arguments.
import pylibmc	import pylibmc.
super ( PyLibMCCache , self ) . __init__ ( server , params ,  library = pylibmc ,  value_not_found_exception = pylibmc . NotFound )	call method __init__ from the base class of the class PyLibMCCache with arguments: server, params,
@ cached_property	library set to pylibmc and value_not_found_exception set to pylibmc.NotFound.   decorator cached_property,
def _cache ( self ) :	define the method _cache with argument self.
client = self . _lib . Client ( self . _servers )	call the method self._lib.Client with argument self._servers.
if self . _options :	if self._options exists,
client . behaviors = self . _options	substitute self._options for client.behaviors.
return client	return client.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import hashlib	import module hashlib.
from django . utils . encoding import force_bytes	from django.utils.encoding import force_bytes into default name space.
from django . utils . http import urlquote	from django.utils.http import urlquote into default name space.
TEMPLATE_FRAGMENT_KEY_TEMPLATE = 'template.cache.%s.%s'	TEMPLATE_FRAGMENT_KEY_TEMPLATE is a string 'template.cache.%s.%s'.
def make_template_fragment_key ( fragment_name , vary_on = None ) :	define the function make_template_fragment_key with fragment_name and vary_on defaulting to None as arguments.
if vary_on is None :	if vary_on is None,
vary_on = ( )	vary_on is an empty tuple.
key = ':' . join ( urlquote ( var ) for var in vary_on )	call the function urlquote with argument var for every var in vary_on, join the results into a string separated by ':', substitute it for key.
args = hashlib . md5 ( force_bytes ( key ) )	call the hashlib.md5 fuction with force_bytes(key) as argument.
return TEMPLATE_FRAGMENT_KEY_TEMPLATE % ( fragment_name , args . hexdigest ( ) )	substitute '%s' in TEMPLATE_FRAGMENT_KEY_TEMPLATE string with fragment_name and args.hexdigest(), respectively, return the result.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from . messages import ( CheckMessage ,  Debug , Info , Warning , Error , Critical ,  DEBUG , INFO , WARNING , ERROR , CRITICAL )	from .messages import CheckMessage, Debug, Info, Warning, Error, Critical, DEBUG, INFO, WARNING, ERROR and CRITICAL into default name space.
from . registry import register , run_checks , tag_exists , Tags	from .registry import register, run_checks, tag_exists and Tags into default name space.
import django . core . checks . compatibility . django_1_6_0	import module django.core.checks.compatibility.django_1_6_0.
import django . core . checks . compatibility . django_1_7_0	import module django.core.checks.compatibility.django_1_7_0.
import django . core . checks . model_checks	import module django.core.checks.model_checks.
__all__ = [  'CheckMessage' ,  'Debug' , 'Info' , 'Warning' , 'Error' , 'Critical' ,  'DEBUG' , 'INFO' , 'WARNING' , 'ERROR' , 'CRITICAL' ,  'register' , 'run_checks' , 'tag_exists' , 'Tags' ,  ]	__all__ is a list containing next strings, 'CheckMessage', 'Debug', 'Info', 'Warning', 'Error', 'Critical',
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . apps import apps	from django.apps import apps into default name space.
from . . import Warning , register , Tags	from .. import Warning, register and Tags into default name space.
@ register ( Tags . compatibility )	decorator register with argument Tags.compatibility.
def check_1_6_compatibility ( ** kwargs ) :	define the function check_1_6_compatibility with argument kwargs dictionary.
errors = [ ]	errors is an empty list
errors . extend ( _check_test_runner ( ** kwargs ) )	call the function _check_test_runner with dictionary kwargs as argument, use the result as an argument for the call to the function errors.extend.
errors . extend ( _check_boolean_field_default_value ( ** kwargs ) )	call the function _check_boolean_field_default_value with dictionary kwargs as argument, use the result as an argument for the call to the function errors.extend.
return errors	return errors.
def _check_test_runner ( app_configs = None , ** kwargs ) :	define the function _check_test_runner with app_config set to None and kwargs dictionary as arguments.
from django . conf import settings	from django.conf import settings into default name space.
weight = 0	weight is an integer 0.
if not settings . is_overridden ( 'TEST_RUNNER' ) :	if call to the settings.is_overridden with string 'TEST_RUNNER' evaluates to boolean False.
try :	try,
settings . SITE_ID	settings.SITE_ID.
weight += 2	increment weight by integer 2.
except AttributeError :	if AttributeError exception is caught,
pass	do nothing.
try :	try,
settings . BASE_DIR	settings.BASE_DIR.
except AttributeError :	if AttributeError exception is caught,
weight += 2	increment weight by integer 2.
if settings . is_overridden ( 'TEMPLATE_LOADERS' ) :	call the function settings.is_overridden with argument string 'TEMPLATE_LOADERS', if it evaluates to boolean True,
weight += 2	increment weight by integer 2.
if settings . is_overridden ( 'MANAGERS' ) :	call the function settings.is_overridden with argument string 'MANAGERS', if it evaluates to boolean True,
weight += 2	increment weight by integer 2.
if settings . is_overridden ( 'ADMINS' ) :	call the function settings.is_overridden with argument string 'ADMINS', if it evaluates to boolean True,
weight += 1	increment weight by integer 2.
if 'django.middleware.clickjacking.XFrameOptionsMiddleware' not in set ( settings . MIDDLEWARE_CLASSES ) :	if string 'django.middleware.clickjacking.XFrameOptionsMiddleware' is not contained in settings.MIDDLEWARE_CLASSES set,
weight += 1	increment weight by integer 2.
if weight >= 6 :	if weight is greater or equal to integer 6,
return [  Warning (  'Some project unittests may not execute as expected.' ,  hint = ( 'Django 1.6 introduced a new default test runner. It looks like '  'this project was generated using Django 1.5 or earlier. You should '  'ensure your tests are all running & behaving as expected. See '  'https://docs.djangoproject.com/en/dev/releases/1.6/#new-test-runner '  'for more information.' ) ,  obj = None ,  id = '1_6.W001' ,  )  ]	call the Warning function with 3 arguments: hint tuple containing one string, Django 1.6 introduced a new default test runner.
else :	It looks like this project was generated using Django 1.5 or earlier. You should ensure your tests are all running & behaving   as expected. See https://docs.djangoproject.com/en/dev/releases/1.6/#new-test-runner for more information.',   obj set to None and id set to a string '1_6.W001', put the result into a list and return it.   if not,
return [ ]	return an empty list.
def _check_boolean_field_default_value ( app_configs = None , ** kwargs ) :	define the function _check_boolean_field_default_value with app_config set to None and kwargs dictionary as arguments.
from django . db import models	from django.db import models into default name space.
problem_fields = [  field  for model in apps . get_models ( ** kwargs )  if app_configs is None or model . _meta . app_config in app_configs  for field in model . _meta . local_fields  if isinstance ( field , models . BooleanField ) and not field . has_default ( )  ]	append field to problem_fields list for every model in apps.get_models with argument kwargs dictionary, only if app_configs is None,
return [  Warning (  'BooleanField does not have a default value.' ,  hint = ( 'Django 1.6 changed the default value of BooleanField from False to None. '  'See https://docs.djangoproject.com/en/1.6/ref/models/fields/#booleanfield '  'for more information.' ) ,  obj = field ,  id = '1_6.W002' ,  )  for field in problem_fields  ]	or model._meta.app_config is contained in app_configs, for every field in model._meta.local_fields,  #ANNOTATION only if field is an instance of models.BooleanField and field.has_default() evaluates to False.    call the Warning function with 4 arguments: string 'BooleanField does not have a default value.',
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from . . import Warning , register , Tags	from .. import Warning, register and Tags into default name space.
@ register ( Tags . compatibility )	decorator register with argument Tags.compatibility.
def check_1_7_compatibility ( ** kwargs ) :	define the function check_1_7_compatibility with argument kwargs dictionary.
errors = [ ]	errors is an empty list.
errors . extend ( _check_middleware_classes ( ** kwargs ) )	call the function _check_middleware_classes with dictionary kwargs as argument, use the result as an argument for the call to the function errors.extend.
return errors	return errors.
def _check_middleware_classes ( app_configs = None , ** kwargs ) :	define the function _check_middleware_classes with app_config set to None and kwargs dictionary as arguments.
from django . conf import settings	from django.conf import settings into default name space.
if not settings . is_overridden ( 'MIDDLEWARE_CLASSES' ) :	call the function settings.is_overridden with argument string 'MIDDLEWARE_CLASSES', if the result is boolean False,
return [  Warning (  'MIDDLEWARE_CLASSES is not set.' ,  hint = ( 'Django 1.7 changed the global defaults for the MIDDLEWARE_CLASSES. '  'django.contrib.sessions.middleware.SessionMiddleware, '  'django.contrib.auth.middleware.AuthenticationMiddleware, and '  'django.contrib.messages.middleware.MessageMiddleware were removed from the defaults. '  'If your project needs these middleware then you should configure this setting.' ) ,  obj = None ,  id = '1_7.W001' ,  )  ]	call the Warning function with 4 arguments: string 'MIDDLEWARE_CLASSES is not set.', hint tuple containing one string,
else :	Django 1.7 changed the global defaults for the MIDDLEWARE_CLASSES. django.contrib.sessions.middleware.SessionMiddleware,   django.contrib.auth.middleware.AuthenticationMiddleware, and django.contrib.messages.middleware.MessageMiddleware were removed   from the defaults. If your project needs these middleware then you should configure this setting., obj set to None, and   id set to a string '1_7.W001', put the result into a list and return it.   if not,
return [ ]	return an empty list.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . utils . encoding import python_2_unicode_compatible , force_str	from django.utils.encoding import python_2_unicode_compatible and force_st into default name space.
DEBUG = 10	DEBUG is integer 10.
INFO = 20	INFO is integer 20.
WARNING = 30	WARNING is integer 30.
ERROR = 40	ERROR is integer 40.
CRITICAL = 50	CRITICAL is integer 50.
@ python_2_unicode_compatible	decorator python_2_unicode_compatible.
class CheckMessage ( object ) :	derive class CheckMessage from object base class.
def __init__ ( self , level , msg , hint = None , obj = None , id = None ) :	define initialization method __init__ with self class instance, level, msg, hint defaulting to None, obj defaulting to None and if defaulting to None as arguments.
assert isinstance ( level , int ) , 'The first argument should be level.'	if level is not an integer raise an error with message string 'The first argument should be level.'.
self . level = level	substitute level for self.level.
self . msg = msg	substitute msg for self.msg.
self . hint = hint	substitute hint for self.hint.
self . obj = obj	substitute obj for self.obj.
self . id = id	substitute id for self.id.
def __eq__ ( self , other ) :	define private method __eq__ with self class instance and other as arguments.
return all ( getattr ( self , attr ) == getattr ( other , attr )  for attr in [ 'level' , 'msg' , 'hint' , 'obj' , 'id' ] )	if for all attr in list of attributes 'level', 'msg', 'hint', 'obj' and 'id', self and other have the same attribute attr,
def __ne__ ( self , other ) :	return boolean True, otherwise return boolean False.   define private method __ne__ with self class instance and other as arguments.
return not ( self == other )	if self equals to other return boolean False, otherwise return True.
def __str__ ( self ) :	define private method __str__ with argument self.
from django . db import models	from django.db import models into default name space.
if self . obj is None :	if self.obj is None,
obj = '?'	obj is a string '?'.
elif isinstance ( self . obj , models . base . ModelBase ) :	otherwise if self.object is an instance of the models.base.ModelBase class,
model = self . obj	substitute self.obj for model.
app = model . _meta . app_label	substitute model._meta.app_label for app.
obj = '%s.%s' % ( app , model . _meta . object_name )	convert app and model._meta.object_name to strings, join them with separating '.' character, substitute it for obj.
else :	if not,
obj = force_str ( self . obj )	call the function force_str with argument self.obj, substitute the result for obj.
id = '(%s) ' % self . id if self . id else ''	if self.id exists, convert self.id to a string, surround it with round brackets, substitute id for it, otherwise id is an empty string.
\hint = '\\n\\tHINT: %s' % self . hint if self . hint else ''\	\if self.hint exists, replace '%s' in a string '\\n\\tHINT: %s' with value of self.hint, substitute it for hint, otherwise hint is an empty string.\
return '%s: %s%s%s' % ( obj , id , self . msg , hint )	replace all '%s' from string '%s: %s%s%s' with values of obj, id, self.msg and hint, respectively, return the result.
def __repr__ ( self ) :	define private method __repr__ with argument self.
return '<%s: level=%r, msg=%r, hint=%r, obj=%r, id=%r>' % ( self . __class__ . __name__ , self . level , self . msg , self . hint , self . obj , self . id )	in the string '<%s: level=%r, msg=%r, hint=%r, obj=%r, id=%r>', replace '%s' with the name of the type of this class instance,
def is_serious ( self ) :	replace all the '%r' with self.level, self.msg, self.hint. self.obj and self.id, respectively, return the result.   define the method is_serious with argument self.
return self . level >= ERROR	return boolean True if self.level is greater than or equals to ERROR, otherwise return boolean False.
def is_silenced ( self ) :	define the method is_silence with argument self.
from django . conf import settings	from django.conf import settings into default name space.
return self . id in settings . SILENCED_SYSTEM_CHECKS	if self.id is contained in settings.SILENCED_SYSTEM_CHECKS return boolean True, False otherwise.
class Debug ( CheckMessage ) :	derive the class Debug from base class CheckMessage.
def __init__ ( self , * args , ** kwargs ) :	define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.
return super ( Debug , self ) . __init__ ( DEBUG , * args , ** kwargs )	call the __init__ method with 3 arguments: DEBUG, unpacked list args and unpacked dictionary kwargs from the base class of Debug.
class Info ( CheckMessage ) :	derive the class Info from base class CheckMessage.
def __init__ ( self , * args , ** kwargs ) :	define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.
return super ( Info , self ) . __init__ ( INFO , * args , ** kwargs )	call the __init__ method with 3 arguments: INFO, unpacked list args and unpacked dictionary kwargs from the base class of Info.
class Warning ( CheckMessage ) :	derive the class Warning from base class CheckMessage.
def __init__ ( self , * args , ** kwargs ) :	define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.
return super ( Warning , self ) . __init__ ( WARNING , * args , ** kwargs )	call the __init__ method with 3 arguments: WARNING, unpacked list args and unpacked dictionary kwargs from the base class of Warning.
class Error ( CheckMessage ) :	derive the class Error from base class CheckMessage.
def __init__ ( self , * args , ** kwargs ) :	define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.
return super ( Error , self ) . __init__ ( ERROR , * args , ** kwargs )	call the __init__ method with 3 arguments: ERROR, unpacked list args and unpacked dictionary kwargs from the base class of Error.
class Critical ( CheckMessage ) :	derive the class Critical from base class CheckMessage.
def __init__ ( self , * args , ** kwargs ) :	define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.
return super ( Critical , self ) . __init__ ( CRITICAL , * args , ** kwargs )	call the __init__ method with 3 arguments: CRITICAL, unpacked list args and unpacked dictionary kwargs from the base class of Critical.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from itertools import chain	from itertools import chain into default name space.
import types	import module types.
from django . apps import apps	from django.apps import apps into default name space.
from . import Error , Tags , register	from . import Error, Tags and register into default name space.
@ register ( Tags . models )	decorator register with Tags.models as an argument.
def check_all_models ( app_configs = None , ** kwargs ) :	define the function check_all_models with app_configs defaulting to None and unpacked dictionary kwargs as arguments.
errors = [ model . check ( ** kwargs )  for model in apps . get_models ( )  if app_configs is None or model . _meta . app_config in app_configs ]	call the model.check method with unpacked dictionary kwargs for every model in return value of function apps.get_models,
return list ( chain ( * errors ) )	only if app_configs is None ot model._meta.app_config is contained in app_configs, error is a list containing all the previous elements.   chain all errors elements into a list, return it.
@ register ( Tags . models , Tags . signals )	decorator register with Tags.models and Tags.signals as arguments.
def check_model_signals ( app_configs = None , ** kwargs ) :	define the function check_model_signals with app_config defaulting to None and unpacked dictionary kwargs as arguments,
from django . db import models	from django.db import models into default name space.
errors = [ ]	errors is an empty list.
for name in dir ( models . signals ) :	for name in attributes of models_signals object,
obj = getattr ( models . signals , name )	get models.signals name attribute, store it in obj.
if isinstance ( obj , models . signals . ModelSignal ) :	if obj is instance of models.signals.ModelSignal class,
for reference , receivers in obj . unresolved_references . items ( ) :	for every reference and receivers in return value of the call of obj.unresolved_references.items method,
for receiver , _ , _ in receivers :	for every receiver, _ and _ in receivers,
  if isinstance ( receiver , types . FunctionType ) :	if receiver is an instance of types.FunctionType type,
    description = 'The '%s' function' % receiver . __name__	description is a string 'The '%s' function' replaced by value of receiver.__name__.
else :	if not,
    description = 'An instance of the '%s' class' % receiver . __class__ . __name__	description is a string 'An instance of the '%s' class' with '%s' replaced by value of receiver.__class__.__name__.
errors . append (  Error (  '%s was connected to the '%s' signal '  'with a lazy reference to the '%s' sender, '  'which has not been installed.' % (  description , name , '.' . join ( reference )  ) ,  obj = receiver . __module__ ,  hint = None ,  id = 'signals.E001'  )  )	call the Error function with 4 arguments, string '%s was connected to the '%s' signal with a lazy reference to the '%s' sender,
return errors	which has not been installed.' with all the '%s' replaced by values of description, name and reference joined into a string delimited by '.', respectively,   obj set to receiver.__module__, hint set to None and id set to string 'signals.E001', append the result to errors.   return errors.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from itertools import chain	from itertools import chain into default name space.
from django . utils . itercompat import is_iterable	from django.utils.itercompat import is_iterable into default name space.
class Tags ( object ) :	derive the class Tags with base class object.
admin = 'admin'	admin is a string 'admin'
compatibility = 'compatibility'	compatibility is a string 'compatibility'.
models = 'models'	models is a string 'models'
signals = 'signals'	signal is a string 'signals'
class CheckRegistry ( object ) :	derive the class CheckRegistry with object as base class.
def __init__ ( self ) :	define initialization method __init__ with argument self.
self . registered_checks = [ ]	self.registered_checks is an empty list.
def register ( self , * tags ) :	define the method register with self ans unpacked list tags as arguments.
def inner ( check ) :	define the method inner with argument check.
check . tags = tags	replace tags for check.tags.
if check not in self . registered_checks :	if check is not contained in self.registered_checks.
self . registered_checks . append ( check )	call the method self.registered_checks.append with argument check.
return check	return check.
return inner	return inner.
def run_checks ( self , app_configs = None , tags = None ) :	define the method run_checks with self class instance, app_configs defaulting to None, tags defaulting to None as argument.
errors = [ ]	errors is an empty list.
if tags is not None :	if tags is not None.
checks = [ check for check in self . registered_checks  if hasattr ( check , 'tags' ) and set ( check . tags ) & set ( tags ) ]	append check to checks list, for every check in self.register_checks, if check has an attribute 'tags' and check.tags and tags set intersection is a non empty set.
else :	if not.
checks = self . registered_checks	substitute self.registered_checks for checks.
for check in checks :	for every check in checks,
new_errors = check ( app_configs = app_configs )	call the check function with argument app_config set to app_config, substitute the result for new_errors.
assert is_iterable ( new_errors ) , (  'The function %r did not return a list. All functions registered '  'with the checks registry must return a list.' % check )	if new_errors is not an iterable object raise an error with error message 'The function %r did not return a list. All functions registered with the checks registry must return a list.', with '%s' replaced by value of check.
errors . extend ( new_errors )	call the method errors.extend with argument new_errors.
return errors	return errors.
def tag_exists ( self , tag ) :	define the method tag_exists with self class instance and tag as arguments.
return tag in self . tags_available ( )	return boolean True if tag is contained in self.tags_available method return value, return False otherwise.
def tags_available ( self ) :	define the method tags_available with argument self.
return set ( chain ( * [ check . tags for check in self . registered_checks if hasattr ( check , 'tags' ) ] ) )	append check.tags into a list for every check in self.registered_checks if check has 'tags' attribute, put the elements into a set and return it.
registry = CheckRegistry ( )	call the function CheckRegistry, substitute the result for registry.
register = registry . register	substitute registry.register for register.
run_checks = registry . run_checks	substitute registry.run_checks for run_checks.
tag_exists = registry . tag_exists	substitute registry.tag_exists for tag_exists.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . middleware . csrf import get_token	from django.middleware.csrf import get_token into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . encoding import smart_text	from django.utils.encoding import smart_text into default name space.
from django . utils . functional import lazy	from django.utils.functional import lazy into default name space.
def csrf ( request ) :	define the function csrf with an argument request.
def _get_val ( ) :	define the function _get_val.
token = get_token ( request )	call the function get_token with an argument request, substitute the result for token.
if token is None :	if token is None,
return 'NOTPROVIDED'	return string 'NOTPROVIDED'.
else :	if not,
return smart_text ( token )	call the smart_text function with an argument token, return the result.
_get_val = lazy ( _get_val , six . text_type )	call the function lazy with arguments _get_val and six.text_type, substitute the result for _get_val.
return { 'csrf_token' : _get_val ( ) }	return an dictionary containing 1 entry: return value of the function _get_val for 'csrf_token'.
def debug ( request ) :	define the function debug with an argument request.
context_extras = { }	context_extras is an empty dictionary.
if settings . DEBUG and request . META . get ( 'REMOTE_ADDR' ) in settings . INTERNAL_IPS :	if settings.DEBUG is true and value of the request.META dictionary under the 'REMOTE_ADDR' key is contained in settings.INTERNAL_IPS,
context_extras [ 'debug' ] = True	value under the 'debug' key of the context_extras dictionary is boolean True.
from django . db import connection	from django.db import connection into default name space.
context_extras [ 'sql_queries' ] = connection . queries	substitute connection.queries for value under the 'debug' key of the context_extras dictionary.
return context_extras	return context_extras.
def i18n ( request ) :	define the function i18n with an argument request.
from django . utils import translation	from django.utils import translation into default name space.
context_extras = { }	context_extras is an empty dictionary.
context_extras [ 'LANGUAGES' ] = settings . LANGUAGES	substitute settings.LANGUAGES for the value under the 'LANGUAGES' key of the context_extras dictionary.
context_extras [ 'LANGUAGE_CODE' ] = translation . get_language ( )	call the translation.get_language function, substitute the result for the value under the 'LANGUAGE_CODE' key of the context_extras dictionary.
context_extras [ 'LANGUAGE_BIDI' ] = translation . get_language_bidi ( )	call the translation.get_language_bidi function, substitute the result for the value under the 'LANGUAGE_BIDI' key of the context_extras dictionary.
return context_extras	return context_extras.
def tz ( request ) :	define the function tz with an argument request.
from django . utils import timezone	  from django.utils import timezone into default name space.
return { 'TIME_ZONE' : timezone . get_current_timezone_name ( ) }	return an dictionary containing 1 entry: return value of the function timezone.get_current_timezone_name for 'TIME_ZONE'.
def static ( request ) :	define the function static with an argument request.
return { 'STATIC_URL' : settings . STATIC_URL }	return an dictionary containing 1 entry: settings.STATIC_URL for 'STATIC_URL'.
def media ( request ) :	define the function media with an argument request.
return { 'MEDIA_URL' : settings . MEDIA_URL }	return an dictionary containing 1 entry: settings.MEDIA_URL for 'MEDIA_URL'.
def request ( request ) :	define the function request with an argument request.
return { 'request' : request }	return an dictionary containing 1 entry: request for 'request'.
from functools import reduce	from functools import reduce into default name space.
import operator	import module operator.
from django . utils import six	from django.utils import six into default name space.
from django . utils . encoding import force_text	from django.utils.encoding import force_text into default name space.
class DjangoRuntimeWarning ( RuntimeWarning ) :	derive the class DjangoRuntimeWarning from the RuntimeWarning base class.
pass	do nothing.
class AppRegistryNotReady ( Exception ) :	derive the class AppRegistryNotReady from the Exception base class.
pass	do nothing.
class ObjectDoesNotExist ( Exception ) :	derive the class ObjectDoesNotExist from the Exception base class.
silent_variable_failure = True	silent_variable_failure is an boolean True.
class MultipleObjectsReturned ( Exception ) :	derive the class MultipleObjectsReturned from the Exception base class.
pass	do nothing.
class SuspiciousOperation ( Exception ) :	derive the class SuspiciousOperation from the Exception base class.
class SuspiciousMultipartForm ( SuspiciousOperation ) :	derive the class SuspiciousMultipartForm from the SuspiciousOperation base class.
pass	do nothing.
class SuspiciousFileOperation ( SuspiciousOperation ) :	derive the class SuspiciousFileOperation from the SuspiciousOperation base class.
pass	do nothing.
class DisallowedHost ( SuspiciousOperation ) :	derive the class DisallowedHost from the SuspiciousOperation base class.
pass	do nothing.
class DisallowedRedirect ( SuspiciousOperation ) :	derive the class DisallowedRedirect from the SuspiciousOperation base class.
pass	do nothing.
class PermissionDenied ( Exception ) :	derive the class PermissionDenied from the Exception base class.
pass	do nothing.
class ViewDoesNotExist ( Exception ) :	derive the class ViewDoesNotExist from the Exception base class.
pass	do nothing.
class MiddlewareNotUsed ( Exception ) :	derive the class MiddlewareNotUsed from the Exception base class.
pass	do nothing.
class ImproperlyConfigured ( Exception ) :	derive the class ImproperlyConfigured from the Exception base class.
pass	do nothing.
class FieldError ( Exception ) :	derive the class FieldError from the Exception base class.
pass	do nothing.
NON_FIELD_ERRORS = '__all__'	NON_FIELD_ERRORS is an string '__all__'.
class ValidationError ( Exception ) :	derive the class ValidationError from the Exception base class.
def __init__ ( self , message , code = None , params = None ) :	define the method __init__ with 4 arguments: self, message, code set to None and params set to None.
super ( ValidationError , self ) . __init__ ( message , code , params )	call the __init__ method from the base class of the class ValidationError with arguments message, code and params.
if isinstance ( message , ValidationError ) :	if message is an instance of ValidationError class,
if hasattr ( message , 'error_dict' ) :	if message has an 'error_dict' attribute,
message = message . error_dict	substitute message.error_dict for message.
elif not hasattr ( message , 'message' if six . PY3 else 'code' ) :	alternatively, if six.PY3 is true check if message does not have an attribute 'message', if six.PY3 is false, check if message doesnt have an attribute 'code', perform the following,
message = message . error_list	substitute message.error_list for message.
else :	if not,
message , code , params = message . message , message . code , message . params	substitute message.message, message.code, message.params for message, code and params, respectively.
if isinstance ( message , dict ) :	if message is an instance of dict type,
self . error_dict = { }	self.error_dict is an empty dictionary.
for field , messages in message . items ( ) :	for every field, messages in return value of the message.items method,
if not isinstance ( messages , ValidationError ) :	if messages is not an instance of the ValidationError class,
messages = ValidationError ( messages )	messages is an instance of the ValidationError class created with an argument messages.
self . error_dict [ field ] = messages . error_list	substitute messages.error_list for the value under the field key of the self.error_dict dictionary.
elif isinstance ( message , list ) :	otherwise if message is an instance of the list type.
self . error_list = [ ]	self.error_list is an empty list.
for message in message :	for every message is message,
if not isinstance ( message , ValidationError ) :	if message is not an instance of the ValidationError class,
message = ValidationError ( message )	message is an instance of the ValidationError class created with an argument message.
self . error_list . extend ( message . error_list )	extend the self.error_list list with message.error_list.
else :	if not,
self . message = message	substitute message for self.message.
self . code = code	substitute code for self.code.
self . params = params	substitute params for self.params.
self . error_list = [ self ]	substitute list containing element self for self.error_list.
@ property	property getter decorator,
def message_dict ( self ) :	define the method message_dict with an argument self.
getattr ( self , 'error_dict' )	get attribute 'error_dict' from the self object.
return dict ( self )	convert object self to a dictionary, return it.
@ property	property getter decorator,
def messages ( self ) :	define the messages with an argument self.
if hasattr ( self , 'error_dict' ) :	if self has an 'error_dict' attribute,
return reduce ( operator . add , dict ( self ) . values ( ) )	call the operator.add on the values of the self object converted into a dictionary, until it is reduced to a single value, return it.
return list ( self )	convert self to a list and return it.
def update_error_dict ( self , error_dict ) :	define the method update_error_dict with arguments self and error_dict.
if hasattr ( self , 'error_dict' ) :	if self has an 'error_dict' attribute,
for field , error_list in self . error_dict . items ( ) :	for every field, error_list in self.error_dict.items method return value,
error_dict . setdefault ( field , [ ] ) . extend ( error_list )	call the method extend with an argument error_list on the return value of the method error_dict.setdefault called with 2 arguments: field and an empty list.
else :	if not,
error_dict . setdefault ( NON_FIELD_ERRORS , [ ] ) . extend ( self . error_list )	call the method extend with an argument error_list on the return value of the method error_dict.setdefault called with 2 arguments: NON_FIELD_ERRORS and an empty list.
return error_dict	return error_dict.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
if hasattr ( self , 'error_dict' ) :	if self has an 'error_dict' attribute,
for field , errors in self . error_dict . items ( ) :	for every field, errors in self.error_dict.items method return value,
yield field , list ( ValidationError ( errors ) )	yield field and ValidationError object converted to an list, created with an argument errors.
else :	if not,
for error in self . error_list :	for every error in self.error_list,
message = error . message	substitute error.message for message.
if error . params :	if error.params is true,
message %= error . params	divide message by error.params, substitute the residue of the division for message.
yield force_text ( message )	call the force_text with an argument message, yield the result.
def __str__ ( self ) :	define the method __str__ with an argument self.
if hasattr ( self , 'error_dict' ) :	if self has an attribute 'error_dict',
return repr ( dict ( self ) )	return the printable representation of the self object converted to a dictionary.
return repr ( list ( self ) )	return the printable representation of the self object converted to a list.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return 'ValidationError(%s)' % self	return the string 'ValidationError(%s)', replace '%s' with self.
from django . core . files . base import File	from django.core.files.base import File into default name space.
__all__ = [ 'File' ]	__all__ is an list containing a string 'File'.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import os	import module os.
from io import BytesIO , StringIO , UnsupportedOperation	from io import BytesIO,  StringIO and UnsupportedOperation into default name space.
from django . utils . encoding import smart_text	from django.utils.encoding import smart_text into default name space.
from django . core . files . utils import FileProxyMixin	from django.core.files.utils import FileProxyMixin into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . encoding import force_bytes , python_2_unicode_compatible	from django.utils.encoding import force_bytes and python_2_unicode_compatible into default name space.
@ python_2_unicode_compatible	decorator python_2_unicode_compatible,
class File ( FileProxyMixin ) :	derive the class File from the FileProxyMixin base class.
DEFAULT_CHUNK_SIZE = 64 * 2 ** 10	bring integer 2 to the power of 10, multiply it by 64, substitute the result for DEFAULT_CHUNK_SIZE.
def __init__ ( self , file , name = None ) :	define the method __init__ with self class instance, file, and name defaulting to None as arguments.
self . file = file	substitute file for self.file.
if name is None :	if name is None,
name = getattr ( file , 'name' , None )	get 'name' attribute from the file object, if it doesnt exists use None, substitute it for name.
self . name = name	substitute name for self.name.
if hasattr ( file , 'mode' ) :	if file object has an attribute 'mode',
self . mode = file . mode	substitute file.mode for self.mode.
def __str__ ( self ) :	define the method __str__ with argument self.
return smart_text ( self . name or '' )	evaluate the function smart_text with argument self.name, if exists, or an empty string, if not, return the result.
def __repr__ ( self ) :	define the method __repr__ with argument self.
return '<%s: %s>' % ( self . __class__ . __name__ , self or 'None' )	substitute '%s' in string '<%s: %s>' with self.__class__.__name__ and self, if exists, or string 'None' if it doesnt, return it.
def __bool__ ( self ) :	define the method __bool__ with argument self.
return bool ( self . name )	convert self.name into an boolean, return it.
def __nonzero__ ( self ) :	define the method __nonzero__ with argument self.
return type ( self ) . __bool__ ( self )	call the __bool__ method with argument self, on the return value of the type function with argument self, return the result.
def __len__ ( self ) :	define the method __len__ with argument self.
return self . size	return self.size.
def _get_size_from_underlying_file ( self ) :	define the method _get_size_from_underlying_file with argument self.
if hasattr ( self . file , 'size' ) :	if self.file has an attribute 'size',
return self . file . size	return self.file.size.
if hasattr ( self . file , 'name' ) :	if self.file has an attribute 'name',
try :	try,
return os . path . getsize ( self . file . name )	call the os.path.getsize function with argument self.file.name, return the result.
except ( OSError , TypeError ) :	if OSError or TypeError errors occurred.
pass	do nothing.
if hasattr ( self . file , 'tell' ) and hasattr ( self . file , 'seek' ) :	if self.file has an attribute 'tell' and an attribute 'seek',
pos = self . file . tell ( )	get the position of the self.file file pointer, substitute it for pos.
self . file . seek ( 0 , os . SEEK_END )	position the file self.file pointer at the end.
size = self . file . tell ( )	get the position of the file self.file pointer, substitute it for size.
self . file . seek ( pos )	position file self.file pointer at the pos position.
return size	return size.
raise AttributeError ( 'Unable to determine the file's size.' )	raise an AttributeError exception with string 'Unable to determine the file's size.' as argument.
def _get_size ( self ) :	define the method _get_size with argument self.
if hasattr ( self , '_size' ) :	if self has an attribute '_size'.
return self . _size	return self._size.
self . _size = self . _get_size_from_underlying_file ( )	call the method self._get_size_from_underlying_file, substitute the result for self._size.
return self . _size	return self._size.
def _set_size ( self , size ) :	define the method _set_size with arguments self and size.
self . _size = size	substitute size for self._size.
size = property ( _get_size , _set_size )	size is a property object with _get_size as getter method and _set_size as setter method.
def _get_closed ( self ) :	define the method _get_closed with argument self.
return not self . file or self . file . closed	if self.file is false or self.file.closed is true, return boolean true, otherwise return boolean false.
closed = property ( _get_closed )	closed is a property object with _get_closed as a getter method.
def chunks ( self , chunk_size = None ) :	define the method chunks with arguments self and chunk_size defaulting to None.
if not chunk_size :	if chunk_size is false,
chunk_size = self . DEFAULT_CHUNK_SIZE	substitute the self.DEFAULT_CHUNK_SIZE for chunk_size.
try :	try,
self . seek ( 0 )	position the file pointer at the beginning of self file.
except ( AttributeError , UnsupportedOperation ) :	if AttributeError or UnsupportedOperation exception occurred.
pass	do nothing.
while True :	endless loop,
data = self . read ( chunk_size )	call the self.read method with argument chunk_size, substitute the result for data.
if not data :	if data is false,
break	break from the smallest enclosing loop.
yield data	yield one element of data iterable.
def multiple_chunks ( self , chunk_size = None ) :	define the method __multiple_chunks__ with arguments self and chunk_size defaulting to None.
if not chunk_size :	if chunk_size is false,
chunk_size = self . DEFAULT_CHUNK_SIZE	substitute self.DEFAULT_CHUNK_SIZE for chunk_size.
return self . size > chunk_size	if self.size is greater than chunk_size, return boolean True, otherwise return boolean False.
def __iter__ ( self ) :	define the method __iter__ with argument self.
buffer_ = None	buffer_ is None.
for chunk in self . chunks ( ) :	for every chunk in return value of the method self.chunks,
chunk_buffer = BytesIO ( chunk )	evaluate the function BytesIO with argument chunk, substitute it for chunk_buffer.
for line in chunk_buffer :	for every line in chunk_buffer,
if buffer_ :	if buffer_ is true,
line = buffer_ + line	increment line by buffer_.
buffer_ = None	buffer_ is None.
\if line [ - 1 : ] in ( b'\\n' , b'\\r' ) :\	if last element of line is newline or carriage return character,
yield line	yield one element of line iterable.
else :	if not,
buffer_ = line	substitute line for buffer_.
if buffer_ is not None :	if buffer_ is not None,
yield buffer_	yield one element from the buffer_ iterable.
def __enter__ ( self ) :	define the method __enter__ with argument self.
return self	return self.
def __exit__ ( self , exc_type , exc_value , tb ) :	define the method __exit__ with self, exc_type, exc_value and tb as arguments.
self . close ( )	close the file self.
def open ( self , mode = None ) :	define the method open with arguments self and mode defaulting to None.
if not self . closed :	if file self is not closed,
self . seek ( 0 )	position the file pointer at the beginning of self file.
elif self . name and os . path . exists ( self . name ) :	otherwise if self.name exists and self.name file path exists,
self . file = open ( self . name , mode or self . mode )	open the file self.name in mode or self.mode mode, whichever exists, assign the file handler to self.file.
else :	if not,
raise ValueError ( 'The file cannot be reopened.' )	raise an ValueError exception with string 'The file cannot be reopened.' as an argument.
def close ( self ) :	define the method close with argument self.
self . file . close ( )	call the method self.file.close.
@ python_2_unicode_compatible	decorator python_2_unicode_compatible,
class ContentFile ( File ) :	derive the class ContentFile from File base class.
def __init__ ( self , content , name = None ) :	define the method __init__ with arguments self, content and name defaulting to None.
if six . PY3 :	if six.PY3 is boolean True,
stream_class = StringIO if isinstance ( content , six . text_type ) else BytesIO	substitute StringIO for stream_class if content is an instance of six.text_type, otherwise substitute BytesIO for stream_class.
else :	if not,
stream_class = BytesIO	substitute BytesIO for stream_class.
content = force_bytes ( content )	call the function force_bytes with argument content, substitute it for content.
super ( ContentFile , self ) . __init__ ( stream_class ( content ) , name = name )	call the __init__ method with stream_class(content) and name set to name arguments, from the base class of the ContentFile class.
self . size = len ( content )	substitute length of content for self.size.
def __str__ ( self ) :	define the method __str__ with argument self.
return 'Raw content'	return a string 'Raw content'.
def __bool__ ( self ) :	define the method __bool__ with argument self.
return True	return boolean True.
def __nonzero__ ( self ) :	define the method __nonzero__ with argument self.
return type ( self ) . __bool__ ( self )	evaluate the method type(self).__bool__ with argument self, return the result.
def open ( self , mode = None ) :	define the method open with arguments self and mode set to None.
self . seek ( 0 )	call the self.seek method with argument integer 0.
def close ( self ) :	define the method close with argument self.
pass	do nothing.
import zlib	import module zlib.
from django . core . files import File	from django.core.files import File into default name space.
class ImageFile ( File ) :	derive class ImageFile from the base class File.
def _get_width ( self ) :	define method _get_width with self class instance as the argument.
return self . _get_image_dimensions ( ) [ 0 ]	return the first element of the return value of the call to the self._det_image_dimensions method.
width = property ( _get_width )	get property attribute _get_width, and substitute it for width.
def _get_height ( self ) :	define method _get_height with self class instance as the argument.
return self . _get_image_dimensions ( ) [ 1 ]	return the second element of the return value of the call to the self._det_image_dimensions method.
height = property ( _get_height )	get property attribute _get_height, and substitute it for width.
def _get_image_dimensions ( self ) :	define the method _get_image_dimensions with self class instance as the argument.
if not hasattr ( self , '_dimensions_cache' ) :	if self does not have an attribute named '_dimensions_cache'.
close = self . closed	substitute self.closed for close.
self . open ( )	call the method self.open()
self . _dimensions_cache = get_image_dimensions ( self , close = close )	evaluate the method get_image_dimensions with self class instance and close set to close as the arguments, substitute the result for self._dimensions_cache.
return self . _dimensions_cache	return self._dimensions_cache.
def get_image_dimensions ( file_or_path , close = False ) :	define the function get_image_dimension with file_or_path and close set to boolean False as the arguments.
from PIL import ImageFile as PillowImageFile	from PIL module import ImageFile as PillowImageFile.
p = PillowImageFile . Parser ( )	p is image parser object, set by calling the PillowImageFile.Parser method.
if hasattr ( file_or_path , 'read' ) :	if file_or_path has an attribute 'read',
file = file_or_path	substitute file_or_path for file.
file_pos = file . tell ( )	get the position in bytes from the start of the file, store it in file_pos.
file . seek ( 0 )	set the file position pointer at the beginning.
else :	if not,
file = open ( file_or_path , 'rb' )	open file named file_or_path for reading, store the file object handle in file.
close = True	close is boolean True.
try :	try,
chunk_size = 1024	chunk_size is an integer 1024.
while 1 :	endless while loop,
data = file . read ( chunk_size )	read chunk_size bytes from file and store it in data.
if not data :	if data is empty.
break	break from the endless loop.
try :	try,
p . feed ( data )	feed data to the parser p.
except zlib . error as e :	if zlib.error as e exception is raised,
if e . args [ 0 ] . startswith ( 'Error -5' ) :	if e.args list first element starts with string 'Error -5',
pass	do nothig.
else :	if not,
raise	raise an exception.
if p . image :	if p.image is not empty,
return p . image . size	return size of the image that was fed to the parser p.
chunk_size *= 2	double the chunk size.
return None	return None.
finally :	execute regardless of the exception being raised,
if close :	if close is True,
file . close ( )	close file file.
else :	if not,
file . seek ( file_pos )	set the file position pointer at file_pos.
import os	import module os.
__all__ = ( 'LOCK_EX' , 'LOCK_SH' , 'LOCK_NB' , 'lock' , 'unlock' )	__all__ is a tuple containing strings: 'LOCK_EX', 'LOCK_SH', 'LOCK_NB', 'lock' and 'unlock'.
def _fd ( f ) :	define the _fd function with argument f.
return f . fileno ( ) if hasattr ( f , 'fileno' ) else f	return result of the f.fileno method if f has an 'fileno' attribute, otherwise return f.
if os . name == 'nt' :	if os.name equals to 'nt',
import msvcrt	import msvcrt.
from ctypes import ( sizeof , c_ulong , c_void_p , c_int64 ,  Structure , Union , POINTER , windll , byref )	from ctypes import sizeof, c_ulong, c_void_p, c_int64, Structure, Union, POINTER, windll and byref into default name space.
from ctypes . wintypes import BOOL , DWORD , HANDLE	from ctypes.wintypes import BOOL, DWORD and HANDLE into default name space.
LOCK_SH = 0	LOCK_SH is a integer 0.
LOCK_NB = 0x1	LOCK_NB is a hexadecimal 1.
LOCK_EX = 0x2	LOCK_EX is a hexadecimal 2.
if sizeof ( c_ulong ) != sizeof ( c_void_p ) :	if size of c_ulong does not equals to size of c_void_p,
ULONG_PTR = c_int64	substitute c_int64 for ULONG_PTR.
else :	if not,
ULONG_PTR = c_ulong	substitute c_ulong for ULONG_PTR.
PVOID = c_void_p	substitute c_void_p for PVOID.
class _OFFSET ( Structure ) :	derive the class _OFFSET from the Structure base class.
_fields_ = [  ( 'Offset' , DWORD ) ,  ( 'OffsetHigh' , DWORD ) ]	_fields_ is a list containing 2 tuples: first tuple contains: string 'Offset' and DWORD, second contains: string 'OffsetHigh' and DWORD.
class _OFFSET_UNION ( Union ) :	derive the class _OFFSET_UNION from the Union base class.
_anonymous_ = [ '_offset' ]	_anonymous_ is a list containing one string: '_offset'.
_fields_ = [  ( '_offset' , _OFFSET ) ,  ( 'Pointer' , PVOID ) ]	_fields_ is a list containing 2 tuples: first tuple contains: string '_offset' and _OFFSET, second contains: string 'Pointer' and PVOID.
class OVERLAPPED ( Structure ) :	derive the class OVERLAPPED from the Structure base class.
_anonymous_ = [ '_offset_union' ]	_anonymous_ is a list containing one string: '_offset_union'.
_fields_ = [  ( 'Internal' , ULONG_PTR ) ,  ( 'InternalHigh' , ULONG_PTR ) ,  ( '_offset_union' , _OFFSET_UNION ) ,  ( 'hEvent' , HANDLE ) ]	_fields_ is a list containing 4 tuples: first tuple contains: string 'Internal' and ULONG_PTR,
LPOVERLAPPED = POINTER ( OVERLAPPED )	second contains: string 'InternalHigh and ULONG_PTR, third: '_offset_union' and _OFFSET_UNION, forth 'hEvent' and HANDLE.   call the function POINTER with argument OVERLAPPED, substitute the result for LPOVERLAPPED.
LockFileEx = windll . kernel32 . LockFileEx	substitute windll.kernel32.LockFileEx for LockFileEx.
LockFileEx . restype = BOOL	substitute BOOL for LockFileEx.restype.
LockFileEx . argtypes = [ HANDLE , DWORD , DWORD , DWORD , DWORD , LPOVERLAPPED ]	LockFileEx.argtypes is a list containing 6 elements: HANDLE, DWORD, DWORD, DWORD, DWORD and LPOVERLAPPED.
UnlockFileEx = windll . kernel32 . UnlockFileEx	substitute windll.kernel32.UnlockFileEx for UnlockFileEx.
UnlockFileEx . restype = BOOL	substitute BOOL for UnlockFileEx.restype.
UnlockFileEx . argtypes = [ HANDLE , DWORD , DWORD , DWORD , LPOVERLAPPED ]	UnlockFileEx.argtypes is a list containing 5 elements: HANDLE, DWORD, DWORD, DWORD and LPOVERLAPPED.
def lock ( f , flags ) :	define the function lock with arguments f and flags.
hfile = msvcrt . get_osfhandle ( _fd ( f ) )	call the function msvcrt.get_osfhandle with return value of the _fd(f) function as argument, substitute the result for hfile.
overlapped = OVERLAPPED ( )	call the OVERLAPPED function, substitute the result for overlapped.
ret = LockFileEx ( hfile , flags , 0 , 0 , 0xFFFF0000 , byref ( overlapped ) )	call the LockFileEx function with 6 arguments: hfile, flags, integer 0, integer 0, hexadecimal value FFFF0000, return value of the byref function called with argument overlapped, substitute the result for ret.
return bool ( ret )	convert ret to a boolean, return it.
def unlock ( f ) :	define the function unlock with argument f.
hfile = msvcrt . get_osfhandle ( _fd ( f ) )	call the function msvcrt.get_osfhandle with return value of the _fd(f) function as argument, substitute the result for hfile.
overlapped = OVERLAPPED ( )	call the OVERLAPPED function, substitute the result for overlapped.
ret = UnlockFileEx ( hfile , 0 , 0 , 0xFFFF0000 , byref ( overlapped ) )	call the LockFileEx function with 5 arguments: hfile, integer 0, integer 0, hexadecimal value FFFF0000, return value of the byref function called with argument overlapped, substitute the result for ret.
return bool ( ret )	convert ret to a boolean, return it.
else :	if not,
try :	try,
import fcntl	import fcntl.
LOCK_SH = fcntl . LOCK_SH	substitute fcntl.LOCK_SH for LOCK_SH.
LOCK_NB = fcntl . LOCK_NB	substitute fcntl.LOCK_NB for LOCK_NB.
LOCK_EX = fcntl . LOCK_EX	substitute fcntl.LOCK_EX for LOCK_EX.
except ( ImportError , AttributeError ) :	if ImportError or AttributeError exception occurred,
LOCK_EX = LOCK_SH = LOCK_NB = 0	LOCK_EX, LOCK_SH and LOCK_NB are all equal to integer 0.
def lock ( f , flags ) :	define the function lock with arguments f and flags.
return False	return boolean False.
def unlock ( f ) :	define the function unlock with argument f.
return True	return boolean True.
else :	if not,
def lock ( f , flags ) :	define the function lock with arguments f and flags.
ret = fcntl . flock ( _fd ( f ) , flags )	call the function fcntl.flock with return value of the _fd(f) function and flags as arguments, substitute the result for ret.
return ( ret == 0 )	if ret equals to integer 0, return boolean True, otherwise return boolean False.
def unlock ( f ) :	define the function unlock with argument f.
ret = fcntl . flock ( _fd ( f ) , fcntl . LOCK_UN )	all the function fcntl.flock with return value of the _fd(f) function and fcntl.LOCK_UN as arguments, substitute the result for ret.
return ( ret == 0 )	if ret equals to integer 0, return boolean True, otherwise return boolean False.
import os	import module os.
from django . core . files import locks	from django.core.files import locks into default name space.
try :	try,
from shutil import copystat	from shutil import copystat into default name space.
except ImportError :	if ImportError exception occurred,
import stat	import stat.
def copystat ( src , dst ) :	define the function copystat with arguments src and dst.
st = os . stat ( src )	call the os.stat function with argument src, substitute the result for st.
mode = stat . S_IMODE ( st . st_mode )	call the function stat.S_IMODE with argument st.st_mode, substitute the result for mode.
if hasattr ( os , 'utime' ) :	if os has an attribute 'utime',
os . utime ( dst , ( st . st_atime , st . st_mtime ) )	call the os.utime function with arguments dst and tuple containing 2 elements: st.st_atime and st.st_mtime.
if hasattr ( os , 'chmod' ) :	if os has an attribute 'chmod',
os . chmod ( dst , mode )	call the function os.chmod with arguments dst and mode.
__all__ = [ 'file_move_safe' ]	__all__ is a list containing a string 'file_move_safe'.
def _samefile ( src , dst ) :	define the function _samefile with arguments src and dst.
if hasattr ( os . path , 'samefile' ) :	if os.path has an attribute 'samefile',
try :	try,
return os . path . samefile ( src , dst )	call the os.path.samefile with arguments src and dst, return the result.
except OSError :	if exception OSError occurred,
return False	return boolean False.
return ( os . path . normcase ( os . path . abspath ( src ) ) ==  os . path . normcase ( os . path . abspath ( dst ) ) )	if file path of src and dst files are the same, return boolean True, otherwise return boolean False.
def file_move_safe ( old_file_name , new_file_name , chunk_size = 1024 * 64 , allow_overwrite = False ) :	define the function file_move_safe with 4 arguments: old_file_name, new_file_name, chunk_size set to multiple of integers 1024 and 64,
if _samefile ( old_file_name , new_file_name ) :	if call to the function _samefile with old_file_name and new_file_name evaluates to boolean True,
return	return nothing.
try :	try,
if not allow_overwrite and os . access ( new_file_name , os . F_OK ) :	if allow_overwrite is boolean False and call to the os.access function with arguments new_file_name and os.F_OK evaluates to boolean True,
raise IOError ( 'Destination file %s exists and allow_overwrite is False' % new_file_name )	raise an IOError exception with string 'Destination file %s exists and allow_overwrite is False' as argument, where '%s' is replaced by new_file_name.
os . rename ( old_file_name , new_file_name )	call the os.rename function with arguments old_file_name and new_file_name.
return	return nothing.
except OSError :	if OSError exception is caught,
pass	do nothing.
with open ( old_file_name , 'rb' ) as old_file :	open file old_file_name in read bytes mode, with file descriptor as f,
fd = os . open ( new_file_name , ( os . O_WRONLY | os . O_CREAT | getattr ( os , 'O_BINARY' , 0 ) |  ( os . O_EXCL if not allow_overwrite else 0 ) ) )	evaluate the binary expression with 4 operands: os.O_WRONLY, binary or os.O_CREATE, binary or 'O_BINARY' attribute of object os,
try :	binary or os.O_EXCL if allow_overwrite is boolean False, use the previous as the mode to open new_file_name file, assign the file descriptor to fd.   try,
locks . lock ( fd , locks . LOCK_EX )	call the function locks.lock with arguments fd and locks.LOCK_EX.
current_chunk = None	current_chunk is None.
while current_chunk != b'' :	as long as current_chunk is not an empty string,
current_chunk = old_file . read ( chunk_size )	read chunk_size bytes from the old_file file, substitute the result for current_chunk.
os . write ( fd , current_chunk )	write current_chunk to file fd.
finally :	finally perform,
locks . unlock ( fd )	call the function locks.unlock with fd as argument.
os . close ( fd )	close the file fd.
copystat ( old_file_name , new_file_name )	call the function copystat with old_file_name and new_file_name as arguments.
try :	tr,
os . remove ( old_file_name )	remove the old_file_name file.
except OSError as e :	if OSError, renamed to e, is caught,
if getattr ( e , 'winerror' , 0 ) != 32 and getattr ( e , 'errno' , 0 ) != 13 :	if attribute 'winerror' of object e is not equal to integer 32 and if 'errno' attribute is not equal to integer 13,
raise	raise an exception.
import os	import module os.
import errno	import module errno.
import itertools	import module itertools.
from datetime import datetime	from datetime import datetime into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . exceptions import SuspiciousFileOperation	from django.core.exceptions import SuspiciousFileOperation into default name space.
from django . core . files import locks , File	from django.core.files import locks and File into default name space.
from django . core . files . move import file_move_safe	from django.core.files.move import file_move_safe into default name space.
from django . utils . encoding import force_text , filepath_to_uri	from django.utils.encoding import force_text and filepath_to_uri into default name space.
from django . utils . functional import LazyObject	from django.utils.functional import LazyObject into default name space.
from django . utils . module_loading import import_string	from django.utils.module_loading import import_string into default name space.
from django . utils . six . moves . urllib . parse import urljoin	from django.utils.six.moves.urllib.parse import urljoin into default name space.
from django . utils . text import get_valid_filename	from django.utils.text import get_valid_filename into default name space.
from django . utils . _os import safe_join , abspathu	from django.utils._os import safe_join and abspathu into default name space.
from django . utils . deconstruct import deconstructible	from django.utils.deconstruct import deconstructible into default name space.
__all__ = ( 'Storage' , 'FileSystemStorage' , 'DefaultStorage' , 'default_storage' )	__all__ is a tuple containing strings: 'Storage', 'FileSystemStorage', 'DefaultStorage' and 'default_storage'.
class Storage ( object ) :	derive the class Storage from the object base class.
def open ( self , name , mode = 'rb' ) :	define the method open with arguments self, name and mode defaulting to string 'rb'.
return self . _open ( name , mode )	call the self._open method with name and mode arguments, return the result.
def save ( self , name , content ) :	define the method save with arguments self, name and content.
if name is None :	if name is None,
name = content . name	substitute content.name for name.
if not hasattr ( content , 'chunks' ) :	if content has an 'chunks' attribute,
content = File ( content )	content is a File object instance created with content argument.
name = self . get_available_name ( name )	call the method self.get_available_name with argument name, substitute it for name.
name = self . _save ( name , content )	call the method self._save with arguments name and content, substitute it for name.
\return force_text ( name . replace ( '\\\\' , '/' ) )\	\replace all the strings '\\\\' with '/' in the string name, use it as an argument for the call to the force_text function, return the result.\
def get_valid_name ( self , name ) :	define the method det_valid_name with arguments self and name.
return get_valid_filename ( name )	call the get_valid_filename with argument name, return the result.
def get_available_name ( self , name ) :	define the method get_available_name with arguments self and name.
dir_name , file_name = os . path . split ( name )	call the os.path.split with argument name, assign the result to the dir_name and file_name respectively.
file_root , file_ext = os . path . splitext ( file_name )	call the os.path.splitext with argument file_name, assign the result to the file_root and file_ext respectively.
count = itertools . count ( 1 )	call the itertools.count function with argument integer 1, substitute the result for count.
while self . exists ( name ) :	as long as self.exists function with argument name evaluates to boolean True,
name = os . path . join ( dir_name , '%s_%s%s' % ( file_root , next ( count ) , file_ext ) )	substitute '%s' in string '%s_%s%s' with: file_root, next(count) and file_ext, join the dir_name and previous string into a valid file path, substitute it for name.
return name	return name.
def path ( self , name ) :	define the method path with arguments self and name.
raise NotImplementedError ( 'This backend doesn't support absolute paths.' )	raise an NotImplementedError exception with argument string 'This backend doesn't support absolute paths.'.
def delete ( self , name ) :	define the method delete with arguments self and name.
raise NotImplementedError ( 'subclasses of Storage must provide a delete() method' )	raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a delete() method'.
def exists ( self , name ) :	define the method exists with arguments self and name.
raise NotImplementedError ( 'subclasses of Storage must provide an exists() method' )	raise an NotImplementedError exception with argument string 'subclasses of Storage must provide an exists() method'.
def listdir ( self , path ) :	define the method listdir with arguments self and path.
raise NotImplementedError ( 'subclasses of Storage must provide a listdir() method' )	raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a listdir() method'.
def size ( self , name ) :	define the method size with arguments self and name.
raise NotImplementedError ( 'subclasses of Storage must provide a size() method' )	raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a size() method'.
def url ( self , name ) :	define the method url with arguments self and name.
raise NotImplementedError ( 'subclasses of Storage must provide a url() method' )	raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a url() method'.
def accessed_time ( self , name ) :	define the method accessed_time with arguments self and name.
raise NotImplementedError ( 'subclasses of Storage must provide an accessed_time() method' )	raise an NotImplementedError exception with argument string 'subclasses of Storage must provide an accessed_time() method'.
def created_time ( self , name ) :	define the method created_time with arguments self and name.
raise NotImplementedError ( 'subclasses of Storage must provide a created_time() method' )	raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a created_time() method'.
def modified_time ( self , name ) :	define the method modified_time with arguments self and name.
raise NotImplementedError ( 'subclasses of Storage must provide a modified_time() method' )	raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a modified_time() method'.
@ deconstructible	decorator deconstructible,
class FileSystemStorage ( Storage ) :	derive the class FileSystemStorage from the Storage base class.
def __init__ ( self , location = None , base_url = None , file_permissions_mode = None ,  directory_permissions_mode = None ) :	define the method __init__ with 5 arguments: self, location set to None, base_url set to None, file_permissions_mode set to None,
if location is None :	and directory_permissions_mode set to None.   if location is None,
location = settings . MEDIA_ROOT	substitute the settings.MEDIA_ROOT for location.
self . base_location = location	substitute the location for self.base_location.
self . location = abspathu ( self . base_location )	substitute the return value of the function abspathu with self.base_location as argument for self.location.
if base_url is None :	if base_url is None,
base_url = settings . MEDIA_URL	substitute settings.MEDIA_URL for base_url.
elif not base_url . endswith ( '/' ) :	otherwise if base_url does not ends with '/' character,
base_url += '/'	append character '/' to the base_url.
self . base_url = base_url	substitute base_url for self.base_url.
self . file_permissions_mode = (  file_permissions_mode if file_permissions_mode is not None  else settings . FILE_UPLOAD_PERMISSIONS  )	self.file_permissions_mode is a tuple containing: file_permissions_mode if file_permissions_mode is not None,
self . directory_permissions_mode = (  directory_permissions_mode if directory_permissions_mode is not None  else settings . FILE_UPLOAD_DIRECTORY_PERMISSIONS  )	or settings.FILE_UPLOAD_PERMISSIONS if it is.   self.directory_permissions_mode is a tuple containing: directory_permissions_mode if directory_permissions_mode is not None,
def _open ( self , name , mode = 'rb' ) :	or settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS if it is.   define the method _open with arguments self, name and mode defaulting to string 'rb'.
return File ( open ( self . path ( name ) , mode ) )	call the function self.path with argument name, use it and mode as arguments for the call to the function open, use it as an argument for creatinon of a File object instance, return it.
def _save ( self , name , content ) :	define the method _save with arguments self, name and content.
full_path = self . path ( name )	substitute result of the self.path function with argument name for full_path.
directory = os . path . dirname ( full_path )	call the function os.path.dirname with argument full_path, substitute the result for directory.
if not os . path . exists ( directory ) :	if call to the function os.path.exists with argument directory evaluates to boolean False,
try :	try,
if self . directory_permissions_mode is not None :	if self.directory_permissions_mode is not None,
  old_umask = os . umask ( 0 )	call the os.umask function with argument integer 0, substitute the result for old_umask.
try :	try,
    os . makedirs ( directory , self . directory_permissions_mode )	call the os.makedirs function with directory and self.directory_permissions_mode as arguments.
finally :	finally perform,
    os . umask ( old_umask )	call the os.umask function with argument old_umask.
else :	if not,
os . makedirs ( directory )	call the function os.makedirs with argument directory.
except OSError as e :	if exception OSError, renamed to e, occurred,
if e . errno != errno . EEXIST :	if e.errno is not equal to errno.EEXIST,
raise	raise an exception.
if not os . path . isdir ( directory ) :	if directory is not an directory,
raise IOError ( '%s exists and is not a directory.' % directory )	raise an IOError exception with argument string '%s exists and is not a directory.', where '%s' is replaced by directory.
while True :	endless loop,
try :	try,
if hasattr ( content , 'temporary_file_path' ) :	if content has an attribute 'temporary_file_path',
file_move_safe ( content . temporary_file_path ( ) , full_path )	call the function file_move_safe with content.temporary_file_path function result and full_path.
else :	if not,
  flags = ( os . O_WRONLY | os . O_CREAT | os . O_EXCL |  getattr ( os , 'O_BINARY' , 0 ) )	evaluate binary expression with 4 operands: os.O_WRONLY, binary or os.O_CREAT, binary or os.O_EXCL,
fd = os . open ( full_path , flags , 0o666 )	binary or 'O_BINARY' attribute of the os object, or integer 0 if it doesnt exists.   call the os.open function with full_path, flags and octal number 0o666 as arguments, substitute the result for fd.
_file = None	_file is None.
try :	try,
    locks . lock ( fd , locks . LOCK_EX )	call the function locks.lock with fd and locks.LOCK_EX as arguments.
for chunk in content . chunks ( ) :	for every chunk in content.chunks function return value,
        if _file is None :	if _file is None,
            mode = 'wb' if isinstance ( chunk , bytes ) else 'wt'	mode is a string 'wb' is chunk is instance of the type bytes, otherwise mode is a string 'wt'.
_file = os . fdopen ( fd , mode )	call the function os.fdopen with arguments fd and mode, substitute it for _file.
_file . write ( chunk )	write the chunk to the file _file.
finally :	finally perform,
    locks . unlock ( fd )	call the function locks.unlock with argument fd.
if _file is not None :	if _file is not None,
        _file . close ( )	close the _file file.
else :	if not,
        os . close ( fd )	close fd file.
except OSError as e :	if OSError, renamed to e, is caught,
if e . errno == errno . EEXIST :	if e.errno equals to errno.EEXIST,
  name = self . get_available_name ( name )	call the method self.get_available_name with argument name, substitute the result for name.
full_path = self . path ( name )	call the method self.path with argument name, substitute the result for full_path.
else :	if not,
raise	raise an exception.
else :	if not,
break	break from the smallest enclosing loop.
if self . file_permissions_mode is not None :	  if self.file_permissions_mode is not None,
os . chmod ( full_path , self . file_permissions_mode )	call the function os.chmod with arguments full_path and self.file_permissions_mode.
return name	return name.
def delete ( self , name ) :	define the method delete with arguments self and name.
assert name , 'The name argument is not allowed to be empty.'	if name is boolean False raise an assert error with message string 'The name argument is not allowed to be empty.'.
name = self . path ( name )	call the self.path with argument name, substitute it for name.
if os . path . exists ( name ) :	if os.path.exists function with argument name, evaluates to boolean True,
try :	try,
os . remove ( name )	call the os.remove function with argument name.
except OSError as e :	if OSError, renamed to e, is caught,
if e . errno != errno . ENOENT :	if e.errno equals to errno.EEXIST,
raise	raise an exception.
def exists ( self , name ) :	define the method exists with arguments self and name.
return os . path . exists ( self . path ( name ) )	call the self.path function with argument name, use the result as the argument for the call to the os.path.exists function, return the result.
def listdir ( self , path ) :	define the method listdir with arguments self and path.
path = self . path ( path )	call the self.path function with argument path, substitute it for path.
directories , files = [ ] , [ ]	directories, files are empty lists.
for entry in os . listdir ( path ) :	for every entry in os.listdir function return value called with the argument path,
if os . path . isdir ( os . path . join ( path , entry ) ) :	join path and entry into a file path, if it exists,
directories . append ( entry )	append entry to the directories list.
else :	if not,
files . append ( entry )	append entry to files list.
return directories , files	return directories and files.
def path ( self , name ) :	define the method path with arguments self and name.
try :	try,
path = safe_join ( self . location , name )	call the safe_join function with arguments self.location and name, substitute it for path.
except ValueError :	if ValueError exception is caught,
raise SuspiciousFileOperation ( 'Attempted access to '%s' denied.' % name )	raise an SuspiciousFileOperation exception with string 'Attempted access to '%s' denied.' as argument, replace '%s' with name.
return os . path . normpath ( path )	call the os.path.normpath with argument path, return the result.
def size ( self , name ) :	define the method size with arguments self and name.
return os . path . getsize ( self . path ( name ) )	call the self.path with argument name, use the result as an argument for the call to the os.path.getsize function, return the result.
def url ( self , name ) :	define the method url with arguments self and name.
if self . base_url is None :	if self.base_url is None,
raise ValueError ( 'This file is not accessible via a URL.' )	raise an ValueError with string 'This file is not accessible via a URL.' as argument.
return urljoin ( self . base_url , filepath_to_uri ( name ) )	call the urljoin function with arguments: self.base_url and result of the call to the function filepath_to_uri with argument name, return the result.
def accessed_time ( self , name ) :	define the method accessed_time with arguments self and name.
return datetime . fromtimestamp ( os . path . getatime ( self . path ( name ) ) )	call the function self.path with argument name, use the result as an argument for the call to the function os.path.getatime,
def created_time ( self , name ) :	use the result as an argument for the call to the function datetime.fromtimestamp, return the result.   define the method created_time with arguments self and name.
return datetime . fromtimestamp ( os . path . getctime ( self . path ( name ) ) )	call the function self.path with argument name, use the result as an argument for the call to the function os.path.getctime,
def modified_time ( self , name ) :	use the result as an argument for the call to the function datetime.fromtimestamp, return the result.   define the method modified_time with arguments self and name.
return datetime . fromtimestamp ( os . path . getmtime ( self . path ( name ) ) )	call the function self.path with argument name, use the result as an argument for the call to the function os.path.getmtime,
def get_storage_class ( import_path = None ) :	use the result as an argument for the call to the function datetime.fromtimestamp, return the result.   define the function get_storage_class with argument import_path=None defaulting to None.
return import_string ( import_path or settings . DEFAULT_FILE_STORAGE )	call the import_string with argument: import_path if exists or settings.DEFAULT_FILE_STORAGE, if not, return the result.
class DefaultStorage ( LazyObject ) :	derive the class DefaultStorage from the LazyObject base class.
def _setup ( self ) :	define the _setup method with argument self.
self . _wrapped = get_storage_class ( ) ( )	call the function that is the return value of get_storage_class method, substitute the result for self._wrapped.
default_storage = DefaultStorage ( )	call the DefaultStorage method, substitute the result for default_storage.
import os	import module os.
import tempfile	import module tempfile.
from django . core . files . utils import FileProxyMixin	from django.core.files.utils import FileProxyMixin into default name space.
__all__ = ( 'NamedTemporaryFile' , 'gettempdir' , )	__all__ is a tuple, containing strings 'NamedTemporaryFile' and 'gettempdir'.
if os . name == 'nt' :	if module os field name equals to string 'nt',
class TemporaryFile ( FileProxyMixin ) :	derive class TemporaryFile from the base class FileProxyMixin.
def __init__ ( self , mode = 'w+b' , bufsize = - 1 , suffix = '' , prefix = '' ,  dir = None ) :	define method __init__ with self class instance, mode string 'w+b', bufsize set to integer -1, suffix and prefix set to empty strig,
fd , name = tempfile . mkstemp ( suffix = suffix , prefix = prefix , dir = dir )	dir set to None as the arguments.   call the method tmpfile.mkstemp with suffix set to suffix, prefix set to prefix and dir set to dir, store the result in the fd and name, respective.
self . name = name	substitute name for self.name.
self . file = os . fdopen ( fd , mode , bufsize )	call the os.fdopen function with fd, mode and bufsize as the arguments, assign the file handle object to self.file.
self . close_called = False	substitute False for self.close_called.
unlink = os . unlink	substitute os.unlink for unlink.
def close ( self ) :	define the method close with self class instance as the argument.
if not self . close_called :	if self.close_called is False,
self . close_called = True	substitute True for self.close_called.
try :	try,
self . file . close ( )	close the file object.
except ( OSError , IOError ) :	if OSError or IOError exceptions were raised,
pass	do nothing.
try :	try,
self . unlink ( self . name )	call the method unlink on self with self.name as the argument.
except ( OSError ) :	if OSError exception was raised,
pass	do nothing.
@ property	property decorator, to be called by property built-in function.
def closed ( self ) :	define the method closed with self as the argument.
return self . file . closed	return self.file.closed.
def __del__ ( self ) :	define __del__ method with self as the argument.
self . close ( )	call the method close on self.
def __enter__ ( self ) :	define __enter__ method with self as the argument.
self . file . __enter__ ( )	call the file.__enter__ method on self.
return self	return self.
def __exit__ ( self , exc , value , tb ) :	define method __exit__ with self, exc, value and tb as the arguments.
self . file . __exit__ ( exc , value , tb )	call the file.__exit__ method on self with exc, value and tb as the arguments.
NamedTemporaryFile = TemporaryFile	substitute TemporaryFile for NamedTemporaryFile.
else :	if not,
NamedTemporaryFile = tempfile . NamedTemporaryFile	substitute tempfile.NamedTemporaryFile for NamedTemporaryFile.
gettempdir = tempfile . gettempdir	substitute tempfile.gettempdir for gettempdir.
import errno	import module errno.
import os	import module os.
from io import BytesIO	from io import BytesIO into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . files . base import File	from django.core.files.base import File into default name space.
from django . core . files import temp as tempfile	from django.core.files import temp as tempfile into default name space.
from django . utils . encoding import force_str	from django.utils.encoding import force_str into default name space.
__all__ = ( 'UploadedFile' , 'TemporaryUploadedFile' , 'InMemoryUploadedFile' ,  'SimpleUploadedFile' )	__all__ is a tuple containing strings: 'UploadedFile', 'TemporaryUploadedFile', 'InMemoryUploadedFile' and 'SimpleUploadedFile'.
class UploadedFile ( File ) :	derive the UploadedFile class from the File base class.
DEFAULT_CHUNK_SIZE = 64 * 2 ** 10	bring integer 2 to the power of 10, multiply it by integer 64, substitute the result for DEFAULT_CHUNK_SIZE.
def __init__ ( self , file = None , name = None , content_type = None , size = None , charset = None , content_type_extra = None ) :	define the method __init__ with 7 arguments: self, file set to None, name set to None, content_type set to None, size set to None, charset set to None and content_type_extra set to None.
super ( UploadedFile , self ) . __init__ ( file , name )	call the __init__ method with arguments file and name, from the base class of the UploadedFile class.
self . size = size	substitute size for self.size.
self . content_type = content_type	substitute content_type for self.content_type.
self . charset = charset	substitute charset for self.charset.
self . content_type_extra = content_type_extra	substitute content_type_extra for self.content_type_extra.
def __repr__ ( self ) :	define the method __repr__ with argument self.
return force_str ( '<%s: %s (%s)>' % (  self . __class__ . __name__ , self . name , self . content_type ) )	substitute '%s' from string '<%s: %s (%s)>' with self.__class__.__name__, self.name and self.content_type, respectively, use it as an argument for the call to the function force_str, return the result.
def _get_name ( self ) :	define the method _get_name with argument self.
return self . _name	return self._name.
def _set_name ( self , name ) :	define the method _set_name with arguments self and name.
if name is not None :	if name is not None,
name = os . path . basename ( name )	call the function os.path.basename with argument name, substitute the result for name.
if len ( name ) > 255 :	if length of name is greater than integer 255,
name , ext = os . path . splitext ( name )	call the os.path.splitex with argument name, assign the result to name and ext, respectively.
ext = ext [ : 255 ]	substitute the first 255 elements of ext for ext.
name = name [ : 255 - len ( ext ) ] + ext	subtract length of the ext from the integer 255, take first elements of the name list up to the previous result index,
self . _name = name	append ext to the end of it, substitute the resulting list for name.   substitute name for self._name.
name = property ( _get_name , _set_name )	name is a property object with _get_name as a getter method and _set_name as a setter method.
class TemporaryUploadedFile ( UploadedFile ) :	derive the TemporaryUploadedFile class from the UploadedFile base class.
def __init__ ( self , name , content_type , size , charset , content_type_extra = None ) :	define the __init__ method with 6 arguments: self, name, content_type, size, charset and content_type_extra set to None.
if settings . FILE_UPLOAD_TEMP_DIR :	  if settings.FILE_UPLOAD_TEMP_DIR is true,
file = tempfile . NamedTemporaryFile ( suffix = '.upload' ,  dir = settings . FILE_UPLOAD_TEMP_DIR )	call the method tempfile.NamedTemporaryFile with arguments: suffix set to string '.upload' and dir set to settings.FILE_UPLOAD_TEMP_DIR.
else :	if not,
file = tempfile . NamedTemporaryFile ( suffix = '.upload' )	call the method tempfile.NamedTemporaryFile with argument suffix set to string '.upload'.
super ( TemporaryUploadedFile , self ) . __init__ ( file , name , content_type , size , charset , content_type_extra )	call the method __init__ from the base class of the TemporaryUploadedFile class with arguments: file, name, content_type, size, charset and content_type_extra.
def temporary_file_path ( self ) :	define the method temporary_file_path with argument self.
return self . file . name	return self.file.name.
def close ( self ) :	define the method close with argument self.
try :	try,
return self . file . close ( )	call the self.file.close method, return the result.
except OSError as e :	if OSError, renamed to e, exception is caught,
if e . errno != errno . ENOENT :	if e.errno is not equal to errno.ENOENT,
raise	raise an exception.
class InMemoryUploadedFile ( UploadedFile ) :	derive the InMemoryUploadedFile class from the UploadedFile base class.
def __init__ ( self , file , field_name , name , content_type , size , charset , content_type_extra = None ) :	define the method __init__ with 8 arguments: self, file, field_name, name, content_type, size, charset and content_type_extra set to None.
super ( InMemoryUploadedFile , self ) . __init__ ( file , name , content_type , size , charset , content_type_extra )	call the method __init__ from the base class of the InMemoryUploadedFile base class, with 6 arguments: file, name, content_type,
self . field_name = field_name	size, charset, content_type_extra.   substitute field_name for self.field_name.
def open ( self , mode = None ) :	define the method open with arguments self and mode set to None.
self . file . seek ( 0 )	set the file pointer at the beginning of the self.file file.
def chunks ( self , chunk_size = None ) :	define the method chunks with arguments self ad chunk_size set to None.
self . file . seek ( 0 )	set the file pointer at the beginning of the self.file file.
yield self . read ( )	read the whole self file and yield it as a generator return value.
def multiple_chunks ( self , chunk_size = None ) :	define the method multiple_chunks with arguments self and hunk_size set to None.
return False	return boolean False.
class SimpleUploadedFile ( InMemoryUploadedFile ) :	derive the SimpleUploadedFile class from the InMemoryUploadedFile base class.
def __init__ ( self , name , content , content_type = 'text/plain' ) :	define the method __init__ with 4 arguments: self, name, content and content_type defaulting to a string 'text/plain'.
content = content or b''	if content is empty, substitute it for an empty string.
super ( SimpleUploadedFile , self ) . __init__ ( BytesIO ( content ) , None , name ,  content_type , len ( content ) , None , None )	call the __init__ method from the base class of the SimpleUploadedFile class with 7 arguments: BytesIO(content), None, name,
@ classmethod	content_type, length of content, None and None.   decorator classmethod.
def from_dict ( cls , file_dict ) :	define the method from_dict with argument cls and file_dict.
return cls ( file_dict [ 'filename' ] ,  file_dict [ 'content' ] ,  file_dict . get ( 'content-type' , 'text/plain' ) )	call the method cls with 3 arguments: value under the 'filename' key of file_dict, value under the 'content' key of file_dict,
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from io import BytesIO	from io import BytesIO into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . files . uploadedfile import TemporaryUploadedFile , InMemoryUploadedFile	from django.core.files.uploadedfile import TemporaryUploadedFile and InMemoryUploadedFile into default name space.
from django . utils . encoding import python_2_unicode_compatible	from django.utils.encoding import python_2_unicode_compatible into default name space.
from django . utils . module_loading import import_string	from django.utils.module_loading import import_string into default name space.
__all__ = [  'UploadFileException' , 'StopUpload' , 'SkipFile' , 'FileUploadHandler' ,  'TemporaryFileUploadHandler' , 'MemoryFileUploadHandler' , 'load_handler' ,  'StopFutureHandlers'  ]	__all__ is a string containing strings: 'UploadFileException', 'StopUpload', 'SkipFile', 'FileUploadHandler',
class UploadFileException ( Exception ) :	'TemporaryFileUploadHandler', 'MemoryFileUploadHandler', 'load_handler' and 'StopFutureHandlers'.   derive the class UploadFileException from the Exception base class.
pass	do nothing.
@ python_2_unicode_compatible	decorator python_2_unicode_compatible,
class StopUpload ( UploadFileException ) :	derive the class StopUpload from the UploadFileException base class.
def __init__ ( self , connection_reset = False ) :	define the method __init__ with arguments self and connection_reset defaulting to boolean False.
self . connection_reset = connection_reset	substitute connection_reset for self.connection_reset.
def __str__ ( self ) :	define the method __str__ with argument self.
if self . connection_reset :	if self.connection_reset is true,
return 'StopUpload: Halt current upload.'	return string 'StopUpload: Halt current upload.'.
else :	if not,
return 'StopUpload: Consume request data, then halt.'	return string 'StopUpload: Consume request data, then halt.'.
class SkipFile ( UploadFileException ) :	derive the class SkipFile from the UploadFileException base class.
pass	do nothing.
class StopFutureHandlers ( UploadFileException ) :	derive the class StopFutureHandlers from the UploadFileException base class.
pass	do nothing.
class FileUploadHandler ( object ) :	derive the class FileUploadHandler from the object base class.
chunk_size = 64 * 2 ** 10	bring integer 2 to the power of 10, multiply it by integer 64, substitute the result for chunk_size.
def __init__ ( self , request = None ) :	define the method __init__ with arguments self and request defaulting to None.
self . file_name = None	self.file_name is None.
self . content_type = None	self.content_type is None.
self . content_length = None	self.content_length is None.
self . charset = None	self.charset is None.
self . content_type_extra = None	self.content_type_extra is None.
self . request = request	self.request is None.
def handle_raw_input ( self , input_data , META , content_length , boundary , encoding = None ) :	define the method handle_raw_input with arguments: self, input_data, META, content_length, boundary and encoding set to None.
pass	do nothing.
def new_file ( self , field_name , file_name , content_type , content_length , charset = None , content_type_extra = None ) :	define the method new_file with arguments: self, field_name, file_name, content_type, content_length, charset set to None,
self . field_name = field_name	substitute field_name for self.field_name.
self . file_name = file_name	substitute file_name for self.file_name.
self . content_type = content_type	substitute content_type for self.content_type.
self . content_length = content_length	substitute content_length for self.content_length.
self . charset = charset	substitute charset for self.charset.
self . content_type_extra = content_type_extra	substitute content_type_extra for self.content_type_extra.
def receive_data_chunk ( self , raw_data , start ) :	define the method receive_data_chunk with arguments: self, raw_data and start.
raise NotImplementedError ( 'subclasses of FileUploadHandler must provide a receive_data_chunk() method' )	raise an NotImplementedError with argument string 'subclasses of FileUploadHandler must provide a receive_data_chunk() method'.
def file_complete ( self , file_size ) :	define the method file_complete with arguments: self and file_size.
raise NotImplementedError ( 'subclasses of FileUploadHandler must provide a file_complete() method' )	raise an NotImplementedError with argument string 'subclasses of FileUploadHandler must provide a file_complete() method'.
def upload_complete ( self ) :	define the method upload_complete with argument self.
pass	do nothing.
class TemporaryFileUploadHandler ( FileUploadHandler ) :	derive the class TemporaryFileUploadHandler from the FileUploadHandler base class.
def __init__ ( self , * args , ** kwargs ) :	define the method __init__ with arguments self, argument list args and dictionary of arguments kwargs.
super ( TemporaryFileUploadHandler , self ) . __init__ ( * args , ** kwargs )	call the __init__ method from the base class of the TemporaryFileUploadHandler class with arguments: unpacked list args,
def new_file ( self , file_name , * args , ** kwargs ) :	and unpacked dictionary kwargs.   define the method new_file with arguments: self, file_name, unpacked list args and unpacked dictionary kwargs.
super ( TemporaryFileUploadHandler , self ) . new_file ( file_name , * args , ** kwargs )	call the method new_file from the base class of the TemporaryFileUploadHandler class with arguments: file_name, unpacked list args and unpacked dictionary kwargs.
self . file = TemporaryUploadedFile ( self . file_name , self . content_type , 0 , self . charset , self . content_type_extra )	self.file is a instance of a class TemporaryUploadedFile initialized with arguments: self.file_name, self.content_type, integer 0,
def receive_data_chunk ( self , raw_data , start ) :	self.charset and self.content_type_extra.   define the method receive_data_chunk with arguments: self, raw_data and start.
self . file . write ( raw_data )	call the method self.file.write with argument raw_data.
def file_complete ( self , file_size ) :	define the method file_complete with arguments self and file_size.
self . file . seek ( 0 )	position the file pointer at the start of the self.file file.
self . file . size = file_size	substitute file_size for self.file.size.
return self . file	return self.file.
class MemoryFileUploadHandler ( FileUploadHandler ) :	derive the class MemoryFileUploadHandler from the FileUploadHandler base class.
def handle_raw_input ( self , input_data , META , content_length , boundary , encoding = None ) :	define the method handle_raw_input with arguments: self, input_data, META, content_length, boundary and encoding set to None.
if content_length > settings . FILE_UPLOAD_MAX_MEMORY_SIZE :	if content_length is greater than settings.FILE_UPLOAD_MAX_MEMORY_SIZE,
self . activated = False	self.activated is boolean False.
else :	if not,
self . activated = True	self.activated is boolean True.
def new_file ( self , * args , ** kwargs ) :	define the method new_file with arguments: self, unpacked list args and unpacked dictionary kwargs.
super ( MemoryFileUploadHandler , self ) . new_file ( * args , ** kwargs )	call the new_file method form the base class from the MemoryFileUploadHandler class with arguments: unpacked list args and unpacked list kwargs.
if self . activated :	if self.activated is boolean True,
self . file = BytesIO ( )	call the function BytesIO, substitute the result for self.file.
raise StopFutureHandlers ( )	raise an exception StopFutureHandlers.
def receive_data_chunk ( self , raw_data , start ) :	define the function receive_data_chunk with arguments self, raw_data and start.
if self . activated :	if self.activated is boolean True,
self . file . write ( raw_data )	write raw_data to self.file file.
else :	if not,
return raw_data	return raw_data.
def file_complete ( self , file_size ) :	define the function file_complete with arguments self and file_size.
if not self . activated :	if self.activated is boolean False,
return	return nothing.
self . file . seek ( 0 )	set file pointer at the beginning of the self.file file.
return InMemoryUploadedFile (  file = self . file ,  field_name = self . field_name ,  name = self . file_name ,  content_type = self . content_type ,  size = file_size ,  charset = self . charset ,  content_type_extra = self . content_type_extra  )	initialize the object of a InMemoryUploadedFile class with arguments: file set to self.file, field_name set to self.field_name,
def load_handler ( path , * args , ** kwargs ) :	name set to self.file_name, content_type set to self.content_type, size set to file_size, charset set to self.charset,   and content_type_extra set to self.content_type_extra, return it.   define the function load_handler with arguments: path, unpacked list args and unpacked dictionary kwargs.
return import_string ( path ) ( * args , ** kwargs )	call the import_string with arguments path, call the return function with arguments: unpacked list args and unpacked dictionary kwargs, return the result.
class FileProxyMixin ( object ) :	derive class FileProxyMixin from the base class object, making it a new-style class.
encoding = property ( lambda self : self . file . encoding )	define lambda function that returns self.file.encoding field, use it as an argument for property function, put the result in encoding.
fileno = property ( lambda self : self . file . fileno )	define lambda function that returns self.file.fileno field, use it as an argument for property function, put the result in fileno.
flush = property ( lambda self : self . file . flush )	define lambda function that returns self.file.flush field, use it as an argument for property function, put the result in flush.
isatty = property ( lambda self : self . file . isatty )	define lambda function that returns self.file.isatty field, use it as an argument for property function, put the result in isatty.
newlines = property ( lambda self : self . file . newlines )	define lambda function that returns self.file.newlines field, use it as an argument for property function, put the result in newlines.
read = property ( lambda self : self . file . read )	define lambda function that returns self.file.read field, use it as an argument for property function, put the result in read.
readinto = property ( lambda self : self . file . readinto )	define lambda function that returns self.file.readinto field, use it as an argument for property function, put the result in readinto.
readline = property ( lambda self : self . file . readline )	define lambda function that returns self.file.readline field, use it as an argument for property function, put the result in readline.
readlines = property ( lambda self : self . file . readlines )	define lambda function that returns self.file.readlines field, use it as an argument for property function, put the result in readlines.
seek = property ( lambda self : self . file . seek )	define lambda function that returns self.file.seek field, use it as an argument for property function, put the result in seek.
softspace = property ( lambda self : self . file . softspace )	define lambda function that returns self.file.softspace field, use it as an argument for property function, put the result in softspace.
tell = property ( lambda self : self . file . tell )	define lambda function that returns self.file.tell field, use it as an argument for property function, put the result in tell.
truncate = property ( lambda self : self . file . truncate )	define lambda function that returns self.file.truncate field, use it as an argument for property function, put the result in truncate.
write = property ( lambda self : self . file . write )	define lambda function that returns self.file.write field, use it as an argument for property function, put the result in write.
writelines = property ( lambda self : self . file . writelines )	define lambda function that returns self.file.writelines field, use it as an argument for property function, put the result in writelines.
xreadlines = property ( lambda self : self . file . xreadlines )	define lambda function that returns self.file.xreadlines field, use it as an argument for property function, put the result in xreadlines.
def __iter__ ( self ) :	define iterator method __iter__ with self as the argument.
return iter ( self . file )	return iterator object based on the self.file collection object.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import logging	import module logging.
import sys	import module sys.
import types	import module types.
from django import http	from django import http into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . core import urlresolvers	from django.core import urlresolvers into default name space.
from django . core import signals	from django.core import signals into default name space.
from django . core . exceptions import MiddlewareNotUsed , PermissionDenied , SuspiciousOperation	from django.core.exceptions import MiddlewareNotUsed, PermissionDenied and SuspiciousOperation into default name space.
from django . db import connections , transaction	from django.db import connections and transaction into default name space.
from django . utils . encoding import force_text	from django.utils.encoding import force_text into default name space.
from django . utils . module_loading import import_string	from django.utils.module_loading import import_string into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . views import debug	from django.views import debug into default name space.
logger = logging . getLogger ( 'django.request' )	call the function logging.getLogger with string 'django.request' as the argument, assign the return object handle to logger.
class BaseHandler ( object ) :	derive class BaseHandler, derive from the base class object, making this a new style class.
response_fixes = [  http . fix_location_header ,  http . conditional_content_removal ,  ]	response_fixes is a list with  http.fix_location_header and http.conditional_content_removal as elements.
def __init__ ( self ) :	define initialization method __init__, with self class instance as the argument.
self . _request_middleware = self . _view_middleware = self . _template_response_middleware = self . _response_middleware = self . _exception_middleware = None	set class fields _request_middleware, _view_middleware, _template_response_middleware, _response_middleware and _exception_middleware to None.
def load_middleware ( self ) :	define method load_middleware with class instance self as the argument.
self . _view_middleware = [ ]	self._view_middleware is an empty list.
self . _template_response_middleware = [ ]	  self._template_response_middleware is an empty list.
self . _response_middleware = [ ]	_response_middleware is an empty list.
self . _exception_middleware = [ ]	exception_middleware is an empty list.
request_middleware = [ ]	request_middleware is an empty list.
for middleware_path in settings . MIDDLEWARE_CLASSES :	for every middleware_path in settings.MIDDLEWARE_CLASSES:
mw_class = import_string ( middleware_path )	evaluate the function import_string with middleware_path as argument, substitute the result for my_class.
try :	try,
mw_instance = mw_class ( )	call the mw_class function, store the result in the mw_instance.
except MiddlewareNotUsed :	if MiddlewareNotUsed exception is raised,
continue	skip this iteration of he smallest enclosing loop.
if hasattr ( mw_instance , 'process_request' ) :	if mw_instance has an attribute named 'process_request'.
request_middleware . append ( mw_instance . process_request )	append mw_instance.process_request at the end of request_middleware.
if hasattr ( mw_instance , 'process_view' ) :	if mw_instance has an attribute named 'process_view'.
self . _view_middleware . append ( mw_instance . process_view )	append mw_instance.process_view at the end of self._view_middleware.
if hasattr ( mw_instance , 'process_template_response' ) :	if mw_instance has an attribute named 'process_template_response'.
self . _template_response_middleware . insert ( 0 , mw_instance . process_template_response )	insert mw_instance.process_template_response at the beginning of self._template_response_middleware.
if hasattr ( mw_instance , 'process_response' ) :	if mw_instance has an attribute named 'process_response'.
self . _response_middleware . insert ( 0 , mw_instance . process_response )	insert mw_instance.process_response at the beginning of self._response_middleware.
if hasattr ( mw_instance , 'process_exception' ) :	if mw_instance has an attribute named 'process_exception'.
self . _exception_middleware . insert ( 0 , mw_instance . process_exception )	insert mw_instance.process_exception at the beginning of self._exception_middleware.
self . _request_middleware = request_middleware	substitute self._request_middleware for request_middleware.
def make_view_atomic ( self , view ) :	define the method make_view_atomic, with self class instance and view as the arguments.
non_atomic_requests = getattr ( view , '_non_atomic_requests' , set ( ) )	get attribute '_non_atomic_requests' from the view object, if the attribute doesnt exist return the empty set, substitute the result for non_atomic_requests.
for db in connections . all ( ) :	call the method connections.all(), perform the following for every db in the result,
if ( db . settings_dict [ 'ATOMIC_REQUESTS' ]  and db . alias not in non_atomic_requests ) :	if value under the key 'ATOMIC_REQUESTS of db.settings_dic dictionary is True and db.alias is not present in the non_atomic_requests,
view = transaction . atomic ( using = db . alias ) ( view )	call the function transaction.atomic, with using set to db.alias as the argument, return value is a function which is called,
return view	with the argument view, store the result in the view.   return view
def get_exception_response ( self , request , resolver , status_code ) :	define method get_exception_response, with self class instance, request, resolver and status_code as the arguments.
try :	try,
callback , param_dict = resolver . resolve_error_handler ( status_code )	call the function resolver.resolve_error_handler with status_code as an argument, assign the result to the callback and param_dict, respectively.
response = callback ( request , ** param_dict )	call the callback function with request and dictionary argument param_dict as the arguments, substitute it for response.
except :	if an exception occurred,
signals . got_request_exception . send ( sender = self . __class__ , request = request )	call the method signals.got_request_exception.send with the sender set to the type of this class, and request set to request as the arguments.
response = self . handle_uncaught_exception ( request , resolver , sys . exc_info ( ) )	call the method self.handle_uncaught_exception with request, resolver and return value of the function sys.exec_info as the arguments.
return response	return response
def get_response ( self , request ) :	define the method get_response, with self class instance and request as the arguments.
urlconf = settings . ROOT_URLCONF	substitute settings.ROOT_URLCONF for urlconf.
urlresolvers . set_urlconf ( urlconf )	call the method urlresolvers.set_urlconf with urlconf as the argument.
resolver = urlresolvers . RegexURLResolver ( r'^/' , urlconf )	call the method urlresolvers.RegexURLResolver with raw literal string '^/' and urlconf as the arguments, substitute the result for resolver.
try :	try,
response = None	set response to None.
for middleware_method in self . _request_middleware :	for every middleware_method in self._request_middleware,
response = middleware_method ( request )	call the middleware_method with the request as an argument, substitute the result for response.
if response :	if response is True,
break	breaks from the smallest enclosing loop execution.
if response is None :	if response is None,
if hasattr ( request , 'urlconf' ) :	if request has an attribute named 'urlconf',
  urlconf = request . urlconf	substitute request.urlconf for urlconf.
urlresolvers . set_urlconf ( urlconf )	call the function urlresolvers.set_urlconf with urlconf as the argument.
resolver = urlresolvers . RegexURLResolver ( r'^/' , urlconf )	call the method urlresolvers.RegexURLResolver with raw literal string '^/' and urlconf as the arguments, substitute the result for resolver.
resolver_match = resolver . resolve ( request . path_info )	call to the resolver.resolve method with request.path_info as an argument.
callback , callback_args , callback_kwargs = resolver_match	assign the values to the callback, callback_args, callback_kwargs, respectively, from the resolver_match tuple.
request . resolver_match = resolver_match	substitute resolver_match for request.resolver_match.
for middleware_method in self . _view_middleware :	for every middleware_method in self._view_middleware,
response = middleware_method ( request , callback , callback_args , callback_kwargs )	call the middleware_method with request, callback, callback_args and callback_kwargs as the arguments, substitute the result for response.
if response :	if response is True,
    break	break from the smallest enclosing loop execution.
if response is None :	if response is None,
wrapped_callback = self . make_view_atomic ( callback )	call the method self.make_view_atomic with callback as the argument, substitute the result for the wrapped_callback.
try :	try,
response = wrapped_callback ( request , * callback_args , ** callback_kwargs )	call the function wrapped_callback with request, list or arguments callback_args and dictionary arguments callback_kwargs,
except Exception as e :	as the arguments, substitute the result for response.   if Exception, renamed to e, exception is caught,
    for middleware_method in self . _exception_middleware :	for every middleware_method in self._exception_middleware,
    response = middleware_method ( request , e )	call the middleware_method with request and e as the arguments, substitute the result for response.
if response :	if response is True,
        break	break from the smallest enclosing loop execution.
if response is None :	if response is None,
    raise	raise the exception.
if response is None :	if response is None,
if isinstance ( callback , types . FunctionType ) :	if callback is of instance types.FunctionType,
view_name = callback . __name__	get the name of the callback, substitute it for view_name.
else :	if not,
view_name = callback . __class__ . __name__ + '.__call__'	get the name of the type of the callback, append the string '.__call__' to it, substitute it for view_name.
raise ValueError ( 'The view %s.%s didn't return an HttpResponse object. It returned None instead.'  % ( callback . __module__ , view_name ) )	substitute the '%s' in the string 'The view %s.%s didn't return an HttpResponse object. It returned None instead.',
if hasattr ( response , 'render' ) and callable ( response . render ) :	with the name of the module callback is in and the view_name, respectively, use it as the argument for the ValueError exception raise.   if response has an attribute named 'render' and response.render is a callable function,
for middleware_method in self . _template_response_middleware :	for every middleware_method in self._template_response_middleware,
response = middleware_method ( request , response )	call the function middleware_method with the request and response as the arguments, assign the result to response.
if response is None :	if response is None,
    raise ValueError (  '%s.process_template_response didn't return an '  'HttpResponse object. It returned None instead.'  % ( middleware_method . __self__ . __class__ . __name__ ) )	replace '%s' in the string  '%s.process_template_response didn't return an HttpResponse object. It returned None instead.',
response = response . render ( )	with name of the class type of the middleware_method instance, use it as the argument for call to the ValueError exception raise.   call the response.render() method and assign the return to the response.
except http . Http404 as e :	if exception http.Http404 as e is caught,
logger . warning ( 'Not Found: %s' , request . path ,  extra = {  'status_code' : 404 ,  'request' : request  } )	substitute '%s' in 'Not Found: %s' with request.path, extra is an dictionary with two pairs of elements 'status_code' with value 404,
if settings . DEBUG :	and 'request with value request, respectively use the previous as the arguments for the call to the logger.warning function.   if settings.DEBUG is True,
response = debug . technical_404_response ( request , e )	call the function debug.technical_404_response with request and e as arguments, assign the result to response.
else :	if not,
response = self . get_exception_response ( request , resolver , 404 )	call the method self.get_exception_response with request, resolver and integer 404 as the arguments, assign the result to response.
except PermissionDenied :	if exception PermissionDenied is caught,
logger . warning (  'Forbidden (Permission denied): %s' , request . path ,  extra = {  'status_code' : 403 ,  'request' : request  } )	substitute '%s' in 'Forbidden (Permission denied): %s' with request.path, extra is an dictionary with two pairs of elements,
response = self . get_exception_response ( request , resolver , 403 )	'status_code' with value 403, and 'request with value request,   respectively use the previous as the arguments for the call to the logger.warning function.   call the method self.get_exception_response with request, resolver and integer 403 as the arguments, assign the result to response.
except SuspiciousOperation as e :	if exception SuspiciousOperation as e is caught,
security_logger = logging . getLogger ( 'django.security.%s' %  e . __class__ . __name__ )	substitute '%s' in 'django.security.%s' with the name of the type of the class object e, use it as the argument for the call to the,
security_logger . error (  force_text ( e ) ,  extra = {  'status_code' : 400 ,  'request' : request  } )	function logging.getLogger, assign the result to the security_logger.   evaluate the function force_text with e as an argument, extra is an dictionary with two pair of elements,
if settings . DEBUG :	'status code' with integer value of 400 and 'request' with value request, respectively use the previous to call the function security_logger.error.   if settings.DEBUG is True,
return debug . technical_500_response ( request , * sys . exc_info ( ) , status_code = 400 )	evaluate the function debug.technical_500_response with request, evaluated value of function sys.exc_info as a list,
response = self . get_exception_response ( request , resolver , 400 )	status code set to integer 400, return the result.   call the method self.get_exception_response with the request, resolver and integer 400 as the arguments, substitute the result for response.
except SystemExit :	if SystemExit exception is caught,
raise	raise an exception.
except :	otherwise if any other exception is caught,
signals . got_request_exception . send ( sender = self . __class__ , request = request )	call the method signals.got_request_exception.send with sender set to type of the self class instance and request set to request.
response = self . handle_uncaught_exception ( request , resolver , sys . exc_info ( ) )	call to the self.handle_uncaught_exception method with request, resolver and value of the evaluated function sys.exec_info,
try :	as the arguments, substitute the result for response.   try,
for middleware_method in self . _response_middleware :	for every middleware_method in self._response_middleware,
response = middleware_method ( request , response )	call the function middleware_method with request and response as the arguments, substitute the result for response.
if response is None :	if response is None,
raise ValueError (  '%s.process_response didn't return an '  'HttpResponse object. It returned None instead.'  % ( middleware_method . __self__ . __class__ . __name__ ) )	substitute '%s' is '%s.process_response didn't return an HttpResponse object. It returned None instead.',
response = self . apply_response_fixes ( request , response )	with the name of the type of the self class instance of the middleware_method, raise the ValueError with the previous as the argument.   call the method self.apply_response_fixes with the request and response as the arguments, substitute the result for response.
except :	if any exception is caught,
signals . got_request_exception . send ( sender = self . __class__ , request = request )	call the signals.got_request_exception.send method with sender set to type of the self class instance and request set to request.
response = self . handle_uncaught_exception ( request , resolver , sys . exc_info ( ) )	call to the self.handle_uncaught_exception method with request, resolver and value of the evaluated function sys.exec_info,
response . _closable_objects . append ( request )	as the arguments, substitute the result for response.   append the request to the end of the protected class member response._closable_objects.
return response	return response.
def handle_uncaught_exception ( self , request , resolver , exc_info ) :	define the method handle_uncaught_exception with self class instance, request, resolver and exec_info as arguments.
if settings . DEBUG_PROPAGATE_EXCEPTIONS :	if settings.DEBUG_PROPAGATE_EXCEPTIONS is True,
raise	raise an exception.
logger . error ( 'Internal Server Error: %s' , request . path ,  exc_info = exc_info ,  extra = {  'status_code' : 500 ,  'request' : request  }  )	substitute '%s' in 'Internal Server Error: %s' with request.path, exc_info set to exc_info,
if settings . DEBUG :	extra is an dictionary with two pairs of elements 'status_code' with value 500, and 'request with value request,   respectively use the previous as the arguments for the call to the logger.error function.   if settings.DEBUG is True,
return debug . technical_500_response ( request , * exc_info )	evaluate debug.technical_500_response with request and list of arguments exec_info, return the result.
if resolver . urlconf_module is None :	if resolver.urlconf_module is None:
six . reraise ( * exc_info )	call the function reraise from the module six, with list of arguments exec_info.
callback , param_dict = resolver . resolve_error_handler ( 500 )	call the resolver.resolve_error_handler with integer 500 as the argument, assign the resulting tuple elements to the callback,
return callback ( request , ** param_dict )	and param_dict, respectively.   evaluate the function callback with request and dictionary of parameters param_dict as the arguments, return the result.
def apply_response_fixes ( self , request , response ) :	define the method apply_response_fixes with self class instance, request and response as the arguments.
for func in self . response_fixes :	for every func in self.response_fixes,
response = func ( request , response )	call the function func with request and response as arguments, assign the result to response.
return response	return response.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import cgi	import module cgi.
import codecs	import module codecs.
import logging	import module logging.
import sys	import module sys.
from io import BytesIO	from io import BytesIO into default name space.
from threading import Lock	from threading import Lock into default name space.
import warnings	import module warnings.
from django import http	from django import http into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . core import signals	from django.core import signals into default name space.
from django . core . handlers import base	from django.core.handlers import base into default name space.
from django . core . urlresolvers import set_script_prefix	from django.core.urlresolvers import set_script_prefix into default name space.
from django . utils import datastructures	from django.utils import datastructures into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
from django . utils . encoding import force_str , force_text	from django.utils.encoding import force_str and force_text into default name space.
from django . utils . functional import cached_property	from django.utils.functional import cached_property into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . http . response import REASON_PHRASES as STATUS_CODE_TEXT	from django.http.response import REASON_PHRASES as STATUS_CODE_TEXT  # NOQA into default name space.
logger = logging . getLogger ( 'django.request' )	call logging.getLogger method with string 'django.request' as argument, store the result in logger.
ISO_8859_1 , UTF_8 = str ( 'iso-8859-1' ) , str ( 'utf-8' )	ISO_8859_1 is a string 'iso-8859-1', UTF_8 is a string 'utf-8'.
class LimitedStream ( object ) :	derive class LimitedStream from the object base class, making it a new-style class.
def __init__ ( self , stream , limit , buf_size = 64 * 1024 * 1024 ) :	def initialization method __init__ with self class instance, stream, limit and buf_size set to integer value of the product 64*1024*1024.
self . stream = stream	substitute stream for self.stream.
self . remaining = limit	substitute limit for self.remaining.
self . buffer = b''	substitute empty bytes string for self.buffer.
self . buf_size = buf_size	substitute buf_size for self.buf_size.
def _read_limited ( self , size = None ) :	define the method _read_limited with self class instance and size set to None as arguments.
if size is None or size > self . remaining :	if size is None or size is greater than self.remaining,
size = self . remaining	substitute self.remaining for size.
if size == 0 :	if size equals to integer zero.
return b''	return empty bytes string.
result = self . stream . read ( size )	read size number of bytes from self.stream stream, store the result in the result.
self . remaining -= len ( result )	decrement self.remaining by length of result.
return result	return result.
def read ( self , size = None ) :	define the method read with self class instance and size set to None as arguments.
if size is None :	if size is None,
result = self . buffer + self . _read_limited ( )	add self.buffer and self._read_limited method return value together, store it in result.
self . buffer = b''	substitute empty bytes string for self.buffer.
elif size < len ( self . buffer ) :	otherwise if size is less than length of self.buffer,
result = self . buffer [ : size ]	substitute first size elements of self.buffer for result.
self . buffer = self . buffer [ size : ]	truncate first size number of elements of self.buffer.
else :	if not,
result = self . buffer + self . _read_limited ( size - len ( self . buffer ) )	call the method self.read_limited with length of self.buffer subtracted from size as argument, add result to self.buffer, store it in result.
self . buffer = b''	substitute empty bytes string for self.buffer.
return result	return result.
def readline ( self , size = None ) :	define method readline with self class instance and size set to None.
\while b'\\n' not in self . buffer and ( size is None or len ( self . buffer ) < size ) :\	while newline character is not contained in self.buffer and, size is None or length of self.buffer is less than size,
if size :	if size is not zero,
chunk = self . _read_limited ( size - len ( self . buffer ) )	call the self._read_limiter with length of self.buffer subtracted from size as argument, store the result into chunk.
else :	if not,
chunk = self . _read_limited ( )	call the method self._read_limited, store the return value into chunk.
if not chunk :	if chunk is empty,
break	break the execution of the smallest enclosing loop.
self . buffer += chunk	increment self.buffer by chunk.
sio = BytesIO ( self . buffer )	call the function BytesIO with self.buffer as argument, store the result is sio.
if size :	if size is not empty,
line = sio . readline ( size )	call the sio.readline method with size as an argument, substitute the result for line.
else :	if not,
line = sio . readline ( )	call the sio.readline method, substitute the result for line.
self . buffer = sio . read ( )	call the sio.read method, substitute the result for self.buffer.
return line	return line.
class WSGIRequest ( http . HttpRequest ) :	derive the class WSGIRequest from base class http.HttpRequest.
def __init__ ( self , environ ) :	define the initialization method __init__ with self class instance and environ as arguments.
script_name = get_script_name ( environ )	call the get_script_name function with environ as argument, substitute the result for script_name.
path_info = get_path_info ( environ )	call the get_path_info function with environ as argument, substitute the result for path_info.
if not path_info :	if path_info is empty,
path_info = '/'	path_info is a character '/'.
self . environ = environ	substitute environ for self.environ.
self . path_info = path_info	substitute path_info for self.path_info.
self . path = '%s/%s' % ( script_name . rstrip ( '/' ) ,  path_info . replace ( '/' , '' , 1 ) )	strip trailing '/' from the script_name string, remove first occurrence of '/' in path_info string, append second result to the first, separated with '/', assign the result to self.path.
self . META = environ	substitute environ for self.META.
self . META [ 'PATH_INFO' ] = path_info	assign path_info to the value under the 'PATH_INFO' key of the self.META dictionary.
self . META [ 'SCRIPT_NAME' ] = script_name	assign script_name to the value under the 'SCRIP_NAME' key of the self.META dictionary.
self . method = environ [ 'REQUEST_METHOD' ] . upper ( )	convert value under the 'REQUEST_METHOD' key of the environ dictionary to uppercase, substitute it for self.method.
_ , content_params = cgi . parse_header ( environ . get ( 'CONTENT_TYPE' , '' ) )	get the value under the 'CONTENT_TYPE' key of environ dictionary, if the key doesnt exist get the empty string,
if 'charset' in content_params :	use it to call the cgi.parse_header method, assign the result to the _ and content_params respectively.   if string 'charset' is contained in content_params,
try :	try,
codecs . lookup ( content_params [ 'charset' ] )	get the value under the 'charset' key of content_params dictionary, use it to call the codec.lookup method.
except LookupError :	if exception LookupError is caught,
pass	do nothing.
else :	if not,
self . encoding = content_params [ 'charset' ]	get the value under the 'charset' key of content_params dictionary, substitute it for self.encoding.
self . _post_parse_error = False	self._post_parse_error is boolean False.
try :	try,
content_length = int ( environ . get ( 'CONTENT_LENGTH' ) )	convert value under the 'CONTENT_LENGTH' key of the environ dictionary to an integer, substitute it for content_length.
except ( ValueError , TypeError ) :	if exception ValueError or TypeError is caught,
content_length = 0	content_length is integer 0.
self . _stream = LimitedStream ( self . environ [ 'wsgi.input' ] , content_length )	self._stream is a class instance of a LimitedStream class, initialized with self.environ dictionary value under the 'wsgi.input' key,
self . _read_started = False	and content_length.   self._read_started is boolean False.
self . resolver_match = None	self.resolver_match is None.
def _get_scheme ( self ) :	define the method _get_scheme with self class instance as argument.
return self . environ . get ( 'wsgi.url_scheme' )	return value under the 'wsgi.url_scheme' key of self.environ dictionary.
def _get_request ( self ) :	define the method _get_request with self class instance as argument.
warnings . warn ( '`request.REQUEST` is deprecated, use `request.GET` or '  '`request.POST` instead.' , RemovedInDjango19Warning , 2 )	call the warnings.warn method with string '`request.REQUEST` is deprecated, use `request.GET` or `request.POST` instead.',
if not hasattr ( self , '_request' ) :	RemovedInDjango19Warning and integer 2 as arguments.   if self does not have an '_request' attribute,
self . _request = datastructures . MergeDict ( self . POST , self . GET )	call the datastructures.MergeDict with self.POST and self.GET as arguments, assign the result to self._request.
return self . _request	return self._request.
@ cached_property	decorator cached_property.
def GET ( self ) :	define method GET with self class instance as an argument.
raw_query_string = get_bytes_from_wsgi ( self . environ , 'QUERY_STRING' , '' )	call the get_bytes_from_wsgi function with self.environ, string 'QUERY_STRING' and empty string as arguments, substitute the return value for raw_query_string.
return http . QueryDict ( raw_query_string , encoding = self . _encoding )	evaluate the http.QueryDict method with raw_query_string and encoding set to self._encoding as arguments, return the result.
def _get_post ( self ) :	def _get_post method with self class instance as the argument.
if not hasattr ( self , '_post' ) :	if self does not has an '_post' attribute.
self . _load_post_and_files ( )	call the self._load_post_and_files method.
return self . _post	return self._post.
def _set_post ( self , post ) :	define the _set_post method with self class instance and post as the arguments.
self . _post = post	substitute post for self._post.
@ cached_property	decorator cached_property.
def COOKIES ( self ) :	define COOKIES method with self as the argument.
raw_cookie = get_str_from_wsgi ( self . environ , 'HTTP_COOKIE' , '' )	call get_str_from_wsgi function with self.environ, string 'HTTP_COOKIE' and empty string as arguments, substitute it for raw_cookie.
return http . parse_cookie ( raw_cookie )	evaluate the function http.parse_cookie with raw_cookie as an argument, return the result.
def _get_files ( self ) :	define _get_files method with self class instance as the argument.
if not hasattr ( self , '_files' ) :	if self does not have '_files' attribute,
self . _load_post_and_files ( )	call the method self._load_post_and_files.
return self . _files	return self._files.
POST = property ( _get_post , _set_post )	_get_post is a getter function and _set_post is a setter function for POST attribute of this class.
FILES = property ( _get_files )	_get_files is getter function for FILES attribute of this class.
REQUEST = property ( _get_request )	_get_request is getter function for REQUEST attribute of this class.
class WSGIHandler ( base . BaseHandler ) :	derive the WSGIHandler class from the base class base.BaseHandler.
initLock = Lock ( )	evaluate function Lock() assign the result to initLock.
request_class = WSGIRequest	substitute WSGIRequest for request_class.
def __call__ ( self , environ , start_response ) :	define private method __call__ with self class instance, environ and start_response as the arguments.
if self . _request_middleware is None :	if self._request_middleware is None,
with self . initLock :	with self.initLock,
try :	try,
  if self . _request_middleware is None :	if self._request_middleware is None,
    self . load_middleware ( )	call the self.load_middleware method.
except :	if exception is caught,
  self . _request_middleware = None	self._request_middleware is None.
raise	re raise an exception.
set_script_prefix ( get_script_name ( environ ) )	call the get_script_name function with environ as argument, use the result as an argument for call to the set_script_prefix function.
signals . request_started . send ( sender = self . __class__ )	call the signals.request_started.send method with sender set to self.__class__ as argument.
try :	try,
request = self . request_class ( environ )	call the self.request_class method with environ as an argument, substitute the result for request.
except UnicodeDecodeError :	if UnicodeDecodeError exception is caught,
logger . warning ( 'Bad Request (UnicodeDecodeError)' ,  exc_info = sys . exc_info ( ) ,  extra = {  'status_code' : 400 ,  }  )	call the logger.warning method with string 'Bad Request (UnicodeDecodeError)', exec_info set to sys.exec_info() and dictionary extra
response = http . HttpResponseBadRequest ( )	with one entry 'status_code' is integer 400, as arguments.   call the http.HttpResponseBadRequest function, assign the result to the response.
else :	if not,
response = self . get_response ( request )	call the self.get_response with request as the argument, substitute the result for response.
response . _handler_class = self . __class__	substitute self.__class__ for response._handler_class.
status = '%s %s' % ( response . status_code , response . reason_phrase )	replace '%s' in the string '%s %s' with response.status_code and response.reason_phrase, respectively, substitute it for status.
response_headers = [ ( str ( k ) , str ( v ) ) for k , v in response . items ( ) ]	convert to k and v to strings for every k and v in return value of the response.item method, response_headers is a list containing all the above iteration elements.
for c in response . cookies . values ( ) :	for every c in return value of the method response.cookies.values,
response_headers . append ( ( str ( 'Set-Cookie' ) , str ( c . output ( header = '' ) ) ) )	convert 'Set-Cookie' to a string and convert the return value of method c.output(header='') call to a string,
start_response ( force_str ( status ) , response_headers )	format the previous in a tuple, append the tuple to the response_headers.   call the start_response function with force_str(status) method return value and response_headers as arguments.
return response	return response.
def get_path_info ( environ ) :	define the get_path_info function with environ as the argument.
path_info = get_bytes_from_wsgi ( environ , 'PATH_INFO' , '/' )	call the function get_bytes_from_wsgi with environ, string 'PATH_INFO' and character '/' as arguments, substitute the result for path_info.
return path_info . decode ( UTF_8 )	return path_info.decode method return value called with UTF_8 as the argument.
def get_script_name ( environ ) :	define get_script_name function with environ as an argument.
if settings . FORCE_SCRIPT_NAME is not None :	if settings.FORCE_SCRIPT_NAME is not None,
return force_text ( settings . FORCE_SCRIPT_NAME )	evaluate the force_text function with settings.FORCE_SCRIPT_NAME as argument, return the result.
script_url = get_bytes_from_wsgi ( environ , 'SCRIPT_URL' , '' )	call the get_bytes_from_wsgi function with environ, string 'SCRIPT_URL' and empty strings as arguments, substitute the result for script_url.
if not script_url :	if script_url is false,
script_url = get_bytes_from_wsgi ( environ , 'REDIRECT_URL' , '' )	call the get_bytes_from_wsgi function with environ, string 'REDIRECT_URL' and empty strings as arguments, substitute the result for script_url.
if script_url :	if script_url is true,
path_info = get_bytes_from_wsgi ( environ , 'PATH_INFO' , '' )	call the get_bytes_from_wsgi function with environ, string 'PATH_INFO' and empty strings as arguments, substitute the result for path_info.
script_name = script_url [ : - len ( path_info ) ]	take all but the length of path_info last elements of script_url, substitute it for script_name.
else :	if not,
script_name = get_bytes_from_wsgi ( environ , 'SCRIPT_NAME' , '' )	call the get_bytes_from_wsgi function with environ, string 'SCRIPT_NAME' and empty strings as arguments, substitute the result for script_name.
return script_name . decode ( UTF_8 )	return scrip_name.decode method result called with UTF_8 as argument.
def get_bytes_from_wsgi ( environ , key , default ) :	define the function get_bytes_from_wsgi with environ, key and default as arguments.
value = environ . get ( str ( key ) , str ( default ) )	convert key and default to strings, get the value under the key string key of the environ dictionary, if it does not exists use the,
return value if six . PY2 else value . encode ( ISO_8859_1 )	default string value, substitute it for value.   return value if six.PY2 is true, if not return value.encode(ISO_8859_1).
def get_str_from_wsgi ( environ , key , default ) :	define the get_str_from_wsgi function with environ, key and default as arguments.
value = environ . get ( str ( key ) , str ( default ) )	convert key and default to strings, get the value under the key string key of the environ dictionary, if it does not exists use the,
return value if six . PY2 else value . encode ( ISO_8859_1 ) . decode ( UTF_8 )	default string value, substitute it for value.   return value if six.PY2 is true, if not return value.encode(ISO_8859_1).decode(UTF_8).
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . utils . module_loading import import_string	from django.utils.module_loading import import_string into default name space.
from django . core . mail . utils import CachedDnsName , DNS_NAME	from django.core.mail.utils import CachedDnsName and DNS_NAME into default name space.
from django . core . mail . message import (  EmailMessage , EmailMultiAlternatives ,  SafeMIMEText , SafeMIMEMultipart ,  DEFAULT_ATTACHMENT_MIME_TYPE , make_msgid ,  BadHeaderError , forbid_multi_line_headers )	from django.core.mail.message import EmailMessage, EmailMultiAlternatives, SafeMIMEText, SafeMIMEMultipart,
__all__ = [  'CachedDnsName' , 'DNS_NAME' , 'EmailMessage' , 'EmailMultiAlternatives' ,  'SafeMIMEText' , 'SafeMIMEMultipart' , 'DEFAULT_ATTACHMENT_MIME_TYPE' ,  'make_msgid' , 'BadHeaderError' , 'forbid_multi_line_headers' ,  'get_connection' , 'send_mail' , 'send_mass_mail' , 'mail_admins' ,  'mail_managers' ,  ]	DEFAULT_ATTACHMENT_MIME_TYPE, make_msgid, BadHeaderError and forbid_multi_line_headers into default name space.   __all__ is a list of strings, 'CachedDnsName', 'DNS_NAME', 'EmailMessage', 'EmailMultiAlternatives', 'SafeMIMEText',
def get_connection ( backend = None , fail_silently = False , ** kwds ) :	'SafeMIMEMultipart', 'DEFAULT_ATTACHMENT_MIME_TYPE', 'make_msgid', 'BadHeaderError', 'forbid_multi_line_headers',   'get_connection', 'send_mail', 'send_mass_mail', 'mail_admins' and 'mail_managers'.   define function get_connection with backend set to None, fail_silently set to boolean False and dictionary kwds as arguments.
klass = import_string ( backend or settings . EMAIL_BACKEND )	call the function import_string with backend if exists or settings.EMAIL_BACKEND if not, store the result into klass.
return klass ( fail_silently = fail_silently , ** kwds )	call the klass method with fail_silently set to fail_silently and dictionary arguments kwds as arguments, return the result.
def send_mail ( subject , message , from_email , recipient_list ,  fail_silently = False , auth_user = None , auth_password = None ,  connection = None , html_message = None ) :	define send_mail funtion with subject, message, from_email, recipient_list, fail_silently set to boolean False,
connection = connection or get_connection ( username = auth_user ,  password = auth_password ,  fail_silently = fail_silently )	if connection exists dont modify it, if not call get_connection function with username set to auth_user, password set to auth_password, fail_silently set to fail_silently as arguments, assign it to connection.
mail = EmailMultiAlternatives ( subject , message , from_email , recipient_list ,  connection = connection )	call the EmailMultiAlternatives function with, subject, message, from_email, recipient_list and connection set to connection, as arguments, assign the result to mail.
if html_message :	if html_message is True,
mail . attach_alternative ( html_message , 'text/html' )	call the mail.attach_alternative method with html_message and string 'text/html' as arguments.
return mail . send ( )	return the evaluated result of the mail.send method.
def send_mass_mail ( datatuple , fail_silently = False , auth_user = None ,  auth_password = None , connection = None ) :	define the function send_mass_mail with, datatuple, fail_silently set to False, auth_user set to None, auth_password set to None,
connection = connection or get_connection ( username = auth_user ,  password = auth_password ,  fail_silently = fail_silently )	if connection exists dont change it, if not call the get_connection function with username set to auth_user,
messages = [ EmailMessage ( subject , message , sender , recipient ,  connection = connection )  for subject , message , sender , recipient in datatuple ]	password set to auth_password, fail_silently set to fail_silently as arguments, assign the result to connection.   call the EmailMessage function wit subject, message, sender, recipient and connection set to connection,
return connection . send_messages ( messages )	for every subject, message, sender and recipient in datatuple, store the results in the messages list.   return evaluated result of the method connection.send_messages with messages as argument.
def mail_admins ( subject , message , fail_silently = False , connection = None ,  html_message = None ) :	define the function mail_admins with subject, message, fails_silently set to boolean False, connection set to None,
if not settings . ADMINS :	if settings.ADMINS is false,
return	return nothing.
mail = EmailMultiAlternatives ( '%s%s' % ( settings . EMAIL_SUBJECT_PREFIX , subject ) ,  message , settings . SERVER_EMAIL , [ a [ 1 ] for a in settings . ADMINS ] ,  connection = connection )	call the function EmailMultiAlternatives with settings.EMAIL_SUBJECT_PREFIX and subject converted to strings and concatenated,
if html_message :	message, settings.SERVER_EMAIL, list of second elements of a for every a in settings.Managers and connection set to connection,   as arguments, assign the result to mail.   if html_message is true,
mail . attach_alternative ( html_message , 'text/html' )	call method mail.attach_alternative as html_message and string 'text/hmtl' as arguments.
mail . send ( fail_silently = fail_silently )	call the mail.send method with fail_silently=fail_silently as argument.
def mail_managers ( subject , message , fail_silently = False , connection = None ,  html_message = None ) :	define the function mail_managers with subject, message, fails_silently set to boolean False, connection set to None,
if not settings . MANAGERS :	if settings.MANAGERS does not exist,
return	return nothing.
mail = EmailMultiAlternatives ( '%s%s' % ( settings . EMAIL_SUBJECT_PREFIX , subject ) ,  message , settings . SERVER_EMAIL , [ a [ 1 ] for a in settings . MANAGERS ] ,  connection = connection )	call the function EmailMultiAlternatives with settings.EMAIL_SUBJECT_PREFIX and subject converted to strings and concatenated,
if html_message :	message, settings.SERVER_EMAIL, list of second elements of a for every a in settings.Managers and connection set to connection,   as arguments, assign the result to mail.   if html_message is true,
mail . attach_alternative ( html_message , 'text/html' )	call the mail.attach_alternative method with html_message and string 'text/html' as arguments.
mail . send ( fail_silently = fail_silently )	call the mail.send method with fail_silently set to fail_silently as argument.
class BaseEmailBackend ( object ) :	derive the class BaseEmailBackend from the object base class.
def __init__ ( self , fail_silently = False , ** kwargs ) :	define the method __init__ with arguments: self, fail_silently set to boolean False and unpacked dictionary kwargs.
self . fail_silently = fail_silently	substitute fail_silently for self.fail_silently.
def open ( self ) :	define the method open with argument self.
pass	do nothing.
def close ( self ) :	define the method close with argument self.
pass	do nothing
def __enter__ ( self ) :	define the method __enter__ with argument self.
self . open ( )	call the method self.open.
return self	return self.
def __exit__ ( self , exc_type , exc_value , traceback ) :	define the method __exit__ with arguments: self, exc_type, exc_value and traceback.
self . close ( )	call the method self.close.
def send_messages ( self , email_messages ) :	define the method send_messages with arguments self and email_messages.
raise NotImplementedError ( 'subclasses of BaseEmailBackend must override send_messages() method' )	raise an NotImplementedError exception with argument string 'subclasses of BaseEmailBackend must override send_messages() method'.
import sys	import module sys.
import threading	import module threading.
from django . core . mail . backends . base import BaseEmailBackend	from django.core.mail.backends.base import BaseEmailBackend into default name space.
from django . utils import six	from django.utils import six into default name space.
class EmailBackend ( BaseEmailBackend ) :	derive the class EmailBackend from the BaseEmailBackend base class.
def __init__ ( self , * args , ** kwargs ) :	define the __init__ method with arguments: self, unpacked list args and unpacked dictionary kwargs.
self . stream = kwargs . pop ( 'stream' , sys . stdout )	pop the value under the 'stream' key of the kwargs dictionary, if it exists replace it for self.stream, if not replace sys.stdout for self.stream.
self . _lock = threading . RLock ( )	call the method threading.RLock, substitute the result for self._lock.
super ( EmailBackend , self ) . __init__ ( * args , ** kwargs )	call the __init__ method from the base class of the EmailBackend class, with arguments: unpacked list args and unpacked dictionary kwargs.
def write_message ( self , message ) :	define the method write_message with arguments self and message.
msg = message . message ( )	call the method message.message, substitute the result for msg.
msg_data = msg . as_bytes ( )	call the method msg.as_bytes, substitute the result for msg_data.
if six . PY3 :	if six.PY3 is boolean True,
charset = msg . get_charset ( ) . get_output_charset ( ) if msg . get_charset ( ) else 'utf-8'	if method msg.get_charset evaluates to true, call the get_output_charset method on the return value of the msg.get_charset method, substitute the result for charset, otherwise if it is false, substitute the string 'utf-8' for charset.
msg_data = msg_data . decode ( charset )	call the method msg_data.decode with argument charset, substitute the result for msg_data.
\self . stream . write ( '%s\\n' % msg_data )\	\call the method self.stream.write with argument string '%s\\n', with '%s' replaced with msg_data.\
self . stream . write ( '-' * 79 )	write 79 '-' characters into self.stream file stream.
\self . stream . write ( '\\n' )\	write a newline into a self.stream file stream.
def send_messages ( self , email_messages ) :	define the method send_messages with arguments self and email_messages.
if not email_messages :	if email_messages is false,
return	return.
msg_count = 0	msg_count is an integer 0.
with self . _lock :	call the method self._lock, with the result,
try :	try,
stream_created = self . open ( )	call the method self.open, substitute the result for stream_created.
for message in email_messages :	for every message in email_messages,
self . write_message ( message )	call the method self.write_message with argument message.
self . stream . flush ( )	call the method self.stream.flush.
msg_count += 1	increment msg_count by one.
if stream_created :	if stream_created is true,
self . close ( )	call the method self.close.
except Exception :	if Exception exception is caught,
if not self . fail_silently :	if self.fail_silently is boolean False,
raise	raise an exception.
return msg_count	return msg_count.
from django . core . mail . backends . base import BaseEmailBackend	from django.core.mail.backends.base import BaseEmailBackend into default name space.
class EmailBackend ( BaseEmailBackend ) :	derive the class EmailBackend from the BaseEmailBackend base class.
def send_messages ( self , email_messages ) :	define the method send_messages with arguments self and email_messages.
return len ( list ( email_messages ) )	create list out of email_messages, return the length of the list.
import datetime	import module datetime.
import os	import module os.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . exceptions import ImproperlyConfigured	from django.core.exceptions import ImproperlyConfigured into default name space.
from django . core . mail . backends . console import EmailBackend as ConsoleEmailBackend	from django.core.mail.backends.console import EmailBackend as ConsoleEmailBackend into default name space.
from django . utils import six	from django.utils import six into default name space.
class EmailBackend ( ConsoleEmailBackend ) :	derive the class EmailBackend from the ConsoleEmailBackend base class.
def __init__ ( self , * args , ** kwargs ) :	define the __init__ method with arguments: self, unpacked list args and unpacked dictionary kwargs.
self . _fname = None	self._fname is None.
if 'file_path' in kwargs :	if 'file_path' is contained in kwargs,
self . file_path = kwargs . pop ( 'file_path' )	pop the value under the 'file_path' key of kwargs dictionary, substitute it for self.file_path.
else :	if not,
self . file_path = getattr ( settings , 'EMAIL_FILE_PATH' , None )	get 'EMAIL_FILE_PATH' from the settings, if it exists, substitute it for self.file_path, if not substitute None for self.file_path.
if not isinstance ( self . file_path , six . string_types ) :	if self.file_path is not an instance of six.string_types,
raise ImproperlyConfigured ( 'Path for saving emails is invalid: %r' % self . file_path )	raise an ImproperlyConfigured exception with argument string 'Path for saving emails is invalid: %r', replace '%r' with self.file_path.
self . file_path = os . path . abspath ( self . file_path )	call the os.path.abspath with argument self.file_path, substitute the result for self.file_path.
if os . path . exists ( self . file_path ) and not os . path . isdir ( self . file_path ) :	if self.file_path file path exists and it is not a directory,
raise ImproperlyConfigured ( 'Path for saving email messages exists, but is not a directory: %s' % self . file_path )	raise an ImproperlyConfigured exception with argument string 'Path for saving email messages exists, but is not a directory: %s',  replace '%s' with self.file_path.
elif not os . path . exists ( self . file_path ) :	otherwise if self.file_path file path doesnt exists,
try :	try,
os . makedirs ( self . file_path )	call the os.makedirs with argument self.file_path.
except OSError as err :	if OSError, renamed to err, is caught,
raise ImproperlyConfigured ( 'Could not create directory for saving email messages: %s (%s)' % ( self . file_path , err ) )	raise an ImproperlyConfigured exception with argument string 'Could not create directory for saving email messages: %s (%s)',
if not os . access ( self . file_path , os . W_OK ) :	replace '%s' with self.file_path and err, respectively.   if self.file_path file is not writable,
raise ImproperlyConfigured ( 'Could not write to directory: %s' % self . file_path )	raise an ImproperlyConfigured exception with argument string 'Could not write to directory: %s', replace '%s' with self.file_path.
kwargs [ 'stream' ] = None	set value under the 'stream' key of kwargs dictionary to None.
super ( EmailBackend , self ) . __init__ ( * args , ** kwargs )	call the __init__ method of the base class of the EmailBackend class with arguments: unpacked list args and unpacked dictionary kwargs.
def write_message ( self , message ) :	define the method write_message with arguments self and message.
\self . stream . write ( message . message ( ) . as_bytes ( ) + b'\\n' )\	\call the as_bytes method on the return value of the message.message method append to it '\\n' character, use it as the argument for the call to the self.stream.write method.\
self . stream . write ( b'-' * 79 )	write 79 '-' characters into self.stream file stream.
\self . stream . write ( b'\\n' )\	write a newline character into self.stream file stream.
def _get_filename ( self ) :	define the method _get_filename with argument self.
if self . _fname is None :	if self._fname is None:
timestamp = datetime . datetime . now ( ) . strftime ( '%Y%m%d-%H%M%S' )	call the strftime function with argument string '%Y%m%d-%H%M%S' on the return value of the function datetime.datetime.now, substitute the result for timestamp.
fname = '%s-%s.log' % ( timestamp , abs ( id ( self ) ) )	fname is a string '%s-%s.log', with '%s' replaced by timestamp and absolute value of the return value of the function id with argument self, respectively.
self . _fname = os . path . join ( self . file_path , fname )	join self.file_path and fname into a valid file path, substitute it for self._fname.
return self . _fname	return self._fname.
def open ( self ) :	define the method open with argument self.
if self . stream is None :	if self.stream is None:
self . stream = open ( self . _get_filename ( ) , 'ab' )	open the file in mode 'ab' and with file name obtained by calling the self._get_filename method.
return True	return boolean True.
return False	return boolean True.
def close ( self ) :	define the method close with argument self.
try :	try,
if self . stream is not None :	if self.stream is not None,
self . stream . close ( )	call the self.stream.close function.
finally :	finally perform,
self . stream = None	self.stream is None.
from django . core import mail	from django.core import mail into default name space.
from django . core . mail . backends . base import BaseEmailBackend	from django.core.mail.backends.base import BaseEmailBackend into default name space.
class EmailBackend ( BaseEmailBackend ) :	derive the class EmailBackend from the BaseEmailBackend base class.
def __init__ ( self , * args , ** kwargs ) :	define the method __init__ with arguments: self, unpacked list args and unpacked dictionary kwargs.
super ( EmailBackend , self ) . __init__ ( * args , ** kwargs )	call the method __init__ from the base class of EmailBackend class, with arguments: unpacked list args and unpacked dictionary kwargs.
if not hasattr ( mail , 'outbox' ) :	if mail doesnt have an 'outbox' attribute,
mail . outbox = [ ]	mail.outbox is an empty list.
def send_messages ( self , messages ) :	define the method send_messages with arguments self and messages.
msg_count = 0	msg_count is integer 0.
for message in messages :	for every message in messages,
message . message ( )	call the method message.message.
msg_count += 1	increment mes_count by one.
mail . outbox . extend ( messages )	call the method mail.outbox.extend with messages.
return msg_count	return msg_count.
import smtplib	import module smtplib.
import ssl	import module ssl.
import threading	import module threading.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . mail . backends . base import BaseEmailBackend	from django.core.mail.backends.base import BaseEmailBackend into default name space.
from django . core . mail . utils import DNS_NAME	from django.core.mail.utils import DNS_NAME into default name space.
from django . core . mail . message import sanitize_address	from django.core.mail.message import sanitize_address into default name space.
class EmailBackend ( BaseEmailBackend ) :	derive the class EmailBackend from the BaseEmailBackend base class.
def __init__ ( self , host = None , port = None , username = None , password = None ,  use_tls = None , fail_silently = False , use_ssl = None , timeout = None ,  ** kwargs ) :	define the method __init__ with arguments: self, host set to None, port set to None, username set to None, password set to None,
super ( EmailBackend , self ) . __init__ ( fail_silently = fail_silently )	use_tls set to None, fail_silently set to False, use_ssl set to None, timeout set to None and unpacked dictionary kwargs.   call the __init__ method from the base class of the EmailBackend class with argument fail_silently set to fail_silently.
self . host = host or settings . EMAIL_HOST	if host exists substitute it for self.host, if not substitute settings.EMAIL_HOST for self.host.
self . port = port or settings . EMAIL_PORT	if port exists substitute it for self.host, if not substitute settings.EMAIL_PORT for self.port.
self . username = settings . EMAIL_HOST_USER if username is None else username	if username is None substitute settings.EMAIL_HOST_USER for self.username, if not substitute username for self.username.
self . password = settings . EMAIL_HOST_PASSWORD if password is None else password	if password is None substitute settings.EMAIL_HOST_PASSWORD for self.username, if not substitute password for self.password.
self . use_tls = settings . EMAIL_USE_TLS if use_tls is None else use_tls	if use_tls is None substitute settings.EMAIL_USE_TLS for self.username, if not substitute use_tls for self.use_tls.
self . use_ssl = settings . EMAIL_USE_SSL if use_ssl is None else use_ssl	if use_ssl is None substitute settings.EMAIL_USE_SSL for self.username, if not substitute use_ssl for self.use_ssl.
self . timeout = timeout	substitute timeout for self.timeout.
if self . use_ssl and self . use_tls :	if self.use_ssl and self.use_tls are boolean True,
raise ValueError (  'EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set '  'one of those settings to True.' )	raise an ValueError exception with argument string 'EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set one of those settings to True.'.
self . connection = None	self.connection is None.
self . _lock = threading . RLock ( )	call the method threading.RLock, substitute the result for self._lock.
def open ( self ) :	define the method open with argument self.
if self . connection :	if self.connection is true,
return False	return boolean False,
connection_class = smtplib . SMTP_SSL if self . use_ssl else smtplib . SMTP	substitute smtplib.SMTP_SSL for connection_class if self.use_ssl is true, if not substitute smtplib.SMTP for connection_class.
connection_params = { 'local_hostname' : DNS_NAME . get_fqdn ( ) }	connection_params is a dictionary with 1 initial entry: return value of the function DNS_NAME.get_fqdn for 'local_hostname'.
if self . timeout is not None :	if self.timeout is not None,
connection_params [ 'timeout' ] = self . timeout	set value under the 'timeout' key of the connection_params to self.timeout.
try :	try,
self . connection = connection_class ( self . host , self . port , ** connection_params )	self.connection is a instance of a class contained in connection_class, instantiated with arguments: self.host, self.port,
if not self . use_ssl and self . use_tls :	and unpacked dictionary connection_params.   if self.use_ssl and self.use_tls are false,
self . connection . ehlo ( )	call the method self.connection.ehlo.
self . connection . starttls ( )	call the method self.connection.starttls.
self . connection . ehlo ( )	call the method self.connection.ehlo.
if self . username and self . password :	if self.username and self.password are true,
self . connection . login ( self . username , self . password )	call the method self.connection.login with arguments self.username and self.password.
return True	return boolean True.
except smtplib . SMTPException :	if smtplib.SMTPException exception is caught,
if not self . fail_silently :	if self.fail_silently is boolean False,
raise	raise an exception.
def close ( self ) :	define the method close with argument self.
if self . connection is None :	if self.connection is None,
return	return nothing.
try :	try,
try :	try,
self . connection . quit ( )	call the method self.connection.quit.
except ( ssl . SSLError , smtplib . SMTPServerDisconnected ) :	if ssl.SSLError or smtplib.SMTPServerDisconnected exception occurred,
self . connection . close ( )	call the method self.connection.close.
except smtplib . SMTPException :	if smtplib.SMTPException exception is caught,
if self . fail_silently :	  if self.fail_silently is boolean True,
return	return nothing.
raise	raise an exception.
finally :	finally perform,
self . connection = None	self.connection is None.
def send_messages ( self , email_messages ) :	define the method send_messages with arguments self and email_message.
if not email_messages :	if email_messages is false,
return	return nothing.
with self . _lock :	call the method self._lock, with the return value,
new_conn_created = self . open ( )	call the method self.open, substitute the result for the new_conn_created.
if not self . connection :	if self.connection is false,
return	return nothing.
num_sent = 0	num_sent is an integer 0.
for message in email_messages :	for every message in email_messages:
sent = self . _send ( message )	call the method self._send with argument message, substitute the result for sent.
if sent :	if sent is true,
num_sent += 1	increment num_sent by one.
if new_conn_created :	if new_conn_created is true,
self . close ( )	call the self.close method.
return num_sent	return num_sent.
def _send ( self , email_message ) :	define the method _send with arguments self and email_message.
if not email_message . recipients ( ) :	call the email_message.recipients method, if it evaluates to false,
return False	return boolean False.
from_email = sanitize_address ( email_message . from_email , email_message . encoding )	call the function sanitize_address with arguments email_message.from_email and email_message.encoding, substitute the result for from_email.
recipients = [ sanitize_address ( addr , email_message . encoding )  for addr in email_message . recipients ( ) ]	call the function sanitize_address with arguments addr and email_message.encoding, for every addr in return value of the function email_message.recipients, store the results in a recipients list.
message = email_message . message ( )	call the function email_message.message, substitute the result for message.
try :	try,
self . connection . sendmail ( from_email , recipients , message . as_bytes ( ) )	call the method self.connection.sendmail with arguments: from_email, recipients and return value of the function message.as_bytes.
except smtplib . SMTPException :	if smtplib.SMTPException exception is caught,
if not self . fail_silently :	if self.fail_silently is false,
raise	raise an exception.
return False	return boolean False.
return True	return boolean True.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import mimetypes	import module mimetypes.
import os	import module os.
import random	import module random.
import sys	import module sys.
import time	import module time.
from email import ( charset as Charset , encoders as Encoders ,  message_from_string , generator )	from email import charset as Charset, encoders as Encoders, message_from_string and generator.
from email . message import Message	from email.message import Message into default name space.
from email . mime . text import MIMEText	from email.mime.text import MIMEText into default name space.
from email . mime . multipart import MIMEMultipart	from email.mime.multipart import MIMEMultipart into default name space.
from email . mime . base import MIMEBase	from email.mime.base import MIMEBase into default name space.
from email . mime . message import MIMEMessage	from email.mime.message import MIMEMessage into default name space.
from email . header import Header	from email.header import Header into default name space.
from email . utils import formatdate , getaddresses , formataddr , parseaddr	from email.utils import formatdate,  getaddresses,  formataddr and parseaddr into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . mail . utils import DNS_NAME	from django.core.mail.utils import DNS_NAME into default name space.
from django . utils . encoding import force_text	from django.utils.encoding import force_text into default name space.
from django . utils import six	from django.utils import six into default name space.
utf8_charset = Charset . Charset ( 'utf-8' )	call the function Charset.Charset with argument string 'utf-8', substitute the result for utf8_charset.
utf8_charset . body_encoding = None	utf8_charset.body_encoding is None.
DEFAULT_ATTACHMENT_MIME_TYPE = 'application/octet-stream'	DEFAULT_ATTACHMENT_MIME_TYPE is a string 'application/octet-stream'.
class BadHeaderError ( ValueError ) :	derive the class BadHeaderError from the ValueError base class.
pass	do nothing.
def make_msgid ( idstring = None ) :	define the function make_msgid with argument idstring set to None.
timeval = time . time ( )	call the function time.time, substitute the result for timeval.
utcdate = time . strftime ( '%Y%m%d%H%M%S' , time . gmtime ( timeval ) )	call the function time.gmtime with argument timeval, use string '%Y%m%d%H%M%S' and the previous result as an argument for the call to the time.strftime function, substitute the result for utcdate.
try :	try,
pid = os . getpid ( )	call the function os.getpid, substitute it for pid.
except AttributeError :	if AttributeError exception is caught,
pid = 1	pid is integer 1.
randint = random . randrange ( 100000 )	call the function random.randrange with argument integer 100000, substitute the result for randint.
if idstring is None :	if idstring is None,
idstring = ''	idstring is an empty string.
else :	if not,
idstring = '.' + idstring	append idstring to the '.' character, substitute it for idstring.
idhost = DNS_NAME	substitute DNS_NAME for idhost.
msgid = '<%s.%s.%s%s@%s>' % ( utcdate , pid , randint , idstring , idhost )	msgid is a string '<%s.%s.%s%s@%s>', replace '%s' with utcdate, pid, randint, idstring and idhost, respectively.
return msgid	return msgid.
ADDRESS_HEADERS = set ( [  'from' ,  'sender' ,  'reply-to' ,  'to' ,  'cc' ,  'bcc' ,  'resent-from' ,  'resent-sender' ,  'resent-to' ,  'resent-cc' ,  'resent-bcc' ,  ] )	ADDRESS_HEADERS is a set containing strings: 'from', 'sender', 'reply-to', 'to', 'cc', 'bcc', 'resent-from', 'resent-sender',
def forbid_multi_line_headers ( name , val , encoding ) :	'resent-to', 'resent-cc' and 'resent-bcc'.   define the function forbid_multi_line_headers with arguments: name, val and encoding.
encoding = encoding or settings . DEFAULT_CHARSET	if encoding does not exists substitute it for settings.DEFAULT_CHARSET.
val = force_text ( val )	call the function force_text with argument val, substitute it for val.
\if '\\n' in val or '\\r' in val :\	\if characters '\\n' or '\\r' are contained in val,\
raise BadHeaderError ( 'Header values can't contain newlines (got %r for header %r)' % ( val , name ) )	raise an BadHeaderError exception  with argument string 'Header values can't contain newlines (got %r for header %r)',
try :	where '%r' are replaced by val and name, respectively.   try,
val . encode ( 'ascii' )	call the method val.encode with argument string 'ascii'.
except UnicodeEncodeError :	if UnicodeEncodeError exception is caught,
if name . lower ( ) in ADDRESS_HEADERS :	convert name to lower case, if it is contained in ADDRESS_HEADERS,s
val = ', ' . join ( sanitize_address ( addr , encoding )  for addr in getaddresses ( ( val , ) ) )	call the function sanitize_address with arguments addr and encoding, for every addr in return value of the getadresses function with tuple containing val as argument, join all the results into a string separated by ', ', substitute the result for val.
else :	if not,
val = Header ( val , encoding ) . encode ( )	call the encode function on the Header class instance, created with arguments val and encoding, substitute the result for val.
else :	if not,
if name . lower ( ) == 'subject' :	if name converted to lower case equals to string 'subject',
val = Header ( val ) . encode ( )	call the encode function on the Header class instance, created with argument val, substitute the result for val.
return str ( name ) , val	return name converted to a string and val.
def sanitize_address ( addr , encoding ) :	define the function sanitize_address with arguments addr and encoding.
if isinstance ( addr , six . string_types ) :	if addr is a instance of six.string_types,
addr = parseaddr ( force_text ( addr ) )	call the parseaddr function with return value of the force_text with argument addr, as argument, substitute the result for addr.
nm , addr = addr	nm and addr are addr.
try :	try,
nm = Header ( nm , encoding ) . encode ( )	call the encode function on the Header class instance, created with arguments nm and encoding, substitute the result for nm.
except UnicodeEncodeError :	if UnicodeEncodeError exception is caught,
nm = Header ( nm , 'utf-8' ) . encode ( )	call the encode function on the Header class instance, created with arguments nm and string 'utf-8', substitute the result for nm.
try :	try,
addr . encode ( 'ascii' )	call the addr.encode method with string 'ascii' as an argument.
except UnicodeEncodeError :	if UnicodeEncodeError exception is caught,
if '@' in addr :	if character '@' is contained in addr,
localpart , domain = addr . split ( '@' , 1 )	call the addr.split method with character '@' and integer 1 as arguments, substitute the result for localpart and domain, respectively.
localpart = str ( Header ( localpart , encoding ) )	instantiate Header class with localpart and encoding, convert it to a string, substitute the result for localpart.
domain = domain . encode ( 'idna' ) . decode ( 'ascii' )	call the decode function with argument string 'ascii' on the return value of the method domain.encode with argument string 'idna' substitute the result for domain.
addr = '@' . join ( [ localpart , domain ] )	join localpart and domain in a string separated by '@' character, substitute it for addr.
else :	if not,
addr = Header ( addr , encoding ) . encode ( )	call the encode function on the Header class instance, created with arguments addr and encoding, substitute the result for addr.
return formataddr ( ( nm , addr ) )	call the formataddr function with argument tuple containing 2 elements nm and addr.
class MIMEMixin ( ) :	derive the class MIMEMixin.
def as_string ( self , unixfrom = False ) :	define the method as_string with arguments self and unixfrom set to boolean False.
fp = six . StringIO ( )	fp is a instance of a class six.StringIO.
g = generator . Generator ( fp , mangle_from_ = False )	g is an instance of a class generator.Generator called with fp and mangle_from_ set to False.
g . flatten ( self , unixfrom = unixfrom )	call the method g.flatten with arguments self and unixfrom set to unixfrom.
return fp . getvalue ( )	call the method fp.getvalue, return the result.
if six . PY2 :	if six.PY2 is boolean True,
as_bytes = as_string	substitute as_string for as_bytes.
else :	if not,
def as_bytes ( self , unixfrom = False ) :	define the method as_bytes with arguments self and unixfrom set to boolean False.
fp = six . BytesIO ( )	fp is a instance of a class six.BytesIO.
g = generator . BytesGenerator ( fp , mangle_from_ = False )	g is an instance of a class generator.BytesGenerator called with fp and mangle_from_ set to False.
g . flatten ( self , unixfrom = unixfrom )	call the method g.flatten with arguments self and unixfrom set to unixfrom.
return fp . getvalue ( )	call the method fp.getvalue, return the result.
class SafeMIMEMessage ( MIMEMixin , MIMEMessage ) :	derive the class SafeMIMEMessage from the MIMEMixin and MIMEMessage base class.
def __setitem__ ( self , name , val ) :	define the method __setitem__ with arguments self, name and val.
name , val = forbid_multi_line_headers ( name , val , 'ascii' )	call the function forbid_multi_line_headers with 3 arguments: name, val and string 'ascii', substitute the result for name and val, respectively.
MIMEMessage . __setitem__ ( self , name , val )	call the method MIMEMessage.__setitem__ with arguments self, name and val.
class SafeMIMEText ( MIMEMixin , MIMEText ) :	derive the class SafeMIMEText from the MIMEMixin and MIMEText base class.
def __init__ ( self , text , subtype , charset ) :	define the __init__ method with arguments: self, text, subtype and charset.
self . encoding = charset	substitute charset for self.encoding.
if charset == 'utf-8' :	if charset equals to string 'utf-8',
MIMEText . __init__ ( self , text , subtype , None )	call the method MIMEText.__init__ with 4 arguments: self, text, subtype and None.
del self [ 'Content-Transfer-Encoding' ]	delete the value under the 'Content-Transfer-Encoding' key of self dictionary.
if ( 3 , 2 ) < sys . version_info < ( 3 , 3 , 4 ) :	if integers 3 and 2 in a tuple are smaller than the sys.version_info and sys.version_info is smaller than integers 3,4 and 4 in a tuple, respectively,
payload = text . encode ( utf8_charset . output_charset )	call the method text.encode with argument utf8_charset.output_charset, substitute the result for payload.
self . _payload = payload . decode ( 'ascii' , 'surrogateescape' )	call the method payload.decode with 2 arguments: string 'ascii' and string 'surrogateescape', substitute the result for self._payload.
self . set_charset ( utf8_charset )	call the method self.set_charset with utf8_charset as an argument.
else :	if not,
self . set_payload ( text , utf8_charset )	call the method payload.decode with 2 arguments: text and utf8_charset, substitute the result for self._payload.
else :	subtype and charset, respectively.   if not,
MIMEText . __init__ ( self , text , subtype , charset )	call the method MIMEText.__init__ with 4 arguments: self, text, subtype and charset.
def __setitem__ ( self , name , val ) :	define the method __setitem__ with arguments self, name and val.
name , val = forbid_multi_line_headers ( name , val , self . encoding )	call the function forbid_multi_line_headers with 3 arguments: name, val and self.encoding, substitute the result for name and val, respectively.
MIMEText . __setitem__ ( self , name , val )	call the method MIMEText.__setitem__ with arguments self, name and val.
class SafeMIMEMultipart ( MIMEMixin , MIMEMultipart ) :	derive the class SafeMIMEMultipart from the MIMEMixin and MIMEMultipart base class.
def __init__ ( self , _subtype = 'mixed' , boundary = None , _subparts = None , encoding = None , ** _params ) :	define the method __init__ with 6 arguments: self, _subtype set to string 'mixed', boundary set to None, _subparts set to None,
self . encoding = encoding	encoding set to None and unpacked dictionary _params.   substitute encoding for self.encoding.
MIMEMultipart . __init__ ( self , _subtype , boundary , _subparts , ** _params )	call the method MIMEMultipart.__init__ with 5 arguments: self, _subtype, boundary, _subparts and unpacked dictionary _params.
def __setitem__ ( self , name , val ) :	define the method __setitem__ with arguments self, name and val.
name , val = forbid_multi_line_headers ( name , val , self . encoding )	call the function forbid_multi_line_headers with 3 arguments: name, val and self.encoding, substitute the result for name and val, respectively.
MIMEMultipart . __setitem__ ( self , name , val )	call the method MIMEMultipart.__setitem__ with arguments self, name and val.
class EmailMessage ( object ) :	derive the class EmailMessage from the object base class.
content_subtype = 'plain'	content_subtype is a string 'plain'.
mixed_subtype = 'mixed'	mixed_subtype is a string 'mixed'.
encoding = None	encoding is None.
def __init__ ( self , subject = '' , body = '' , from_email = None , to = None , bcc = None ,  connection = None , attachments = None , headers = None , cc = None ) :	define the method __init__ with 10 arguments: self, subject set to an empty string, body set to an empty string,
if to :	if to is true,
self . to = list ( to )	put to into a list, assign it to self.to.
else :	if not,
self . to = [ ]	self.to is an empty list.
if cc :	if cc is true,
self . cc = list ( cc )	put cc into a list, assign it to self.cc.
else :	if not,
self . cc = [ ]	self.cc is an empty list.
if bcc :	if bcc is true,
self . bcc = list ( bcc )	put bcc into a list, assign it to self.bcc.
else :	if not,
self . bcc = [ ]	self.bcc is an empty list.
self . from_email = from_email or settings . DEFAULT_FROM_EMAIL	if from_email exists substitute from_email for self.from_email, if not substitute settings.DEFAULT_FROM_EMAIL for self.from_email.
self . subject = subject	substitute subject for self.subject.
self . body = body	substitute body for self.body.
self . attachments = attachments or [ ]	if attachments exists substitute it for self.attachments, if not attachments is an empty list.
self . extra_headers = headers or { }	if headers exists substitute it for self.extra_headers, if not extra_headers is an empty dictionary.
self . connection = connection	substitute connection for self.connection.
def get_connection ( self , fail_silently = False ) :	define the method get_connection with arguments self and fail_silently set to boolean False.
from django . core . mail import get_connection	from django.core.mail import get_connection into default name space.
if not self . connection :	if self.connection is false,
self . connection = get_connection ( fail_silently = fail_silently )	call the function get_connection with argument fail_silently set to fail_silently, substitute it for self.connection.
return self . connection	return self.connection.
def message ( self ) :	define the method message with argument self.
encoding = self . encoding or settings . DEFAULT_CHARSET	if self.encoding exists substitute it for encoding, if not substitute settings.DEFAULT_CHARSET for encoding.
msg = SafeMIMEText ( self . body , self . content_subtype , encoding )	msg is a instance of a SafeMIMEText class created with arguments: self.body, self.content_subtype and encoding.
msg = self . _create_message ( msg )	call the self._create_message method with argument msg, substitute it for msg.
msg [ 'Subject' ] = self . subject	substitute self.subject for value under the 'Subject' key of msg dictionary.
msg [ 'From' ] = self . extra_headers . get ( 'From' , self . from_email )	call the method self.extra_headers.get with string 'From' and self.from_email as arguments, substitute the result for value under the 'From' key of msg dictionary.
msg [ 'To' ] = self . extra_headers . get ( 'To' , ', ' . join ( self . to ) )	call the method self.extra_headers.get with arguments: string 'To' and joined string from self.to elements separated by ', ',
if self . cc :	substitute the result for value under the 'To' key of msg dictionary.   if self.cc is true,
msg [ 'Cc' ] = ', ' . join ( self . cc )	join elements of self.cc into a string separated by ', ', substitute the result for value under the 'Cc' key of msg dictionary.
header_names = [ key . lower ( ) for key in self . extra_headers ]	call the key.lower method for every key in self.extra_headers, join the results into a header_names.
if 'date' not in header_names :	if 'date' is not in header_names,
msg [ 'Date' ] = formatdate ( )	call the formatdate function, substitute it for value under the 'Date' key of msg dictionary.
if 'message-id' not in header_names :	if message-id' is not in header_names,
msg [ 'Message-ID' ] = make_msgid ( )	call the make_msgid function, substitute it for value under the 'Message-ID' key of msg dictionary.
for name , value in self . extra_headers . items ( ) :	for every name and value in return value of the method self.extra_headers.items,
if name . lower ( ) in ( 'from' , 'to' ) :	convert name to lower case if it equals to string 'from' or 'to,
continue	skip this loop execution,
msg [ name ] = value	substitute value for value under name key of msg dictionary.
return msg	return msg.
def recipients ( self ) :	define the method recipients with argument self.
return self . to + self . cc + self . bcc	add together self.to, self.cc and self.bcc, return the result.
def send ( self , fail_silently = False ) :	define the method send with arguments self and fail_silently set to boolean False.
if not self . recipients ( ) :	call the method self.recipients, if it evaluates to false,
return 0	return an integer 0.
return self . get_connection ( fail_silently ) . send_messages ( [ self ] )	call the method self.get_connection with argument fail_silently, on the result call the method send_messages with one argument: list containing self, return the result.
def attach ( self , filename = None , content = None , mimetype = None ) :	define the method attach with 4 arguments: self, filename set to None, content set to None and mimetype set to None.
if isinstance ( filename , MIMEBase ) :	if filename is an instance of MIMEBase,
assert content is None	if content is not None raise an error.
assert mimetype is None	if mimetype is not None raise an error.
self . attachments . append ( filename )	append filename to the self.attachments list.
else :	if not,
assert content is not None	if content is not None raise an error.
self . attachments . append ( ( filename , content , mimetype ) )	append a tuple containing 3 elements: filename, content, mimetype to self.attachments list.
def attach_file ( self , path , mimetype = None ) :	define the method attach_file with arguments self, path and mimetype set to None.
filename = os . path . basename ( path )	call the os.path.basename with path as argument, substitute the result for filename.
with open ( path , 'rb' ) as f :	open file named path in 'rb' mode, with file descriptor as f,
content = f . read ( )	read the whole file f, substitute the result for content.
self . attach ( filename , content , mimetype )	call the method self.attach with arguments filename, content and mimetype.
def _create_message ( self , msg ) :	define the method _create_message with arguments self and msg.
return self . _create_attachments ( msg )	call the method self._create_attachments with argument msg, return the result.
def _create_attachments ( self , msg ) :	define the method _create_attachments with arguments self and msg.
if self . attachments :	if self.attachments is true,
encoding = self . encoding or settings . DEFAULT_CHARSET	if self.encoding exists substitute it for encoding, if not substitute settings.DEFAULT_CHARSET for encoding.
body_msg = msg	substitute msg for body_msg.
msg = SafeMIMEMultipart ( _subtype = self . mixed_subtype , encoding = encoding )	msg is an instance of a class SafeMIMEMultipart, created with arguments: _subtype set to self.mixed_subtype and encoding set to encoding.
if self . body :	if self.body is true,
msg . attach ( body_msg )	call the method msg.attach with an argument body_msg.
for attachment in self . attachments :	for every attachment in self.attachments,
if isinstance ( attachment , MIMEBase ) :	if attachment is an instance of MIMEBase,
msg . attach ( attachment )	call the method msg.attach with an argument attachment.
else :	if not,
msg . attach ( self . _create_attachment ( * attachment ) )	call the method self._create_attachment with an unpacked list attachment as an argument, use the result as an argument for the call to the msg.attach method.
return msg	return msg.
def _create_mime_attachment ( self , content , mimetype ) :	define the method _create_mime_attachment with arguments self, content and mimetype.
basetype , subtype = mimetype . split ( '/' , 1 )	call the method mimetype.split with arguments: character '/' and integer 1, substitute the result for basetype and subtype, respectively.
if basetype == 'text' :	if basetype equals a string 'text',
encoding = self . encoding or settings . DEFAULT_CHARSET	if self.encoding exists substitute it for encoding, if not substitute settings.DEFAULT_CHARSET for encoding.
attachment = SafeMIMEText ( content , subtype , encoding )	attachment is an instance of a class SafeMIMEText, created with arguments: content, subtype and encoding.
elif basetype == 'message' and subtype == 'rfc822' :	otherwise if basetype equals a string 'message' and subtype equals a string 'rfc822',
if isinstance ( content , EmailMessage ) :	if content is an instance of a EmailMessage class,
content = content . message ( )	call the method content.message, substitute the result for content.
elif not isinstance ( content , Message ) :	otherwise if content is not an instance of Message class,
content = message_from_string ( content )	call the message_from_string function with an argument content, substitute the result for content.
attachment = SafeMIMEMessage ( content , subtype )	attachment is an instance of a class SafeMIMEMessage, created with the arguments content and subtype.
else :	if not,
attachment = MIMEBase ( basetype , subtype )	attachment is an instance of a class MIMEBase, created with the arguments basetype and subtype.
attachment . set_payload ( content )	call the method attachment.set_payload with an argument content.
Encoders . encode_base64 ( attachment )	call the method Encoders.encode_base64 with an argument attachment.
return attachment	return attachment.
def _create_attachment ( self , filename , content , mimetype = None ) :	define the method _create_attachment with 4 arguments: self, filename, content and mimetype set to None.
if mimetype is None :	if mimetype is None,
mimetype , _ = mimetypes . guess_type ( filename )	call the mimetypes.guess_type with an argument filename, assign the result to the mimetype and _, respectively.
if mimetype is None :	if mimetype is None,
mimetype = DEFAULT_ATTACHMENT_MIME_TYPE	substitute DEFAULT_ATTACHMENT_MIME_TYPE for mimetype.
attachment = self . _create_mime_attachment ( content , mimetype )	call the method self._create_mime_attachment with the arguments content and mimetype, substitute the result for attachment.
if filename :	if filename is true,
try :	try,
filename . encode ( 'ascii' )	call the method filename.encode with an argument string 'ascii'
except UnicodeEncodeError :	if UnicodeEncodeError exception is caught,
if six . PY2 :	if six.PY2 is true,
filename = filename . encode ( 'utf-8' )	call the method filename.encode with an argument string 'utf-8', substitute the result for filename.
filename = ( 'utf-8' , '' , filename )	filename is a tuple containing 3 initial elements: string 'utf-8', and empty string and filename.
attachment . add_header ( 'Content-Disposition' , 'attachment' ,  filename = filename )	call the method attachment.add_header with 3 arguments: string 'Content-Disposition', string 'attachment' and filename set to filename.
return attachment	return attachment.
class EmailMultiAlternatives ( EmailMessage ) :	derive the class EmailMultiAlternatives from the EmailMessage base class.
alternative_subtype = 'alternative'	alternative_subtype is a string 'alternative'.
def __init__ ( self , subject = '' , body = '' , from_email = None , to = None , bcc = None ,  connection = None , attachments = None , headers = None , alternatives = None ,  cc = None ) :	define the method __init__ with 11 arguments: self, subject set to an empty string, body set to an empty string,
super ( EmailMultiAlternatives , self ) . __init__ ( subject , body , from_email , to , bcc , connection , attachments , headers , cc )	call the method __init__ from the base class of the EmailMultiAlternatives class, with 9 arguments: subject, body, from_email, to,
self . alternatives = alternatives or [ ]	bcc, connection, attachments, headers and cc.   if alternatives exists substitute it for self.alternatives, if not self.alternatives is an empty list.
def attach_alternative ( self , content , mimetype ) :	define the method attach_alternative with arguments self, content and mimetype.
assert content is not None	if content is None, raise an error.
assert mimetype is not None	if mimetype is None, raise an error.
self . alternatives . append ( ( content , mimetype ) )	append a tuple containing 2 elements: content and mimetype, to the self.alternatives list.
def _create_message ( self , msg ) :	define the method _create_message with arguments self and msg.
return self . _create_attachments ( self . _create_alternatives ( msg ) )	call the method self._create_alternatives with an argument msg, use it as an argument for the call to the self._create_attachments method, return the result.
def _create_alternatives ( self , msg ) :	define the method _create_alternatives with arguments self and msg.
encoding = self . encoding or settings . DEFAULT_CHARSET	if self.encoding exists substitute it for encoding, if not substitute settings.DEFAULT_CHARSET for encoding.
if self . alternatives :	if self.alternatives is true,
body_msg = msg	substitute msg for body_msg.
msg = SafeMIMEMultipart ( _subtype = self . alternative_subtype , encoding = encoding )	msg is an instance of a class SafeMIMEMultipart, created with the arguments: _subtype set to self.alternative_subtype and encoding set to encoding.
if self . body :	if self.body is true,
msg . attach ( body_msg )	call the msg.attach with an argument body_msg.
for alternative in self . alternatives :	for every alternative in self.alternatives,
msg . attach ( self . _create_mime_attachment ( * alternative ) )	call the method self._create_mime_attachment with unpacked list alternative as an argument, use the result as an argument for the call to the msg.attach method.
return msg	return msg.
import socket	import module socket.
class CachedDnsName ( object ) :	derive class CachedDnsName from the object base class.
def __str__ ( self ) :	define the method __str__ with argument self.
return self . get_fqdn ( )	evaluate the self.get_fqdn method, return the result.
def get_fqdn ( self ) :	define the method get_fqdn with argument self.
if not hasattr ( self , '_fqdn' ) :	if self doesnt have an attribute '_fqdn',
self . _fqdn = socket . getfqdn ( )	call the function socket.getfqdn, substitute the result for self._fqdn.
return self . _fqdn	return self._fqdn.
DNS_NAME = CachedDnsName ( )	DNS_NAME is a instance of CachedDnsName class.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import collections	import module collections.
from importlib import import_module	from importlib import import_module into default name space.
import os	import module os.
import sys	import module sys.
import django	import module django.
from django . apps import apps	from django.apps import apps into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . exceptions import ImproperlyConfigured	from django.core.exceptions import ImproperlyConfigured into default name space.
from django . core . management . base import ( BaseCommand , CommandError ,  CommandParser , handle_default_options )	from django.core.management.base import BaseCommand, CommandError, CommandParser and handle_default_options into default name space.
from django . core . management . color import color_style	from django.core.management.color import color_style into default name space.
from django . utils import lru_cache	from django.utils import lru_cache into default name space.
from django . utils import six	from django.utils import six into default name space.
def find_commands ( management_dir ) :	define the function find_commands with an argument management_dir.
command_dir = os . path . join ( management_dir , 'commands' )	join management_dir and string 'commands' into a file path name, substitute it for command_dir.
try :	try,
return [ f [ : - 3 ] for f in os . listdir ( command_dir )  if not f . startswith ( '_' ) and f . endswith ( '.py' ) ]	for every f in return value of the os.listdir function called with an argument command_dir, append f without 3 last elements to a list, only if f doesnt start with character '_' and doesnt ends with string '.py', return the resulting list.
except OSError :	if OSError exception is caught,
return [ ]	return an empty list.
def load_command_class ( app_name , name ) :	define the function load_command_class with arguments: app_name and name.
module = import_module ( '%s.management.commands.%s' % ( app_name , name ) )	replace '%s' in string '%s.management.commands.%s' with app_name and name, respectively, use it as an result for the call to the
return module . Command ( )	import_module function, substitute the result for module.   return an instance of the module.Command class.
@ lru_cache . lru_cache ( maxsize = None )	decorator lru_cache.lru_cache with an argument maxsize set to None.
def get_commands ( ) :	define the function get_commands.
commands = { name : 'django.core' for name in find_commands ( __path__ [ 0 ] ) }	commands is an dictionary containing elements: string 'django.core' for every name in the function find_commands return value, called with first element of __path__ as an argument.
if not settings . configured :	if settings.configured is false,
return commands	return commands.
for app_config in reversed ( list ( apps . get_app_configs ( ) ) ) :	for every app_config in reversed list created out of the return value of the function apps.get_app_configs,
path = os . path . join ( app_config . path , 'management' )	join app_config.path and string 'management' into a file path, substitute it for path.
commands . update ( { name : app_config . name for name in find_commands ( path ) } )	call the method commands.update, with an argument dictionary containing entries: app_config_name for name, for every name in return value of the function find_commands, called with an argument path.
return commands	return commands.
def call_command ( name , * args , ** options ) :	define the function call_command with 3 arguments: name, unpacked list args and unpacked dictionary options.
try :	try,
app_name = get_commands ( ) [ name ]	call the function get_commands, substitute the value under the name key of the return value, for app_name.
except KeyError :	if KeyError exception is caught,
raise CommandError ( 'Unknown command: %r' % name )	raise an CommandError exception with an argument string 'Unknown command: %r', with '%r' replaced by name.
if isinstance ( app_name , BaseCommand ) :	if app_name is an instance of BaseCommand,
command = app_name	substitute app_namefor command.
else :	if not,
command = load_command_class ( app_name , name )	call the function load_command_class with arguments: app_name and name, substitute the result for command.
parser = command . create_parser ( '' , name )	all the method command.create_parser with arguments: empty and name, substitute the result for parser.
if command . use_argparse :	if command.use_argparse is true,
defaults = parser . parse_args ( args = args )	call the method parser.parse_args with an argument args set to args, substitute the result for defaults.
defaults = dict ( defaults . _get_kwargs ( ) , ** options )	create dictionary out of the unpacked dictionary options, using defaults._get_kwargs as a mapping function, substitute the result for defaults.
else :	if not,
defaults , _ = parser . parse_args ( args = [ ] )	call the method parser.parse_args with an arguments args set to an empty list, assign the result for defaults and _, respectively.
defaults = dict ( defaults . __dict__ , ** options )	create dictionary out of the unpacked dictionary options, using defaults.__dict__ as a mapping function, substitute the result for defaults.
return command . execute ( * args , ** defaults )	call the command.execute method with arguments: unpacked list args and unpacked dictionary defaults, return the result.
class ManagementUtility ( object ) :	derive the class ManagementUtility from object base class.
def __init__ ( self , argv = None ) :	define the method __init__ with arguments: self class instance and argv set to None.
self . argv = argv or sys . argv [ : ]	if argv is true, substitue it for self.argv, if not substitute sys.argv for self.argv.
self . prog_name = os . path . basename ( self . argv [ 0 ] )	call the function os.path.basename with first element of self.argv as an argument, substitute the result for self.prog_name.
self . settings_exception = None	self.settings_exception is None.
def main_help_text ( self , commands_only = False ) :	define the method  main_help_text with arguments: self class instance and commands_only set to boolean False.
if commands_only :	if commands_only is true,
usage = sorted ( get_commands ( ) . keys ( ) )	call the function get_commands, call the method keys on the result, substitute sorted result for usage.
else :	if not,
usage = [  '' ,  'Type '%s help <subcommand>' for help on a specific subcommand.' % self . prog_name ,  '' ,  'Available subcommands:' ,  ]	usage is a list containing 4 entries: an empty string, string 'Type '%s help <subcommand>' for help on a specific subcommand.',
commands_dict = collections . defaultdict ( lambda : [ ] )	where '%s' is replaced with self.prog_name, an empty string and string 'Available subcommands:'.   call the method collections.defaultdict with a argument: lambda function without arguments that returns an empty list,
for name , app in six . iteritems ( get_commands ( ) ) :	substitute the result for commands_dict.   for every name and app in return value of the function six.iteritems calle with return argument of function get_commands as an arugment,
if app == 'django.core' :	if app equals a string 'django.core',
app = 'django'	app is a string 'django'
else :	if not,
app = app . rpartition ( '.' ) [ - 1 ]	call the method app.rpartition with an argument '.', substitute last element of the result for app.
commands_dict [ app ] . append ( name )	append name to the value of under the app key of the commands_dict.
style = color_style ( )	call the color_style function, substitute the result for style.
for app in sorted ( commands_dict . keys ( ) ) :	for every app in sorted return value of the commands_dict.keys function,
usage . append ( '' )	append an empty string to usage.
usage . append ( style . NOTICE ( '[%s]' % app ) )	call the style.NOTICE method with an argument string '[%s]', where '%s' is replaced with app, append the result to usage.
for name in sorted ( commands_dict [ app ] ) :	for every name in sorted value under the app key of the commands_dict dictionary,
usage . append ( '    %s' % name )	append string '    %s', where '%s' is replaced by name to the usage.
if self . settings_exception is not None :	if self.settings_exception is not None,
usage . append ( style . NOTICE (  'Note that only Django core commands are listed '  'as settings are not properly configured (error: %s).'  % self . settings_exception ) )	call the method style.NOTICE with an argument string 'Note that only Django core commands are listed as settings are not properly configured (error: %s).', where '%s' is replaced by self.settings_exception, append the result to usage.
\return '\\n' . join ( usage )\	join usage elements in a string separated by newline characters, return it.
def fetch_command ( self , subcommand ) :	define the method fetch_command, with arguments self and subcommand.
commands = get_commands ( )	call the function get_commands, substitute it for commands.
try :	try,
app_name = commands [ subcommand ]	substitute value under the subcommand key of the commands dictionary for app_name.
except KeyError :	if KeyError exception is caught,
settings . INSTALLED_APPS	call settings.INSTALLED_APPS.
\sys . stderr . write ( 'Unknown command: %r\\nType '%s help' for usage.\\n' %  ( subcommand , self . prog_name ) )\	\call the method sys.stderr.write with an argument string 'Unknown command: %r\\nType '%s help' for usage.\\n',\
sys . exit ( 1 )	where '%r' is replaced with subcommand and '%s' is replaced with self.prog_name.   call the function sys.exit with an argument integer 1.
if isinstance ( app_name , BaseCommand ) :	if app_name is an instance of BaseCommands.
klass = app_name	substitute app_name for klass.
else :	if not,
klass = load_command_class ( app_name , subcommand )	call the function load_command_class with arguments app_name and subcommand, substitute the result for klass.
return klass	return klass.
def autocomplete ( self ) :	define the method autocomplete with an argument self.
if 'DJANGO_AUTO_COMPLETE' not in os . environ :	if string 'DJANGO_AUTO_COMPLETE' is not contained in os.environ,
return	return nothing.
cwords = os . environ [ 'COMP_WORDS' ] . split ( ) [ 1 : ]	slit by whitespace the value under the 'COMP_WORDS' key of the os.environ dictionary, substitute the result without the first element for cwords.
cword = int ( os . environ [ 'COMP_CWORD' ] )	convert to an integer value under the 'COMP_CWORD' key of the os.environ dictionary, substitute it for cword.
try :	try,
curr = cwords [ cword - 1 ]	substitute cwords element at the cword decremented by 1 index for curr.
except IndexError :	if IndexError exception is caugh,
curr = ''	curr is an empty string.
subcommands = list ( get_commands ( ) ) + [ 'help' ]	call the function get_commands, convert the result to a list, append string 'help' to it, substitute it for subcommands.
options = [ ( '--help' , None ) ]	options is a list containing a tuple with 2 entries: string '--help' and None.
if cword == 1 :	if cword equlals a integer 1,
print ( ' ' . join ( sorted ( filter ( lambda x : x . startswith ( curr ) , subcommands ) ) ) )	filter all the subcommands element through the lambda function with an argument x, that evaluates the method x.startswith,
elif cwords [ 0 ] in subcommands and cwords [ 0 ] != 'help' :	with an argument curr, sort the result and join it in a list separated with blank spaces, print it to the standard output.   otherwise if first element of cwords is contanied in subcommands and is not equal to string 'help',
subcommand_cls = self . fetch_command ( cwords [ 0 ] )	call the method self.fetch_command with first element of cwords as an argument, substitute it for subcommand_cls.
if cwords [ 0 ] == 'runfcgi' :	if first element of cwords equals a string 'runfcgi',
from django . core . servers . fastcgi import FASTCGI_OPTIONS	from django.core.servers.fastcgi import FASTCGI_OPTIONS into default namespace,
options += [ ( k , 1 ) for k in FASTCGI_OPTIONS ]	append tuple containing two entries: k and integer 1 to options, for every k in FASTCGI_OPTIONS.
elif cwords [ 0 ] in ( 'dumpdata' , 'sql' , 'sqlall' , 'sqlclear' ,  'sqlcustom' , 'sqlindexes' , 'sqlsequencereset' , 'test' ) :	otherwise if first element of cwords is contanied in tuple with 8 entries: 'dumpdata', 'sql', 'sqlall', 'sqlclear', 'sqlcustom',
try :	try,
app_configs = apps . get_app_configs ( )	call the method apps.get_app_configs, substitute the result for app_configs.
options += [ ( app_config . label , 0 ) for app_config in app_configs ]	append tuple containing two entries: app_config.label and integer 0 to options, for every app_config in app_configs.
except ImportError :	if ImportError exception is caught,
  pass	do nothing.
parser = subcommand_cls . create_parser ( '' , cwords [ 0 ] )	call the method subcommand_cls.create_parser with 2 argument an empty string an first element of cwords, substitute it for parser.
if subcommand_cls . use_argparse :	if subcommand_cls.use_argparse is true,
options += [ ( sorted ( s_opt . option_strings ) [ 0 ] , s_opt . nargs != 0 ) for s_opt in  parser . _actions if s_opt . option_strings ]	append to options a tuple containing 2 entries: firs element of sorted list of the s_opt.option_strings,
else :	and evaluated boolean expression s_opt.nargs doesnt equal to integer 0, for every s_opt in parser._actions,   only if s_opt.option_strings is true,   if not,
options += [ ( s_opt . get_opt_string ( ) , s_opt . nargs ) for s_opt in  parser . option_list ]	append to options a tuple containing 2 entries: result of the method s_opt.get_opt_string and s_opt.nargs,
prev_opts = [ x . split ( '=' ) [ 0 ] for x in cwords [ 1 : cword - 1 ] ]	for every s_opt in parser.option_list.   for every x in slice of cwords from the second element to the element at the cword decremented by 1 index,
options = [ opt for opt in options if opt [ 0 ] not in prev_opts ]	split x by character '=' and append first element of the result to the prev_opts list.   for every opt in options, if first element of opt is not contained in prev_opts, append opt to the list, substitute it for options.
options = sorted ( ( k , v ) for k , v in options if k . startswith ( curr ) )	append tuple containing 2 elements: k and v to a list, for every k and v in options, only if k starts with curr,
for option in options :	sort the result and substitute it for options.   for every option in options,
opt_label = option [ 0 ]	substitute first element of options for opt_label.
if option [ 1 ] :	if second element of options is true,
opt_label += '='	append '=' to opt_label.
print ( opt_label )	print opt_label to the standard output.
sys . exit ( 1 )	call the function sys.exit with an integer 1 as an argument.
def execute ( self ) :	define the method execute with an argument self,
try :	try,
subcommand = self . argv [ 1 ]	substitute first element of self.argv for subcommand.
except IndexError :	if IndexError exception is caught,
subcommand = 'help'	subcommand is a string 'help'.
parser = CommandParser ( None , usage = '%(prog)s subcommand [options] [args]' , add_help = False )	parser is an instance of CommandParser class, created with 3 arguments, None, usage as a string '%(prog)s subcommand [options] [args]' and add_help set to boolean False.
parser . add_argument ( '--settings' )	call the method parser.add_argument with an argument string '--settings'.
parser . add_argument ( '--pythonpath' )	call the method parser.add_argument with an argument string '--pythonpath'.
parser . add_argument ( 'args' , nargs = '*' )	call the method parser.add_argument with arguments: string 'args' and nargs set to '*'.
try :	try,
options , args = parser . parse_known_args ( self . argv [ 2 : ] )	call the method parser.parse_known_args wiht an argument self.argv, without the first two elements, assign the result for options,
handle_default_options ( options )	and args, respectively.   call the method handle_default_options with an argument options.
except CommandError :	if CommandError exception is caught,
pass	do nothing.
no_settings_commands = [  'help' , 'version' , '--help' , '--version' , '-h' ,  'compilemessages' , 'makemessages' ,  'startapp' , 'startproject' ,  ]	no_settings_commands is a list containing entries: 'help', 'version', '--help', '--version', '-h', 'compilemessages', 'makemessages',
try :	'startapp' and 'startproject'.   try,
settings . INSTALLED_APPS	call the settings.INSTALLED_APPS.
except ImproperlyConfigured as exc :	if ImproperlyConfigured renamed to exc, exception is caught,
self . settings_exception = exc	substitute exc for self.settings_exception,
if subcommand in no_settings_commands :	if subcommand is contained in no_settings_commands,
settings . configure ( )	call the method settings.configure.
if settings . configured :	if settings.configured is true,
django . setup ( )	call the method django.setup.
self . autocomplete ( )	call the method self.autocomplete.
if subcommand == 'help' :	if subcommand equals to a string 'help'.
if '--commands' in args :	if string '--commands' is contained in args,
\sys . stdout . write ( self . main_help_text ( commands_only = True ) + '\\n' )\	call the method self.main_help_text with an argument commands_only set to boolean True, append new line to it, write it to sys.stdout.
elif len ( options . args ) < 1 :	otherwise, length of options.args is lesser than integer 1,
\sys . stdout . write ( self . main_help_text ( ) + '\\n' )\	call the method self.main_help_text append new line to it, write it to sys.stdout.
else :	if not,
self . fetch_command ( options . args [ 0 ] ) . print_help ( self . prog_name , options . args [ 0 ] )	call the method self.fetch_command with first element of options.args as argument, on the result call the method print_help,
elif subcommand == 'version' or self . argv [ 1 : ] == [ '--version' ] :	with 2 arguments: self.prog_name and first element of options.args.   otherwise if subcommand equals a string 'version' or self.argv, without the first element equals a list containing a string '--version'
\sys . stdout . write ( django . get_version ( ) + '\\n' )\	call the method django.get_version append new line to it, write it to sys.stdout.
elif self . argv [ 1 : ] in ( [ '--help' ] , [ '-h' ] ) :	if self.argv, without the first element is contained in a tuple with 2 entries: a list containing a string '--help',
\sys . stdout . write ( self . main_help_text ( ) + '\\n' )\	and a list containing a string '-h',   call the method self.main_help_text, append new line to it, write it to sys.stdout.
else :	if not,
self . fetch_command ( subcommand ) . run_from_argv ( self . argv )	call the method self.fetch_command with an argument command, call the method run_from_argv on the result with an argument self.argv.
def execute_from_command_line ( argv = None ) :	define the function execute_from_command_line with an argument argv set to None.
utility = ManagementUtility ( argv )	utility is a instance of ManagementUtility class, created with an argument argv.
utility . execute ( )	call the method utility.execute.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import os	import module os.
import sys	import module sys.
import warnings	import module warnings.
from argparse import ArgumentParser	from argparse import ArgumentParser into default name space.
from optparse import OptionParser	from optparse import OptionParser into default name space.
import django	import module django.
from django . core import checks	from django.core import checks into default name space.
from django . core . exceptions import ImproperlyConfigured	from django.core.exceptions import ImproperlyConfigured into default name space.
from django . core . management . color import color_style , no_style	from django.core.management.color import color_style and no_style into default name space.
from django . utils . deprecation import RemovedInDjango19Warning , RemovedInDjango20Warning	from django.utils.deprecation import RemovedInDjango19Warning and RemovedInDjango20Warning into default name space.
from django . utils . encoding import force_str	from django.utils.encoding import force_st into default name space.
class CommandError ( Exception ) :	derive the class CommandError from the base class Exception.
pass	do nothing.
class CommandParser ( ArgumentParser ) :	derive the CommandParser class from the ArgumentParser base class.
def __init__ ( self , cmd , ** kwargs ) :	define the method __init__ with arguments: self, cmd and unpacked dictionary kwargs.
self . cmd = cmd	substitute cmd for self.cmd.
super ( CommandParser , self ) . __init__ ( ** kwargs )	call the method __init__ from the base class of the CommandParser class, with unpacked dictionary kwargs as argument.
def parse_args ( self , args = None , namespace = None ) :	define the method parse_args with 3 arguments: self, args set to None and namespace set to None.
if ( hasattr ( self . cmd , 'missing_args_message' ) and  not ( args or any ( [ not arg . startswith ( '-' ) for arg in args ] ) ) ) :	if self.cmd has an attribute 'missing_args_message' and next statement is not true: args is true or any arg doesnt start with '-' for arg in args,
self . error ( self . cmd . missing_args_message )	call the method self.error with an argument self.cmd.missing_args_message.
return super ( CommandParser , self ) . parse_args ( args , namespace )	call the parse_args method with arguments args and namespace, from the base class of the CommandParser class.
def error ( self , message ) :	define the method error with arguments self and message.
if self . cmd . _called_from_command_line :	if self.cmd._called_from_command_line is true,
super ( CommandParser , self ) . error ( message )	call the method error with an argument message, from the base class of the class CommandParser.
else :	if not,
raise CommandError ( 'Error: %s' % message )	raise an CommandError exception with an argument string 'Error: %s', with '%s' replaced by message.
def handle_default_options ( options ) :	define the function handle_default_options with an argument options.
if options . settings :	if options.settings is true,
os . environ [ 'DJANGO_SETTINGS_MODULE' ] = options . settings	substitute options.settings for value under the 'DJANGO_SETTINGS_MODULE' key of the os.environ dictionary.
if options . pythonpath :	if options.pythonpath is true,
sys . path . insert ( 0 , options . pythonpath )	insert options.pythonpath at the beginning of sys.path.
class OutputWrapper ( object ) :	derive the OutputWrapper class from the object base class.
\def __init__ ( self , out , style_func = None , ending = '\\n' ) :\	define the method __init__ with 4 arguments: self, out, style, func set to None and endings set to newline character.
self . _out = out	substitute out for self._out.
self . style_func = None	substitute None for self.style_func.
if hasattr ( out , 'isatty' ) and out . isatty ( ) :	if out has an 'isatty' argument and return value of the function out.isatty is true,
self . style_func = style_func	substitute style_func for self.style_func.
self . ending = ending	substitute ending for self.ending.
def __getattr__ ( self , name ) :	define the method __getattr__ with arguments self and name.
return getattr ( self . _out , name )	get name attribute of the self._out object, return it.
def write ( self , msg , style_func = None , ending = None ) :	define the method write with 4 arguments: self, msg, style_func with None and ending set None.
ending = self . ending if ending is None else ending	if ending is None substitute self.ending for ending.
if ending and not msg . endswith ( ending ) :	if ending is true and msg doesnt end with ending,
msg += ending	append ending to msg.
style_func = [ f for f in ( style_func , self . style_func , lambda x : x )  if f is not None ] [ 0 ]	if f is not None append it to a list for every f in tuple containing 3 elements: style_func, self.style_func,
self . _out . write ( force_str ( style_func ( msg ) ) )	and lambda function returning x for x, substitute the firs element of resulting list for style_func.   call the function style_func with an argument msg, use the result as an argument for the call to the function force_str,
class BaseCommand ( object ) :	use the result as an argument for the call to the function self._out.write.   derive the BaseCommand class from the object base class.
option_list = ( )	options_list is an empty tuple.
help = ''	help is an empty string.
args = ''	args is an empty string.
_called_from_command_line = False	_called_from_command_line is boolean False.
can_import_settings = True	can_import_settings is boolean True.
output_transaction = False	output_transaction is boolean False.
leave_locale_alone = False	leave_locale_alone is boolean False.
def __init__ ( self ) :	define the method __init__ with an argument self.
self . style = color_style ( )	call the function color_style, substitute the result for self.style.
has_old_option = hasattr ( self , 'requires_model_validation' )	if self has an 'requires_model_validation' attribute, has_old_option is boolean True, otherwise it is boolean False.
has_new_option = hasattr ( self , 'requires_system_checks' )	if self has an 'requires_system_checks' attribute, has_new_option is boolean True, otherwise it is boolean False.
if has_old_option :	if has_old_option is true,
if has_old_option and has_new_option :	'in favor of 'requires_system_checks'.' and RemovedInDjango19Warning.   if has_old_option and has_new_option are both true,
self . requires_system_checks = (  self . requires_system_checks if has_new_option else  self . requires_model_validation if has_old_option else  True )	'and 'requires_system_checks', which is illegal. Use only 'requires_system_checks'.', replace '%s' for self.__class__.__name__.   call the method self.requires_system_checks with an argument: self.requires_system_checks if has_new_option is true,
@ property	or if it is false, but has_old_option is true use self.requires_model_validation, if they are both false use boolean True as an argument.   property decorator,
def use_argparse ( self ) :	define the method use_argparse with an argument self,
return not bool ( self . option_list )	convert self.option_list into a boolean, return the inverted value.
def get_version ( self ) :	define the method get_version with an arguments self.
return django . get_version ( )	call the function django.get_version, return the result.
def usage ( self , subcommand ) :	define the method usage with arguments self and subcommand.
usage = '%%prog %s [options] %s' % ( subcommand , self . args )	substitute '%s' in the string '%%prog %s [options] %s' with subcommand and self.args, respectively, substitute it for usage.
if self . help :	if self.help is true,
\return '%s\\n\\n%s' % ( usage , self . help )\	join usage and self.help into a string, separated by 2 new line characters, return it.
else :	if not,
return usage	return usage.
def create_parser ( self , prog_name , subcommand ) :	define the method create_parser with 3 arguments: self, prog_name and subcommand.
if not self . use_argparse :	if self.use_argparse is false,
warnings . warn ( 'OptionParser usage for Django management commands '  'is deprecated, use ArgumentParser instead' ,  RemovedInDjango20Warning )	call the function warnings.warn with 2 arguments: string 'OptionParser usage for Django management commands '
parser = OptionParser ( prog = prog_name ,  usage = self . usage ( subcommand ) ,  version = self . get_version ( ) )	is deprecated, use ArgumentParser instead and RemovedInDjango20Warning.   parser is an instance of the object OptionParser, created with arguments: prog set to prog_name,
parser . add_option ( '-v' , '--verbosity' , action = 'store' , dest = 'verbosity' , default = '1' ,  type = 'choice' , choices = [ '0' , '1' , '2' , '3' ] ,  help = 'Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output' )	usage set to return value of the method self.usage called with an argument subcommand, version set to return value of the method self.get_version.   call the method parser.add_option with 8 arguments: string '-v', string '--verbosity', action set to string 'store',
\parser . add_option ( '--settings' ,  help = 'The Python path to a settings module, e.g. 'myproject.settings.main'. If this isn\\'t provided, the DJANGO_SETTINGS_MODULE environment variable will be used.' )\	\dest set to string 'verbosity', default set to string '1', type set to string 'choice', choices is a list containing elements: '0', '1', '2', '3', and help as a string 'Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output'.   call the method parser.add_option with 2 arguments: string '--settings' and help as a string 'The Python path to a settings module, e.g. 'myproject.settings.main'. If this isn\\'t provided, the DJANGO_SETTINGS_MODULE environment variable will be used.'.\
parser . add_option ( '--pythonpath' ,  help = 'A directory to add to the Python path, e.g. '/home/djangoprojects/myproject'.' ) ,	call the method parser.add_option with 2 arguments: string '--pythonpath' and help set to string 'A directory to add to the Python path, e.g. '/home/djangoprojects/myproject'.'.
parser . add_option ( '--traceback' , action = 'store_true' ,  help = 'Raise on exception' )	call the method parser.add_option with 3 arguments: string '--traceback', action set to a string 'store_true',
parser . add_option ( '--no-color' , action = 'store_true' , dest = 'no_color' , default = False ,  help = 'Don't colorize the command output.' )	and help='Raise on exception'.   call the method parser.add_option with 5 arguments: string '--no-color', action set to a string 'store_true',
for opt in self . option_list :	dest set to string 'no_color' default set to boolean False and help set to a string 'Don't colorize the command output.'.   for every opt in self.option_list,
parser . add_option ( opt )	call the method parser.add_option with an argument opt.
else :	if not,
parser = CommandParser ( self , prog = '%s %s' % ( os . path . basename ( prog_name ) , subcommand ) ,  description = self . help or None )	parser is an instance of CommandParser class, created with 3 arguments: self, prog as a string created by joining:
parser . add_argument ( '--version' , action = 'version' , version = self . get_version ( ) )	os.path.basename(prog_name) and subcommand, separated by whitespace and description set to self.help, if exists, or None, otherwise.   call the method parser.add_option with 3 arguments: string '--version', action set to string 'version',
parser . add_argument ( '-v' , '--verbosity' , action = 'store' , dest = 'verbosity' , default = '1' ,  type = int , choices = [ 0 , 1 , 2 , 3 ] ,  help = 'Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output' )	and version set to result of the method self.get_version.   call the method parser.add_option with 8 arguments: string '-v', string '--verbosity', action set to string 'store',
\parser . add_argument ( '--settings' ,  help = 'The Python path to a settings module, e.g. 'myproject.settings.main'. If this isn\\'t provided, the DJANGO_SETTINGS_MODULE environment variable will be used.' )\	\dest set to string 'verbosity', default set to string '1', type set to int, choices is a list, containing integers: 0, 1, 2 and 3,   call the method parser.add_option with 2 arguments: string '--settings' and help as a string 'The Python path to a settings module,  e.g. 'myproject.settings.main'. If this isn\\'t provided, the DJANGO_SETTINGS_MODULE environment variable will be used.'\
parser . add_argument ( '--pythonpath' ,  help = 'A directory to add to the Python path, e.g. '/home/djangoprojects/myproject'.' )	call the method parser.add_option with 2 arguments: string '--pythonpath' and help set to a string 'A directory to add to the Python  path, e.g. '/home/djangoprojects/myproject'.'
parser . add_argument ( '--traceback' , action = 'store_true' ,  help = 'Raise on exception' )	call the method parser.add_option with 3 arguments: string '--traceback', action set to a string 'store_true',
parser . add_argument ( '--no-color' , action = 'store_true' , dest = 'no_color' , default = False ,  help = 'Don't colorize the command output.' )	and help set to string 'Raise on exception'.   call the method parser.add_option with 5 arguments: string '--no-color', action is string 'store_true', dest is string 'no_color',
if self . args :	default is boolean False, and help is a string 'Don't colorize the command output.'.   if self.args is true,
parser . add_argument ( 'args' , nargs = '*' )	call the method parser.add_argument with 2 arguments: string 'args' and nargs set to '*'.
self . add_arguments ( parser )	call the method self.add_arguments with an argument parser.
return parser	return parser
def add_arguments ( self , parser ) :	define the method add_arguments with an argument self and parser.
pass	do nothing
def print_help ( self , prog_name , subcommand ) :	define the method print_help with 3 arguments: self, prog_name and subcommand.
parser = self . create_parser ( prog_name , subcommand )	call the method self.create_parser with arguments prog_name and subcommand.
parser . print_help ( )	call the method parser.print_help.
def run_from_argv ( self , argv ) :	define the method run_from_argv with arguments self and argv.
self . _called_from_command_line = True	self._called_from_command_line is boolean True.
parser = self . create_parser ( argv [ 0 ] , argv [ 1 ] )	call the method self.create_parser with first and second element of argv, substitute the result for parser.
if self . use_argparse :	if self.use_argparse is true,
options = parser . parse_args ( argv [ 2 : ] )	call the method parser.parse_args with argv, without the first 2 elements, substitute the result for options.
cmd_options = vars ( options )	call the function vars with an argument options, substitute the result for cmd_options.
if 'args' in options :	if 'args' is contained in options,
args = options . args	substitute options.args for args.
del cmd_options [ 'args' ]	delete value under the 'args' key of the cmd_options dictionary.
else :	if not,
args = ( )	args is an empty tuple.
else :	if not,
options , args = parser . parse_args ( argv [ 2 : ] )	call the method parser.parse_args with argv, without the first 2 elements, substitute the result for options and args.
cmd_options = vars ( options )	call the function vars with an argument options, substitute the result for cmd_options.
handle_default_options ( options )	call the function handle_default_options with an argument options.
try :	try,
self . execute ( * args , ** cmd_options )	call the method self.execute, with 2 arguments: unpacked list args and unpacked dictionary cmd_options.
except Exception as e :	if Exception, renamed to e, exception is caught,
if options . traceback or not isinstance ( e , CommandError ) :	if options.traceback is true or e is not CommandError instance,
raise	raise an exception.
stderr = getattr ( self , 'stderr' , OutputWrapper ( sys . stderr , self . style . ERROR ) )	if it exists, get 'stderr' attribute of self, substitute it for stderr, if not, stderr is an instance of OutputWrapper class,
stderr . write ( '%s: %s' % ( e . __class__ . __name__ , e ) )	created with arguments sys.stderr and self.style.ERROR.   replace '%s' in string '%s: %s' with e.__class__.__name__ and e, respectively, write it to the stderr stream.
sys . exit ( 1 )	call the function sys.exit with an argument integer 1.
def execute ( self , * args , ** options ) :	define the method execute with 3 arguments: self, unpacked list args and unpacked dictionary options.
self . stdout = OutputWrapper ( options . get ( 'stdout' , sys . stdout ) )	self.stdout is an instance of OutputWrapper class created with an argument: value under the 'stdout' key of the options dictionary,
if options . get ( 'no_color' ) :	if the key doesnt exists use sys.stdout as an argument.   if value under the 'no_color' key of the options dictionary.
self . style = no_style ( )	call the function no_style, substitute the result for self.style.
self . stderr = OutputWrapper ( options . get ( 'stderr' , sys . stderr ) )	self.stderr is an OutputWrapper object instance, created with value under the 'stderr' key of the options dictionary as an argument,
else :	if the key doesnt exists use sys.stderr as an argument.   if not,
self . stderr = OutputWrapper ( options . get ( 'stderr' , sys . stderr ) , self . style . ERROR )	self.stderr is an instance of an OutputWrapper object, created with 2 arguments: value under the 'stderr' key of the options dictionary, if it doesnt exists use the sys.stderr instead, and self.style.ERROR.
if self . can_import_settings :	if self.can_import_settings is true,
from django . conf import settings	from django.conf import settings into default namespace,
saved_locale = None	saved_locale is None.
if not self . leave_locale_alone :	if self.leave_locale_alone is false,
if not self . can_import_settings :	if self.can_import_settings is false,
raise CommandError ( 'Incompatible values of 'leave_locale_alone' '  '(%s) and 'can_import_settings' (%s) command '  'options.' % ( self . leave_locale_alone ,  self . can_import_settings ) )	raise an CommandError exception with an argument string, 'Incompatible values of 'leave_locale_alone' '
from django . utils import translation	(%s) and 'can_import_settings' (%s) command options., replace '%s' with self.leave_locale_alone and self.can_import_settings.   from django.utils import translation into default namespace.
saved_locale = translation . get_language ( )	call the method translation.get_language, substitute th result for saved_locale.
translation . activate ( 'en-us' )	call the method translation.activate with an argument string 'en-us'.
try :	try,
if ( self . requires_system_checks and  not options . get ( 'skip_validation' ) and  not options . get ( 'skip_checks' ) ) :	if self.requires_system_checks is true and values under the 'skip_validation' and 'skip_checks' keys of the options dictionary are false,
self . check ( )	call the method self.check,
output = self . handle ( * args , ** options )	call the method self.handle with 2 arguments unpacked list args and unpacked dictionary options, substitute the result for output.
if output :	if output is true,
if self . output_transaction :	if self.output_transaction is true,
  from django . db import connections , DEFAULT_DB_ALIAS	from django.db import connections and DEFAULT_DB_ALIAS into default namespace.
connection = connections [ options . get ( 'database' , DEFAULT_DB_ALIAS ) ]	get the value under the 'database' key of the options dictionary, if it doesnt exists use the DEFAULT_DB_ALIAS to address an element
if connection . ops . start_transaction_sql ( ) :	from the connections list, substitute it for connection.   call the method connection.ops.start_transaction_sql, if it evaluates to true,
    self . stdout . write ( self . style . SQL_KEYWORD ( connection . ops . start_transaction_sql ( ) ) )	call the method connection.ops.start_transaction_sql, use the result as an argument for the call to the method self.style.SQL_KEYWORD,
self . stdout . write ( output )	write the result to the self.stdout stream.   write output to self.stdout stream.
if self . output_transaction :	if self.output_transaction is true,
\self . stdout . write ( '\\n' + self . style . SQL_KEYWORD ( connection . ops . end_transaction_sql ( ) ) )\	call the method connection.ops.end_transaction_sql, use the result as the argument for the call to the method self.style.SQL_KEYWORD,
finally :	\append the result to the '\\n' string, write it to self.stdout.   finally perform,\
if saved_locale is not None :	if saved_locale is not None,
translation . activate ( saved_locale )	call the method translation.activate with an argument saved_locale.
def validate ( self , app_config = None , display_num_errors = False ) :	define the method with 3 arguments: self, app_config  set to None and display_num_errors set to boolean False.
if app_config is None :	if app_config is None,
app_configs = None	app_configs is not None.
else :	if not,
app_configs = [ app_config ]	app_configs is a list containing app_config.
return self . check ( app_configs = app_configs , display_num_errors = display_num_errors )	call the method self.check with 2 arguments app_configs set to app_configs, display_num_errors set to display_num_errors, return the result.
def check ( self , app_configs = None , tags = None , display_num_errors = False ) :	define the method check with 4 arguments: self, app_configs set to None, tags set to None, display_num_errors set to boolean False.
all_issues = checks . run_checks ( app_configs = app_configs , tags = tags )	call the method checks.run_checks with 2 arguments: app_configs set to app_configs, tags set t tags, substitute the result for all_issues.
msg = ''	msg is an empty string.
visible_issue_count = 0	visible_issue_count is an integer 0.
if all_issues :	if all_issues is true,
debugs = [ e for e in all_issues if e . level < checks . INFO and not e . is_silenced ( ) ]	append e to debugs list for every e in all_issues, if e.level is lesser than checks.INFO and result of the method e.is_silenced in false.
infos = [ e for e in all_issues if checks . INFO <= e . level < checks . WARNING and not e . is_silenced ( ) ]	append e to infos list for every e in all_issues, if checks.INFO is lesser or equal to e.level,
warnings = [ e for e in all_issues if checks . WARNING <= e . level < checks . ERROR and not e . is_silenced ( ) ]	and e.level is lesser than checks.WARNING and result of the method e.is_silenced in false.   append e to warnings list for every e in all_issues, if checks.WARNING is lesser than or equal to e.level,
errors = [ e for e in all_issues if checks . ERROR <= e . level < checks . CRITICAL ]	and e.level is lesser than checks.WARNING and result of the method e.is_silenced in false.   append e to errors list for every e in all_issues, if checks.ERROR is lesser than or equal to e.level,
criticals = [ e for e in all_issues if checks . CRITICAL <= e . level ]	and e.level is lesser than checks.CRITICAL.   append e to criticals list for every e in all_issues, if checks.CRITICAL is lesser than or equal to e.level.
sorted_issues = [  ( criticals , 'CRITICALS' ) ,  ( errors , 'ERRORS' ) ,  ( warnings , 'WARNINGS' ) ,  ( infos , 'INFOS' ) ,  ( debugs , 'DEBUGS' ) ,  ]	sorted_issues is a list of tuples with 5 entries: criticals and 'CRITICALS', errors and 'ERRORS', warnings and 'WARNINGS',
for issues , group_name in sorted_issues :	infos, 'INFOS'   for every issues and group_name in sorted_issues,
if issues :	if issues is true,
visible_issue_count += len ( issues )	increment visible_issue_count for length of issues.
formatted = (  color_style ( ) . ERROR ( force_str ( e ) )  if e . is_serious ( )  else color_style ( ) . WARNING ( force_str ( e ) )  for e in issues )	if e.is_serious method evaluates to true, call the function color_style, on the result call the method ERROR with result of the  force_str called with an argument e, if not call the function color_style on the result call the method ERROR with result of the  force_str called with an argument e, for every e in issues, formatted is a tuple containing the previous result.
\formatted = '\\n' . join ( sorted ( formatted ) )\	sort elements formatted, join them in the list separated with newline character, substitute the result for formatted.
\msg += '\\n%s:\\n%s\\n' % ( group_name , formatted )\	\substitute '%s' in the string '\\n%s:\\n%s\\n', with group_name and formatted, substitute the result for msg.\
if msg :	if msg is true,
\msg = 'System check identified some issues:\\n%s' % msg\	\replace '%s' in string 'System check identified some issues:\\n%s' with msg, substitute it for msg.\
if display_num_errors :	if display_num_errors is true,
if msg :	if msg is true,
\msg += '\\n'\	append newline character to msg.
msg += 'System check identified %s (%s silenced).' % (  'no issues' if visible_issue_count == 0 else  '1 issue' if visible_issue_count == 1 else  '%s issues' % visible_issue_count ,  len ( all_issues ) - visible_issue_count ,  )	append string 'System check identified %s (%s silenced).' to msg, replace first '%s' for: string 'no issues',
if any ( e . is_serious ( ) and not e . is_silenced ( ) for e in all_issues ) :	if visible_issue_count equals to integer 0, or for string '1 issue' if visible_issue_count equals integer 1,   or for string '%s issues', with '%s' replaced by visible_issue_count, subtract visible_issue_count from length of all_issues,   and substitute it for second '%s' in the stirting string.   if any element in the return value of the e.is_serious method is true, and if return value of the method e.is_silenced is false,
raise CommandError ( msg )	for every e in all_issues,   raise an CommandError with argument msg,
elif msg and visible_issue_count :	otherwise if msg and visible_issue_count are true,
self . stderr . write ( msg )	write msg to self.stderr stream.
elif msg :	otherwise if msg is true,
self . stdout . write ( msg )	write msg to self.stderr stream.
def handle ( self , * args , ** options ) :	define the method handle with 3 arguments: self, unpacked args and unpacked dictionary options.
raise NotImplementedError ( 'subclasses of BaseCommand must provide a handle() method' )	raise an NotImplementedError exception with an argument string 'subclasses of BaseCommand must provide a handle() method'.
class AppCommand ( BaseCommand ) :	derive the AppCommand class from the BaseCommand base class.
missing_args_message = 'Enter at least one application label.'	missing_args_message is an string 'Enter at least one application label.'.
def add_arguments ( self , parser ) :	define the method add_arguments with self and parser as arguments.
parser . add_argument ( 'args' , metavar = 'app_label' , nargs = '+' ,  help = 'One or more application label.' )	call the method parser.add_argument with 4 arguments: string 'args', metavar set to 'app_label', nargs set to '+',
def handle ( self , * app_labels , ** options ) :	and help set to string 'One or more application label.'.   define the method handle with 3 arguments: self, unpacked list app_labels and unpacked dictionary options.
from django . apps import apps	from django.apps import apps into default name space.
try :	try,
app_configs = [ apps . get_app_config ( app_label ) for app_label in app_labels ]	call the method apps.get_app_config with an argument app_lable, for every app_label in app_labels, append the results to app_configs list.
except ( LookupError , ImportError ) as e :	if LookupError or ImportError, renamed to e, exceptions are caught,
raise CommandError ( '%s. Are you sure your INSTALLED_APPS setting is correct?' % e )	raise an CommandError with an argument string '%s. Are you sure your INSTALLED_APPS setting is correct?', with '%s' replaced by e.
output = [ ]	output is an empty list.
for app_config in app_configs :	for eery app_config in app_configs,
app_output = self . handle_app_config ( app_config , ** options )	call the self.handle_app_config method with app_config and options as arguments, substitute the result for app_output.
if app_output :	if app_output is true,
output . append ( app_output )	append app_output to output.
\return '\\n' . join ( output )\	join elements of output into a string, separated by newline characters, return it.
def handle_app_config ( self , app_config , ** options ) :	define the method handle_app_config with 3 arguments: self, app_config and unpacked dictionary options.
try :	try,
handle_app = self . handle_app	substitute self.handle_app for handle_app.
except AttributeError :	if AttributeError exception is caught,
raise NotImplementedError (  'Subclasses of AppCommand must provide'  'a handle_app_config() method.' )	raise an NotImplementedError with an argument string 'Subclasses of AppCommand must provide a handle_app_config() method.'.
else :	if not,
warnings . warn (  'AppCommand.handle_app() is superseded by '  'AppCommand.handle_app_config().' ,  RemovedInDjango19Warning , stacklevel = 2 )	call the function warnings.warn with 3 argument: string 'AppCommand.handle_app() is superseded by AppCommand.handle_app_config().',
if app_config . models_module is None :	RemovedInDjango19Warning and stacklevel set to integer 2.   if app_config.models_module is None,
raise CommandError (  'AppCommand cannot handle app '%s' in legacy mode '  'because it doesn't have a models module.'  % app_config . label )	raise an CommandError with an argument string 'AppCommand cannot handle app '%s' in legacy mode because it doesn't have a models module.', where '%s' is replaced by app_config.label.
return handle_app ( app_config . models_module , ** options )	call the function handle_app with 2 arguments: app_config.models_module and unpacked dictionary options.
class LabelCommand ( BaseCommand ) :	derive the LabelCommand class from the BaseCommand base class.
label = 'label'	label is a string 'label'
missing_args_message = 'Enter at least one %s.' % label	substitute string 'Enter at least one %s.', with '%s' replaced by label, for missing_args_message.
def add_arguments ( self , parser ) :	define the method add_arguments with arguments self and parser.
parser . add_argument ( 'args' , metavar = self . label , nargs = '+' )	call the method parser.add_argument with 3 arguments: string 'args', metavar set to self.label and nargs set to '+'.
def handle ( self , * labels , ** options ) :	define the method handle with 3 arguments: self, unpacked list labels and unpacked dictionary options.
output = [ ]	output is an empty list.
for label in labels :	for every label in labels,
label_output = self . handle_label ( label , ** options )	call the method self.handle_label with 2 arguments: label and unpacked dictionary options, substitute the result for label_output.
if label_output :	if label_output is true,
output . append ( label_output )	append label_output to output.
\return '\\n' . join ( output )\	join output into a string, separated by newline characters, return it.
def handle_label ( self , label , ** options ) :	define the method handle_label with 3 arguments: self, label and unpacked dictionary options.
raise NotImplementedError ( 'subclasses of LabelCommand must provide a handle_label() method' )	raise an NotImplementedError exception with an argument string 'subclasses of LabelCommand must provide a handle_label() method'.
class NoArgsCommand ( BaseCommand ) :	derive the NoArgsCommand class from the BaseCommand base class.
args = ''	args is an empty string.
def __init__ ( self ) :	define the method __init__ with an argument self.
warnings . warn (  'NoArgsCommand class is deprecated and will be removed in Django 2.0. '  'Use BaseCommand instead, which takes no arguments by default.' ,  RemovedInDjango20Warning  )	call the function warnings.warn with 2 arguments: string 'NoArgsCommand class is deprecated and will be removed in Django 2.0. '
super ( NoArgsCommand , self ) . __init__ ( )	Use BaseCommand instead, which takes no arguments by default. and RemovedInDjango20Warning.   call the __init__ method from the base class of the NoArgsCommand class.
def handle ( self , * args , ** options ) :	define the method handle with 3 arguments: self, unpacked list args and unpacked dictionary options.
if args :	if args is true,
raise CommandError ( 'Command doesn't accept any arguments' )	raise an CommandError exception with an argument string 'Command doesn't accept any arguments'.
return self . handle_noargs ( ** options )	call the self.handle_noargs method with with unpacked dictionary options as argument, return the result.
def handle_noargs ( self , ** options ) :	define the method handle_noargs with 2 arguments: self and unpacked dictionary options.
raise NotImplementedError ( 'subclasses of NoArgsCommand must provide a handle_noargs() method' )	raise an NotImplementedError with an argument string 'subclasses of NoArgsCommand must provide a handle_noargs() method'.
import os	import module os.
import sys	import module sys.
from django . utils import termcolors	from django.utils import termcolors into default name space.
def supports_color ( ) :	define the function supports_color, without arguments.
plat = sys . platform	substitute sys.platform for plat.
supported_platform = plat != 'Pocket PC' and ( plat != 'win32' or  'ANSICON' in os . environ )	evaluate the logic expression, plat does not equals to string 'Pocket PC', and plat does not equals to string 'win32'
is_a_tty = hasattr ( sys . stdout , 'isatty' ) and sys . stdout . isatty ( )	or string 'ANICON' is in os.environ, substitute the evaluated boolean for supported_platform.   if sys.stdout has an attribute named 'isatty' and call to the sys.stdout.isatty returns boolean True, substitute True for is_a_tty.
if not supported_platform or not is_a_tty :	if supported_platform is False or is_a_tty is False,
return False	return boolean False.
return True	return boolean True.
def color_style ( ) :	define function color_style, without input arguments.
if not supports_color ( ) :	call the function supports_color, if evaluates to False,
style = no_style ( )	substitute return value of function no_style for style.
else :	if not,
DJANGO_COLORS = os . environ . get ( 'DJANGO_COLORS' , '' )	get the value under the key 'DJANGO_COLORS' of os.environ dictionary, if key doesnt exists return empty string, assign the result to DJANGO_COLORS.
color_settings = termcolors . parse_color_setting ( DJANGO_COLORS )	call the function termcolors.parse_color_setting with DJANGO_COLORS as an argument, assign the result to color_settings.
if color_settings :	if color_setting is True,
class dummy :	define class dummy.
pass	do nothing.
style = dummy ( )	style is an instance of the dummy class.
for role in termcolors . PALETTES [ termcolors . NOCOLOR_PALETTE ] :	for every role in termcolors.PALETTES list at the index termcolors.NOCOLOR_PALETTE,
format = color_settings . get ( role , { } )	assign the value of the dictionary color_settings under the key role to format, if key doesnt exist assign the empty dictionary.
setattr ( style , role , termcolors . make_style ( ** format ) )	sets the role attribute of the style object to the value of the call to the termcolors.make_style function with dictionary format as an argument.
style . ERROR_OUTPUT = style . ERROR	substitute style.ERROR for style.ERROR_OUTPUT.
else :	if not,
style = no_style ( )	substitute return value of function no_style for style.
return style	return style.
def no_style ( ) :	define function no_style, without input arguments.
class dummy :	define class dummy.
def __getattr__ ( self , attr ) :	define private method __getattr__ with self class instance and attr as the arguments.
return lambda x : x	create lambda identity function which returns x for input parameter x, return the function.
return dummy ( )	return an instance of a dummy class.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . apps import apps	from django.apps import apps into default name space.
from django . core import checks	from django.core import checks into default name space.
from django . core . checks . registry import registry	from django.core.checks.registry import registry into default name space.
from django . core . management . base import BaseCommand , CommandError	from django.core.management.base import BaseCommand and CommandError into default name space.
class Command ( BaseCommand ) :	derive the class Command from the BaseCommand base class.
help = 'Checks the entire Django project for potential problems.'	help is a string 'Checks the entire Django project for potential problems.'.
requires_system_checks = False	requires_system_checks is boolean False.
def add_arguments ( self , parser ) :	define the method add_arguments with arguments self and parser.
parser . add_argument ( 'args' , metavar = 'app_label' , nargs = '*' )	call the method parser.add_argument with 3 arguments: string 'args', metavar set to string 'app_label' and nargs set to '*'.
parser . add_argument ( '--tag' , '-t' , action = 'append' , dest = 'tags' ,  help = 'Run only checks labeled with given tag.' )	call the method parser.add_argument with 5 arguments: string '--tag', string '-t', action set to string 'append',
parser . add_argument ( '--list-tags' , action = 'store_true' , dest = 'list_tags' ,  help = 'List available tags.' )	dest set to string 'tags' and help set to string 'Run only checks labeled with given tag.'.   call the method parser.add_argument with 4 arguments: string '--list-tags', action set to string 'store_true',
def handle ( self , * app_labels , ** options ) :	dest set to string 'list_tags' and help set to string 'List available tags.'.   define method handle with arguments self, unapcked list app_labels and unpacked dictionary options.
if options . get ( 'list_tags' ) :	if value under the 'list_tags' key of options dictionay is true,
\self . stdout . write ( '\\n' . join ( sorted ( registry . tags_available ( ) ) ) )\	call the method registry.tags_available, sort the result and join it into a string, separate by newlines, write it to self.stdout.
return	return nothing.
if app_labels :	if app_labels is true,
app_configs = [ apps . get_app_config ( app_label ) for app_label in app_labels ]	call the method apps.get_app_config with an argument app_label, for every app_label in app_labels, append the results to a list,
else :	substitute the resulting list for app_config.   if not,
app_configs = None	app_configs is None.
tags = options . get ( 'tags' , None )	get the value under the 'tags' key of the options dictionary, if it exists substitute it for tags, if not, tags is None.
if tags and any ( not checks . tag_exists ( tag ) for tag in tags ) :	if tags exists and if all elements in the return value of the method checks.tag_exists called with an argument tag,
invalid_tag = next ( tag for tag in tags if not checks . tag_exists ( tag ) )	for every tag in tags, are false,   for every tag in tags, if return value of the method checks.tag_exists called with an argument tag, evaluates to false,
raise CommandError ( 'There is no system check with the '%s' tag.' % invalid_tag )	use tag as an argument to call the iterator method next, substitute the result for invalid_tag.   raise an CommandError exception with an argument string 'There is no system check with the '%s' tag.', where '%s' is replaced with invalid_tag.
self . check ( app_configs = app_configs , tags = tags , display_num_errors = True )	call the method self.check with arguments: app_configs set to app_configs, tags set to tags, display_num_errors set to boolean True.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import codecs	import module codecs.
import glob	import module glob.
import os	import module os.
from django . core . management . base import BaseCommand , CommandError	from django.core.management.base import BaseCommand and CommandError into default name space.
from django . core . management . utils import find_command , popen_wrapper	from django.core.management.utils import find_command and popen_wrapper into default name space.
from django . utils . _os import npath , upath	from django.utils._os import npath and upath into default name space.
def has_bom ( fn ) :	define the function has_bom with fn as argument.
with open ( fn , 'rb' ) as f :	open the file fn in read mode, with file descriptor as f,
sample = f . read ( 4 )	read 4 bytes from file f and store it in sample.
\return sample [ : 3 ] == b'\\xef\\xbb\\xbf' or sample . startswith ( codecs . BOM_UTF16_LE ) or sample . startswith ( codecs . BOM_UTF16_BE )\	\evaluate the boolean expression, if first three characters of sample equals to string of bytes '\\xef\\xbb\\xbf\\',\
def is_writable ( path ) :	of if sample starts with codecs.BOM_UTF16_LE or sample starts with codecs.BOM_UTF16_BE, return the evaluated boolean expression.   define the function is_writable with path as argument,
try :	try,
with open ( path , 'a' ) :	with open file path in append mode,
os . utime ( path , None )	call the os.utime unction, with path and None as arguments.
except ( IOError , OSError ) :	if IOError or OSError exceptions occurred,
return False	return boolean False.
return True	return boolean True.
class Command ( BaseCommand ) :	derive class Command from base class BaseCommand.
help = 'Compiles .po files to .mo files for use with builtin gettext support.'	help is string 'Compiles .po files to .mo files for use with builtin gettext support.'.
requires_system_checks = False	requires_system_checks is boolean False.
leave_locale_alone = True	leave_locale_alone is boolean True.
program = 'msgfmt'	program is string 'msgfmt'
program_options = [ '--check-format' ]	program_options is list containing string '--check-format'.
def add_arguments ( self , parser ) :	define method add_arguments with self class instance and parser as arguments.
parser . add_argument ( '--locale' , '-l' , dest = 'locale' , action = 'append' , default = [ ] ,  help = 'Locale(s) to process (e.g. de_AT). Default is to process all. '  'Can be used multiple times.' )	call the method parser.add_argument with string '--locale', string '-l', dest set to string 'locale', action set to string 'append',
parser . add_argument ( '--exclude' , '-x' , dest = 'exclude' , action = 'append' , default = [ ] ,  help = 'Locales to exclude. Default is none. Can be used multiple times.' )	default as an empty list and help as an string 'Locale(s) to process (e.g. de_AT). Default is to process all. Can be used multiple times.'.   call the method parser.add_argument with string '--exclude', string '-x', dest set to string 'exclude', action set to string 'append',
def handle ( self , ** options ) :	default as an empty list and help as an string 'Locales to exclude. Default is none. Can be used multiple times.'.   define the handle method with self class instance and dictionary **options as arguments.
locale = options . get ( 'locale' )	get the value under the key 'locale' of the options dictionary, substitute it for locale.
exclude = options . get ( 'exclude' )	get the value under the key 'exclude' of the options dictionary, substitute it for exclude.
self . verbosity = int ( options . get ( 'verbosity' ) )	get the value under the key 'exclude' of the options dictionary, convert it to an integer, substitute it for exclude.
if find_command ( self . program ) is None :	if evaluation of the function find_command with self.program as argument equals to None,
raise CommandError ( 'Can't find %s. Make sure you have GNU gettext '  'tools 0.15 or newer installed.' % self . program )	raise CommandError exception, with sring 'Can't find %s. Make sure you have GNU gettext tools 0.15 or newer installed.' as argument, substitute '%s' with self.program.
basedirs = [ os . path . join ( 'conf' , 'locale' ) , 'locale' ]	basedirs is a list containing tuple with strings, 'conf/locale' and 'locale'.
if os . environ . get ( 'DJANGO_SETTINGS_MODULE' ) :	if value under the 'DJANGO_SETTINGS_MODULE' key of os.environ dictionary exists.
from django . conf import settings	from django.conf import settings into default name space.
basedirs . extend ( [ upath ( path ) for path in settings . LOCALE_PATHS ] )	call function update with path as the argument, for every path in settings.LOCALE_PATHS, extend basedirs list with previous items.
basedirs = set ( map ( os . path . abspath , filter ( os . path . isdir , basedirs ) ) )	create a list out of basedir elements for which function os.path.isdir returns true, apply the os.path.abspath function on every element, and put the results in a list, basedir is set of previous list elements.
if not basedirs :	if basedirs is empty,
raise CommandError ( 'This script should be run from the Django Git '  'checkout or your project or app tree, or with '  'the settings module specified.' )	raise CommandError exception with string 'This script should be run from the Django Git checkout or your project or app tree, or with the settings module specified.', as argument.
all_locales = [ ]	all_locales is an empty string.
for basedir in basedirs :	for every basedir in basedirs,
locale_dirs = filter ( os . path . isdir , glob . glob ( '%s/*' % basedir ) )	locale_dirs is a list of elements from the list of path names that maths the basedir path with '/*' wild card characters for which call to the os.path.isdir returned true, assign it to locale_dirs.
all_locales . extend ( map ( os . path . basename , locale_dirs ) )	extend all_locales list with the elements of locale_dirs list on which os.path.basename function was applied.
locales = locale or all_locales	take locale or all_locales, whichever is not empty, respectively, and substitute it for locales.
locales = set ( locales ) - set ( exclude )	locales is relative complement of set exclude in set locales.
for basedir in basedirs :	for every basedir in basedirs,
if locales :	if locales in not empty,
dirs = [ os . path . join ( basedir , l , 'LC_MESSAGES' ) for l in locales ]	join basedir, l and string 'LC_MESSAGES' into a path separated by '/' for every l in locales, assign the list to dirs.
else :	if not,
dirs = [ basedir ]	dirs is a list containing basedir.
locations = [ ]	locations is an empty list.
for ldir in dirs :	for every ldir in dirs,
for dirpath , dirnames , filenames in os . walk ( ldir ) :	for dirpath, dirnames and filenames, respectively, in directory tree tuple starting from the ldir,
locations . extend ( ( dirpath , f ) for f in filenames if f . endswith ( '.po' ) )	extend locations with tuple containing dirpath and f, for every f in filenames, only if it ends with string '.po'.
if locations :	if locations is not empty,
self . compile_messages ( locations )	call the self.compile_messages with locations as argument,
def compile_messages ( self , locations ) :	define compile_messages method with self class instance and locations as a arguments.
for i , ( dirpath , f ) in enumerate ( locations ) :	for every i and tuple containing dirpath and f, in enumerated list of locations,
if self . verbosity > 0 :	if self.verbosity is greater than integer 0,
\self . stdout . write ( 'processing file %s in %s\\n' % ( f , dirpath ) )\	\call the self.stdout.write method with string 'processing file %s in %s\\n' as argument, replacing all the occurrences of '%s' with f and dirpath, respectively.\
po_path = os . path . join ( dirpath , f )	po_path is a string containing joined directory path from dirpath and f.
if has_bom ( po_path ) :	evaluate function has_bom with po_path as argument.
raise CommandError ( 'The %s file has a BOM (Byte Order Mark). '  'Django only supports .po files encoded in '  'UTF-8 and without any BOM.' % po_path )	raise CommandError exception with string 'The %s file has a BOM (Byte Order Mark). Django only supports .po files encoded in UTF-8 and without any BOM.', with '%s' replaced with po_path, as argument.
base_path = os . path . splitext ( po_path ) [ 0 ]	call os.path.splitext function with po_path as argument, substitute the first element of the result for base_path.
if i == 0 and not is_writable ( npath ( base_path + '.mo' ) ) :	if i equals to integer 0 and
self . stderr . write ( 'The po files under %s are in a seemingly not writable location. '  'mo files will not be updated/created.' % dirpath )	call the self.stderr.write, with string 'The po files under %s are in a seemingly not writable location. mo files will not be updated/created.' as argument, with '%s' replaced by dirpath.
return	return nothing.
args = [ self . program ] + self . program_options + [ '-o' ,  npath ( base_path + '.mo' ) , npath ( base_path + '.po' ) ]	extend self.program list with self.program_options, string '-o',
output , errors , status = popen_wrapper ( args )	return value of the npath function with string '.mo' appended to the base_path as argument,   and return value of the npath function with string '.po' appended to the base_path as argument, substitute it for args.   call the popen_wrapper with args as the argument, assign the result to the output, errors and status, respectively.
if status :	if status is True,
if errors :	if errors is True,
msg = 'Execution of %s failed: %s' % ( self . program , errors )	msg is a string 'Execution of %s failed: %s', with '%s' replaced by self.program and errors.
else :	if not,
msg = 'Execution of %s failed' % self . program	msg is a string 'Execution of %s failed', with '%s' replaced by self.program.
raise CommandError ( msg )	raise CommandError exception with msg as argument.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . cache import caches	from django.core.cache import caches into default name space.
from django . core . cache . backends . db import BaseDatabaseCache	from django.core.cache.backends.db import BaseDatabaseCache into default name space.
from django . core . management . base import BaseCommand , CommandError	from django.core.management.base import BaseCommand and CommandError into default name space.
from django . db import connections , router , transaction , models , DEFAULT_DB_ALIAS	from django.db import connections, router, transaction, models and DEFAULT_DB_ALIAS into default name space.
from django . db . utils import DatabaseError	from django.db.utils import DatabaseError into default name space.
from django . utils . encoding import force_text	from django.utils.encoding import force_text into default name space.
class Command ( BaseCommand ) :	derive the class Command from the BaseCommand base class.
help = 'Creates the tables needed to use the SQL cache backend.'	help is an string 'Creates the tables needed to use the SQL cache backend.'.
requires_system_checks = False	requires_system_checks is boolean False.
def add_arguments ( self , parser ) :	define the method add_arguments with arguments self and parser.
parser . add_argument ( 'args' , metavar = 'table_name' , nargs = '*' ,  help = 'Optional table names. Otherwise, settings.CACHES is used to '  'find cache tables.' )	call the method parser.add_argument with 4 arguments: string 'args', metavar set to string 'table_name', nargs set to '*' character,
parser . add_argument ( '--database' , action = 'store' , dest = 'database' ,  default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database onto which the cache tables will be '  'installed. Defaults to the 'default' database.' )	and help set to a string 'Optional table names. Otherwise, settings.CACHES is used to find cache tables.' .   call the method parser.add_argument with 5 arguments: string '--database', action set to string 'store', dest as a string 'database',
def handle ( self , * tablenames , ** options ) :	default set to DEFAULT_DB_ALIAS and help set to a string:   'Nominates a database onto which the cache tables will be installed. Defaults to the 'default' database.'   define the method handle with arguments self, unpacked list tablenames and unpacked dictionary options.
db = options . get ( 'database' )	get value under the 'database' key of the options dictionary, substitute it for db.
self . verbosity = int ( options . get ( 'verbosity' ) )	get the value under the 'verbosity' key of the options dictionary, convet it to an integer and substitute for self.verbosity.
if len ( tablenames ) :	if length of tablenames is greater than zero,
for tablename in tablenames :	for every tablename in tablenames,
self . create_table ( db , tablename )	call the method self.create_table with arguments: db and tablename.
else :	if not,
for cache_alias in settings . CACHES :	for every cache_alias in settings.CACHES,
cache = caches [ cache_alias ]	substitute value under the cache_alias key of the caches dictionary for cache.
if isinstance ( cache , BaseDatabaseCache ) :	if cache is an instance of BaseDatabaseCache,
self . create_table ( db , cache . _table )	all the method self.create_table with arguments: db and cache._table.
def create_table ( self , database , tablename ) :	define the method create_table with arguments self, database and tablename.
cache = BaseDatabaseCache ( tablename , { } )	cache is an instance of BaseDatabaseCache class, created with arguments: tablename and an empty dictionary.
if not router . allow_migrate ( database , cache . cache_model_class ) :	call the method router.allow_migrate with 2 arguments: database and cache.cache_model_class, if it evaluates to false,
return	return nothing.
connection = connections [ database ]	substitute value under the database key of the connections dictionary for connection.
if tablename in connection . introspection . table_names ( ) :	if tablename is contained in return value of the method connection.introspection.table_names,
if self . verbosity > 0 :	if self.verbosity is greater than integer 0,
self . stdout . write ( 'Cache table '%s' already exists.' % tablename )	replace '%s' in string 'Cache table '%s' already exists.' with tablename, write it to the self.stdout stream.
return	return nothing.
fields = (   models . CharField ( name = 'cache_key' , max_length = 255 , unique = True , primary_key = True ) ,  models . TextField ( name = 'value' ) ,  models . DateTimeField ( name = 'expires' , db_index = True ) ,  )	fields is an tuple containing 3 entries: return value of the method models.CharField called with 4 arguments:
table_output = [ ]	name set to a string 'cache_key', max_length set to integer 255, unique set to boolean True and primary_key set to boolean True,   return value of the method models.TextField called with argument name set to a string 'value',   and return value of the method models.DateTimeField called with 2 arguments: name set to string 'expires' and db_index set to True.   table_output is an empty list.
index_output = [ ]	index_output is an empty list.
qn = connection . ops . quote_name	substitute connection.ops.quote_name for qn.
for f in fields :	for every f in fields,
field_output = [ qn ( f . name ) , f . db_type ( connection = connection ) ]	field_output is an list containing 2 elements: return value of the function qn called with an argument f.name,
field_output . append ( '%sNULL' % ( 'NOT ' if not f . null else '' ) )	and return value of the function f.db_type called with an argument connection set to connection.   if f.null is false, append string append 'NOT NULL' to field_output, otherwise append 'NULL' to field_output.
if f . primary_key :	if f.primary_key is true,
field_output . append ( 'PRIMARY KEY' )	append string 'PRIMARY KEY' to field_output.
elif f . unique :	otherwise if f.unique is true,
field_output . append ( 'UNIQUE' )	append string 'UNIQUE' to field_output.
if f . db_index :	if f.db_index is true,
unique = 'UNIQUE ' if f . unique else ''	if f.unique is true, substitute 'UNIQUE ' for unique, otherwise unique is an empty string.
index_output . append ( 'CREATE %sINDEX %s ON %s (%s);' %  ( unique , qn ( '%s_%s' % ( tablename , f . name ) ) , qn ( tablename ) ,  qn ( f . name ) ) )	replace '%s' in string 'CREATE %sINDEX %s ON %s (%s);' with: unique, return value of the function qn called with an argument:
table_output . append ( ' ' . join ( field_output ) )	a string '%s_%s', where '%s' is replaced with tablename and f.name, respectively,   return value of the function qn called with an argument tablename and return value of the function qn called with an argument f.name.   join field_output elements into a string, separated by whitespaces, append it to table_output.
full_statement = [ 'CREATE TABLE %s (' % qn ( tablename ) ]	full_statement is a list containing: string 'CREATE TABLE %s (', where %s is replaced by result of the function qn called with an argument tablename.
for i , line in enumerate ( table_output ) :	for every i and line in enumerated iterable table_output,
full_statement . append ( '    %s%s' % ( line , ',' if i < len ( table_output ) - 1 else '' ) )	replace %s in string '    %s%s' with: line and character ',' if i is lesser than length of table_output decremented by one,
full_statement . append ( ');' )	or with an empty string if its not, append the resulting string to full_statement.   append string ');' to full_statement.
with transaction . atomic ( using = database ,  savepoint = connection . features . can_rollback_ddl ) :	evaluate method transaction.atomic with arguments: using set to database and savepoint set to connection.features.can_rollback_ddl,
with connection . cursor ( ) as curs :	with the result,   evaluate method connection.cursor, with return value as curs,
try :	try,
\curs . execute ( '\\n' . join ( full_statement ) )\	join full_statement into a string, separated by newlines, use it as an argument for the call to the method curs.execute.
except DatabaseError as e :	if DatabaseError, renamed to e, exception is caught,
\raise CommandError (  'Cache table '%s' could not be created.\\nThe error was: %s.' %  ( tablename , force_text ( e ) ) )\	\raise an CommandError with an argument string 'Cache table '%s' could not be created.\\nThe error was: %s.', replace '%s' with:\
for statement in index_output :	tablename and return value of the function force_text called with an argument e, respectively.   for every statement in index_output,
curs . execute ( statement )	execute statement on the database that curs points to.
if self . verbosity > 1 :	if self.verbosity is greater than integer 1,
self . stdout . write ( 'Cache table '%s' created.' % tablename )	replace '%s' in string 'Cache table '%s' created.' with tablename, write it to self.stdout.
from django . core . management . base import BaseCommand , CommandError	from django.core.management.base import BaseCommand and CommandError into default name space.
from django . db import connections , DEFAULT_DB_ALIAS	from django.db import connections and DEFAULT_DB_ALIAS into default name space.
class Command ( BaseCommand ) :	derive the class Command from the BaseCommand base class.
help = ( 'Runs the command-line client for specified database, or the '  'default database if none is provided.' )	help is a tuple containing a string 'Runs the command-line client for specified database, or the default database if none is provided.'.
requires_system_checks = False	requires_system_checks is boolean False.
def add_arguments ( self , parser ) :	define the method add_arguments with self and parser.
parser . add_argument ( '--database' , action = 'store' , dest = 'database' ,  default = DEFAULT_DB_ALIAS , help = 'Nominates a database onto which to '  'open a shell. Defaults to the 'default' database.' )	call the method parser.add_argument with arguments: string '--database', action set to string 'store', dest set to string 'database',
def handle ( self , ** options ) :	default set to DEFAULT_DB_ALIAS and help set to string 'Nominates a database onto which to open a shell. Defaults to the 'default' database.'.   define the method handle with arguments self and unpacked dictionary options.
connection = connections [ options . get ( 'database' ) ]	get the value under the 'database' key of the options dictionary, use it as a key to access the element under the connections dictionary, substitute it for connection.
try :	try,
connection . client . runshell ( )	call the method connection.client.runshell.
except OSError :	if OSError exception is caught,
raise CommandError ( 'You appear not to have the %r program installed or on your path.' %  connection . client . executable_name )	raise an CommandError exception with an argument string 'You appear not to have the %r program installed or on your path.',
from django . core . management . base import BaseCommand	from django.core.management.base import BaseCommand into default name space.
def module_to_dict ( module , omittable = lambda k : k . startswith ( '_' ) ) :	define the function module_to_dict with 2 arguments: module and omittable as a lambda function with an argument k,
return dict ( ( k , repr ( v ) ) for k , v in module . __dict__ . items ( ) if not omittable ( k ) )	return dictionary created out of tuple elements k and printable representation of v,
class Command ( BaseCommand ) :	for every k and v in return value of the method module.__dict__.items, only if result of the method omittable called with an argument k is false.   derive the class Command from the BaseCommand base class.
requires_system_checks = False	requires_system_checks is boolean False.
def add_arguments ( self , parser ) :	define the method add_arguments with 2 arguments self and parser.
parser . add_argument ( '--all' , action = 'store_true' , dest = 'all' , default = False ,  help = 'Display all settings, regardless of their value. '  'Default values are prefixed by '###'.' )	call the method parser.add_argument with 5 arguments: string '--all', action set to string 'store_true', dest set to string 'all',
def handle ( self , ** options ) :	default set to boolean False and help set to a string 'Display all settings, regardless of their value. Default values are prefixed by '###'.'   define the method handle with arguments self and unpacked dictionary options.
from django . conf import settings , global_settings	from django.conf import settings, global_settings into default name space.
settings . _setup ( )	call the method settings._setup.
user_settings = module_to_dict ( settings . _wrapped )	call the function module_to_dict with an argument settings._wrapped, substitute it for user_settings.
default_settings = module_to_dict ( global_settings )	call the function module_to_dict with an argument global_settings, substitute it for default_settings.
output = [ ]	output is an empty string.
for key in sorted ( user_settings ) :	for every key in sorted list of user_settings,
if key not in default_settings :	if key is not contained in default_settings,
output . append ( '%s = %s  ###' % ( key , user_settings [ key ] ) )	replace '%s' in string '%s = %s  ###' with key and value under the key key of the user_setting dictionary, append it to the output.
elif user_settings [ key ] != default_settings [ key ] :	otherwise if value under the key key of the user_settings dictionary is not equal to the value under the key key of the default_settings dictionary,
output . append ( '%s = %s' % ( key , user_settings [ key ] ) )	replace '%s' in string '%s = %s' with key and value under the key key of the user_setting dictionary, append it to the output.
elif options [ 'all' ] :	otherwise if value under the key 'all' of the options dictionary is true,
output . append ( '### %s = %s' % ( key , user_settings [ key ] ) )	replace '%s' in string '### %s = %s' with key and value under the key key of the user_setting dictionary, append it to the output.
\return '\\n' . join ( output )\	join elements of the output into a string, separated by newlies, return the string.
import warnings	import module warnings.
from collections import OrderedDict	from collections import OrderedDict into default name space.
from django . apps import apps	from django.apps import apps into default name space.
from django . core . management . base import BaseCommand , CommandError	from django.core.management.base import BaseCommand and CommandError into default name space.
from django . core import serializers	from django.core import serializers into default name space.
from django . db import router , DEFAULT_DB_ALIAS	from django.db import router and DEFAULT_DB_ALIAS into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
class Command ( BaseCommand ) :	derive the class Command from the BaseCommand base class.
help = ( 'Output the contents of the database as a fixture of the given '  'format (using each model's default manager unless --all is '  'specified).' )	help is a tuple containing a string 'Output the contents of the database as a fixture of the given '
def add_arguments ( self , parser ) :	format (using each model's default manager unless --all is specified)..   define the method add_arguments with arguments self and parser.
parser . add_argument ( 'args' , metavar = 'app_label[.ModelName]' , nargs = '*' ,  help = 'Restricts dumped data to the specified app_label or app_label.ModelName.' )	call the method parser.add_argument with 4 arguments: string 'args', metavar set to string 'app_label[.ModelName]',
parser . add_argument ( '--format' , default = 'json' , dest = 'format' ,  help = 'Specifies the output serialization format for fixtures.' )	nargs set to '*' and help is a string 'Restricts dumped data to the specified app_label or app_label.ModelName.'.   call the method parser.add_argument with 4 arguments: string '--format', default set to string 'json',
parser . add_argument ( '--indent' , default = None , dest = 'indent' , type = int ,  help = 'Specifies the indent level to use when pretty-printing output.' )	dest set to 'format' and help is a string 'Specifies the output serialization format for fixtures.'.   call the method parser.add_argument with 5 arguments: string '--indent', default set to None, dest set to 'indent',
parser . add_argument ( '--database' , action = 'store' , dest = 'database' ,  default = DEFAULT_DB_ALIAS ,  help = 'Nominates a specific database to dump fixtures from. '  'Defaults to the 'default' database.' )	type set to int and help is a string 'Specifies the indent level to use when pretty-printing output.'.   call the method parser.add_argument with 5 arguments: string '--database', default set to string 'store', dest set to 'database',
parser . add_argument ( '-e' , '--exclude' , dest = 'exclude' , action = 'append' , default = [ ] ,  help = 'An app_label or app_label.ModelName to exclude '  '(use multiple --exclude to exclude multiple apps/models).' )	add set to DEFAULT_DB_ALIAS and help is 'Nominates a specific database to dump fixtures from. Defaults to the 'default' database.'.   call the method parser.add_argument with 6 arguments: string '-e', string '--exclude', dest set to 'exclude', action set to 'append',
parser . add_argument ( '-n' , '--natural' , action = 'store_true' , dest = 'use_natural_keys' , default = False ,  help = 'Use natural keys if they are available (deprecated: use --natural-foreign instead).' )	default is a an empty list and help is a string '(use multiple --exclude to exclude multiple apps/models).'.   call the method parser.add_argument with 6 arguments: string '-n', string '--natural', action is string 'store_true', dest is string 'use_natural_keys',
parser . add_argument ( '--natural-foreign' , action = 'store_true' , dest = 'use_natural_foreign_keys' , default = False ,  help = 'Use natural foreign keys if they are available.' )	default is boolean False and help is a string 'Use natural keys if they are available (deprecated: use --natural-foreign instead).'.   call the method parser.add_argument with 5 arguments: string '--natural-foreign', action set to string 'store_true',
parser . add_argument ( '--natural-primary' , action = 'store_true' , dest = 'use_natural_primary_keys' , default = False ,  help = 'Use natural primary keys if they are available.' )	dest is string 'use_natural_foreign_keys', default is boolean False and help is a string 'Use natural foreign keys if they are available.'.   call the method parser.add_argument with 5 arguments: string '--natural-primary', action set to 'store_true',
parser . add_argument ( '-a' , '--all' , action = 'store_true' , dest = 'use_base_manager' , default = False ,  help = 'Use Django's base manager to dump all models stored in the database, '  'including those that would otherwise be filtered or modified by a custom manager.' )	dest is 'use_natural_primary_keys', default is boolean False and help is a string 'Use natural primary keys if they are available.'.   call the method parser.add_argument with 6 arguments: string '-a', string '--all', action set to 'store_true',
parser . add_argument ( '--pks' , dest = 'primary_keys' ,  help = 'Only dump objects with given primary keys. '  'Accepts a comma separated list of keys. '  'This option will only work when you specify one model.' )	dest is 'use_base_manager', default is boolean False and help is a string '(use multiple --exclude to exclude multiple apps/models).'.   call the method parser.add_argument with 3 arguments: string '--pks', dest set to string 'primary_keys',
parser . add_argument ( '-o' , '--output' , default = None , dest = 'output' ,  help = 'Specifies file to which the output is written.' )	and help is a string 'Only dump objects with given primary keys. Accepts a comma separated list of keys. '   'This option will only work when you specify one model.'.   call the method parser.add_argument with 5 arguments: string '-o', string '--output', default is None, dest set to string 'output',
def handle ( self , * app_labels , ** options ) :	and help is a string 'Specifies file to which the output is written.'.   define the method handle with arguments self, unpacked list app_labels and unpacked dictionary options.
format = options . get ( 'format' )	get the value under the 'format' key of the options dictionary, substitute the result for format.
indent = options . get ( 'indent' )	get the value under the 'indent' key of the options dictionary, substitute the result for indent.
using = options . get ( 'database' )	get the value under the 'database' key of the options dictionary, substitute the result for database.
excludes = options . get ( 'exclude' )	get the value under the 'exclude' key of the options dictionary, substitute the result for exclude.
output = options . get ( 'output' )	get the value under the 'output' key of the options dictionary, substitute the result for output.
show_traceback = options . get ( 'traceback' )	get the value under the 'traceback' key of the options dictionary, substitute the result for traceback.
use_natural_keys = options . get ( 'use_natural_keys' )	get the value under the 'use_natural_keys' key of the options dictionary, substitute the result for use_natural_keys.
if use_natural_keys :	if use_natural_keys is true,
warnings . warn ( '``--natural`` is deprecated; use ``--natural-foreign`` instead.' ,  RemovedInDjango19Warning )	call the function warnings.warn with an argument string '``--natural`` is deprecated; use ``--natural-foreign`` instead.',
use_natural_foreign_keys = options . get ( 'use_natural_foreign_keys' ) or use_natural_keys	and RemovedInDjango19Warning.   get the value under the ' use_natural_foreign_keys' key of the options dictionary, substitute the result for  use_natural_foreign_keys.
use_natural_primary_keys = options . get ( 'use_natural_primary_keys' )	get the value under the 'use_natural_primary_keys' key of the options dictionary, substitute the result for use_natural_primary_keys.
use_base_manager = options . get ( 'use_base_manager' )	get the value under the 'use_base_manager' key of the options dictionary, substitute the result for use_base_manager.
pks = options . get ( 'primary_keys' )	get the value under the 'primary_keys' key of the options dictionary, substitute the result for pks.
if pks :	if pks is true,
primary_keys = pks . split ( ',' )	split string pks by ',', substitute the result for primary_keys.
else :	if not,
primary_keys = [ ]	primary_keys is an empty list.
excluded_apps = set ( )	excluded_apps is an empty set.
excluded_models = set ( )	excluded_models is an empty set.
for exclude in excludes :	for every exclude in excludes,
if '.' in exclude :	if '.' is contained in exclude,
try :	try,
model = apps . get_model ( exclude )	call the method apps.get_model with exclude as an argument, substitute it for model.
except LookupError :	if LookupError exception is caught,
raise CommandError ( 'Unknown model in excludes: %s' % exclude )	raise an CommandError exception with an argument string 'Unknown model in excludes: %s', where '%s' is replaced with exclude.
excluded_models . add ( model )	add model to excluded_models set.
else :	if not,
try :	try,
app_config = apps . get_app_config ( exclude )	call the method apps.get_app_config with an argument exclude, substitute the result for app_config.
except LookupError :	if LookupError exception is caught,
raise CommandError ( 'Unknown app in excludes: %s' % exclude )	  raise CommandError with an argument string 'Unknown app in excludes: %s', where '%s' is replaced with exclude.
excluded_apps . add ( app_config )	add app_config to excluded_apps set.
if len ( app_labels ) == 0 :	if length of app_labels equals integer 0,
if primary_keys :	if primary_keys is true,
raise CommandError ( 'You can only use --pks option with one model' )	raise an CommandError exception with an argument string 'You can only use --pks option with one model'.
app_list = OrderedDict ( ( app_config , None )  for app_config in apps . get_app_configs ( )  if app_config . models_module is not None and app_config not in excluded_apps )	app_list is an instance of OrderedDict class, created with an argument a tuple containing elements: app_config and None,
else :	for every app_config in return value of the method apps.get_app_configs, only if app_config.models_module is not None,   and app_config is not contained in excluded_apps.   if not,
if len ( app_labels ) > 1 and primary_keys :	if length of app_labels is greater than integer 1 and primary_keys is true,
raise CommandError ( 'You can only use --pks option with one model' )	raise an CommandError exception with an argument string 'You can only use --pks option with one model'.
app_list = OrderedDict ( )	app_list is an instance of a class OrderedDict.
for label in app_labels :	for every label in app_labels,
try :	try,
app_label , model_label = label . split ( '.' )	split label by '.', assign the result to app_label and model_label, respectively.
try :	try,
    app_config = apps . get_app_config ( app_label )	call the method apps.get_app_config with an argument app_label, substitute the result for app_config.
except LookupError :	if LookupError exception is caught,
    raise CommandError ( 'Unknown application: %s' % app_label )	raise CommandError with an argument string 'Unknown app in excludes: %s', where '%s' is replaced with exclude.
if app_config . models_module is None or app_config in excluded_apps :	  if app_config.models_module is None or app_config is contained in excluded_apps,
    continue	skip this loop iteration.
try :	try,
    model = app_config . get_model ( model_label )	call the method app_config.get_model with an argument model_label, substitute the result for model.
except LookupError :	if LookupError exception is caught,
    raise CommandError ( 'Unknown model: %s.%s' % ( app_label , model_label ) )	raise CommandError with an argument string 'Unknown model: %s', where '%s' is replaced with app_label and model_label, respectively.
app_list_value = app_list . setdefault ( app_config , [ ] )	call the method app_list.setdefault with 2 arguments app_config and an empty list, substitute the result for app_list_value.
if app_list_value is not None :	if app_list_value is not None,
    if model not in app_list_value :	if mode is not contained in app_list_value,
        app_list_value . append ( model )	append model to app_list_value.
except ValueError :	if ValueError exception is caught,
if primary_keys :	if primary_keys is true,
    raise CommandError ( 'You can only use --pks option with one model' )	raise an CommandError exception with an argument string 'You can only use --pks option with one model'.
app_label = label	substitute label for app_label.
try :	try,
    app_config = apps . get_app_config ( app_label )	call the method apps.get_app_config with an argument app_label, substitute the result for app_config.
except LookupError :	if LookupError exception is caught,
    raise CommandError ( 'Unknown application: %s' % app_label )	raise CommandError with an argument string 'Unknown application: %s', where '%s' is replaced with app_label.
if app_config . models_module is None or app_config in excluded_apps :	if app_config.models_module is None or app_config is contained in excluded_apps
    continue	skip this loop iteration.
app_list [ app_config ] = None	value under the app_config key of the app_list is None.
if format not in serializers . get_public_serializer_formats ( ) :	if format is not contained in return value of the method serializers.get_public_serializer_formats,
try :	try,
serializers . get_serializer ( format )	call the method serializers.get_serializer with an argument format.
except serializers . SerializerDoesNotExist :	if serializers.SerializerDoesNotExist exception is caught,
pass	do nothing.
raise CommandError ( 'Unknown serialization format: %s' % format )	raise CommandError with an argument string 'Unknown serialization format: %s', where '%s' is replaced with format.
def get_objects ( ) :	define the function get_objects.
for model in sort_dependencies ( app_list . items ( ) ) :	call the method app_list.items, use the result as an argument for the call to the function sort_dependencies, for every model in result,
if model in excluded_models :	if model is contained in excluded_models,
continue	skip this loop iteration.
if not model . _meta . proxy and router . allow_migrate ( using , model ) :	if model._meta.proxy is false and return value of the function router.allow_migrate called with arguments using and model is true,
if use_base_manager :	if use_base_manager is true,
    objects = model . _base_manager	substitute model._base_manager for objects.
else :	if not,
    objects = model . _default_manager	substitute model._default_manager for objects.
queryset = objects . using ( using ) . order_by ( model . _meta . pk . name )	call the method objects.using with an argument using, call the method order_by on the result with an argument model._meta.pk.name,
if primary_keys :	substitute the result for queryset.   if primary_keys is true,
    queryset = queryset . filter ( pk__in = primary_keys )	call the method queryset.filter with an argument pk__in set to primary_keys, substitute the result for queryset.
for obj in queryset . iterator ( ) :	for every obj in result of the method queryset.iterator,
    yield obj	yield obj, as an return value of the generator.
try :	try,
self . stdout . ending = None	self.stdout.ending is None.
stream = open ( output , 'w' ) if output else None	open the output file in writing mode if output is true, assign the file descriptor to stream, otherwise stream is None.
try :	try,
serializers . serialize ( format , get_objects ( ) , indent = indent ,  use_natural_foreign_keys = use_natural_foreign_keys ,  use_natural_primary_keys = use_natural_primary_keys ,  stream = stream or self . stdout )	call the method serializers.serialize with 6 arguments: format, result of the function get_objects, indent set to indent,
finally :	use_natural_foreign_keys set to use_natural_foreign_keys, use_natural_primary_keys set to use_natural_primary_keys,   and stream set to stream, if the stream is true, otherwise stream set to self.stdout.   finally perform,
if stream :	if stream is true,
stream . close ( )	close the file stream.
except Exception as e :	if Exception, renamed to e, exception is caught,
if show_traceback :	if show_traceback is true,
raise	raise an exception.
raise CommandError ( 'Unable to serialize database: %s' % e )	raise CommandError with an argument string 'Unable to serialize database: %s', where '%s' is replaced with e.
def sort_dependencies ( app_list ) :	define the function sort_dependencies with an argument app_list.
model_dependencies = [ ]	model_dependencies is an empty list.
models = set ( )	models is an empty set.
for app_config , model_list in app_list :	for every app_config and model_list in app_list,
if model_list is None :	if model_list is None,
model_list = app_config . get_models ( )	call the method app_config.get_models, substitute the result fr model_list.
for model in model_list :	for every model in model_list,
models . add ( model )	add model to models set.
if hasattr ( model , 'natural_key' ) :	if model has an 'natural_key' attribute,
deps = getattr ( model . natural_key , 'dependencies' , [ ] )	get 'dependencies' attribute of the model.natural_key, substitute it for deps, if the attribute doesnt exist, deps in an empty list.
if deps :	if deps is true,
deps = [ apps . get_model ( dep ) for dep in deps ]	for every dep in deps call the method apps.get_model with an argument dep, and append the result to the list, substitute it for deps.
else :	if not,
deps = [ ]	deps is an empty list.
for field in model . _meta . fields :	for every field in model._meta.fields,
if hasattr ( field . rel , 'to' ) :	if field.rel has an 'to' attribute,
rel_model = field . rel . to	substitute field.rel.to with rel_model.
if hasattr ( rel_model , 'natural_key' ) and rel_model != model :	if rel_model has an attribute 'natural_key' and rel_model is not equal to model,
    deps . append ( rel_model )	append rel_model to deps.
for field in model . _meta . many_to_many :	for every field in model._meta.many_to_many,
if field . rel . through . _meta . auto_created :	if field.rel.through._meta.auto_created is true,
rel_model = field . rel . to	substitute field.rel.to for rel_model.
if hasattr ( rel_model , 'natural_key' ) and rel_model != model :	if rel_model has an 'natural_key' attribute and rel_model is not equal to model,
    deps . append ( rel_model )	append rel_model to deps.
model_dependencies . append ( ( model , deps ) )	append a tuple containing 2 elements: model and deps to model_dependencies.
model_dependencies . reverse ( )	call the methof model_dependencies.reverse.
model_list = [ ]	model_list is an empty list.
while model_dependencies :	while model_dependencies is true,
skipped = [ ]	skipped is an empty list.
changed = False	changed is boolean False.
while model_dependencies :	while model_dependencies is true,
model , deps = model_dependencies . pop ( )	remove first element from model_dependencies, assign it to model and deps, respectively.
found = True	found is boolean True.
for candidate in ( ( d not in models or d in model_list ) for d in deps ) :	for every d in deps, if d is not contained in models and d is contained in model_list add boolean True to a tuple,
if not candidate :	otherwise add boolean False, for every candidate in the result perform following,   if candidate is false,
found = False	found is boolean False.
if found :	if found is true,
model_list . append ( model )	append model to model_list.
changed = True	changed is boolean True.
else :	if not,
skipped . append ( ( model , deps ) )	append a tuple containing 2 elemetns: model and deps, to skipped.
if not changed :	if changed is false,
raise CommandError ( 'Can't resolve dependencies for %s in serialized app list.' %  ', ' . join ( '%s.%s' % ( model . _meta . app_label , model . _meta . object_name )  for model , deps in sorted ( skipped , key = lambda obj : obj [ 0 ] . __name__ ) )  )	raise an CommandError with argument: string 'Can't resolve dependencies for %s in serialized app list.', where '%s' is replaced with:
model_dependencies = skipped	model._meta.app_label and model._meta.object_name joined into a string, with separator '.',   result joined into a string, separated by string ', ' for every model and deps in sorted list of elements skipped sorted by key:   return value of the lambda function with an argument obj, and result the __name__ field of the first element of obj.   substitute skipped for model_dependencies.
return model_list	return model_list.
import sys	import module sys.
from importlib import import_module	from importlib import import_module into default name space.
from django . apps import apps	from django.apps import apps into default name space.
from django . db import connections , router , transaction , DEFAULT_DB_ALIAS	from django.db import connections, router, transaction and DEFAULT_DB_ALIAS into default name space.
from django . core . management import call_command	from django.core.management import call_command into default name space.
from django . core . management . base import BaseCommand , CommandError	from django.core.management.base import BaseCommand and CommandError into default name space.
from django . core . management . color import no_style	from django.core.management.color import no_style into default name space.
from django . core . management . sql import sql_flush , emit_post_migrate_signal	from django.core.management.sql import sql_flush and emit_post_migrate_signal into default name space.
from django . utils . six . moves import input	from django.utils.six.moves import input into default name space.
from django . utils import six	from django.utils import six into default name space.
class Command ( BaseCommand ) :	derive the class Command from the BaseCommand base class.
help = ( 'Removes ALL DATA from the database, including data added during '  'migrations. Unmigrated apps will also have their initial_data '  'fixture reloaded. Does not achieve a 'fresh install' state.' )	help is a tuple containing a string: 'Removes ALL DATA from the database, including data added during '
def add_arguments ( self , parser ) :	'migrations. Unmigrated apps will also have their initial_data fixture reloaded. Does not achieve a 'fresh install' state.'   define the add_arguments with arguments self and parser.
parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )	call the method parser.add_argument with 5 arguments: string '--noinput', action set to string 'store_false',
parser . add_argument ( '--database' , action = 'store' , dest = 'database' ,  default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to flush. Defaults to the 'default' database.' )	dest set to string 'interactive', default set to boolean True, help as a string 'Tells Django to NOT prompt the user for input of any kind.'.   call the method parser.add_argument with 5 arguments: string '--database', action set to string 'store', dest as a string 'database',
parser . add_argument ( '--no-initial-data' , action = 'store_false' ,  dest = 'load_initial_data' , default = True ,  help = 'Tells Django not to load any initial data after database synchronization.' )	default set to DEFAULT_DB_ALIAS and help as a string 'Nominates a database to flush. Defaults to the 'default' database.'.   call the method parser.add_argument with 5 arguments: string '--no-initial-data', action set to string 'store_false',
def handle ( self , ** options ) :	dest set to string 'load_initial_data', default=True and help as a string 'Tells Django not to load any initial data after database synchronization.'.   define the method handle with arguments self and unpacked dictionary options.
database = options . get ( 'database' )	substitute value under the 'database' key of the options dictionary for database.
connection = connections [ database ]	substitute value under the database key of the connections dictionary for connection.
verbosity = options . get ( 'verbosity' )	substitute value under the 'verbosity' key of the options dictionary for verbosity.
interactive = options . get ( 'interactive' )	substitute value under the 'interactive' key of the options dictionary for interactive.
reset_sequences = options . get ( 'reset_sequences' , True )	get the value 'reset_sequences' key of the options dictionary, if it exists substitute it for reset_sequences, otherwise reset_sequences is boolean True.
allow_cascade = options . get ( 'allow_cascade' , False )	get the value 'allow_cascade' key of the options dictionary, if it exists substitute it for allow_cascade, otherwise allow_cascade is boolean False.
inhibit_post_migrate = options . get ( 'inhibit_post_migrate' , False )	get the value 'inhibit_post_migrate' key of the options dictionary, if it exists substitute it for inhibit_post_migrate, otherwise inhibit_post_migrate is boolean False.
self . style = no_style ( )	call the function no_style, substitute it for self.style.
for app_config in apps . get_app_configs ( ) :	for every app_config in return value of the method apps.get_app_configs,
try :	try,
import_module ( '.management' , app_config . name )	call the function import_module with 2 arguments: string .management and app_config.name.
except ImportError :	if ImportError exception is caught,
pass	do nothing.
sql_list = sql_flush ( self . style , connection , only_django = True ,  reset_sequences = reset_sequences ,  allow_cascade = allow_cascade )	call the method sql_flush with 5 arguments: self.style, connection, only_django set to boolean True,
if interactive :	reset_sequences set to reset_sequences, allow_cascade set to allow_cascade, substitute the result for sql_list.   if interactive is true,
confirm = input ( '''You have requested a flush of the database. This will IRREVERSIBLY DESTROY all data currently in the %r database, and return each table to an empty state. Are you sure you want to do this?     Type 'yes' to continue, or 'no' to cancel: ''' % connection . settings_dict [ 'NAME' ] )	request user input from the standard input, assign it o confirm, with the query string: 'You have requested a flush of the database.'
else :	This will IRREVERSIBLY DESTROY all data currently in the %r database, and return each table to an empty state.   'Are you sure you want to do this?'Type 'yes' to continue, or 'no' to cancel: ', where '%s' is replaced with value under the 'NAME' key of the connection.settings_dict dictionary.   if not,
confirm = 'yes'	confirm is a string 'yes'.
if confirm == 'yes' :	if confirm equals a string 'yes',
try :	try,
with transaction . atomic ( using = database ,  savepoint = connection . features . can_rollback_ddl ) :	call the method transaction.atomic with 2 arguments: using set to database, savepoint set to connection.features.can_rollback_ddl,
with connection . cursor ( ) as cursor :	with the result,   call the method connection.cursor, with the result as cursor,
    for sql in sql_list :	for every sql in sql_list,
        cursor . execute ( sql )	call the method cursor.execute with an argument sql.
except Exception as e :	if Exception, renamed to e, exception is caught,
\new_msg = (  'Database %s couldn't be flushed. Possible reasons:\\n'  '  * The database isn't running or isn't configured correctly.\\n'  '  * At least one of the expected database tables doesn't exist.\\n'  '  * The SQL was invalid.\\n'  'Hint: Look at the output of 'django-admin.py sqlflush'. That's the SQL this command wasn't able to run.\\n'  'The full error: %s' ) % ( connection . settings_dict [ 'NAME' ] , e )\	\new_msg is a tuple containing a string: 'Database %s couldn't be flushed. Possible reasons:\\n'\
six . reraise ( CommandError , CommandError ( new_msg ) , sys . exc_info ( ) [ 2 ] )	\  * The database isn't running or isn't configured correctly.\\n  * At least one of the expected database tables doesn't exist.\\n   '  * The SQL was invalid.\\nHint: Look at the output of 'django-admin.py sqlflush'. That's the SQL this command wasn't able to run.\\n'   'The full error: %s', where '%s' is replaced by value under the 'NAME' key of the connection.settings_dict dictionary and e.   call the function six.reraise with 3 arguments: CommandError, CommandError created with argument new_msg,\
if not inhibit_post_migrate :	and third element of the return value of the function sys.exc_info.   if inhibit_post_migrate is false,
self . emit_post_migrate ( verbosity , interactive , database )	call the method self.emit_post_migrate with arguments verbosity, interactive and database.
if options . get ( 'load_initial_data' ) :	if value under the 'load_initial_data' key of the options dictionary is true,
call_command ( 'loaddata' , 'initial_data' , ** options )	call the function call_command with 3 arguments: string 'loaddata', string 'initial_data' and unpacked dictionary options.
else :	if not,
\self . stdout . write ( 'Flush cancelled.\\n' )\	\write string 'Flush cancelled.\\n' to self.stdout stream.\
@ staticmethod	class static method,
def emit_post_migrate ( verbosity , interactive , database ) :	define the method emit_post_migrate with arguments verbosity, interactive and database.
all_models = [ ]	all_models is an empty list.
for app_config in apps . get_app_configs ( ) :	for every app_config in return value of the method apps.get_app_configs,
all_models . extend ( router . get_migratable_models ( app_config , database , include_auto_created = True ) )	call the method router.get_migratable_models with arguments app_config, database and include_auto_created set to boolean True,
emit_post_migrate_signal ( set ( all_models ) , verbosity , interactive , database )	extend all_models list with the result.   call the function emit_post_migrate_signal with 4 arguments: all_models converted into a set, verbosity, interactive and database.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from collections import OrderedDict	from collections import OrderedDict into default name space.
import keyword	import module keyword.
import re	import module re.
from django . core . management . base import BaseCommand , CommandError	from django.core.management.base import BaseCommand and CommandError into default name space.
from django . db import connections , DEFAULT_DB_ALIAS	from django.db import connections and DEFAULT_DB_ALIAS into default name space.
class Command ( BaseCommand ) :	derive the class Command from the BaseCommand base class.
help = 'Introspects the database tables in the given database and outputs a Django model module.'	help is an string 'Introspects the database tables in the given database and outputs a Django model module.'.
requires_system_checks = False	requires_system_checks is boolean False.
db_module = 'django.db'	db_module is a string 'django.db'.
def add_arguments ( self , parser ) :	define the method add_arguments with arguments self and parser.
parser . add_argument ( '--database' , action = 'store' , dest = 'database' ,  default = DEFAULT_DB_ALIAS , help = 'Nominates a database to '  'introspect. Defaults to using the 'default' database.' )	call the method parser.add_argument with 5 arguments: string '--database', action set to string 'store', dest as a string 'database',
def handle ( self , ** options ) :	default set to DEFAULT_DB_ALIAS and help as a string 'Nominates a database to introspect. Defaults to using the 'default' database.'.   define the method handle with 2 arguments: self and unpacked dictionary options.
try :	try,
for line in self . handle_inspection ( options ) :	for every line in return value of the method self.handle_inspection called with an argument options,
\self . stdout . write ( '%s\\n' % line )\	append new line to line, write it to self.stdout stream.
except NotImplementedError :	if NotImplementedError exception is caught,
raise CommandError ( 'Database inspection isn't supported for the currently selected database backend.' )	raise an CommandError exception with an argument 'Database inspection isn't supported for the currently selected database backend.'.
def handle_inspection ( self , options ) :	define the method handle_inspection with 2 argument: self and options.
connection = connections [ options [ 'database' ] ]	get value under the 'database' key of the options dictionary, use it as a key to get the value from the connections dictionary,
table_name_filter = options . get ( 'table_name_filter' )	substitute the result for connection.   get the value under the 'table_name_filter' key of the options dictionary, substitute it for table_name_filter.
table2model = lambda table_name : re . sub ( r'[^a-zA-Z0-9]' , '' , table_name . title ( ) )	table2model is a lambda function with an argument table_name, return value is the return value of the re.sub method,
with connection . cursor ( ) as cursor :	otherwise returns s.   call the method connection.cursor, with the result as cursor,
yield '# This is an auto-generated Django model module.'	yield string '# This is an auto-generated Django model module.' as the result.
yield '# You'll have to do the following manually to clean this up:'	yield string '# You'll have to do the following manually to clean this up:' as the result.
yield '#   * Rearrange models' order'	yield string '#   * Rearrange models' order' as the result.
yield '#   * Make sure each model has one field with primary_key=True'	yield string '#   * Make sure each model has one field with primary_key=True' as the result.
yield '#   * Remove `managed = False` lines if you wish to allow Django to create, modify, and delete the table'	yield string '#   * Remove `managed = False` lines if you wish to allow Django to create, modify, and delete the table' as the result.
yield '# Feel free to rename the models, but don't rename db_table values or field names.'	yield string '# Feel free to rename the models, but don't rename db_table values or field names.' as the result.
yield '#'	yield string '#' as the result.
yield '# into your database.'	yield string '# into your database.' as the result.
yield 'from __future__ import unicode_literals'	yield string 'from __future__ import unicode_literals' as the result.
yield ''	yield and empty string as the result.
yield 'from %s import models' % self . db_module	yield string 'from %s import models' % self.db_module as the result, where '%s' is replaced with self.db_module.
known_models = [ ]	known_models is an empty list.
for table_name in connection . introspection . table_names ( cursor ) :	for every table_name in return value of the method connection.introspection.table_names called with an argument cursor,
if table_name_filter is not None and callable ( table_name_filter ) :	if table_name_filter is not None and table_name_filter is callable object,
if not table_name_filter ( table_name ) :	call the function table_name_filter with an argument table_name, if it evaluates to true,
    continue	skip this loop iteration,
yield ''	yield and empty string as the result.
yield ''	yield and empty string as the result.
yield 'class %s(models.Model):' % table2model ( table_name )	yield string 'from %s import models' % self.db_module as the result, where '%s' is replaced with result of the call to the function,
known_models . append ( table2model ( table_name ) )	table2model with an argument table_name.   call the function table2model with an argument table_name, append the result to known_models.
try :	try,
relations = connection . introspection . get_relations ( cursor , table_name )	call the method connection.introspection.get_relations with 2 arguments cursor, table_name and substitute the result for relations.
except NotImplementedError :	if NotImplementedError exception is caught,
relations = { }	relations is an empty dictionary.
try :	try,
indexes = connection . introspection . get_indexes ( cursor , table_name )	call the method connection.introspection.get_relations with 2 arguments cursor, table_name and substitute the result for indexes.
except NotImplementedError :	if NotImplementedError exception is caught,
indexes = { }	indexes is an empty dictionary.
used_column_names = [ ]	used_column_names is an empty list.
for i , row in enumerate ( connection . introspection . get_table_description ( cursor , table_name ) ) :	for every i and row in enumerated result of the method connection.introspection.get_table_description called with arguments: cursor and table_name,
comment_notes = [ ]	comment_notes is an empty list.
extra_params = OrderedDict ( )	extra_params is an instance of the class OrderedDict.
column_name = row [ 0 ]	substitute first element of row for column_name.
is_relation = i in relations	if i is contained in relations, is_relation is boolean True, otherwise is_relation is boolean False.
att_name , params , notes = self . normalize_col_name (  column_name , used_column_names , is_relation )	call the method self.normalize_col_name with 3 arguments column_name, used_column_names, is_relation, assign the result to att_name,  params and notes, respectively.
extra_params . update ( params )	add params to extra_params dictionary.
comment_notes . extend ( notes )	extend comment_notes list with notes.
used_column_names . append ( att_name )	append att_name to used_column_names list.
if column_name in indexes :	if column_name is contained in indexes,
    if indexes [ column_name ] [ 'primary_key' ] :	if value under the 'primary_key' key of the dictionary contained under the column_name key of the dictionary indexes is true,
        extra_params [ 'primary_key' ] = True	value under the 'primary_key' key of the extra_params dictionary is boolean True,
elif indexes [ column_name ] [ 'unique' ] :	otherwise if, if value under the 'unique' key of the dictionary contained under the column_name key of the dictionary indexes is true,
        extra_params [ 'unique' ] = True	value under the 'unique' key of the extra_params dictionary is boolean True,
if is_relation :	if is_relation is true,
    rel_to = 'self' if relations [ i ] [ 1 ] == table_name else table2model ( relations [ i ] [ 1 ] )	if second element of the i-th row of relations equals table_name, rel_to is string 'self',
if rel_to in known_models :	otherwise call the method table2model with second element of the i-th row of relations and substitute it for rel_to.   if rel_to is contained in known_models,
        field_type = 'ForeignKey(%s' % rel_to	append rel_to to string 'ForeignKey(, substitute the result for field_type.
else :	if not,
else :	if not,
      field_type , field_params , field_notes = self . get_field_type ( connection , table_name , row )	call the method self.get_field_type with 3 arguments connection, table_name and row, assign the result to field_type, field_params,
extra_params . update ( field_params )	field_notes, respectively.   add field_params to extra_params dictionary.
comment_notes . extend ( field_notes )	extend comment_notes list with field_notes.
field_type += '('	append '(' to field_type.
if att_name == 'id' and extra_params == { 'primary_key' : True } :	if att_name equals string 'id' and extra_params equals a dictionary with 1 entry: boolean True for 'primary_key',
    if field_type == 'AutoField(' :	if field_type equals a string 'AutoField(',
        continue	skip this loop iteration.
elif field_type == 'IntegerField(' and not connection . features . can_introspect_autofield :	otherwise if field_type equals a string 'IntegerField(' and connection.features.can_introspect_autofield is false,
        comment_notes . append ( 'AutoField?' )	append string 'AutoField?' to comment_notes.
if row [ 6 ] :	if seventh element of row is true,
    if field_type == 'BooleanField(' :	if field_type equals a string 'BooleanField(',
        field_type = 'NullBooleanField('	field_type is a string 'NullBooleanField('
else :	if not,
        extra_params [ 'blank' ] = True	value under the 'blank' key of the extra_params dictionary is boolean True.
if field_type not in ( 'TextField(' , 'CharField(' ) :	if field_type is not equal to string 'TextField(' or string 'CharField(',
            extra_params [ 'null' ] = True	value under the 'null' key of the extra_params dictionary is boolean True.
field_desc = '%s = %s%s' % (  att_name ,   '' if '.' in field_type else 'models.' ,  field_type ,  )	field_desc is a string '%s = %s%s', where '%s' is replaced with: att_name, an empty string if '.' is contained in field_type,
if extra_params :	or with string 'models.' if it is not and field_type.   if extra_params is true,
    if not field_desc . endswith ( '(' ) :	if field_desc doesnt end with '(',
        field_desc += ', '	append string ', ' to field_desc.
field_desc += ', ' . join ( [  '%s=%s' % ( k , strip_prefix ( repr ( v ) ) )  for k , v in extra_params . items ( ) ] )	in string '%s=%s' replace '%s' with k and return value of the function strip_prefix with an argument printable representation of v,
field_desc += ')'	for every k and v in return value of the extra_params.items method, join all results into a string separated by a string ', ',   substitute it for field_desc.   append string ')' to field_desc.
if comment_notes :	if comment_notes is true,
    field_desc += '  # ' + ' ' . join ( comment_notes )	join elements of comment_notes into a string, separated by whitespaces, append it to the string ' #', append the result to field_desc.
yield '    %s' % field_desc	yield string '    %s', where '%s' is replaced with field_desc.
for meta_line in self . get_meta ( table_name ) :	for meta_line in return value of the method self.get_meta called with an argument table_name.
yield meta_line	yield meta_line as the result.
def normalize_col_name ( self , col_name , used_column_names , is_relation ) :	define the method normalize_col_name with 4 arguments: self, col_name, used_column_names and is_relation.
field_params = { }	field_params is an empty dictionary.
field_notes = [ ]	field_notes is an empty list.
new_name = col_name . lower ( )	convert col_name to lowercase, substitute the result for new_name.
if new_name != col_name :	if new_name is not equal to col_name,
field_notes . append ( 'Field name made lowercase.' )	append string 'Field name made lowercase.' to field_notes.
if is_relation :	if is_relation,
if new_name . endswith ( '_id' ) :	if new_name ends with string '_id',
new_name = new_name [ : - 3 ]	substitute new_name, without the last 3 elements for new_name.
else :	if not,
field_params [ 'db_column' ] = col_name	substitute col_name for value under the 'db_column' key of the field_params dictionary.
\new_name , num_repl = re . subn ( r'\\W' , '_' , new_name )\	\cal the method re.subn with 3 arguments: raw string '\\W', string '_' and new_name.\
if num_repl > 0 :	if num_repl is greater than integer 0,
field_notes . append ( 'Field renamed to remove unsuitable characters.' )	append string 'Field renamed to remove unsuitable characters.' to field_notes.
if new_name . find ( '__' ) >= 0 :	call the method new_name.find, with an argument string '__', if it evaluates to greater or equal than integer 0,
while new_name . find ( '__' ) >= 0 :	while the result of the method new_name.find, called with an argument string '__' is greater or equals integer 0,
new_name = new_name . replace ( '__' , '_' )	replace all the occurrences of '__' with '_' in new_name.
if col_name . lower ( ) . find ( '__' ) >= 0 :	convert col_name to lowercase, on the result call the method find with an argument string '__', if the result is greater of equal to integer 0,
field_notes . append ( 'Field renamed because it contained more than one '_' in a row.' )	append string 'Field renamed because it contained more than one '_' in a row.' to field_notes.
if new_name . startswith ( '_' ) :	if new_name starts with a string '_',
new_name = 'field%s' % new_name	convert new_name to a string and append it to string 'field', substitute the result for new_name.
field_notes . append ( 'Field renamed because it started with '_'.' )	append string 'Field renamed because it started with '_'.' to field_notes.
if new_name . endswith ( '_' ) :	if new_name ends with a string '_',
new_name = '%sfield' % new_name	convert new_name to a string and append string 'field' to it, substitute the result for new_name.
field_notes . append ( 'Field renamed because it ended with '_'.' )	append string 'Field renamed because it ended with '_'.' to field_notes.
if keyword . iskeyword ( new_name ) :	call the method keyword.iskeyword with an argument new_name, if it evaluates to true,
new_name += '_field'	append string '_field' to new_name.
field_notes . append ( 'Field renamed because it was a Python reserved word.' )	append string 'Field renamed because it was a Python reserved word.' to field_notes.
if new_name [ 0 ] . isdigit ( ) :	if first element of new_name is digit,
new_name = 'number_%s' % new_name	convert new_name to a string and append it to string 'number_', substitute the result for new_name.
field_notes . append ( 'Field renamed because it wasn't a valid Python identifier.' )	append string 'Field renamed because it wasn't a valid Python identifier.' to field_notes.
if new_name in used_column_names :	if new_name is contained in used_column_names,
num = 0	num is an integer 0.
while '%s_%d' % ( new_name , num ) in used_column_names :	in string '%s_%d', replace '%s' with new_name and '%d' with num, while the result is contained in used_column_names,
num += 1	increment num by one.
new_name = '%s_%d' % ( new_name , num )	in string '%s_%d', replace '%s' with new_name and '%d' with num, substitute the result for new_name.
field_notes . append ( 'Field renamed because of name conflict.' )	append string 'Field renamed because of name conflict.' to field_notes.
if col_name != new_name and field_notes :	if col_name is not equal to new_name and field_notes is true,
field_params [ 'db_column' ] = col_name	substitute col_name for value under the 'db_column' key of the field_params dictionary.
return new_name , field_params , field_notes	return new_name, field_params and field_notes.
def get_field_type ( self , connection , table_name , row ) :	define the method get_field_type with 4 arguments: self, connection, table_name and row.
field_params = OrderedDict ( )	field_params is an instance of a class OrderedDict.
field_notes = [ ]	field_notes is an empty list.
try :	try,
field_type = connection . introspection . get_field_type ( row [ 1 ] , row )	call the method connection.introspection.get_field_type with 2 arguments: second element of row and row, substitute the result for field_type.
except KeyError :	if KeyError exception is caught,
field_type = 'TextField'	field_type is a string 'TextField'.
field_notes . append ( 'This field type is a guess.' )	append a string 'This field type is a guess.' to field_notes.
if type ( field_type ) is tuple :	if field_type is a tuple,
field_type , new_params = field_type	substitute field_type for field_type and new_params, respectively.
field_params . update ( new_params )	call the method field_params.update with an argument new_params.1
if field_type == 'CharField' and row [ 3 ] :	if field_type equals a string CharField' and fourth element of row is true,
field_params [ 'max_length' ] = int ( row [ 3 ] )	convert fourth element of row to an integer, substitute it for value under the 'max_digits' key of the field_params.
if field_type == 'DecimalField' :	if field_type equals a string 'DecimalField',
if row [ 4 ] is None or row [ 5 ] is None :	if fifth and sixth elements of row are None,
field_notes . append (  'max_digits and decimal_places have been guessed, as this '  'database handles decimal fields as float' )	append string 'max_digits and decimal_places have been guessed, as this database handles decimal fields as float' to field_notes.
field_params [ 'max_digits' ] = row [ 4 ] if row [ 4 ] is not None else 10	if fifth element of row is not None, substitute it for value under the 'max_digits' key of the field_params,
field_params [ 'decimal_places' ] = row [ 5 ] if row [ 5 ] is not None else 5	otherwise, value under the 'max_digits' key of the field_params is integer 10.   if sixth element of row is not None, substitute it for value under the 'decimal_places' key of the field_params,
else :	otherwise, value under the 'decimal_places' key of the field_params is integer 5.   if not
field_params [ 'max_digits' ] = row [ 4 ]	substitute fifth element of row for value under the 'max_digits' key of the field_params.
field_params [ 'decimal_places' ] = row [ 5 ]	substitute sixth element of row for value under the 'decimal_places' key of the field_params.
return field_type , field_params , field_notes	return field_type, field_params and field_notes.
def get_meta ( self , table_name ) :	define the method get_meta with arguments self and table_name.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import glob	import module glob.
import gzip	import module gzip.
import os	import module os.
import warnings	import module warnings.
import zipfile	import module zipfile.
from django . apps import apps	from django.apps import apps into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . core import serializers	from django.core import serializers into default name space.
from django . core . management . base import BaseCommand , CommandError	from django.core.management.base import BaseCommand and CommandError into default name space.
from django . core . management . color import no_style	from django.core.management.color import no_style into default name space.
from django . db import ( connections , router , transaction , DEFAULT_DB_ALIAS ,  IntegrityError , DatabaseError )	from django.db import connections, router, transaction, DEFAULT_DB_ALIAS, IntegrityError and DatabaseError into default name space.
from django . utils import lru_cache	from django.utils import lru_cache into default name space.
from django . utils . encoding import force_text	from django.utils.encoding import force_text into default name space.
from django . utils . functional import cached_property	from django.utils.functional import cached_property into default name space.
from django . utils . _os import upath	from django.utils._os import upath into default name space.
from itertools import product	from itertools import product into default name space.
try :	try,
import bz2	import bz2.
has_bz2 = True	has_bz2 is boolean True.
except ImportError :	if ImportError exception is caught,
has_bz2 = False	has_bz2 is boolean False.
class Command ( BaseCommand ) :	derive the class Command from the BaseCommand base class.
help = 'Installs the named fixture(s) in the database.'	help is an string 'Installs the named fixture(s) in the database.'.
missing_args_message = ( 'No database fixture specified. Please provide the '  'path of at least one fixture in the command line.' )	missing_args_message is a tuple containing a string 'No database fixture specified. Please provide the '
def add_arguments ( self , parser ) :	path of at least one fixture in the command line.   define the method add_arguments with 2 arguments: self and parser.
parser . add_argument ( 'args' , metavar = 'fixture' , nargs = '+' ,  help = 'Fixture labels.' )	call the method parser.add_argument with 4 arguments: string 'args', metavar set to string 'fixture', nargs set to '+',
parser . add_argument ( '--database' , action = 'store' , dest = 'database' ,  default = DEFAULT_DB_ALIAS , help = 'Nominates a specific database to load '  'fixtures into. Defaults to the 'default' database.' )	and help set to 'Fixture labels.'.   call the method parser.add_argument with 5 arguments: string '--database', action set to string 'store', dest as a string 'database',
parser . add_argument ( '--app' , action = 'store' , dest = 'app_label' ,  default = None , help = 'Only look for fixtures in the specified app.' )	default set to DEFAULT_DB_ALIAS and help as a string 'Nominates a specific database to load fixtures into. Defaults to the 'default' database.'   call the method parser.add_argument with 5 arguments: string '--app', action as a string 'store', dest as a string 'app_label',
parser . add_argument ( '--ignorenonexistent' , '-i' , action = 'store_true' ,  dest = 'ignore' , default = False ,  help = 'Ignores entries in the serialized data for fields that do not '  'currently exist on the model.' )	default set to None, help is a string 'Only look for fixtures in the specified app.'.   call the method parser.add_argument with 6 arguments: string '--ignorenonexistent', string '-i', action as a string 'store_true',
def handle ( self , * fixture_labels , ** options ) :	dest as a string 'ignore', default set to boolean False and help set to string 'Ignores entries in the serialized data for fields that do not currently exist on the model.'.   define the method handle with 3 arguments: self, unpacked list fixture_labels and unpacked dictionary options.
self . ignore = options . get ( 'ignore' )	get the value under the 'ignore' key of the options dictionary, substitute it for self.ignore.
self . using = options . get ( 'database' )	get the value under the 'database' key of the options dictionary, substitute it for self.database.
self . app_label = options . get ( 'app_label' )	get the value under the 'app_label' key of the options dictionary, substitute it for self.app_label.
self . hide_empty = options . get ( 'hide_empty' , False )	get the value under the 'hide_empty' key of the options dictionary, if the key exists substitute it for self.hide_empty,
self . verbosity = options . get ( 'verbosity' )	if not, self.hide_empty is boolean False.   get the value under the 'verbosity' key of the options dictionary, substitute it for self.verbosity.
with transaction . atomic ( using = self . using ) :	call the method transaction.atomic with an argument using set to self.using, with the result,
self . loaddata ( fixture_labels )	call the method self.loaddata with an argument fixture_labels.
if transaction . get_autocommit ( self . using ) :	call the method transaction.get_autocommit with an argument self.using, if it evaluates to true,
connections [ self . using ] . close ( )	get the value under the self.using key of the connections dictionary, call the method close on it.
def loaddata ( self , fixture_labels ) :	define the method loaddata with 2 arguments self and fixture_labels.
connection = connections [ self . using ]	get the value under the self.using key of the connections dictionary, substitute it for connection.
self . fixture_count = 0	self.fixture_count is integer 0.
self . loaded_object_count = 0	self.loaded_object_count is integer 0.
self . fixture_object_count = 0	self.fixture_object_count is integer 0.
self . models = set ( )	self.models is an empty set.
self . serialization_formats = serializers . get_public_serializer_formats ( )	call the method serializers.get_public_serializer_formats, substitute the result for self.serialization_formats.
self . compression_formats = {  None : ( open , 'rb' ) ,  'gz' : ( gzip . GzipFile , 'rb' ) ,  'zip' : ( SingleZipReader , 'r' ) ,  }	self.compression_formats is an dictionary with 3 initial entries: tuple containing 2 elements: open and string 'rb' for None,
if has_bz2 :	tuple with 2 arguments: gzip.GzipFile and string 'rb' for 'gz', tuple with 2 arguments: SingleZipReader and string 'r' for 'gzip'.   if has_bz2 is true,
self . compression_formats [ 'bz2' ] = ( bz2 . BZ2File , 'r' )	substitute tuple with 2 elements: bz2.BZ2File and string 'r' for value under the 'bz2' key of the self.compression_formats dictionary.
with connection . constraint_checks_disabled ( ) :	call the method connection.constraint_checks_disabled, with the result perform,
for fixture_label in fixture_labels :	for every fixture_label in fixture_labels,
self . load_label ( fixture_label )	call the method self.load_label with an argument fixture_label.
table_names = [ model . _meta . db_table for model in self . models ]	for model in self.models append model._meta.db_table to a list, substitute the resulting list for table_names.
try :	try,
connection . check_constraints ( table_names = table_names )	call the method connection.check_constraints with an arguments table_names set to table_names.
except Exception as e :	if Exception, renamed to e, exception is caught,
e . args = ( 'Problem installing fixtures: %s' % e , )	e.args is a tuple, containing 1 element: string 'Problem installing fixtures: %s', where '%s' is replaced with e.
raise	raise an exception.
if self . loaded_object_count > 0 :	if self.loaded_object_count is greater than zero,
sequence_sql = connection . ops . sequence_reset_sql ( no_style ( ) , self . models )	call the method connection.ops.sequence_reset_sql with 2 arguments: return value of the no_style and self.models,
if sequence_sql :	substitute the result for sequence_sql.   if sequence_sql is true,
if self . verbosity >= 2 :	if self.verbosity is grater than, or equal to integer 2,
\self . stdout . write ( 'Resetting sequences\\n' )\	\write a string 'Resetting sequences\\n' to self.stdout stream.\
with connection . cursor ( ) as cursor :	call the method connection.cursor, with the result renamed to cursor, perform the following,
for line in sequence_sql :	for every line in sequence_sql,
    cursor . execute ( line )	call the method cursor.execute with an argument line.
if self . verbosity >= 1 :	if self.verbosity is greater of equal to integer 1,
if self . fixture_count == 0 and self . hide_empty :	if self.fixture_count equals integer 0 and self.hide_empty is true,
pass	do nothing.
elif self . fixture_object_count == self . loaded_object_count :	otherwise if self.fixture_object_count equals self.loaded_object_count,
self . stdout . write ( 'Installed %d object(s) from %d fixture(s)' %  ( self . loaded_object_count , self . fixture_count ) )	call the method self.stdout.write with an argument string 'Installed %d object(s) from %d fixture(s)',
else :	where '%d' is replaced with self.loaded_object_count and self.fixture_count, respectively.   if not,
self . stdout . write ( 'Installed %d object(s) (of %d) from %d fixture(s)' %  ( self . loaded_object_count , self . fixture_object_count , self . fixture_count ) )	call the method self.stdout.write with an argument string 'Installed %d object(s) (of %d) from %d fixture(s)',
def load_label ( self , fixture_label ) :	substitute '%d' with self.loaded_object_count, self.fixture_object_count and self.fixture_count.   define the method load_label with self and fixture_label as arguments.
for fixture_file , fixture_dir , fixture_name in self . find_fixtures ( fixture_label ) :	for every fixture_file, fixture_dir and fixture_name in return value of the method self.find_fixtures called with an argument fixture_label,
_ , ser_fmt , cmp_fmt = self . parse_name ( os . path . basename ( fixture_file ) )	call the function os.path.basename with an argument fixture_file, use the result as an argument for the call to the method,
open_method , mode = self . compression_formats [ cmp_fmt ]	self.parse_name, assign the result to _, ser_fmt and cmp_fmt, respectively.   get the value under the cmp_fmt key of the self.compression_formats dictionary, assign it to open_method and mode.
fixture = open_method ( fixture_file , mode )	call the function open_method with arguments: fixture_file and mode, substitute the result for fixture.
try :	try,
self . fixture_count += 1	increment self.fixture_count by one.
objects_in_fixture = 0	objects_in_fixture is integer 0.
loaded_objects_in_fixture = 0	loaded_objects_in_fixture is integer 0.
if self . verbosity >= 2 :	if self.verbosity is greater or equal to integer 2,
self . stdout . write ( 'Installing %s fixture '%s' from %s.' %  ( ser_fmt , fixture_name , humanize ( fixture_dir ) ) )	call the method self.stdout.write with an argument string 'Installing %s fixture '%s' from %s.',
objects = serializers . deserialize ( ser_fmt , fixture ,  using = self . using , ignorenonexistent = self . ignore )	substitute '%s' with ser_fmt, fixture_name and return value of the function humanize called with an argument fixture_dir.   call the method serializers.deserialize with 4 arguments: ser_fmt, fixture, using set to self.using,
for obj in objects :	and ignorenonexistent set to self.ignore, substitute the result for objects.   for every obj in objects,
objects_in_fixture += 1	increment objects_in_fixture by one.
if router . allow_migrate ( self . using , obj . object . __class__ ) :	call the method router.allow_migrate with 2 arguments: self.using and obj.object.__class__, if it evaluates to true,
    loaded_objects_in_fixture += 1	increment loaded_objects_in_fixture by one.
self . models . add ( obj . object . __class__ )	add obj.object.__class__ to self.models set.
try :	try,
        obj . save ( using = self . using )	call the method obj.save with an argument using set to self.using.
except ( DatabaseError , IntegrityError ) as e :	if DatabaseError or IntegrityError, renamed to e, exceptions are caught,
        e . args = ( 'Could not load %(app_label)s.%(object_name)s(pk=%(pk)s): %(error_msg)s' % {  'app_label' : obj . object . _meta . app_label ,  'object_name' : obj . object . _meta . object_name ,  'pk' : obj . object . pk ,  'error_msg' : force_text ( e )  } , )	e.args is a tuple containing string 'Could not load %(app_label)s.%(object_name)s(pk=%(pk)s): %(error_msg)s,
raise	where '%(app_label)s' is replaced for obj.object._meta.app_label, '%(object_name)s' is replaced with obj.object._meta.object_name,   '%(pk)s' is replaced with obj.object.pk and '%(error_msg)s' is replaced with result of the function force_text with an argument e.   raise an exceptions
self . loaded_object_count += loaded_objects_in_fixture	increment self.loaded_object_count by loaded_objects_in_fixture.
self . fixture_object_count += objects_in_fixture	increment self.fixture_object_count by objects_in_fixture.
except Exception as e :	if Exception, renamed to e, exception is caught,
if not isinstance ( e , CommandError ) :	if e is not an instance of CommandError class,
e . args = ( 'Problem installing fixture '%s': %s' % ( fixture_file , e ) , )	e.args is a tuple containing string 'Problem installing fixture '%s': %s', where '%s' is replaced with fixture_file, e.
raise	raise an exception.
finally :	finally perform,
fixture . close ( )	call the method fixture.close.
if objects_in_fixture == 0 :	if objects_in_fixture equals integer 0,
warnings . warn (  'No fixture data found for '%s'. (File format may be '  'invalid.)' % fixture_name ,  RuntimeWarning  )	call the method warnings.warn with 2 arguments: string 'No fixture data found for '%s'. (File format may be invalid.)',
@ lru_cache . lru_cache ( maxsize = None )	where '%s' is replaced with fixture_name, and RuntimeWarning.   decorator method lru_cache.lru_cache with an argument maxsize set to None.
def find_fixtures ( self , fixture_label ) :	define the method find_fixtures with arguments: self and fixture_label.
fixture_name , ser_fmt , cmp_fmt = self . parse_name ( fixture_label )	call the method self.parse_name with an argument fixture_label, substitute the result for fixture_name, ser_fmt, cmp_fmt, respective.
databases = [ self . using , None ]	databases is a list containing 2 elements: self.using and None.
cmp_fmts = list ( self . compression_formats . keys ( ) ) if cmp_fmt is None else [ cmp_fmt ]	call the method self.compression_formats.keys, convert it to list, substitute it for cmp_fmts if cmp_fmt is None,
ser_fmts = serializers . get_public_serializer_formats ( ) if ser_fmt is None else [ ser_fmt ]	otherwise cmp_fmts is a list containing cmp_fmt.   call the method serializers.get_public_serializer_formats, substitute the result for ser_fmts if ser_fmt is None,
if self . verbosity >= 2 :	otherwise ser_fmts is a list containing ser_fmt.   if self.verbosity is greater or equal to integer 2,
self . stdout . write ( 'Loading '%s' fixtures...' % fixture_name )	call the method self.stdout.write with an argument string 'Loading '%s' fixtures...', where '%s' is replaced with fixture_name.
if os . path . isabs ( fixture_name ) :	if fixture_name is an absolute file path,
fixture_dirs = [ os . path . dirname ( fixture_name ) ]	call the method os.path.dirname with an argument fixture_name, append it to a list, substitute resulting list for fixture_dirs.
fixture_name = os . path . basename ( fixture_name )	call the method os.path.basename with an argument fixture_name, substitute the result for fixture_name.
else :	if not,
fixture_dirs = self . fixture_dirs	substitute self.fixture_dirs for fixture_dirs.
if os . path . sep in fixture_name :	if os.path.sep is contained in fixture_name,
fixture_dirs = [ os . path . join ( dir_ , os . path . dirname ( fixture_name ) )  for dir_ in fixture_dirs ]	join dir_ and return value of the function os.path.dirname called with an argument fixture_name into a valid file path,
fixture_name = os . path . basename ( fixture_name )	append it to a list, perform the previous for every dir_ in fixture_dirs, substitute the resulting list for fixture_dirs.   call the method os.path.basename with an argument fixture_name, substitute the result for fixture_name.
suffixes = ( '.' . join ( ext for ext in combo if ext )  for combo in product ( databases , ser_fmts , cmp_fmts ) )	for every ext in combo, if ext is true, join it to a string, separated by '.', put the result in a tuple,
targets = set ( '.' . join ( ( fixture_name , suffix ) ) for suffix in suffixes )	perform the previous for every combo in result of the function product called with 3 arguments: databases, ser_fmts and cmp_fmts,   substitute the result for suffixes.   join fixture_name and suffix into a string, separated by '.' for every suffix in suffixes, put the results in set, substitute it for targets.
fixture_files = [ ]	fixture_files is an empty list.
for fixture_dir in fixture_dirs :	for every fixture_dir in fixture_dirs,
if self . verbosity >= 2 :	if self.verbosity is greater or equals to integer 2.
self . stdout . write ( 'Checking %s for fixtures...' % humanize ( fixture_dir ) )	call the method self.stdout.write with an argument string 'Checking %s for fixtures...',
fixture_files_in_dir = [ ]	where '%s' is replaced with result of the function humanize, called with an argument fixture_dir.   fixture_files_in_dir is an empty list.
for candidate in glob . iglob ( os . path . join ( fixture_dir , fixture_name + '*' ) ) :	join fixture_dir, fixture_name with appended character '*' into a valid file path,
if os . path . basename ( candidate ) in targets :	use it as an argument for the call to the glob.iglob, for every candidate in result,   call the method os.path.basename with an argument candidate, is result is contained in targets,
  fixture_files_in_dir . append ( ( candidate , fixture_dir , fixture_name ) )	append tuple containing 3 elements: candidate, fixture_dir and fixture_name to list fixture_files_in_dir.
if self . verbosity >= 2 and not fixture_files_in_dir :	if self.verbosity is greater or equals integer 2 and fixture_files_in_dir is false,
self . stdout . write ( 'No fixture '%s' in %s.' %  ( fixture_name , humanize ( fixture_dir ) ) )	call the method self.stdout.write with an argument string 'No fixture '%s' in %s.', where '%s' is replaced with fixture_name,
if len ( fixture_files_in_dir ) > 1 :	and result of the function humanize called with an argument fixture_dir.   if length of fixture_files_in_dir is greater than 1,
raise CommandError (  'Multiple fixtures named '%s' in %s. Aborting.' %  ( fixture_name , humanize ( fixture_dir ) ) )	raise an CommandError exception with an argument string 'Multiple fixtures named '%s' in %s. Aborting.', where '%s' is replaced with:
fixture_files . extend ( fixture_files_in_dir )	fixture_name and result of the function humanize called with an argument fixture_dir.   extend fixture_files list with fixture_files_in_dir.
if fixture_name != 'initial_data' and not fixture_files :	if fixture_name is not equal to string 'initial_data' and fixture_files is false,
warnings . warn ( 'No fixture named '%s' found.' % fixture_name )	call the method warnings.warn with an argument string 'No fixture named '%s' found.' where '%s' is replaced with fixture_name.
return fixture_files	return fixture_files.
@ cached_property	decorator cached_property,
def fixture_dirs ( self ) :	define the method fixture_dirs with an argument self.
dirs = [ ]	dirs is an empty dictionary.
for app_config in apps . get_app_configs ( ) :	for ever app_config in return value of the method apps.get_app_configs,
if self . app_label and app_config . label != self . app_label :	if self.app_label is true and app_config.label is not equal to self.app_label,
continue	skip this loop iteration.
app_dir = os . path . join ( app_config . path , 'fixtures' )	join app_config.path and string 'fixtures' into a valid file path, substitute it for app_dir.
if os . path . isdir ( app_dir ) :	if app_dir is a directory,
dirs . append ( app_dir )	append app_dir to dirs list.
dirs . extend ( list ( settings . FIXTURE_DIRS ) )	convert settings.FIXTURE_DIRS to a list, extend dirs by it.
dirs . append ( '' )	append an empty string to dirs list.
dirs = [ upath ( os . path . abspath ( os . path . realpath ( d ) ) ) for d in dirs ]	call the function os.path.realpath with an argument d, use the result as an argument for the call to the function os.path.abspath,
return dirs	use the result as an argument for the call to the upath function, for every d in dirs, append the results into a list,   substitute the resulting list for dirs.   return dirs.
def parse_name ( self , fixture_name ) :	define the method parse_name with arguments self and fixture_name.
parts = fixture_name . rsplit ( '.' , 2 )	call the method fixture_name.rsplit with 2 arguments: character '.' and integer 2, substitute the result for parts.
if len ( parts ) > 1 and parts [ - 1 ] in self . compression_formats :	if length of parts is greater than integer 1 and last element of parts is contained in self.compression_formats,
cmp_fmt = parts [ - 1 ]	substitute the last element of parts for cmp_fmt.
parts = parts [ : - 1 ]	substitute the last element of parts for parts.
else :	if not,
cmp_fmt = None	cmp_fmt is None.
if len ( parts ) > 1 :	if length of parts is greater than integer 1.
if parts [ - 1 ] in self . serialization_formats :	if last element of parts is contained in self.serialization_formats,
ser_fmt = parts [ - 1 ]	substitute the last element of parts for ser_fmt.
parts = parts [ : - 1 ]	substitute the last element of parts for parts.
else :	if not,
raise CommandError (  'Problem installing fixture '%s': %s is not a known '  'serialization format.' % ( '' . join ( parts [ : - 1 ] ) , parts [ - 1 ] ) )	raise an CommandError with an argument string 'Problem installing fixture '%s': %s is not a known serialization format.',
else :	replace '%s' with: elements of last element of parts joined into a string and last element of parts.   if not,
ser_fmt = None	ser_fmt is None.
name = '.' . join ( parts )	join elements of parts into a string, separated with '.', substitute it for name.
return name , ser_fmt , cmp_fmt	return name, ser_fmt and cmp_fmt.
class SingleZipReader ( zipfile . ZipFile ) :	derive class SingleZipReader for zipfile.ZipFile base class.
def __init__ ( self , * args , ** kwargs ) :	define the method __init__ with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
zipfile . ZipFile . __init__ ( self , * args , ** kwargs )	call the method zipfile.ZipFile.__init___ with the arguments self, unpacked list args and unpacked dictionary kwargs.
if len ( self . namelist ( ) ) != 1 :	call the method self.namelist, if the length of the result is not integer 1,
raise ValueError ( 'Zip-compressed fixtures must contain one file.' )	raise an ValueError with an string 'Zip-compressed fixtures must contain one file.'.
def read ( self ) :	define the method read with an argument self.
return zipfile . ZipFile . read ( self , self . namelist ( ) [ 0 ] )	call the method zipfile.ZipFile.read with 2 arguments: self and first element of the result of the self.namelist method.
def humanize ( dirname ) :	define the function humanize with an argument dirname.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import fnmatch	import module fnmatch.
import glob	import module glob.
import io	import module io.
import os	import module os.
import re	import module re.
import sys	import module sys.
from itertools import dropwhile	from itertools import dropwhile into default name space.
import django	import module django.
from django . core . management . base import CommandError , BaseCommand	from django.core.management.base import CommandError and BaseCommand into default name space.
from django . core . management . utils import ( handle_extensions , find_command ,  popen_wrapper )	from django.core.management.utils import handle_extensions, find_command and popen_wrapper into default name space.
from django . utils . encoding import force_str	from django.utils.encoding import force_st into default name space.
from django . utils . functional import total_ordering	from django.utils.functional import total_ordering into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . text import get_text_list	from django.utils.text import get_text_list into default name space.
from django . utils . jslex import prepare_js_for_gettext	from django.utils.jslex import prepare_js_for_gettext into default name space.
\plural_forms_re = re . compile ( r'^(?P<value>'Plural-Forms.+?\\\\n')\\s*$' , re . MULTILINE | re . DOTALL )\	\call the method re.compile with 2 arguments: raw string '^(?P<value>'Plural-Forms.+?\\\\n')\\s*$',\
STATUS_OK = 0	and result of the bitwise OR performed on the re.MULTILINE and re.DOTALL operands, substitute the result for plural_forms_re/   STATUS_OK is integer 0.
def check_programs ( * programs ) :	define the method check_programs with an argument unpacked list programs.
for program in programs :	for every program in programs,
if find_command ( program ) is None :	call the function find_command with an argument program, if it evaluates to None,
raise CommandError ( 'Can't find %s. Make sure you have GNU '  'gettext tools 0.15 or newer installed.' % program )	raise an CommandError exception with an argument 'Can't find %s. Make sure you have GNU gettext tools 0.15 or newer installed.',  where '%s' is replaced with program.
@ total_ordering	total_ordering decorator,
class TranslatableFile ( object ) :	derive the class TranslatableFile from the object class.
def __init__ ( self , dirpath , file_name , locale_dir ) :	define the method __init__ with 4 arguments: self, dirpath, file_name and locale_dir.
self . file = file_name	substitute file_name for self.file_name.
self . dirpath = dirpath	substitute dirpath for self.dirpath.
self . locale_dir = locale_dir	substitute locale_dir for self.locale_dir.
def __repr__ ( self ) :	define the method __repr__with an argument self.
return '<TranslatableFile: %s>' % os . sep . join ( [ self . dirpath , self . file ] )	join self.dirpath and self.file in a string, substitute with it '%s' in string '<TranslatableFile: %s>', return the result.
def __eq__ ( self , other ) :	define the method __eq__ with self and other arguments:
return self . path == other . path	if self.path equals other.path, return boolean True, if not return boolean False.
def __lt__ ( self , other ) :	define the mehod __lt__ with self and other.
return self . path < other . path	if self.path is lesser than other.path, return boolean True, otherwise return boolean False.
@ property	property decorator.
def path ( self ) :	define the method path with an argument self.
return os . path . join ( self . dirpath , self . file )	join self.dirpath and self.file into a file path, return it.
def process ( self , command , domain ) :	define the method process with 3 arguments: self, command and domain.
from django . conf import settings	from django.conf import settings into default namespace.
from django . utils . translation import templatize	from django.utils.translation import templatize into default namespace.
if command . verbosity > 1 :	if command.verbosity is greater than integer 1,
\command . stdout . write ( 'processing file %s in %s\\n' % ( self . file , self . dirpath ) )\	\substitute '%s' is string 'processing file %s in %s\\n' with self.file and self.dirpath, write it to command.stdout.\
_ , file_ext = os . path . splitext ( self . file )	call the method os.path.splitext with an argument self.file, assign the result to _ and file_ext.
if domain == 'djangojs' and file_ext in command . extensions :	if domain equals a string 'djangojs' and file_ext is contained in command.extensions,
is_templatized = True	is_templatized is boolean True.
orig_file = os . path . join ( self . dirpath , self . file )	join self.dirpath and self.file into a file path, substitute it for orig_file.
with io . open ( orig_file , encoding = settings . FILE_CHARSET ) as fp :	call the function io.open with orig_file and encoding set to settings.FILE_CHARSET, with the result renamed to fp,
src_data = fp . read ( )	perform the following:   call the method fp.read, substitute the result for src_data.
src_data = prepare_js_for_gettext ( src_data )	call the function prepare_js_for_gettext with an argument src_data, substitute it for src_data.
thefile = '%s.c' % self . file	convert self.file to a string and append '.c' string to it, substitute the result for thefile.
work_file = os . path . join ( self . dirpath , thefile )	join self.dirpath and thefile in a string, substitute the result for work_file.
with io . open ( work_file , 'w' , encoding = 'utf-8' ) as fp :	call the function io.open with 3 arguments: work_file, string 'w' and encoding set to string 'utf-8' as arguments,
fp . write ( src_data )	with the result renamed to fp, perform the following:   call the method fp.write with an arguments src_data.
args = [  'xgettext' ,  '-d' , domain ,  '--language=C' ,  '--keyword=gettext_noop' ,  '--keyword=gettext_lazy' ,  '--keyword=ngettext_lazy:1,2' ,  '--keyword=pgettext:1c,2' ,  '--keyword=npgettext:1c,2,3' ,  '--output=-'  ] + command . xgettext_options	append command.xgettext_options to the list containing 10 elements: string 'xgettext', string '-d', domain, string '--language=C',
args . append ( work_file )	string '--keyword=gettext_noop', string '--keyword=gettext_lazy', string '--keyword=ngettext_lazy:1,2',   string '--keyword=pgettext:1c,2', string '--keyword=npgettext:1c,2,3' and string '--output=-', substitute it for args.   append work_file to args.
elif domain == 'django' and ( file_ext == '.py' or file_ext in command . extensions ) :	otherwise if domains equals a string django' and, file_ext equals '.py' or file_ext is contained in command.extensions,
thefile = self . file	substitute self.file for thefile.
orig_file = os . path . join ( self . dirpath , self . file )	join self.dirpath and self.file into a file path, substitute it for orig_file.
is_templatized = file_ext in command . extensions	if file_ext is contained in command.extensions, is_templatized is boolean True, otherwise it is boolean False.
if is_templatized :	if is_templatized is true,
with io . open ( orig_file , 'r' , encoding = settings . FILE_CHARSET ) as fp :	call the function io.open with 3 arguments: work_file, string 'w' and encoding set to settings.FILE_CHARSET as arguments,
src_data = fp . read ( )	with the result renamed to fp, perform the following:   call the method fp.read, substitute the result for src_data.
thefile = '%s.py' % self . file	convert self.file to string and append string '.py' to it, substitute the result for thefile.
content = templatize ( src_data , orig_file [ 2 : ] )	call the function templatize with 2 arguments: src_data and sliced orig_file, without first 2 elements, substitute the result for content.
with io . open ( os . path . join ( self . dirpath , thefile ) , 'w' , encoding = 'utf-8' ) as fp :	call the function io.open with 3 arguments: self.dirpath and thefile joined into a file path, string 'w',
fp . write ( content )	and encoding set to string 'utf-8' as arguments, with the result renamed to fp, perform the following:   call the method fp.write with an argument content.
work_file = os . path . join ( self . dirpath , thefile )	join self.dirpath, thefile into a file path, substitute it for work_file.
args = [  'xgettext' ,  '-d' , domain ,  '--language=Python' ,  '--keyword=gettext_noop' ,  '--keyword=gettext_lazy' ,  '--keyword=ngettext_lazy:1,2' ,  '--keyword=ugettext_noop' ,  '--keyword=ugettext_lazy' ,  '--keyword=ungettext_lazy:1,2' ,  '--keyword=pgettext:1c,2' ,  '--keyword=npgettext:1c,2,3' ,  '--keyword=pgettext_lazy:1c,2' ,  '--keyword=npgettext_lazy:1c,2,3' ,  '--output=-'  ] + command . xgettext_options	append command.xgettext_options to list containing 15 elements: string 'xgettext', string '-d', domain, string '--language=Python',
args . append ( work_file )	string '--keyword=gettext_noop', string '--keyword=gettext_lazy', string '--keyword=ngettext_lazy:1,2',   string '--keyword=ugettext_noop', string '--keyword=ugettext_lazy', string '--keyword=ungettext_lazy:1,2',   string '--keyword=pgettext:1c,2', string '--keyword=npgettext:1c,2,3', string '--keyword=pgettext_lazy:1c,2',   string '--keyword=npgettext_lazy:1c,2,3' and string '--output=-', substitute the result for args.   append work_file to args.
else :	if not,
return	return nothing.
msgs , errors , status = popen_wrapper ( args )	call the function popen_wrapper with argument args, assign the result to msgs, errors and status.
if errors :	if errors is true,
if status != STATUS_OK :	if status is not equal to STATUS_OK,
if is_templatized :	if is_templatized is true,
os . unlink ( work_file )	call the function os.unlink with an argument work_file.
\raise CommandError (  'errors happened while running xgettext on %s\\n%s' %  ( self . file , errors ) )\	\raise an CommandError exception with an argument string 'errors happened while running xgettext on %s\\n%s',\
elif command . verbosity > 0 :	where '%s' are replaced by sel.file and errors, respectively.   if command.verbosity is greater than integer 0,
command . stdout . write ( errors )	call the method command.stdout.write with an argument errors.
if msgs :	if msgs is true,
if six . PY2 :	if six.PY2 is true,
msgs = msgs . decode ( 'utf-8' )	call the method msgs.decode with an argument string 'utf-8', substitute the result for msgs.
potfile = os . path . join ( self . locale_dir , '%s.pot' % str ( domain ) )	join into a file path: self.locale_dir and string '.pot' appended to domain converted to string, substitute it for potfile.
if is_templatized :	if is_templatized is true,
if os . name == 'nt' :	if os.name equals string 'nt',
  old = '#: ' + work_file	append work_file to string '#: ', substitute it for old.
new = '#: ' + orig_file	append orig_file to string '#: ', substitute it for new.
else :	if not,
old = '#: ' + work_file [ 2 : ]	append work_file to string '#: ', substitute it for old.
new = '#: ' + orig_file [ 2 : ]	append orig_file to string '#: ', substitute it for new.
msgs = msgs . replace ( old , new )	replace every occurrence of old for new in msgs, substitute the result for msgs.
write_pot_file ( potfile , msgs )	call the function write_pot_file with 2 arguments: potfile and msgs.
if is_templatized :	if is_templatized is true,
os . unlink ( work_file )	call the function os.unlink with an argument work_file.
def write_pot_file ( potfile , msgs ) :	define the function write_pot_file with 2 arguments potfile and msgs.
if os . path . exists ( potfile ) :	if potfile fie exists,
\msgs = '\\n' . join ( dropwhile ( len , msgs . split ( '\\n' ) ) )\	call the function dropwhile with 2 arguments: function len and msgs spit into parts at newlines, join the result into a string,
else :	separated by newline, substitute it for msgs.   if not,
msgs = msgs . replace ( 'charset=CHARSET' , 'charset=UTF-8' )	replace every occurrence of string 'charset=CHARSET' for string  'charset=UTF-8' in msgs, substitute the result for msgs.
with io . open ( potfile , 'a' , encoding = 'utf-8' ) as fp :	call the function io.open with 3 arguments: potfile, string 'a' and encoding set to string 'utf-8' as arguments,
fp . write ( msgs )	with the result renamed to fp, perform the following:   call the method fp.write with an argument msgs.
class Command ( BaseCommand ) :	derive the class Command from the BaseCommands base class.
\help = ( 'Runs over the entire source tree of the current directory and '  'pulls out all strings marked for translation. It creates (or updates) a message '  'file in the conf/locale (in the django tree) or locale (for projects and '  'applications) directory.\\n\\nYou must run this command with one of either the '  '--locale, --exclude or --all options.' )\	help is a string 'Runs over the entire source tree of the current directory and '
requires_system_checks = False	\pulls out all strings marked for translation. It creates (or updates) a message    'file in the conf/locale (in the django tree) or locale (for projects and '   'applications) directory.\\n\\nYou must run this command with one of either the '   '--locale, --exclude or --all options.'.    requires_system_checks is boolean False.\
leave_locale_alone = True	leave_locale_alone is boolean True
msgmerge_options = [ '-q' , '--previous' ]	msgmerge_options is an list with elements: strings '-q' and '--previous'.
msguniq_options = [ '--to-code=utf-8' ]	msguniq_options is an list with elements: string '--to-code=utf-8'.
msgattrib_options = [ '--no-obsolete' ]	msgattrib_options is an list with elements: string '--no-obsolete'.
xgettext_options = [ '--from-code=UTF-8' , '--add-comments=Translators' ]	xgettext_options is an list with elements: strings '--from-code=UTF-8' and '--add-comments=Translators'.
def add_arguments ( self , parser ) :	define the method add_arguments with 2 arguments: self and parser.
parser . add_argument ( '--locale' , '-l' , default = [ ] , dest = 'locale' , action = 'append' ,  help = 'Creates or updates the message files for the given locale(s) (e.g. pt_BR). '  'Can be used multiple times.' )	call the method parser.add_argument with 6 arguments: string '--locale', string '-l', default as an empty list,
parser . add_argument ( '--exclude' , '-x' , default = [ ] , dest = 'exclude' , action = 'append' ,  help = 'Locales to exclude. Default is none. Can be used multiple times.' )	dest as a string 'locale', action as a string 'append' and help as a string,   'Creates or updates the message files for the given locale(s) (e.g. pt_BR). Can be used multiple times.'.   call the method parser.add_argument with 5 arguments: string '--exclude', string '-x', default as a empty list,
parser . add_argument ( '--domain' , '-d' , default = 'django' , dest = 'domain' ,  help = 'The domain of the message files (default: 'django').' )	dest as a string 'exclude', action as a string 'append' and help as a string 'Locales to exclude. Default is none. Can be used multiple times.'.   call the method parser.add_argument with 5 arguments: string '--domain', string '-d', default as a string 'django',
parser . add_argument ( '--all' , '-a' , action = 'store_true' , dest = 'all' ,  default = False , help = 'Updates the message files for all existing locales.' )	dest set to string 'domain' and help as a string 'The domain of the message files (default: 'django').'.   call the method parser.add_argument with 6 arguments: string '--all', string '-a', action as a string'store_true',
parser . add_argument ( '--extension' , '-e' , dest = 'extensions' ,  help = 'The file extension(s) to examine (default: 'html,txt', or 'js' '  'if the domain is 'djangojs'). Separate multiple extensions with '  'commas, or use -e multiple times.' ,  action = 'append' )	dest as a string 'all' default as boolean False and help as a string 'Updates the message files for all existing locales.'.   call the method parser.add_argument with 5 arguments: string '--extension', string '-e', dest set to string 'extensions',
parser . add_argument ( '--symlinks' , '-s' , action = 'store_true' , dest = 'symlinks' ,  default = False , help = 'Follows symlinks to directories when examining '  'source code and templates for translation strings.' )	help set to a string 'The file extension(s) to examine (default: 'html,txt', or 'js' '   'if the domain is 'djangojs'). Separate multiple extensions with commas, or use -e multiple times.' and action as a string 'append'.   call the method parser.add_argument with 6 arguments: string '--symlinks', string '-s', action as a string 'store_true',
parser . add_argument ( '--ignore' , '-i' , action = 'append' , dest = 'ignore_patterns' ,  default = [ ] , metavar = 'PATTERN' ,  help = 'Ignore files or directories matching this glob-style pattern. '  'Use multiple times to ignore more.' )	dest as a string 'symlinks', default as boolean False and help as a string 'Follows symlinks to directories when examining '   'source code and templates for translation strings.'.   call the method parser.add_argument with 7 arguments: string '--ignore', string '-i', action as a string 'append',
parser . add_argument ( '--no-default-ignore' , action = 'store_false' , dest = 'use_default_ignore_patterns' ,  default = True , help = 'Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'.' )	dest as a string 'ignore_patterns', default as an empty list, metavar as a string 'PATTERN',   and help as a string 'Ignore files or directories matching this glob-style pattern. Use multiple times to ignore more.'.   call the method parser.add_argument with 5 arguments: string '--no-default-ignore', action as a string 'store_false',
parser . add_argument ( '--no-wrap' , action = 'store_true' , dest = 'no_wrap' ,  default = False , help = 'Don't break long message lines into several lines.' )	dest as a string 'use_default_ignore_patterns', default set to boolean True,   and help as a string 'Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'.'.   call the method parser.add_argument with 5 arguments: string '--no-wrap', action as a string 'store_true', dest as a string 'no_wrap',
parser . add_argument ( '--no-location' , action = 'store_true' , dest = 'no_location' ,  default = False , help = 'Don't write '#: filename:line' lines.' )	default as boolean False and help as a string 'Don't break long message lines into several lines.'.   call the method parser.add_argument with 5 arguments: string '--no-location', action set to string 'store_true',
parser . add_argument ( '--no-obsolete' , action = 'store_true' , dest = 'no_obsolete' ,  default = False , help = 'Remove obsolete message strings.' )	dest set to string 'no_location', default as boolean False and help as a string 'Don't write '#: filename:line' lines.'.   call the method parser.add_argument with 5 arguments: string '--no-obsolete', action as a string 'store_true',
parser . add_argument ( '--keep-pot' , action = 'store_true' , dest = 'keep_pot' ,  default = False , help = 'Keep .pot file after making messages. Useful when debugging.' )	dest as a string 'no_obsolete', default as boolean False and help as a string 'Remove obsolete message strings.'.   call the method parser.add_argument with 5 arguments: string '--keep-pot', action as a string 'store_true',
def handle ( self , * args , ** options ) :	dest as a string 'keep_pot', default as boolean False and help as a string 'Keep .pot file after making messages. Useful when debugging.'   define the method handle with 3 arguments: self, unpacked list args and unpacked dictionary options.
locale = options . get ( 'locale' )	get the value under the 'locale' key of the options dictionary, substitute it for locale.
exclude = options . get ( 'exclude' )	get the value under the 'exclude' key of the options dictionary, substitute it for exclude.
self . domain = options . get ( 'domain' )	get the value under the 'domain' key of the options dictionary, substitute it for self.domain.
self . verbosity = options . get ( 'verbosity' )	get the value under the 'verbosity' key of the options dictionary, substitute it for self.verbosity.
process_all = options . get ( 'all' )	get the value under the 'all' key of the options dictionary, substitute it for process_all.
extensions = options . get ( 'extensions' )	get the value under the 'extensions' key of the options dictionary, substitute it for extensions.
self . symlinks = options . get ( 'symlinks' )	get the value under the 'symlinks' key of the options dictionary, substitute it for self.symlinks.
ignore_patterns = options . get ( 'ignore_patterns' )	get the value under the 'ignore_patterns' key of the options dictionary, substitute it for ignore_patterns.
if options . get ( 'use_default_ignore_patterns' ) :	get the value under the 'use_default_ignore_patterns' key of the options dictionary, if it is true,
ignore_patterns += [ 'CVS' , '.*' , '*~' , '*.pyc' ]	append list containing 4 elements: 'CVS', '.*', '*~' and '*.pyc', to ignore_patterns.
self . ignore_patterns = list ( set ( ignore_patterns ) )	put elements of ignore_patterns into a set, substitute the length of it for self.ignore_patterns.
if options . get ( 'no_wrap' ) :	get the value under the 'no_wrap' key of the options dictionary, if it is true,
self . msgmerge_options = self . msgmerge_options [ : ] + [ '--no-wrap' ]	append list containing string '--no-wrap' to self.msgmerge_options
self . msguniq_options = self . msguniq_options [ : ] + [ '--no-wrap' ]	append list containing string '--no-wrap' to self.msguniq_options.
self . msgattrib_options = self . msgattrib_options [ : ] + [ '--no-wrap' ]	append list containing string '--no-wrap' to self.msgattrib_options.
self . xgettext_options = self . xgettext_options [ : ] + [ '--no-wrap' ]	append list containing string '--no-wrap' to self.xgettext_options.
if options . get ( 'no_location' ) :	get the value under the 'no_location' key of the options dictionary, if it is true,
self . msgmerge_options = self . msgmerge_options [ : ] + [ '--no-location' ]	append list containing string '--no-location' to self.msgmerge_options.
self . msguniq_options = self . msguniq_options [ : ] + [ '--no-location' ]	append list containing string '--no-location' to self.msguniq_options.
self . msgattrib_options = self . msgattrib_options [ : ] + [ '--no-location' ]	append list containing string '--no-location' to self.msgattrib_options.
self . xgettext_options = self . xgettext_options [ : ] + [ '--no-location' ]	append list containing string '--no-location' to self.xgettext_options.
self . no_obsolete = options . get ( 'no_obsolete' )	get the value under the 'no_obsolete' key of the options dictionary, substitute it for self.no_obsolete.
self . keep_pot = options . get ( 'keep_pot' )	get the value under the 'keep_pot' key of the options dictionary, substitute it for self.keep_pot.
if self . domain not in ( 'django' , 'djangojs' ) :	if self.domain is not equal to string 'django' or string 'djangojs',
if self . domain == 'djangojs' :	if self.domain equals to string 'djangojs',
exts = extensions if extensions else [ 'js' ]	if extensions is false, substitute it for exts, otherwise exts is a list containing string 'js'.
else :	if not,
exts = extensions if extensions else [ 'html' , 'txt' ]	if extensions is false, substitute it for exts, otherwise exts is a list containing 2 elements: string 'html' and string 'txt'.
self . extensions = handle_extensions ( exts )	call the function handle_extensions exts, substitute self.extensions.
if ( locale is None and not exclude and not process_all ) or self . domain is None :	evaluate the boolean expression: locale is None and exclude is false and process_all is false,
raise CommandError ( 'Type '%s help %s' for usage information.' % (  os . path . basename ( sys . argv [ 0 ] ) , sys . argv [ 1 ] ) )	if the result is true or self.domain is not None,   raise an CommandError exception with an argument string 'Type '%s help %s' for usage information.', where '%s' are replaced by:
from django . conf import settings	return value of the function os.path.basename called with first element of sys.argv as an argument, and second element of sys.argv.   from django.conf import settings into default namespace.
if settings . configured :	if settings.configured,
settings . USE_I18N = True	settings.USE_I18N is boolean True.
else :	if not,
settings . configure ( USE_I18N = True )	call the method settings.configure with an argument USE_I18N set to boolean True.
if self . verbosity > 1 :	if self.verbosity is integer 1,
\self . stdout . write ( 'examining files with the extensions: %s\\n'  % get_text_list ( list ( self . extensions ) , 'and' ) )\	\call the method self.stdout.write with an argument string 'examining files with the extensions: %s\\n',\
self . invoked_for_django = False	substitute '%s' with return value of the function get_text_list called with 2 arguments:self.extensions converted into a list and string 'and'.   self.invoked_for_django is boolean False.
self . locale_paths = [ ]	  self.locale_paths is an empty list.
self . default_locale_path = None	self.default_locale_path is None.
if os . path . isdir ( os . path . join ( 'conf' , 'locale' ) ) :	join 'conf' and 'locale' into a file path, if it is a directory,
self . locale_paths = [ os . path . abspath ( os . path . join ( 'conf' , 'locale' ) ) ]	join 'conf' and 'locale' into a file path, use it as an argument for the call the method os.path.abspath,
self . default_locale_path = self . locale_paths [ 0 ]	put the results into a list, substitute self.locale_paths for it.   substitute first element of self.locale_paths for self.default_locale_path.
self . invoked_for_django = True	self.invoked_for_django is boolean True.
else :	if not,
self . locale_paths . extend ( list ( settings . LOCALE_PATHS ) )	convert settings.LOCALE_PATHS into a list and extend list self.locale_paths with it.
if os . path . isdir ( 'locale' ) :	if 'locale' is a directory,
self . locale_paths . append ( os . path . abspath ( 'locale' ) )	call the function os.path.abspath with an argument 'locale', append the result to self.locale_paths.
if self . locale_paths :	if self.locale_paths is true,
self . default_locale_path = self . locale_paths [ 0 ]	substitute first element of self.locale_paths for self.default_locale_path.
if not os . path . exists ( self . default_locale_path ) :	if self.default_locale_path directory doesnt exists,
os . makedirs ( self . default_locale_path )	create a directory self.default_locale_path.
locale_dirs = filter ( os . path . isdir , glob . glob ( '%s/*' % self . default_locale_path ) )	call the function glob.glob with an argument: string '/*' appended to self.default_locale_path converted into a string,
all_locales = map ( os . path . basename , locale_dirs )	filter out the results for which function os.path.isdir returns false, substitute the result for locale_dirs.   map the locale_dirs elements with mapping function os.path.basename, substitute the result for all_locales.
if process_all :	if process_all is true,
locales = all_locales	substitute all_locales for locales.
else :	if not,
locales = locale or all_locales	if locale is not false or None, substitute it for locales, otherwise substitute all_locales for locales.
locales = set ( locales ) - set ( exclude )	locales is a difference between the locales and exclude sets.
if locales :	if locales is true,
check_programs ( 'msguniq' , 'msgmerge' , 'msgattrib' )	call the function check_programs with 3 arguments: strings 'msguniq', 'msgmerge' and 'msgattrib'.
check_programs ( 'xgettext' )	call the function check_programs with an argument string 'xgettext'.
try :	try,
potfiles = self . build_potfiles ( )	call the method self.build_potfiles, substitute the result for potfiles.
for locale in locales :	for every locale in locales,
if self . verbosity > 0 :	if self.verbosity is greater than integer 0,
\self . stdout . write ( 'processing locale %s\\n' % locale )\	\replace '%s' in string 'processing locale %s\\n' with locale, write it to self.stdout.\
for potfile in potfiles :	for every potfile in potfiles,
self . write_po_file ( potfile , locale )	call the method self.write_po_file with 2 arguments: potfile and locale.
finally :	finally perform,
if not self . keep_pot :	if self.keep_pot is false,
self . remove_potfiles ( )	call the method self.remove_potfiles.
def build_potfiles ( self ) :	define the method build_potfiles with an argument self.
file_list = self . find_files ( '.' )	call the method self.find_files with an argument string '.', substitute the result for file_list.
self . remove_potfiles ( )	call the method self.remove_potfiles.
for f in file_list :	for f in file_list,
try :	try,
f . process ( self , self . domain )	call the function f.process with 2 arguments: self and self.domain.
except UnicodeDecodeError :	if except UnicodeDecodeError exception is caught,
self . stdout . write ( 'UnicodeDecodeError: skipped file %s in %s' % ( f . file , f . dirpath ) )	substitute '%s' in string 'UnicodeDecodeError: skipped file %s in %s' with f.file and f.dirpath, write it to self.stdout.
potfiles = [ ]	potfiles is an empty list.
for path in self . locale_paths :	for every path in self.locale_paths,
potfile = os . path . join ( path , '%s.pot' % str ( self . domain ) )	join into a path: path and string '%s.pot', where '%s' is replaced with self.domain converted into a string.
if not os . path . exists ( potfile ) :	if potfile file path doesnt exist,
continue	skip this loop iteration.
args = [ 'msguniq' ] + self . msguniq_options + [ potfile ]	append self.msguniq_options to a list containing a string 'msguniq', append list containing potfile to the result, substitute it for args.
msgs , errors , status = popen_wrapper ( args )	call the function popen_wrapper with an argument args, assign the result to msgs, errors and status, respectively.
if six . PY2 :	if six.PY2 is true,
msgs = msgs . decode ( 'utf-8' )	call the method msgs.decode with an argument string 'utf-8', substitute it for msgs.
if errors :	if errors is true,
if status != STATUS_OK :	if status is not equal to STATUS_OK,
\raise CommandError (  'errors happened while running msguniq\\n%s' % errors )\	\raise an CommandError exception with an argument string 'errors happened while running msguniq\\n%s', where '%s' is replaced with errors.\
elif self . verbosity > 0 :	otherwise if self.verbosity is greater than integer 0,
self . stdout . write ( errors )	write errors to self.stdout.
with io . open ( potfile , 'w' , encoding = 'utf-8' ) as fp :	call the function io.open with 3 arguments: potfile, string 'w' and encoding set to string 'utf-8' as arguments,
fp . write ( msgs )	with the result renamed to fp, perform the following:   write msgs to fp.
potfiles . append ( potfile )	append potfile to potfiles.
return potfiles	return potfiles.
def remove_potfiles ( self ) :	define the method  remove_potfiles with an argument self.
for path in self . locale_paths :	for every path in self.locale_paths,
pot_path = os . path . join ( path , '%s.pot' % str ( self . domain ) )	join into a file path: path and string '%s.pot', where '%s' is replaced with self.domain converted into a string, substitute the result for pot_path.
if os . path . exists ( pot_path ) :	if pot_path file path exists,
os . unlink ( pot_path )	call the method os.unlink with an argument pot_path.
def find_files ( self , root ) :	define the method find_potfiles with an arguments self and root.
def is_ignored ( path , ignore_patterns ) :	define the function is_ignored with arguments path and ignore_patterns.
filename = os . path . basename ( path )	call the function os.path.basename with an arguments path, substitute the result for filename.
ignore = lambda pattern : fnmatch . fnmatchcase ( filename , pattern )	ignore is a lambda function with pattern as an argument, return value is the return value of the function fnmatch.fnmatchcase,
return any ( ignore ( pattern ) for pattern in ignore_patterns )	called with arguments: filename and pattern.   call the function ignore with an argument pattern, for every pattern in ignore_patterns,
dir_suffix = '%s*' % os . sep	if any resulting element is true, return boolean True, otherwise return boolean False.   convert os.sep into a string and append '*' to it, substitute the result for dir_suffix.
norm_patterns = [ p [ : - len ( dir_suffix ) ] if p . endswith ( dir_suffix ) else p for p in self . ignore_patterns ]	for p in self.ignore_patterns if p ends with dir_suffix take sliced list p from the start,
all_files = [ ]	to the negative length of the dir_suffix as the end index and append it to a list,   if p doesnt end with dir_suffix, append p to a list, substitute resulting list for norm_patterns.   all_files is an empty list.
for dirpath , dirnames , filenames in os . walk ( root , topdown = True , followlinks = self . symlinks ) :	call the function os.walk with 3 arguments: root, topdown set to boolean True, followlinks set to self.symlinks,
for dirname in dirnames [ : ] :	for every dirpath, dirnames and filenames in the result,   for every dirname in list dirnames,
if is_ignored ( os . path . normpath ( os . path . join ( dirpath , dirname ) ) , norm_patterns ) :	join dirpath and dirname into a file path, use is as an argument for the call to the function os.path.join,
dirnames . remove ( dirname )	use the result as an argument for the call to the os.path.join function,   use the result and the norm_patterns as arguments for the call to the is_ignored function, if it evaluates to true,   remove dirname from the dirnames.
if self . verbosity > 1 :	if self.verbosity is greater than integer 1,
\    self . stdout . write ( 'ignoring directory %s\\n' % dirname )\	\replace '%s' in string 'ignoring directory %s\\n' with dirname, write it to self.stdout stream.\
elif dirname == 'locale' :	otherwise if dirname equals string 'locale',
dirnames . remove ( dirname )	remove dirname from the dirnames.
self . locale_paths . insert ( 0 , os . path . join ( os . path . abspath ( dirpath ) , dirname ) )	call the method os.path.abspath with an argument dirpath, join the result and dirname into a file path, inset it at the beggining of self.locale_paths.
for filename in filenames :	for every filename in filenames,
file_path = os . path . normpath ( os . path . join ( dirpath , filename ) )	join dirpath and filename into path, use it as an argument for the call to the function os.path.normpath, substitute it for file_path.
if is_ignored ( file_path , self . ignore_patterns ) :	call the function is_ignored, with arguments: file_path and self.ignore_patterns, if it evaluates to true,
if self . verbosity > 1 :	if self.verbosity is greater than integer 1,
\    self . stdout . write ( 'ignoring file %s in %s\\n' % ( filename , dirpath ) )\	\replace '%s' in string 'ignoring file %s in %s\\n' with filename and dirpath, write it to self.stdout.\
else :	if not,
locale_dir = None	locale_dir is None.
for path in self . locale_paths :	for every path in self.locale_paths,
    if os . path . abspath ( dirpath ) . startswith ( os . path . dirname ( path ) ) :	call the function os.path.abspath with an argument dirpath, if it starts with return value of the method os.path.dirname,
        locale_dir = path	called with an argument path,   substitute path for locale_dir.
break	break the loop execution.
if not locale_dir :	if locale_dir is false,
    locale_dir = self . default_locale_path	substitute self.default_locale_path for locale_dir.
if not locale_dir :	if locale_dir is false,
    raise CommandError (  'Unable to find a locale path to store translations for file %s' % file_path )	raise an CommandError with an argument string 'Unable to find a locale path to store translations for file %s',
all_files . append ( TranslatableFile ( dirpath , filename , locale_dir ) )	where '%s' is replaced with file_path.   create an object TranslatableFile with arguments: dirpath, filename and locale_dir, append it to all_files.
return sorted ( all_files )	sort all_files and return it.
def write_po_file ( self , potfile , locale ) :	define the method write_po_file with arguments self, potfile and locale.
basedir = os . path . join ( os . path . dirname ( potfile ) , locale , 'LC_MESSAGES' )	call the method os.path.dirname with an argument potfile, join the result, locale and string 'LC_MESSAGES' into a file path,
if not os . path . isdir ( basedir ) :	substitute it for basedir.   if basedir is not a directory,
os . makedirs ( basedir )	make basedir directory,
pofile = os . path . join ( basedir , '%s.po' % str ( self . domain ) )	convert self.domain into a string and append string '.po' to it, join basedir and result in file path, substitute it for pofile.
if os . path . exists ( pofile ) :	if pofile path exists,
args = [ 'msgmerge' ] + self . msgmerge_options + [ pofile , potfile ]	append self.msgmerge_options to a list containing string 'msgmerge', append to it a list containing pofile and potfile, substitute the result for args.
msgs , errors , status = popen_wrapper ( args )	call the function popen_wrapper with an argument args, assign the result to msgs, errors and status.
if six . PY2 :	if six.PY2 is true,
msgs = msgs . decode ( 'utf-8' )	call the method msgs.decode with an argument string 'utf-8', substitute the result for msgs.
if errors :	if errors is true,
if status != STATUS_OK :	if statue is not equal to STATUS_OK.
\raise CommandError (  'errors happened while running msgmerge\\n%s' % errors )\	\raise an CommandError with an argument string 'errors happened while running msgmerge\\n%s', where '%s' is replaced with errors.\
elif self . verbosity > 0 :	otherwise if self.verbosity is greater than integer 0,
self . stdout . write ( errors )	write errors to self.stdout.
else :	if not,
with io . open ( potfile , 'r' , encoding = 'utf-8' ) as fp :	call the function io.open with 3 arguments: potfile, string 'r' and encoding set to string 'utf-8' as arguments,
msgs = fp . read ( )	with the result renamed to fp, perform the following:   read file fp and substitute the result for msgs.
if not self . invoked_for_django :	if self.invoked_for_django is false,
msgs = self . copy_plural_forms ( msgs , locale )	call the method self.copy_plural_forms with arguments: msgs and locale, substitute it for msgs.
\msgs = msgs . replace (  '#. #-#-#-#-#  %s.pot (PACKAGE VERSION)  #-#-#-#-#\\n' % self . domain , '' )\	\substitute '%s' in string '#. #-#-#-#-#  %s.pot (PACKAGE VERSION)  #-#-#-#-#\\n' with self.domain,\
with io . open ( pofile , 'w' , encoding = 'utf-8' ) as fp :	replace all the occurrences of previous string in msgs for an empty string, substitute the result for msgs.   call the function io.open with 3 arguments: pofile, string 'w' and encoding set to string 'utf-8' as arguments,
fp . write ( msgs )	with the result renamed to fp, perform the following:   write msgs to fp.
if self . no_obsolete :	if self.no_obsolete is true,
args = [ 'msgattrib' ] + self . msgattrib_options + [ '-o' , pofile , pofile ]	append self.msgattrib_options to a list containing string 'msgattrib', append to it a list containing string '-o', pofile and pofile,
msgs , errors , status = popen_wrapper ( args )	substitute the result for args.   call the function popen_wrapper with an argument args, assign the result to msgs, errors and status, respectively.
if errors :	if errors is true,
if status != STATUS_OK :	if status is not equal to STATUS_OK,
\raise CommandError (  'errors happened while running msgattrib\\n%s' % errors )\	\raise an CommandError with an argument string 'errors happened while running msgattrib\\n%s', where '%s' is replaced with errors.\
elif self . verbosity > 0 :	otherwise if self.verbosity is greater than integer 0,
self . stdout . write ( errors )	write errors to self.stdout.
def copy_plural_forms ( self , msgs , locale ) :	define the method copy_plural_forms with arguments self, msgs and locale.
django_dir = os . path . normpath ( os . path . join ( os . path . dirname ( django . __file__ ) ) )	call the function os.path.dirname with an argument django.__file__, join the result into a path,
if self . domain == 'djangojs' :	use it as an argument for the call to the function os.path.normpath, substitute the result for django_dir.   if self.domain equals a string 'djangojs',
domains = ( 'djangojs' , 'django' )	domains is a tuple with 2 elements: strings 'djangojs' and 'django'.
else :	if not,
domains = ( 'django' , )	domains is a tuple with element string 'django'.
for domain in domains :	  for every domain in domains,
django_po = os . path . join ( django_dir , 'conf' , 'locale' , locale , 'LC_MESSAGES' , '%s.po' % domain )	join into a file path: django_dir, 'conf', 'locale', locale, 'LC_MESSAGES' and string '.po' appended to domain, substitute the result for django_po.
if os . path . exists ( django_po ) :	if django_po file path exists,
with io . open ( django_po , 'r' , encoding = 'utf-8' ) as fp :	call the function io.open with 3 arguments: django_po, string 'r' and encoding set to string 'utf-8' as arguments,
m = plural_forms_re . search ( fp . read ( ) )	with the result renamed to fp, perform the following:   read data from file fp, use the result as an argument for the call to the function plural_forms_re.search, substitute it for m.
if m :	  if m is true,
plural_form_line = force_str ( m . group ( 'value' ) )	call the method m.group with an argument string 'value', use the result as an argument for the call to the force_str,
if self . verbosity > 1 :	substitute the result for plural_form_line.   if self.verbosity is greater than integer 1,
\    self . stdout . write ( 'copying plural forms: %s\\n' % plural_form_line )\	\replace '%s' in string 'copying plural forms: %s\\n' with plural_form_line, write it to self.stdout.\
lines = [ ]	lines is an empty list.
found = False	found is boolean False.
\for line in msgs . split ( '\\n' ) :\	split msgs by newline characters, for every line in result,
    if not found and ( not line or plural_forms_re . search ( line ) ) :	if found is false and, line is false or return value of the function plural_forms_re.search called with an argument line is false,
\        line = '%s\\n' % plural_form_line\	append newline to plural_form_line, substitute the result for line.
found = True	found is boolean True.
lines . append ( line )	append line to lines.
\msgs = '\\n' . join ( lines )\	join elements of lines into a string, separated by newline characters, substitute it for msgs.
break	break the loop execution.
return msgs	return msgs.
import sys	import module sys.
import os	import module os.
import operator	import module operator.
from django . apps import apps	from django.apps import apps into default name space.
from django . core . management . base import BaseCommand , CommandError	from django.core.management.base import BaseCommand and CommandError into default name space.
from django . db . migrations import Migration	from django.db.migrations import Migration into default name space.
from django . db . migrations . loader import MigrationLoader	from django.db.migrations.loader import MigrationLoader into default name space.
from django . db . migrations . autodetector import MigrationAutodetector	from django.db.migrations.autodetector import MigrationAutodetector into default name space.
from django . db . migrations . questioner import MigrationQuestioner , InteractiveMigrationQuestioner	from django.db.migrations.questioner import MigrationQuestioner and InteractiveMigrationQuestioner into default name space.
from django . db . migrations . state import ProjectState	from django.db.migrations.state import ProjectState into default name space.
from django . db . migrations . writer import MigrationWriter	from django.db.migrations.writer import MigrationWriter into default name space.
from django . utils . six . moves import reduce	from django.utils.six.moves import reduce into default name space.
class Command ( BaseCommand ) :	derive the class Command from the BaseCommand class.
help = 'Creates new migration(s) for apps.'	  help is a string 'Creates new migration(s) for apps.'.
def add_arguments ( self , parser ) :	define the method add_arguments with 2 arguments self and parser.
parser . add_argument ( 'args' , metavar = 'app_label' , nargs = '*' ,  help = 'Specify the app label(s) to create migrations for.' )	call the method parser.add_argument with 4 arguments: string 'args', metavar set to string 'app_label', nargs set to character'*',
parser . add_argument ( '--dry-run' , action = 'store_true' , dest = 'dry_run' , default = False ,  help = 'Just show what migrations would be made; don't actually write them.' )	and help as a string 'Specify the app label(s) to create migrations for.'.   call the method parser.add_argument with 5 arguments: string '--dry-run', action as a string 'store_true', dest as string 'dry_run',
parser . add_argument ( '--merge' , action = 'store_true' , dest = 'merge' , default = False ,  help = 'Enable fixing of migration conflicts.' )	default set to boolean False, help as a string 'Just show what migrations would be made; don't actually write them.'.   call the method parser.add_argument with 5 arguments: string '--merge', action as a string 'store_true', dest as a string 'merge',
parser . add_argument ( '--empty' , action = 'store_true' , dest = 'empty' , default = False ,  help = 'Create an empty migration.' )	default set to boolean False and help set to a string 'Enable fixing of migration conflicts.'.   call the method parser.add_argument with 5 arguments: string '--empty', action as a string 'store_true', dest as a string 'empty',
parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )	default set to boolean False and help as a string 'Create an empty migration.'.   call the method parser.add_argument with 5 arguments: string '--noinput', action as a string 'store_false',
def handle ( self , * app_labels , ** options ) :	dest as a string 'interactive', default set to boolean True,   and help as a string 'Tells Django to NOT prompt the user for input of any kind.'.   define the method handle with 3 arguments: self, unpacked list app_labels and unpacked dictionary options.
self . verbosity = options . get ( 'verbosity' )	get the value under the 'verbosity' key of the options dictionary, substitute it for self.verbosity.
self . interactive = options . get ( 'interactive' )	get the value under the 'interactive' key of the options dictionary, substitute it for self.interactive.
self . dry_run = options . get ( 'dry_run' , False )	get the value under the 'dry_run' key of the options dictionary, if the key exists substitute it for self.dry_run,
self . merge = options . get ( 'merge' , False )	if not, self.dry_run is boolean False.   get the value under the 'merge' key of the options dictionary, if the key exists substitute it for self.merge,
self . empty = options . get ( 'empty' , False )	if not, self.merge is boolean False.   get the value under the 'empty' key of the options dictionary, if the key exists substitute it for self.empty,
app_labels = set ( app_labels )	if not, self.empty is boolean False.   crate a set containing of app_labels elements, substitute it for app_labels.
bad_app_labels = set ( )	bad_app_labels is an empty set.
for app_label in app_labels :	for every app_label in app_labels,
try :	try,
apps . get_app_config ( app_label )	call the method apps.get_app_config with an argument app_label.
except LookupError :	if LookupError exception is caught,
bad_app_labels . add ( app_label )	call the method bad_app_labels with an argument app_label,
if bad_app_labels :	if bad_app_labels is true,
for app_label in bad_app_labels :	for every app_label in bad_app_labels,
self . stderr . write ( 'App '%s' could not be found. Is it in INSTALLED_APPS?' % app_label )	write string 'App '%s' could not be found. Is it in INSTALLED_APPS?' with '%s' where '%s' is replaced with app_label,
sys . exit ( 2 )	write it for self.stderr.   exit the program with the integer 2 as exit code.
loader = MigrationLoader ( None , ignore_no_migrations = True )	loader is an instance of MigrationLoader class, created with 2 arguments: None and ignore_no_migrations set to boolean True.
conflicts = loader . detect_conflicts ( )	call the method loader.detect_conflicts, substitute the result for conflicts.
if conflicts and not self . merge :	if conflicts is true and self.merge is false,
name_str = '; ' . join (  '%s in %s' % ( ', ' . join ( names ) , app )  for app , names in conflicts . items ( )  )	for every app and names in result of the method conflicts.items, join names into a string, separated by ', ',
if self . merge and not conflicts :	with name_str, use it as an argument to throw an CommandError exception.   if self.merge is true and conflicts is false,
self . stdout . write ( 'No conflicts detected to merge.' )	write string 'No conflicts detected to merge.' to self.stdout stream.
return	return nothing.
if self . merge and conflicts :	if self.merge and conflicts are both true,
return self . handle_merge ( loader , conflicts )	call the method self.handle_merge with 2 arguments: loader and conflicts, return the result.
autodetector = MigrationAutodetector (  loader . project_state ( ) ,  ProjectState . from_apps ( apps ) ,  InteractiveMigrationQuestioner ( specified_apps = app_labels , dry_run = self . dry_run ) ,  )	autodetector is an instance of the MigrationAutodetector class, created with 3 arguments: result of the method loader.project_state,
if self . empty :	result of the method ProjectState.from_apps with an argument apps and result of the method InteractiveMigrationQuestioner,   called with 2 arguments specified_apps set to app_labels and dry_run set to self.dry_run.   if self.empty is true,
if not app_labels :	if app_labels is false,
raise CommandError ( 'You must supply at least one app label when using --empty.' )	raise an CommandError with an argument string 'You must supply at least one app label when using --empty.'.
changes = dict (  ( app , [ Migration ( 'custom' , app ) ] )  for app in app_labels  )	crate a dictionary with app mapping and from the class Migration, created with arguments: string 'custom' and app,
changes = autodetector . arrange_for_graph ( changes , loader . graph )	for every app in app_labels.   call the method autodetector.arrange_for_graph with 2 arguments: changes, loader.graph, substitute the result for changes.
self . write_migration_files ( changes )	call the method self.write_migration_files with an argument changes.
return	return nothing.
changes = autodetector . changes (  graph = loader . graph ,  trim_to_apps = app_labels or None ,  convert_apps = app_labels or None ,  )	call the method autodetector.changes with 3 arguments: graph set to loader.graph, trim_to_apps set to app_labels,
if not changes and self . verbosity >= 1 :	if it exists or None if not and convert_apps set to app_labels, if it exists or None if not, substitute the result for changes.   if changes is false and self.verbosity is greater than, or equal to iteger 1,
if len ( app_labels ) == 1 :	if length of app_labels is equal to integer 1,
elif len ( app_labels ) > 1 :	otherwise if length of app_labels is greater than integer 1,
else :	write it to self.stdout.   if not,
self . stdout . write ( 'No changes detected' )	write string 'No changes detected' to self.stdout stream.
return	return nothing.
self . write_migration_files ( changes )	call the method self.write_migration_files with an argument changes.
def write_migration_files ( self , changes ) :	define the method write_migration_files with arguments self and changes.
directory_created = { }	directory_created is an empty dictionary.
for app_label , app_migrations in changes . items ( ) :	for every app_label and app_migrations in result of the method changes.items,
if self . verbosity >= 1 :	if self.verbosity is greater or equal to integer 1,
\self . stdout . write ( self . style . MIGRATE_HEADING ( 'Migrations for '%s':' % app_label ) + '\\n' )\	substitute '%s' in a string 'Migrations for '%s':' with app_label, append newline to it,
for migration in app_migrations :	use it as an argument for the call to the method self.style.MIGRATE_HEADING, write the result to self.stdout.   for every migration in app_migrations,
writer = MigrationWriter ( migration )	writer is an instance of MigrationWriter class, created with an argument migration.
if self . verbosity >= 1 :	if self.verbosity is greater or equal to integer 1,
\self . stdout . write ( '  %s:\\n' % ( self . style . MIGRATE_LABEL ( writer . filename ) , ) )\	\substitute '%s' in a string '  %s:\\n' with return value of the self.style.MIGRATE_LABEL method called with argument writer.filename,\
for operation in migration . operations :	write the result to self.stdout.   for every operation in migration.operations,
\    self . stdout . write ( '    - %s\\n' % operation . describe ( ) )\	\substitute '%s' in a string '    - %s\\n' with return value of the operation.describe method, write the result to self.stdout.\
if not self . dry_run :	if self.dry_run is false,
  migrations_directory = os . path . dirname ( writer . path )	call the function os.path.dirname with an argument writer.path, substitute the result for migrations_directory.
if not directory_created . get ( app_label , False ) :	get the value under the app_label key of the directory_created dictionary, if exists and it is false,
    if not os . path . isdir ( migrations_directory ) :	if migrations_directory is not a directory,
        os . mkdir ( migrations_directory )	make a directory migrations_directory.
init_path = os . path . join ( migrations_directory , '__init__.py' )	join migrations_directory and string '__init__.py' into a file path, substitute it for init_path.
if not os . path . isfile ( init_path ) :	if init_path is not a file,
        open ( init_path , 'w' ) . close ( )	crate a file named init_path.
directory_created [ app_label ] = True	value under the all_label key of the directory_created dictionary is boolean True.
migration_string = writer . as_string ( )	call the method writer.as_string, substitute the result for migration_string.
with open ( writer . path , 'wb' ) as fh :	open writer.path file in write mode, with the file descriptor as fh, perform,
    fh . write ( migration_string )	write migration_string to file fh.
elif self . verbosity == 3 :	otherwise if self.verbosity equals integer 3,
\    self . stdout . write ( self . style . MIGRATE_HEADING ( 'Full migrations file '%s':' % writer . filename ) + '\\n' )\	substitute '%s' in a string 'Full migrations file '%s':' with writer.filename, append newline to it,
\self . stdout . write ( '%s\\n' % writer . as_string ( ) )\	use it as an argument for the call to the method self.style.MIGRATE_HEADING, write the result to self.stdout.   call the method writer.as_string, append newline to the result, write it to self.stdout.
def handle_merge ( self , loader , conflicts ) :	define the method handle_merge with arguments self, loader and conflicts.
if self . interactive :	if self.interactive is true,
questioner = InteractiveMigrationQuestioner ( )	questioner is an instance of a InteractiveMigrationQuestioner class.
else :	if not,
questioner = MigrationQuestioner ( defaults = { 'ask_merge' : True } )	questioner is an instance of a InteractiveMigrationQuestioner class, created with an argument: defaults set to dictionary with entry:
for app_label , migration_names in conflicts . items ( ) :	boolean True for 'ask_merge'.   for every app_label and migration_names in result of the method conflicts.items,
merge_migrations = [ ]	merge_migrations is an empty list.
for migration_name in migration_names :	for every migration_name in migration_names,
migration = loader . get_migration ( app_label , migration_name )	call the method loader.get_migration with arguments app_label and migration_name, substitute the result for migration.
migration . ancestry = loader . graph . forwards_plan ( ( app_label , migration_name ) )	call the method loader.graph.forwards_plan with argument a tuple, with 2 elements: app_label and migration_name,
merge_migrations . append ( migration )	substitute the result for migration.ancestry.   append migration to merge_migrations.
common_ancestor = None	common_ancestor is None.
for level in zip ( * [ m . ancestry for m in merge_migrations ] ) :	for m in merge_migrations append m.ancestry to a list, zip the resulting list into tuples of pairs, for every level in result,
if reduce ( operator . eq , level ) :	apply operator.eq function to elements of level iterable, until level is reduced to a single value, if the result is true,
common_ancestor = level [ 0 ]	substitute first element of level for common_ancestor.
else :	if not,
break	break the loop execution,
if common_ancestor is None :	if common_ancestor is None,
raise ValueError ( 'Could not find common ancestor of %s' % migration_names )	raise an ValueError with an argument string 'Could not find common ancestor of %s', where '%s' is replaced with migration_names.
for migration in merge_migrations :	for every migration in merge_migrations,
migration . branch = migration . ancestry [  ( migration . ancestry . index ( common_ancestor ) + 1 ) :  ]	call the method migration.ancestry.index with an argument common_ancestor, increment the result by one,
migration . merged_operations = [ ]	slice migration.ancestry list from the last result as an starting index to the end, substitute the slice for migration.branch.   migration.merged_operations is an empty list.
for node_app , node_name in migration . branch :	for every node_app and node_name in migration.branch,
migration . merged_operations . extend (  loader . get_migration ( node_app , node_name ) . operations  )	call the method loader.get_migration with arguments node_app and node_name, extend the migration.merged_operations with the operations field of the result.
if self . verbosity > 0 :	if self.verbosity is greater than integer 1,
self . stdout . write ( self . style . MIGRATE_HEADING ( 'Merging %s' % app_label ) )	substitute '%s' in a string 'Merging %s' with app_label,
for migration in merge_migrations :	use it as an argument for the call to the method self.style.MIGRATE_HEADING, write the result to self.stdout.   for every migration in merge_migrations,
self . stdout . write ( self . style . MIGRATE_LABEL ( '  Branch %s' % migration . name ) )	substitute '%s' in a string '  Branch %s' with migration.name,
for operation in migration . merged_operations :	use it as an argument for the call to the method self.style.MIGRATE_HEADING, write the result to self.stdout.   for every operation in migration.merged_operations,
\    self . stdout . write ( '    - %s\\n' % operation . describe ( ) )\	\substitute '%s' in a string '    - %s\\n' with return value of the operation.describe method, write the result to self.stdout.\
if questioner . ask_merge ( app_label ) :	call the method questioner.ask_merge with an argument app_label, if it evaluates to true,
numbers = [  MigrationAutodetector . parse_number ( migration . name )  for migration in merge_migrations  ]	numbers is a list containing return value of the MigrationAutodetector.parse_number method called with an argument migration.name,
try :	for every migration in merge_migrations.   try,
biggest_number = max ( [ x for x in numbers if x is not None ] )	biggest_number is maximum numbers element.
except ValueError :	if ValueError exception is caught,
biggest_number = 1	biggest_number is integer 1.
subclass = type ( 'Migration' , ( Migration , ) , {  'dependencies' : [ ( app_label , migration . name ) for migration in merge_migrations ] ,  } )	subclass is a instance of a class named Migration, derived from the base class Migration, with 1 field:
new_migration = subclass ( '%04i_merge' % ( biggest_number + 1 ) , app_label )	dependencies set to a list of tuples with 2 elements: app_label and migration.name for every migration in merge_migrations.   call the method subsclass with 2 arguments: string '%04i_merge', replace '%04i' with biggest_number incremented by one,
writer = MigrationWriter ( new_migration )	that occupies minimum 4 places within a string, and app_label, substitute the result for new_migration.   writer is instance of MigrationWriter class, created with new_migration argument.
with open ( writer . path , 'wb' ) as fh :	open writer.path file in write mode, with the file descriptor as fh, perform the following,
fh . write ( writer . as_string ( ) )	call the method writer.as_string, write the result to fh file.
if self . verbosity > 0 :	if self.verbosity is greater than integer 0,
\self . stdout . write ( '\\nCreated new merge migration %s' % writer . path )\	\substitute '%s' in a string '\\nCreated new merge migration %s' with writer path, write it to self.stdout.\
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from collections import OrderedDict	from collections import OrderedDict into default name space.
from importlib import import_module	from importlib import import_module into default name space.
import itertools	import module itertools.
import traceback	import module traceback.
from django . apps import apps	from django.apps import apps into default name space.
from django . core . management import call_command	from django.core.management import call_command into default name space.
from django . core . management . base import BaseCommand , CommandError	from django.core.management.base import BaseCommand and CommandError into default name space.
from django . core . management . color import no_style	from django.core.management.color import no_style into default name space.
from django . core . management . sql import custom_sql_for_model , emit_post_migrate_signal , emit_pre_migrate_signal	from django.core.management.sql import custom_sql_for_model, emit_post_migrate_signal and emit_pre_migrate_signal into default name space.
from django . db import connections , router , transaction , DEFAULT_DB_ALIAS	from django.db import connections,  router,  transaction and DEFAULT_DB_ALIAS into default name space.
from django . db . migrations . executor import MigrationExecutor	from django.db.migrations.executor import MigrationExecutor into default name space.
from django . db . migrations . loader import MigrationLoader , AmbiguityError	from django.db.migrations.loader import MigrationLoader and AmbiguityError into default name space.
from django . db . migrations . state import ProjectState	from django.db.migrations.state import ProjectState into default name space.
from django . db . migrations . autodetector import MigrationAutodetector	from django.db.migrations.autodetector import MigrationAutodetector into default name space.
from django . utils . module_loading import module_has_submodule	from django.utils.module_loading import module_has_submodule into default name space.
class Command ( BaseCommand ) :	derive the class Command from the base class BaseCommand.
help = 'Updates database schema. Manages both apps with migrations and those without.'	help is a string 'Updates database schema. Manages both apps with migrations and those without.'.
def add_arguments ( self , parser ) :	define the method add_arguments with self class instance and parse as the arguments.
parser . add_argument ( 'app_label' , nargs = '?' ,  help = 'App label of an application to synchronize the state.' )	call the method parser.add_argument with string 'app_label', nargs set to charcter '?', help containing string,
parser . add_argument ( 'migration_name' , nargs = '?' ,  help = 'Database state will be brought to the state after that migration.' )	'App label of an application to synchronize the state.' as arguments.   call the method parser.add_argument with string 'migration_name', nargs set to charcter '?', help containing string,
parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )	'Database state will be brought to the state after that migration.' as arguments.   call the method parser.add_argument with string '--noinput', action containing string 'store_false', dest set to string 'interactive',
parser . add_argument ( '--no-initial-data' , action = 'store_false' , dest = 'load_initial_data' , default = True ,  help = 'Tells Django not to load any initial data after database synchronization.' )	default set to True, help containing string 'Tells Django to NOT prompt the user for input of any kind.' as arguments.   call the method parser.add_argument with string '--no-initial-data', action containing string 'store_false',
parser . add_argument ( '--database' , action = 'store' , dest = 'database' ,  default = DEFAULT_DB_ALIAS , help = 'Nominates a database to synchronize. '  'Defaults to the 'default' database.' )	dest set to string 'load_initial_data', default set to True,   help containing string 'Tells Django not to load any initial data after database synchronization.' as arguments.   call the method parser.add_argument with string '--database', action containing string 'store', dest set to string 'database',
parser . add_argument ( '--fake' , action = 'store_true' , dest = 'fake' , default = False ,  help = 'Mark migrations as run without actually running them' )	default set to DEFAULT_DB_ALIAS, help containing string 'Nominates a database to synchronize. Defaults to the 'default' database.' as arguments.   call the method parser.add_argument with string '--fake', action containing string 'store_true', dest set to string 'fake',
parser . add_argument ( '--list' , '-l' , action = 'store_true' , dest = 'list' , default = False ,  help = 'Show a list of all known migrations and which are applied' )	default set to False, help containing string 'Mark migrations as run without actually running them' as arguments.   call the method parser.add_argument with string '--list', string '-l', action contains string 'store_true', dest set to string 'list',
def handle ( self , * args , ** options ) :	default set to False, help containing string 'Show a list of all known migrations and which are applied' as arguments.   define the method handle with self instance of a class, list args, dictionary options as arguments.
self . verbosity = options . get ( 'verbosity' )	get the value from the options dictionary under the key 'verbosity', substitute it for self.verbosity.
self . interactive = options . get ( 'interactive' )	get the value from the options dictionary under the key 'interactive', substitute it for self.interactive.
self . show_traceback = options . get ( 'traceback' )	get the value from the options dictionary under the key 'traceback', substitute it for self.show_traceback.
self . load_initial_data = options . get ( 'load_initial_data' )	get the value from the options dictionary under the key 'load_initial_data', substitute it for self.load_initial_data.
self . test_database = options . get ( 'test_database' , False )	get the value from the options dictionary under the key 'test_database', or False if the key dont exists, substitute it for self.test_database.
for app_config in apps . get_app_configs ( ) :	for every app_config in return value of the call to the function apps.get_app_configs,
if module_has_submodule ( app_config . module , 'management' ) :	if call to the function module_has_submodule with app_config.module and 'management' evaluates to True.
import_module ( '.management' , app_config . name )	import module '.management' from the package app_config.name.
db = options . get ( 'database' )	get the value under the key 'database' of the options dictionary, substitute it for db.
connection = connections [ db ]	substitute connections element at the index of the value db for connections.
if options . get ( 'list' , False ) :	get the value under the 'list' key of options dictionary, if key doesnt exist return False, if the return value is True,
return self . show_migration_list ( connection , [ options [ 'app_label' ] ] if options [ 'app_label' ] else None )	call the method self.show_migration_list with connection as first argument, as second argument use value under the 'app_label' key of options dictionary,
executor = MigrationExecutor ( connection , self . migration_progress_callback )	if exists, if not use None as the second argument, return the result.   call the function MigrationExecutor with connection and self.migration_progress_callback as arguments, substitute the result fro executor.
conflicts = executor . loader . detect_conflicts ( )	call the executor.loader.detect_conflicts, substitute the result fr conflicts.
if conflicts :	if conflicts is true,
name_str = '; ' . join (  '%s in %s' % ( ', ' . join ( names ) , app )  for app , names in conflicts . items ( )  )	for every app and names in key, value tuple pairs of conflicts dictionary join names into a string separated by commas,
run_syncdb = False	with '%s' substituted for name_str, as argument.   run_syncdb is boolean False.
target_app_labels_only = True	target_app_labels_only is boolean True.
if options [ 'app_label' ] and options [ 'migration_name' ] :	if values under the 'app_label' and 'migration_name' keys of the options dictionary are True,
app_label , migration_name = options [ 'app_label' ] , options [ 'migration_name' ]	assign values under the 'app_label' and 'migration_name' keys of the options dictionary to the app_label and migration_name, respectively.
if app_label not in executor . loader . migrated_apps :	if app_label is not contained in executor.loader.migrated_apps,
raise CommandError ( 'App '%s' does not have migrations (you cannot selectively sync unmigrated apps)' % app_label )	raise CommandError exception with 'App '%s' does not have migrations (you cannot selectively sync unmigrated apps)',
if migration_name == 'zero' :	with '%s' substituted for app_label, as arguments.   if migration_name equals to string 'zero',
targets = [ ( app_label , None ) ]	targets is a list containing tuple with two elements, app_label and None.
else :	if not,
try :	try,
migration = executor . loader . get_migration_by_prefix ( app_label , migration_name )	call the executor.loader.get_migration_by_prefix with app_label and migration_name, substitute the result for migration.
except AmbiguityError :	if AmbiguityError exception is caught,
raise CommandError ( 'More than one migration matches '%s' in app '%s'. Please be more specific.' % (  migration_name , app_label ) )	raise CommandError exception with 'More than one migration matches '%s' in app '%s'. Please be more specific.',
except KeyError :	with '%s' substituted for migration_name and app_label, respectively, as arguments.   if KeyError exception is caught,
raise CommandError ( 'Cannot find a migration matching '%s' from app '%s'.' % (  migration_name , app_label ) )	raise CommandError exception with 'Cannot find a migration matching '%s' from app '%s'.',
targets = [ ( app_label , migration . name ) ]	with '%s' substituted for migration_name and app_label, respectively, as arguments.   targets is a list containing tuple with two elements, app_label and migration.name.
target_app_labels_only = False	target_app_labels_only is boolean False.
elif options [ 'app_label' ] :	otherwise if value under the 'app_label' key of options dictionary is true,
app_label = options [ 'app_label' ]	substitute the value under the 'app_label' key of options dictionary for app_label.
if app_label not in executor . loader . migrated_apps :	if app_label is not contained in executor.loader.migrated_apps,
raise CommandError ( 'App '%s' does not have migrations (you cannot selectively sync unmigrated apps)' % app_label )	raise CommandError exception with 'App '%s' does not have migrations (you cannot selectively sync unmigrated apps)',
targets = [ key for key in executor . loader . graph . leaf_nodes ( ) if key [ 0 ] == app_label ]	with '%s' substituted for app_label, as arguments.   for every key in return vale of the method executor.loader.graph.leaf_nodes, check if the first element of key equals to app_label,
else :	if it does append it to targets list.   if not,
targets = executor . loader . graph . leaf_nodes ( )	call the method executor.loader.graph.leaf_nodes and substitute its result for targets.
run_syncdb = True	run_syncdb is boolean True.
plan = executor . migration_plan ( targets )	call the executor.migration_plan method with targets as the argument, substitute the result for plan.
if self . verbosity >= 1 :	if self.verbosity is greater or equal to integer 1.
self . stdout . write ( self . style . MIGRATE_HEADING ( 'Operations to perform:' ) )	call the self.style.MIGRATE_HEADING method, with string 'Operations to perform:' as an argument,
if run_syncdb and executor . loader . unmigrated_apps :	use the result as an argument for the call to the self.stdout.write method.   if run_syncdb and executor.loader.unmigrated_apps exist,
self . stdout . write ( self . style . MIGRATE_LABEL ( '  Synchronize unmigrated apps: ' ) + ( ', ' . join ( executor . loader . unmigrated_apps ) ) )	join the executor.loader.unmigrated_apps into a string separated by string ', ' append it to the end of a string '  Synchronize unmigrated apps: ',
if target_app_labels_only :	use it as an argument for the call to the self.style.MIGRATE_LABEL method, use the result of the previous method as an argument for the call to the self.stdout.write method.   if target_app_labels_only is true,
self . stdout . write ( self . style . MIGRATE_LABEL ( '  Apply all migrations: ' ) + ( ', ' . join ( set ( a for a , n in targets ) ) or '(none)' ) )	for every a and n in targets, put a into a set, join all the set elements into a string separated by string ', ',
else :	if set is empty return string '(none)' instead, append the previous to the string ' Apply all migrations: ',   use the previous string as the argument for the call to the method self.style.MIGRATE_LABEL,   use the result as an argument for the call to the method self.stdout.write.   if not,
if targets [ 0 ] [ 1 ] is None :	if element of targets in first row and second column is None,
self . stdout . write ( self . style . MIGRATE_LABEL ( '  Unapply all migrations: ' ) + '%s' % ( targets [ 0 ] [ 0 ] , ) )	convert the first element of the first row of targets to string, append it to the string '  Unapply all migrations: ',
else :	use the it as an argument for the call to the self.style.MIGRATE_LABEL method, use the result to cal the self.stdout.write method.   if not,
self . stdout . write ( self . style . MIGRATE_LABEL ( '  Target specific migration: ' ) + '%s, from %s' % ( targets [ 0 ] [ 1 ] , targets [ 0 ] [ 0 ] ) )	replace '%s' in string '%s, from %s' with second and first element of the first targets row, respectively,
if run_syncdb and executor . loader . unmigrated_apps :	append it to the string '  Target specific migration: ', use it as the argument for the call to the self.style.MIGRATE_LABEL method,   call the self.stdout.write method with previous return value as an argument.   if run_syncdb and executor.loader.unmigrated_apps is true,
if self . verbosity >= 1 :	if self.verbosity is greater or equal to integer 1.
self . stdout . write ( self . style . MIGRATE_HEADING ( 'Synchronizing apps without migrations:' ) )	call the self.style.MIGRATE_HEADING with string 'Synchronizing apps without migrations:' as an argument,
created_models = self . sync_apps ( connection , executor . loader . unmigrated_apps )	use the result as an argument for the call to the self.stdout.write.   call the self.sync_apps method with connection and executor.loader.unmigrated_apps as arguments, substitute it for created_models.
else :	if not,
created_models = [ ]	create_models is an empty list.
if options . get ( 'test_flush' , False ) :	if the value under the 'test_flush' key of the options dictionary exists,
call_command (  'flush' ,  verbosity = max ( self . verbosity - 1 , 0 ) ,  interactive = False ,  database = db ,  reset_sequences = False ,  inhibit_post_migrate = True ,  )	call the function call_command with string 'flush', verbosity set to greater element, self.verbosity decremented by 1 or integer 0,
if self . verbosity >= 1 :	interactive set to boolean False, database set to db, reset_sequences set to boolean False, inhibit_post_migrate set to boolean True.   if self.verbosity is greater or equal to integer 1,
self . stdout . write ( self . style . MIGRATE_HEADING ( 'Running migrations:' ) )	call the self.style.MIGRATE_HEADING method with string 'Running migrations:' as an argument, use the result as an argument for the call to the self.stdout.write method.
if not plan :	if plan is not true,
if self . verbosity >= 1 :	if self.verbosity is greater or equal to integer 1,
self . stdout . write ( '  No migrations to apply.' )	call the method self.stdout.write with string '  No migrations to apply.' as an argument.
autodetector = MigrationAutodetector (  executor . loader . project_state ( ) ,  ProjectState . from_apps ( apps ) ,  )	call the MigrationAutodetector function with arguments, return value of the call to the method executor.loader.project_state,
changes = autodetector . changes ( graph = executor . loader . graph )	and return value of the call to the method ProjectState.from_apps with apps as an argument, assign it to the autodetector.   call the method autodetector.changes with the graph set to executor.loader.graph as an argument, substitute it for the changes.
if changes :	if changes is true,
self . stdout . write ( self . style . NOTICE ( '  Your models have changes that are not yet reflected in a migration, and so won't be applied.' ) )	call the method self.style.NOTICE with string '  Your models have changes that are not yet reflected in a migration, and so won't be applied.' as an argument, use the result as an argument for the call to the self.stdout.write method.
self . stdout . write ( self . style . NOTICE ( '  Run 'manage.py makemigrations' to make new migrations, and then re-run 'manage.py migrate' to apply them.' ) )	call the method self.style.NOTICE with string '  Run 'manage.py makemigrations' to make new migrations, and then re-run 'manage.py migrate' to apply them.' as an argument, use the result as an argument for the call to the self.stdout.write method.
else :	if not,
executor . migrate ( targets , plan , fake = options . get ( 'fake' , False ) )	call the executor.migrate method with, targets, plan and fake set to the value under the 'fake' key of options dictionary,
emit_post_migrate_signal ( created_models , self . verbosity , self . interactive , connection . alias )	if the 'fake' key doesnt exists set fake to boolean False, as arguments.   call the method emit_post_migrate_signal with created_models, self.verbosity, self.interactive and connection.alias as arguments.
def migration_progress_callback ( self , action , migration , fake = False ) :	define the method migration_progress_callback with self class instance, action, migration and fake set to boolean False as arguments.
if self . verbosity >= 1 :	if self.verbosity is greater or equal to integer 1,
if action == 'apply_start' :	if action equals to string 'apply_start',
self . stdout . write ( '  Applying %s...' % migration , ending = '' )	call the self.stdout.write method, with string '  Applying %s...' with '%s' replaced with migration and ending set to '', as arguments.
self . stdout . flush ( )	flush the output buffer of the self.stdout object.
elif action == 'apply_success' :	otherwise if action equals to string 'apply_success',
if fake :	if fake is true,
self . stdout . write ( self . style . MIGRATE_SUCCESS ( ' FAKED' ) )	wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS with string ' FAKED' as a argument.
else :	if not,
self . stdout . write ( self . style . MIGRATE_SUCCESS ( ' OK' ) )	wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS with string ' OK' as a argument.
elif action == 'unapply_start' :	otherwise if action equals to string 'unapply_start'.
self . stdout . write ( '  Unapplying %s...' % migration , ending = '' )	call the self.stdout.write method, with string '  Unapplying %s...' with '%s' replaced with migration and ending set to '', as arguments.
self . stdout . flush ( )	flush the output buffer of the self.stdout object.
elif action == 'unapply_success' :	otherwise if action equals to string 'unapply_success'.
if fake :	if fake is true,
self . stdout . write ( self . style . MIGRATE_SUCCESS ( ' FAKED' ) )	wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS with string ' FAKED' as a argument.
else :	if not,
self . stdout . write ( self . style . MIGRATE_SUCCESS ( ' OK' ) )	wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS with string ' OK' as a argument.
def sync_apps ( self , connection , app_labels ) :	define the method sync_apps with self class instance, connection and app_labels as arguments.
cursor = connection . cursor ( )	call the connection.cursor method, substitute the result for cursor.
try :	try,
tables = connection . introspection . table_names ( cursor )	call the connection.introspection.table_names with cursor as argument, store the result in tables.
seen_models = connection . introspection . installed_models ( tables )	call the connection.introspection.table_names with tables as argument, store the result in seen_models.
created_models = set ( )	created_models is a set.
pending_references = { }	pending_references is a empty dictionary.
all_models = [  ( app_config . label ,  router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) )  for app_config in apps . get_app_configs ( )  if app_config . models_module is not None and app_config . label in app_labels  ]	for every app_config in return value of the method apps.get_app_configs if app_config.models_module is not None,
def model_installed ( model ) :	and app_config.label is contained in app_labels, create a tuple containing app_config.label and return value of the method   router.get_migratable_models called with app_config, connection.alias and include_auto_created set to True, append the tuple to the list all_models.   define the method model_installed with model as an argument.
opts = model . _meta	substitute model._meta for opts.
converter = connection . introspection . table_name_converter	substitute connection.introspection.table_name_converter for converter.
return not ( ( converter ( opts . db_table ) in tables ) or  ( opts . auto_created and converter ( opts . auto_created . _meta . db_table ) in tables ) )	evaluate next boolean expression, value of converter function with opts.db_table as argument is contained in tables,
manifest = OrderedDict (  ( app_name , list ( filter ( model_installed , model_list ) ) )  for app_name , model_list in all_models  )	or opts.auto_created is True and return value of converter function with opts.auto_created._meta.db_table is contained in tables,   invert the evaluated expression and return it.   manifest is OrderDict class instance, created with tuple of two elements, app_name and list of elements of model_list for which model_installed function returned true, for every app_name and model_list in all_modules.
create_models = set ( itertools . chain ( * manifest . values ( ) ) )	unpack the manifest.values function return value and feed it to the itertools.chain function, create_models is a set containing chanied list.
emit_pre_migrate_signal ( create_models , self . verbosity , self . interactive , connection . alias )	call the emit_pre_migrate_signal with create_models, self.verbosity, self.interactive. connection.alias as arguments.
if self . verbosity >= 1 :	if self.verbosity is greater or equal than integer 1,
\self . stdout . write ( '  Creating tables...\\n' )\	\write the string '  Creating tables...\\n' to the standard output.\
with transaction . atomic ( using = connection . alias , savepoint = connection . features . can_rollback_ddl ) :	with the call to the transaction.atomic method with using set to connection.alias, savepoint set to connection.features.can_rollback_ddl as arguments,
for app_name , model_list in manifest . items ( ) :	for every app_name and model_list in return value of manifest.items function,
for model in model_list :	for every model in model_list,
      if self . verbosity >= 3 :	if self.verbosity is greater or equal to 3,
\        self . stdout . write ( '    Processing %s.%s model\\n' % ( app_name , model . _meta . object_name ) )\	\call the self.stdout.write method with string '    Processing %s.%s model\\n' as argument, with all occurrences of '%s' replaced with,\
sql , references = connection . creation . sql_create_model ( model , no_style ( ) , seen_models )	app_name and model._meta.object_name, respectively.   evaluate connection.creation.sql_create_model method with model, no_style() and seen_models as arguments,
seen_models . add ( model )	assign the result to the sql and references, respectively.   add model to seen_models set.
created_models . add ( model )	add model to created_models set.
for refto , refs in references . items ( ) :	for every refto and refs in return value of references.items method.
        pending_references . setdefault ( refto , [ ] ) . extend ( refs )	call the method extend with refs as argument, on the result call the pending_references.setdefault method with refto and empty list as arguments.
if refto in seen_models :	if refto is contained in seen_models,
            sql . extend ( connection . creation . sql_for_pending_references ( refto , no_style ( ) , pending_references ) )	call the connection.creation.sql_for_pending_references method with refto, no_style() and pending_references as arguments,
sql . extend ( connection . creation . sql_for_pending_references ( model , no_style ( ) , pending_references ) )	use the result as the argument for the call to the sql.extend method.   call the connection.creation.sql_for_pending_references method with refto, no_style() and pending_references as arguments,
if self . verbosity >= 1 and sql :	use the result as the argument for the call to the sql.extend method.   if self.verbosity is greater or equal than integer 1 and sql is true,
\        self . stdout . write ( '    Creating table %s\\n' % model . _meta . db_table )\	\call the self.stdout.write method with string '    Creating table %s\\n' as argument, with all occurrences of '%s' replaced with model._meta.db_table.\
for statement in sql :	for statements is sql,
        cursor . execute ( statement )	call the cursor.execute method with statement as argument.
tables . append ( connection . introspection . table_name_converter ( model . _meta . db_table ) )	evaluate the method connection.introspection.table_name_converter with model._meta.db_table as argument, append it to tables.
finally :	finally, perform,
cursor . close ( )	call the cursor.close method.
cursor = connection . cursor ( )	call the connection.cursor method, substitute it for cursor.
try :	try,
if self . verbosity >= 1 :	if self.verbosity is greater or equal than integer 1,
\self . stdout . write ( '  Installing custom SQL...\\n' )\	\write the string '  Installing custom SQL...\\n' to the standard output.\
for app_name , model_list in manifest . items ( ) :	for every app_name and mode_list in return value of manifest.items method,
for model in model_list :	for model in model_list,
if model in created_models :	if model is contained in created_models,
    custom_sql = custom_sql_for_model ( model , no_style ( ) , connection )	call the method custom_sql_for_model with model, no_style() and connection as arguments, substitute the result for custom_sql.
if custom_sql :	if custom_sql is empty,
        if self . verbosity >= 2 :	if self.verbosity is greater or equal to integer 2,
\            self . stdout . write ( '    Installing custom SQL for %s.%s model\\n' % ( app_name , model . _meta . object_name ) )\	\call the self.stdout.write method with string '    Installing custom SQL for %s.%s model\\n' as argument,\
try :	with all occurrences of '%s' replaced with app_name and model._meta.object_name, respectively.   try,
            with transaction . atomic ( using = connection . alias ) :	with call to the function transaction.atomic with using set to connection.alias as argument,
                for sql in custom_sql :	for every sql in custom_sql,
                    cursor . execute ( sql )	call the cursor.execute method with sql as argument.
except Exception as e :	if exception of class Exception, as e, is caught,
\            self . stderr . write ( '    Failed to install custom SQL for %s.%s model: %s\\n' % ( app_name , model . _meta . object_name , e ) )\	\call the self.stderr.write method with string '    Failed to install custom SQL for %s.%s model: %s\\n' as argument,\
if self . show_traceback :	with all occurrences of '%s' replaced with app_name and model._meta.object_name and e, respectively.   if self.show_traceback is true,
                traceback . print_exc ( )	call the traceback.print_exc method.
else :	if not,
        if self . verbosity >= 3 :	if self.verbosity is greater or equal to integer 3,
\            self . stdout . write ( '    No custom SQL for %s.%s model\\n' % ( app_name , model . _meta . object_name ) )\	\call the self.stderr.write method with string '    No custom SQL for %s.%s model\\n' as argument,\
if self . verbosity >= 1 :	with all occurrences of '%s' replaced with app_name and model._meta.object_name, respectively.   if self.verbosity is greater or equal to integer 1,
\self . stdout . write ( '  Installing indexes...\\n' )\	\write string '  Installing indexes...\\n' to the standard output.\
for app_name , model_list in manifest . items ( ) :	for every app_name and model_list in return value of manifest.items method,
for model in model_list :	for every model in model_list,
if model in created_models :	if model is contained in created_models,
    index_sql = connection . creation . sql_indexes_for_model ( model , no_style ( ) )	call the connection.creation.sql_indexes_for_model with model and no_style() as arguments, substitute the result for index_squl.
if index_sql :	if index_sql is not empty,
        if self . verbosity >= 2 :	if self.verbosity is greater or equal to integer 2,
\            self . stdout . write ( '    Installing index for %s.%s model\\n' % ( app_name , model . _meta . object_name ) )\	\call the self.stderr.write method with string '    Installing index for %s.%s model\\n' as argument,\
try :	with all occurrences of '%s' replaced with app_name and model._meta.object_name, respectively.   try,
            with transaction . atomic ( using = connection . alias , savepoint = connection . features . can_rollback_ddl ) :	with call to the function transaction.atomic with using set to connection.alias and savepoint set to connection.features.can_rollback_ddl, as arguments.
                for sql in index_sql :	for every sql in index_sql,
                    cursor . execute ( sql )	call the method cursor.execute with sql as argument.
except Exception as e :	if exception of the class Exception, as e, is caught,
\            self . stderr . write ( '    Failed to install index for %s.%s model: %s\\n' % ( app_name , model . _meta . object_name , e ) )\	\call the self.stderr.write method with string '    Failed to install index for %s.%s model: %s\\n' as argument,\
finally :	with all occurrences of '%s' replaced with app_name and model._meta.object_name and e, respectively.   finally perform,
cursor . close ( )	call the cursor.close method.
if self . load_initial_data :	if self.load_initial_data is not empty,
for app_label in app_labels :	for every app_label in app_labels,
call_command ( 'loaddata' , 'initial_data' , verbosity = self . verbosity , database = connection . alias , skip_validation = True , app_label = app_label , hide_empty = True )	call the method call_command with string 'loaddata', string 'initial_data', verbosity set to self.verbosity,
return created_models	database set to connection.alias, skip_validation set to boolean True, app_label set to app_label and hide_empty set to boolean True.   return created_models
def show_migration_list ( self , connection , app_names = None ) :	define show_migration_list with self class instance, connection and app_names set to None, as arguments.
loader = MigrationLoader ( connection )	loader is instance of MigrationLoader initialized with connection as an argument.
graph = loader . graph	substitute loader.graph for graph.
if app_names :	if app_names is not empty,
invalid_apps = [ ]	invalid_apps is an empty list.
for app_name in app_names :	for every app_name is app_names,
if app_name not in loader . migrated_apps :	if app_name is not contained in loader.migrated_apps,
invalid_apps . append ( app_name )	append app_name to the invalid_apps.
if invalid_apps :	if invalid_apps in not empty,
raise CommandError ( 'No migrations present for: %s' % ( ', ' . join ( invalid_apps ) ) )	raise a CommandError exception, with string 'No migrations present for: %s' as argument, substitute '%s' in previous string with,
else :	string joined from invalided_apps list and separated with string ', '.   if not,
app_names = sorted ( loader . migrated_apps )	sort loader.migrated_apps, substitute it for app_names.
for app_name in app_names :	for every app_name in app_names.
self . stdout . write ( app_name , self . style . MIGRATE_LABEL )	call self.stdout.write method with app_name and self.style.MIGRATE_LABEL as arguments.
shown = set ( )	shown is an empty set.
for node in graph . leaf_nodes ( app_name ) :	for every node in return value of the graph.leaf_nodes method called with the app_name argument,
for plan_node in graph . forwards_plan ( node ) :	for every plan_node in return value of the graph.forwards_plan method called with node as argument.
if plan_node not in shown and plan_node [ 0 ] == app_name :	if plan_node is not contained in shown and first element of plan_node equals to app_name,
      title = plan_node [ 1 ]	substitute second element of plan_node for title.
if graph . nodes [ plan_node ] . replaces :	if replaces filed of graph.nodes element at the plan_node index is true,
        title += ' (%s squashed migrations)' % len ( graph . nodes [ plan_node ] . replaces )	substitute '%s' in the string ' (%s squashed migrations)' with length of replaces filed of graph.nodes element at the plan_node index, append the string to the title.
if plan_node in loader . applied_migrations :	if plan_node is contained in loader.applied_migrations,
        self . stdout . write ( ' [X] %s' % title )	substitute '%s' with title in the string ' [X] %s', write it to the standard output.
else :	if not,
        self . stdout . write ( ' [ ] %s' % title )	substitute '%s' with title in the string ' [ ] %s', write it to the standard output.
shown . add ( plan_node )	add plan_node to the shown set.
if not shown :	if shown is an empty set,
self . stdout . write ( ' (no migrations)' , self . style . MIGRATE_FAILURE )	call the self.stdout.write method with string ' (no migrations)' and self.style.MIGRATE_FAILURE as arguments.
import argparse	import module argparse.
import warnings	import module warnings.
from django . core . management . base import BaseCommand	from django.core.management.base import BaseCommand into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
class Command ( BaseCommand ) :	derive the class Command from the BaseCommand class.
help = 'Runs this project as a FastCGI application. Requires flup.'	help is a string 'Runs this project as a FastCGI application. Requires flup.'.
def add_arguments ( self , parser ) :	define the method add_arguments with 2 arguments self and parser.
parser . add_argument ( 'args' , nargs = argparse . REMAINDER ,  help = 'Various KEY=val options.' )	call the method parser.add_argument with 3 arguments: string 'args', nargs set to argparse.REMAINDER and help as a string 'Various KEY=val options.'
def handle ( self , * args , ** options ) :	define the method handle with 3 arguments: self, unpacked list args and unpacked dictionary options.
warnings . warn (  'FastCGI support has been deprecated and will be removed in Django 1.9.' ,  RemovedInDjango19Warning )	call the method warnings.warn with 2 arguments: string 'FastCGI support has been deprecated and will be removed in Django 1.9.',
from django . conf import settings	and RemovedInDjango19Warning.   from django.conf import settings into default namespace.
from django . utils import translation	  from django.utils import translation into default namespace.
try :	try,
translation . activate ( settings . LANGUAGE_CODE )	call the method translation.activate with an argument settings.LANGUAGE_CODE.
except AttributeError :	if AttributeError exception is caught,
pass	do nothing.
from django . core . servers . fastcgi import runfastcgi	from django.core.servers.fastcgi import runfastcgi into default namespace.
runfastcgi ( args )	call the function runfastcgi with an argument args.
def usage ( self , subcommand ) :	define the method usage with 2 argument: self and subcommand.
from django . core . servers . fastcgi import FASTCGI_HELP	from django.core.servers.fastcgi import FASTCGI_HELP into default namespace.
return FASTCGI_HELP	return FASTCGI_HELP.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from datetime import datetime	from datetime import datetime into default name space.
import errno	import module errno.
import os	import module os.
import re	import module re.
import sys	import module sys.
import socket	import module socket.
from django . core . management . base import BaseCommand , CommandError	from django.core.management.base import BaseCommand and CommandError into default name space.
from django . core . servers . basehttp import run , get_internal_wsgi_application	from django.core.servers.basehttp import run and get_internal_wsgi_application into default name space.
from django . db import connections , DEFAULT_DB_ALIAS	from django.db import connections and DEFAULT_DB_ALIAS into default name space.
from django . db . migrations . executor import MigrationExecutor	from django.db.migrations.executor import MigrationExecutor into default name space.
from django . utils import autoreload	from django.utils import autoreload into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . core . exceptions import ImproperlyConfigured	from django.core.exceptions import ImproperlyConfigured into default name space.
\naiveip_re = re . compile ( r'''^(?: (?P<addr>     (?P<ipv4>\\d{1,3}(?:\\.\\d{1,3}){3}) |         # IPv4 address     (?P<ipv6>\\[[a-fA-F0-9:]+\\]) |               # IPv6 address     (?P<fqdn>[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*) # FQDN ):)?(?P<port>\\d+)$''' , re . X )\	\call the method re.compile with 2 arguments: raw string '''^(?: (?P<addr> (?P<ipv4>\\d{1,3}(?:\\.\\d{1,3}){3}) |'''\
DEFAULT_PORT = '8000'	\'(?P<ipv6>\\[[a-fA-F0-9:]+\\]) | (?P<fqdn>[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*) ):)?(?P<port>\\d+)$', re.X   DEFAULT_PORT is a string '8000'.\
class Command ( BaseCommand ) :	derive the class Command from the BaseCommand class.
help = 'Starts a lightweight Web server for development.'	help is a string 'Starts a lightweight Web server for development.'.
requires_system_checks = False	requires_system_checks is boolean False.
def add_arguments ( self , parser ) :	define the method add_arguments with 2 arguments self and parser.
parser . add_argument ( 'addrport' , nargs = '?' ,  help = 'Optional port number, or ipaddr:port' )	call the method parser.add_argument with 3 arguments: string 'addrport', nargs='?' and help as a string 'Optional port number, or ipaddr:port'.
parser . add_argument ( '--ipv6' , '-6' , action = 'store_true' , dest = 'use_ipv6' , default = False ,  help = 'Tells Django to use an IPv6 address.' )	call the method parser.add_argument with 6 arguments: string '--ipv6', string '-6', action set to string 'store_true',
parser . add_argument ( '--nothreading' , action = 'store_false' , dest = 'use_threading' , default = True ,  help = 'Tells Django to NOT use threading.' )	dest set to string 'use_ipv6', default set to boolean False and help set to string 'Tells Django to use an IPv6 address.'.   call the method parser.add_argument with 5 arguments: string '--nothreading', action set to string 'store_false',
parser . add_argument ( '--noreload' , action = 'store_false' , dest = 'use_reloader' , default = True ,  help = 'Tells Django to NOT use the auto-reloader.' )	dest set to string 'use_threading', default set to boolean True and help set to 'Tells Django to NOT use threading.'.   call the method parser.add_argument with 5 arguments: string '--noreload', action set to string 'store_false',
def get_handler ( self , * args , ** options ) :	dest set to string 'use_reloader', default set to boolean True and help is a string 'Tells Django to NOT use the auto-reloader.'.   def get_handler with 3 arguments: self, unpacked list args and unpacked dictionary options.
return get_internal_wsgi_application ( )	call the function get_internal_wsgi_application, return the result.
def handle ( self , * args , ** options ) :	define the method handle with 3 arguments: self, unpacked list args and unpacked dictionary options.
from django . conf import settings	from django.conf import settings into default namespace.
if not settings . DEBUG and not settings . ALLOWED_HOSTS :	if not settings.DEBUG is true and settings.ALLOWED_HOSTS is false,
raise CommandError ( 'You must set settings.ALLOWED_HOSTS if DEBUG is False.' )	raise an CommandError exception with an argument string 'You must set settings.ALLOWED_HOSTS if DEBUG is False.'.
self . use_ipv6 = options . get ( 'use_ipv6' )	substitute value under the 'use_ipv6' key of the options dictionary for self.use_ipv6.
if self . use_ipv6 and not socket . has_ipv6 :	if self.use_ipv6 is true and socket.has_ipv6 is false,
raise CommandError ( 'Your Python does not support IPv6.' )	raise an CommandError exception with an argument string 'Your Python does not support IPv6.'.
self . _raw_ipv6 = False	self._raw_ipv6 is boolean False.
if not options . get ( 'addrport' ) :	get the value under the 'addrport' key of the options dictionary, if it is false,
self . addr = ''	self.addr is an empty string.
self . port = DEFAULT_PORT	substitute DEFAULT_PORT for self.port.
else :	if not,
m = re . match ( naiveip_re , options [ 'addrport' ] )	call the method re.match with 2 arguments: naiveip_re and value under the 'addrport' key of the options dictionary, substitute the result for m.
if m is None :	if m is None,
self . addr , _ipv4 , _ipv6 , _fqdn , self . port = m . groups ( )	where '%s' is replaced with value under the 'addrport' key of the options dictionary.   call the method m.groups, assign the result to self.addr, _ipv4, _ipv6, _fqdn and self.port, respectively.
if not self . port . isdigit ( ) :	call the method self.port.isdigit, if it evaluates to false,
raise CommandError ( '%r is not a valid port number.' % self . port )	raise an CommandError exception with an argument string '%r is not a valid port number.', where '%r' is repaced with self.port.
if self . addr :	if self.addr is true,
if _ipv6 :	if _ipv6 is true,
self . addr = self . addr [ 1 : - 1 ]	substitute self.addr without the first and last element for self.addr.
self . use_ipv6 = True	self.use_ipv6 is boolean True.
self . _raw_ipv6 = True	self._raw_ipv6 is boolean True.
elif self . use_ipv6 and not _fqdn :	otherwise if self.use_ipv6 is true and _fqdn is false,
if not self . addr :	if self.addr is false,
self . addr = '::1' if self . use_ipv6 else '127.0.0.1'	if self.use_ipv6 substitute string '::1' for self.addr, if not substitute '127.0.0.1' for self.addr.
self . _raw_ipv6 = bool ( self . use_ipv6 )	convert self.use_ipv6 to boolean, substitute it for self._raw_ipv6.
self . run ( ** options )	call the self.run method with unpacked dictionary options as an argument.
def run ( self , ** options ) :	define the method run with 3 arguments: self and unpacked dictionary options.
use_reloader = options . get ( 'use_reloader' )	substitute value under the 'use_reloader' key of the options dictionary for use_reloader.
if use_reloader :	if use_reloader is true,
autoreload . main ( self . inner_run , None , options )	call the method autoreload.main with 3 arguments: self.inner_run, None and options.
else :	if not,
self . inner_run ( None , ** options )	call the method self.inner_run with 2 arguments: None and unpacked dictionary options.
def inner_run ( self , * args , ** options ) :	define the method inner_run with 3 arguments: self, unpacked list args and unpacked dictionary options.
from django . conf import settings	from django.conf import settings into default namespace.
from django . utils import translation	django.utils import translation into default namespace.
threading = options . get ( 'use_threading' )	substitute value under the 'use_threading' key of the options dictionary for threading.
shutdown_message = options . get ( 'shutdown_message' , '' )	get the value under the 'shutdown_message' key of the options dictionary, if it exists substitute it for shutdown_message,
quit_command = 'CTRL-BREAK' if sys . platform == 'win32' else 'CONTROL-C'	if not, shutdown_message is an empty string.   if sys.platform equals string win32', substitute string 'CTRL-BREAK' for quit_command, if not substitute string 'CONTROL-C' for quit_command.
\self . stdout . write ( 'Performing system checks...\\n\\n' )\	\write string 'Performing system checks...\\n\\n' to self.stdout stream.\
self . validate ( display_num_errors = True )	call the method self.validate with an argument display_num_errors set to boolean True.
try :	try,
self . check_migrations ( )	call the method self.check_migrations.
except ImproperlyConfigured :	if ImproperlyConfigured exception is caught,
pass	do nothing.
now = datetime . now ( ) . strftime ( '%B %d, %Y - %X' )	call the function datetime.now, on the result call the method strftime with an argument string '%B %d, %Y - %X', substitute the result for now.
if six . PY2 :	if six.PY2 is true,
now = now . decode ( 'utf-8' )	call the method now.decode with an argument string 'utf-8', substitute the result for now.
\self . stdout . write ( (  '%(started_at)s\\n'  'Django version %(version)s, using settings %(settings)r\\n'  'Starting development server at http://%(addr)s:%(port)s/\\n'  'Quit the server with %(quit_command)s.\\n'  ) % {  'started_at' : now ,  'version' : self . get_version ( ) ,  'settings' : settings . SETTINGS_MODULE ,  'addr' : '[%s]' % self . addr if self . _raw_ipv6 else self . addr ,  'port' : self . port ,  'quit_command' : quit_command ,  } )\	\call the method self.stdout.write with an argument: string '%(started_at)s\\nDjango version %(version)s, using settings %(settings)r\\n'\
try :	try,
handler = self . get_handler ( * args , ** options )	call the method self.get_handler with 2 arguments unpacked list args and unpacked dictionary options, substitute the result for handler.
run ( self . addr , int ( self . port ) , handler ,  ipv6 = self . use_ipv6 , threading = threading )	call the function run with 5 arguments: self.addr, self.port converted to an integer, handler, ipv6 set to self.use_ipv6,  and threading set to threading.
except socket . error as e :	if socket.error, renamed to e, exception is caught,
ERRORS = {  errno . EACCES : 'You don't have permission to access that port.' ,  errno . EADDRINUSE : 'That port is already in use.' ,  errno . EADDRNOTAVAIL : 'That IP address can't be assigned-to.' ,  }	ERRORS is a dictionary with 3 initial entries: string 'You don't have permission to access that port.' for errno.EACCES,
try :	That port is already in use. for errno.EADDRINUSE and 'That IP address can't be assigned-to.' for errno.EADDRNOTAVAIL.   try,
error_text = ERRORS [ e . errno ]	get the value under the e.errno key of the ERRORS dictionary, substitute it for error_text.
except KeyError :	if KeyError exception is caught.
error_text = str ( e )	convert e to a string, substitute it for error_text.
self . stderr . write ( 'Error: %s' % error_text )	replace '%s' in a string 'Error: %s' with error_text, write it to self.stderr.
os . _exit ( 1 )	exit the program with the code integer 1.
except KeyboardInterrupt :	if KeyboardInterrupt exception is caught,
if shutdown_message :	if shutdown_message is true,
self . stdout . write ( shutdown_message )	write shutdown_message to self.stdout file stream.
sys . exit ( 0 )	exit program with code integer 0.
def check_migrations ( self ) :	define the method check_migrations with an argument self.
executor = MigrationExecutor ( connections [ DEFAULT_DB_ALIAS ] )	executor is an instance of the class MigrationExecutor created with an argument: value under the DEFAULT_DB_ALIAS key of the connections dictionary.
plan = executor . migration_plan ( executor . loader . graph . leaf_nodes ( ) )	call the method executor.migration_plan wiht return value of te method executor.loader.graph.leaf_nodes as argument, substitute it for plan.
if plan :	if plan is true,
\self . stdout . write ( self . style . NOTICE ( '\\nYou have unapplied migrations; your app may not work properly until they are applied.' ) )\	call the method self.style.NOTICE with an argument:
\self . stdout . write ( self . style . NOTICE ( 'Run 'python manage.py migrate' to apply them.\\n' ) )\	\string: '\\nYou have unapplied migrations; your app may not work properly until they are applied.', write it to self.stdout.   call the method self.style.NOTICE with an argument string 'Run 'python manage.py migrate' to apply them.\\n',\
BaseRunserverCommand = Command	write it to self.stdout.   substitute Command for BaseRunserverCommand.
import os	import module os.
from django . core . management . base import BaseCommand	from django.core.management.base import BaseCommand into default name space.
class Command ( BaseCommand ) :	derive the class Command from the BaseCommand class.
help = 'Runs a Python interactive interpreter. Tries to use IPython or bpython, if one of them is available.'	help is a string 'Runs a Python interactive interpreter. Tries to use IPython or bpython, if one of them is available.'.
requires_system_checks = False	requires_system_checks is boolean False.
shells = [ 'ipython' , 'bpython' ]	shells is a list containing 2 elements: string 'ipython' and string 'bpython'.
def add_arguments ( self , parser ) :	define the method add_arguments with 2 arguments self and parser.
parser . add_argument ( '--plain' , action = 'store_true' , dest = 'plain' ,  help = 'Tells Django to use plain Python, not IPython or bpython.' )	call the method parser.add_argument with 4 arguments: string '--plain', action set to string 'store_true', dest as a string 'plain',
parser . add_argument ( '--no-startup' , action = 'store_true' , dest = 'no_startup' ,  help = 'When using plain Python, ignore the PYTHONSTARTUP environment variable and ~/.pythonrc.py script.' )	and help is a string 'Tells Django to use plain Python, not IPython or bpython.'.   call the method parser.add_argument with 4 arguments: string '--no-startup', action as a string 'store_true',
from IPython . Shell import IPShell	from IPython.Shell import IPShell into default namespace.
shell = IPShell ( argv = [ ] )	shell is an instance of IPShell class, created with an argument argv as an empty list.
shell . mainloop ( )	call the method shell.mainloop.
def _ipython_pre_100 ( self ) :	define the method _ipython_pre_100 with an argument self.
from IPython . frontend . terminal . ipapp import TerminalIPythonApp	  from IPython.frontend.terminal.ipapp import TerminalIPythonApp into default namespace.
app = TerminalIPythonApp . instance ( )	call the method instance of TerminalIPythonApp class, substitute the result for app.
app . initialize ( argv = [ ] )	call the method app.initialize with an argument argv as an empty list.
app . start ( )	call the method app.start.
def _ipython ( self ) :	define the method _ipython with an argument self.
from IPython import start_ipython	from IPython import start_ipython into default namespace.
start_ipython ( argv = [ ] )	call the method start_ipython with an argument argv as an empty list.
def ipython ( self ) :	define the method ipython with an argument self.
for ip in ( self . _ipython , self . _ipython_pre_100 , self . _ipython_pre_011 ) :	for every ip in tuple containing 3 elements: self._ipython, self._ipython_pre_100 and self._ipython_pre_011,
try :	try,
ip ( )	call the function ip.
except ImportError :	if ImportError exception is caught,
pass	do nothing.
else :	if not,
return	return nothing.
raise ImportError ( 'No IPython' )	raise an ImportError exception with an argument string 'No IPython'.
def bpython ( self ) :	define the method bpython with an argument self.
import bpython	import bpython.
bpython . embed ( )	call the method bpython.embed.
def run_shell ( self , shell = None ) :	define the method run_shell with an arguments self and shell set to None.
available_shells = [ shell ] if shell else self . shells	if shell is true substitute list with element shell for available_shells, if not substitute self.shells for available_shells.
for shell in available_shells :	for every shell in available_shells,
try :	try,
return getattr ( self , shell ) ( )	get shell attribute of the self object, call it and return the result.
except ImportError :	if ImportError exception is caught,
pass	do nothing.
raise ImportError	raise an ImportError exception.
def handle ( self , ** options ) :	define the method handle with 3 arguments: self and unpacked dictionary options.
try :	try,
if options [ 'plain' ] :	if value under 'plain' key of the options dictionary is true,
raise ImportError	raise an ImportError exception.
self . run_shell ( shell = options [ 'interface' ] )	call the method self.run_shell with an argument shell set to value under the 'interface' key of the options dictionary.
except ImportError :	if ImportError exception is caught,
import code	import code.
imported_objects = { }	imported_objects is an empty dictionary.
try :	try,
import readline	import readline.
except ImportError :	if ImportError exception is caught,
pass	do nothing.
else :	if not,
import rlcompleter	import rlcompleter.
readline . set_completer ( rlcompleter . Completer ( imported_objects ) . complete )	call the method rlcompleter.Completer with an argument imported_objects, use the complete field of the result as an argument for the call to the method readline.set_completer.
readline . parse_and_bind ( 'tab:complete' )	call the method readline.parse_and_bind with an argument string 'tab:complete'.
if not options [ 'no_startup' ] :	get the value under the 'no_startup' key of the options dictionary, if it evaluates to false,
for pythonrc in ( os . environ . get ( 'PYTHONSTARTUP' ) , '~/.pythonrc.py' ) :	for every pythonrc in tuple containing 2 elements: return value of the function os.environ.get called with a string 'PYTHONSTARTUP',
if not pythonrc :	and string '~/.pythonrc.py' as tuples second element.   if pythonrc is true,
    continue	skip this loop iteration.
pythonrc = os . path . expanduser ( pythonrc )	call the function os.path.expanduser with an argument pythonrc, substitute the result for pythonrc.
if not os . path . isfile ( pythonrc ) :	if pythonrc is not a file,
    continue	skip this loop iteration.
try :	try,
    with open ( pythonrc ) as handle :	open pythonrc, with the file handle renamed to handle perform the following,
        exec ( compile ( handle . read ( ) , pythonrc , 'exec' ) , imported_objects )	compile the handle.read in mode 'exec' source is read from file pythonrc, execute the compiled script with imported_objects variables.
except NameError :	if NameError exception is caught,
    pass	do nothing.
code . interact ( local = imported_objects )	call the method code.interact with an argument local set to imported_objects.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . core . management . base import AppCommand	from django.core.management.base import AppCommand into default name space.
from django . core . management . sql import sql_create	from django.core.management.sql import sql_create into default name space.
from django . db import connections , DEFAULT_DB_ALIAS	from django.db import connections and DEFAULT_DB_ALIAS into default name space.
class Command ( AppCommand ) :	derive the class Command from the AppCommand base class.
help = 'Prints the CREATE TABLE SQL statements for the given app name(s).'	help is a string 'Prints the CREATE TABLE SQL statements for the given app name(s).'.
output_transaction = True	output_transaction is boolean True.
def add_arguments ( self , parser ) :	define the method add_arguments with 2 arguments self and parser.
super ( Command , self ) . add_arguments ( parser )	call the method add_arguments from the base class of the class Command, with an argument parser.
def handle_app_config ( self , app_config , ** options ) :	and help set to a string 'Nominates a database to print the SQL for. Defaults to the 'default' database.'.   define the method handle_app_config with 3 arguments: self, app_config and unpacked dictionary options.
if app_config . models_module is None :	if app_config.models_module is None,
return	return nothing.
connection = connections [ options [ 'database' ] ]	get the value under the 'database' key of the options dictionary, use it as the key to get the value from the connections dictionary, substitute the result for connection.
statements = sql_create ( app_config , self . style , connection )	call the function sql_create with 3 arguments: app_config, self.style and connection, substitute the result for statements.
\return '\\n' . join ( statements )\	join statements into a string, separated by newlines, return it.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . core . management . base import AppCommand	from django.core.management.base import AppCommand into default name space.
from django . core . management . sql import sql_all	from django.core.management.sql import sql_all into default name space.
from django . db import connections , DEFAULT_DB_ALIAS	from django.db import connections and DEFAULT_DB_ALIAS into default name space.
class Command ( AppCommand ) :	derive the class Command from the AppCommand base class.
help = 'Prints the CREATE TABLE, custom SQL and CREATE INDEX SQL statements for the given model module name(s).'	help is a string 'Prints the CREATE TABLE, custom SQL and CREATE INDEX SQL statements for the given model module name(s).'.
output_transaction = True	output_transaction is boolean True.
def add_arguments ( self , parser ) :	define the method add_arguments with 2 arguments self and parser.
super ( Command , self ) . add_arguments ( parser )	call the method add_arguments from the base class of the class Command, with an argument parser.
def handle_app_config ( self , app_config , ** options ) :	and help set to a string 'Nominates a database to print the SQL for. Defaults to the 'default' database.'.   define the method handle_app_config with 3 arguments: self, app_config and unpacked dictionary options.
if app_config . models_module is None :	if app_config.models_module is None,
return	return nothing.
connection = connections [ options [ 'database' ] ]	get the value under the 'database' key of the options dictionary, use it as the key to get the value from the connections dictionary, substitute the result for connection.
statements = sql_all ( app_config , self . style , connection )	call the function sql_all with 3 arguments: app_config, self.style and connection, substitute the result for statements.
\return '\\n' . join ( statements )\	join statements into a string, separated by newlines, return it.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . core . management . base import AppCommand	from django.core.management.base import AppCommand into default name space.
from django . core . management . sql import sql_delete	from django.core.management.sql import sql_delete into default name space.
from django . db import connections , DEFAULT_DB_ALIAS	from django.db import connections and DEFAULT_DB_ALIAS into default name space.
class Command ( AppCommand ) :	derive the class Command from the AppCommand base class.
help = 'Prints the DROP TABLE SQL statements for the given app name(s).'	help is a string 'Prints the DROP TABLE SQL statements for the given app name(s).'.
output_transaction = True	output_transaction is boolean True.
def add_arguments ( self , parser ) :	define the method add_arguments with 2 arguments self and parser.
super ( Command , self ) . add_arguments ( parser )	call the method add_arguments from the base class of the class Command, with an argument parser.
def handle_app_config ( self , app_config , ** options ) :	and help set to a string 'Nominates a database to print the SQL for. Defaults to the 'default' database.'.   define the method handle_app_config with 3 arguments: self, app_config and unpacked dictionary options.
if app_config . models_module is None :	if app_config.models_module is None,
return	return nothing.
connection = connections [ options [ 'database' ] ]	get the value under the 'database' key of the options dictionary, use it as the key to get the value from the connections dictionary, substitute the result for connection.
statements = sql_delete ( app_config , self . style , connection )	call the function sql_destroy_indexes with 3 arguments: app_config, self.style and connection, substitute the result for statements.
\return '\\n' . join ( statements )\	join statements into a string, separated by newlines, return it.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . core . management . base import AppCommand	from django.core.management.base import AppCommand into default name space.
from django . core . management . sql import sql_custom	from django.core.management.sql import sql_custom into default name space.
from django . db import connections , DEFAULT_DB_ALIAS	from django.db import connections and DEFAULT_DB_ALIAS into default name space.
class Command ( AppCommand ) :	derive class Command from the base class AppCommand.
help = 'Prints the custom table modifying SQL statements for the given app name(s).'	help is a string, 'Prints the custom table modifying SQL statements for the given app name(s).'.
output_transaction = True	substitute True for output_transaction.
def add_arguments ( self , parser ) :	define method add_arguments with class instance self and parser as the input arguments.
super ( Command , self ) . add_arguments ( parser )	call the function add_arguments with parser as an argument, from the base class of the Command class.
def handle_app_config ( self , app_config , ** options ) :	'Nominates a database to print the SQL for. Defaults to the 'default' database.' as the arguments.   define method handle_app_config with self class instance, app_config and dictionary options as arguments.
if app_config . models_module is None :	if app_config.models_module is None,
return	return nothing.
connection = connections [ options [ 'database' ] ]	extract the value under the key 'database' from the options dictionary, use the value for indexing connections list, substitute the result for connection.
statements = sql_custom ( app_config , self . style , connection )	call the function sql_custom with app_config, self.style and connection as the arguments, substitute the result for statements.
\return '\\n' . join ( statements )\	join the list of statements into a string separated by new lines, return it.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . core . management . base import AppCommand	from django.core.management.base import AppCommand into default name space.
from django . core . management . sql import sql_destroy_indexes	from django.core.management.sql import sql_destroy_indexes into default name space.
from django . db import connections , DEFAULT_DB_ALIAS	from django.db import connections and DEFAULT_DB_ALIAS into default name space.
class Command ( AppCommand ) :	derive the class Command from the AppCommand base class.
help = 'Prints the DROP INDEX SQL statements for the given model module name(s).'	help is an string 'Prints the DROP INDEX SQL statements for the given model module name(s).'.
output_transaction = True	output_transaction is boolean True.
def add_arguments ( self , parser ) :	define the method add_arguments with 2 arguments: self and parser.
super ( Command , self ) . add_arguments ( parser )	call the add_arguments method from the base class of the class Command with parser as an argument.
def handle_app_config ( self , app_config , ** options ) :	and help set to string 'Nominates a database to print the SQL for. Defaults to the 'default' database.'.   define the handle_app_config with 3 arguments self, app_config and unpacked dictionary options.
if app_config . models_module is None :	if app_config.models_module is None.
return	return nothing.
connection = connections [ options [ 'database' ] ]	get the value under the 'database' key of the options dictionary, use it as the key to get the value from the connections dictionary, substitute the result for connection.
statements = sql_destroy_indexes ( app_config , self . style , connection )	call the function sql_destroy_indexes with 3 arguments: app_config, self.style and connection, substitute the result for statements.
\return '\\n' . join ( statements )\	join statements into a string, separated by newlines, return it.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . core . management . base import BaseCommand	from django.core.management.base import BaseCommand into default name space.
from django . core . management . sql import sql_flush	from django.core.management.sql import sql_flush into default name space.
from django . db import connections , DEFAULT_DB_ALIAS	from django.db import connections and DEFAULT_DB_ALIAS into default name space.
class Command ( BaseCommand ) :	derive the class Command from the base class BaseCommand.
help = 'Returns a list of the SQL statements required to return all tables in the database to the state they were in just after they were installed.'	help is a string, containing 'Returns a list of the SQL statements required to return all tables in the database to the state they were in just after they were installed.'.
output_transaction = True	output_transaction is boolean True.
def add_arguments ( self , parser ) :	define method add_arguments with self class instance and parser as the arguments.
super ( Command , self ) . add_arguments ( parser )	call the parent class of Command class add_arguments method and parser as the arguments.
def handle ( self , ** options ) :	'Nominates a database to print the SQL for. Defaults to the 'default' database.' as the arguments.   define the method handle with self class instance and dictionary options as the arguments.
\return '\\n' . join ( sql_flush ( self . style , connections [ options [ 'database' ] ] , only_django = True ) )\	call the sql_flush function with self.style, connections under the key with the value of options dictionary under the 'database' key,
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . core . management . base import AppCommand	from django.core.management.base import AppCommand into default name space.
from django . core . management . sql import sql_indexes	from django.core.management.sql import sql_indexes into default name space.
from django . db import connections , DEFAULT_DB_ALIAS	from django.db import connections and DEFAULT_DB_ALIAS into default name space.
class Command ( AppCommand ) :	derive the class Command from the base class AppCommand.
help = 'Prints the CREATE INDEX SQL statements for the given model module name(s).'	help is a string 'Prints the CREATE INDEX SQL statements for the given model module name(s).'.
output_transaction = True	output_transaction is boolean True.
def add_arguments ( self , parser ) :	define the method add_arguments with self class instance and parser as the arguments.
super ( Command , self ) . add_arguments ( parser )	call the add_arguments method with parser as argument form the base class of the class Command.
def handle_app_config ( self , app_config , ** options ) :	and help as a string 'Nominates a database to print the SQL for. Defaults to the 'default' database.', as arguments.   define the method handle_app_config with self class instance, app_config and dictionary options as arguments.
if app_config . models_module is None :	if app_config.models_module is None,
return	return nothing.
connection = connections [ options [ 'database' ] ]	get the value under the 'database' key of options dictionary, use it as a index to get connections list element, store it in connection.
statements = sql_indexes ( app_config , self . style , connection )	call the function sql_indexes with app_config, self.style and connection as arguments, store the result in statements.
\return '\\n' . join ( statements )\	join statements in a string separated by newline, return the result.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . core . management . base import BaseCommand , CommandError	from django.core.management.base import BaseCommand and CommandError into default name space.
from django . db import connections , DEFAULT_DB_ALIAS	from django.db import connections and DEFAULT_DB_ALIAS into default name space.
from django . db . migrations . executor import MigrationExecutor	from django.db.migrations.executor import MigrationExecutor into default name space.
from django . db . migrations . loader import AmbiguityError	from django.db.migrations.loader import AmbiguityError into default name space.
class Command ( BaseCommand ) :	derive class Command from the base class BaseCommand.
help = 'Prints the SQL statements for the named migration.'	help is a string 'Prints the SQL statements for the named migration.'
def add_arguments ( self , parser ) :	def method add_arguments with self class instance and parser as the arguments.
parser . add_argument ( 'app_label' ,  help = 'App label of the application containing the migration.' )	call the add_argument method on the parser object, with string 'app_label', and help set to string 'App label of the application containing the migration.' as arguments.
parser . add_argument ( 'migration_name' ,  help = 'Migration name to print the SQL for.' )	call the add_argument method on the parser object, with string 'migration_name', and help set to string 'Migration name to print the SQL for.' as arguments.
parser . add_argument ( '--backwards' , action = 'store_true' , dest = 'backwards' ,  default = False , help = 'Creates SQL to unapply the migration, rather than to apply it' )	call the add_argument method on the parser object with string '--backwards', asction set to 'store_true', dest set to 'backwards',
def handle ( self , * args , ** options ) :	default set to False and help set to string'Creates SQL to unapply the migration, rather than to apply it' as arguments.   define the method handle with self class instance, list of arguments args and options dictionary as the arguments.
connection = connections [ options [ 'database' ] ]	get the value under the key 'database' of the options dictionary, use it as a index to get an element from connections, substitute it for connection.
executor = MigrationExecutor ( connection )	call the MigrationExecutor with the connection as the argument, substitute it for executor.
app_label , migration_name = options [ 'app_label' ] , options [ 'migration_name' ]	get the values under the keys 'app_label' and 'migration_name' of the options dictionary, substitute the results for app_label and migration_name, respectively.
if app_label not in executor . loader . migrated_apps :	if app_label is not contained in executor.loader.migrated_apps,
raise CommandError ( 'App '%s' does not have migrations' % app_label )	raise a exception of CommandError class, with string 'App '%s' does not have migrations' with '%s' replaced with app_label as the argument.
try :	try,
migration = executor . loader . get_migration_by_prefix ( app_label , migration_name )	call the executor.loader.get_migration_by_prefix with app_label and migration_name with arguments, substitute the result fr migration.
except AmbiguityError :	if AmbiguityError exception is raised,
raise CommandError ( 'More than one migration matches '%s' in app '%s'. Please be more specific.' % (  migration_name , app_label ) )	raise a exception of ComandError class with string 'More than one migration matches '%s' in app '%s'. Please be more specific.',
except KeyError :	with all '%s' strings replaced with migration_name and app_label, respectively, as an argument.   if KeyError exception is raised,
raise CommandError ( 'Cannot find a migration matching '%s' from app '%s'. Is it in INSTALLED_APPS?' % (  migration_name , app_label ) )	raise a exception of CommandError class, with string 'Cannot find a migration matching '%s' from app '%s'. Is it in INSTALLED_APPS?',
targets = [ ( app_label , migration . name ) ]	replace all the '%s' occurrences with migration_name and app_label, respectively.   target is a list containing tuple with two elements app_label and migration.name.
plan = [ ( executor . loader . graph . nodes [ targets [ 0 ] ] , options [ 'backwards' ] ) ]	get executor.loader.graph.nodes list item at the index of the first element of targets list, get the value under the 'backwards' key of options dictionary, put previous two elements is a tuple, tuple is contained in a plan list.
sql_statements = executor . collect_sql ( plan )	call method executor.collect_sql with plan as the argument, substitute the result for sql_statements.
for statement in sql_statements :	for every statements in sql_statements:
self . stdout . write ( statement )	call method self.stdout.write with statement as an argument.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . core . management . base import AppCommand	from django.core.management.base import AppCommand into default name space.
from django . core . management . sql import check_for_migrations	from django.core.management.sql import check_for_migrations into default name space.
from django . db import connections , DEFAULT_DB_ALIAS	from django.db import connections and DEFAULT_DB_ALIAS into default name space.
class Command ( AppCommand ) :	derive the class Command from the AppCommand base class.
help = 'Prints the SQL statements for resetting sequences for the given app name(s).'	help is a string 'Prints the SQL statements for resetting sequences for the given app name(s).'.
output_transaction = True	output_transaction is boolean True.
def add_arguments ( self , parser ) :	define the method add_arguments, with 2 arguments self and parser.
super ( Command , self ) . add_arguments ( parser )	call the method add_arguments from the base class of the Command class, with an argument parser.
def handle_app_config ( self , app_config , ** options ) :	and help set to string 'Nominates a database to print the SQL for. Defaults to the 'default' database.'.   define the method handle_app_config with 3 arguments: self, app_config and unpacked dictionary options.
if app_config . models_module is None :	if app_config.models_module is None,
return	return nothing.
connection = connections [ options . get ( 'database' ) ]	get the value under the 'database' key of the options dictionary,
check_for_migrations ( app_config , connection )	use the result as a key to get the value from the connections dictionary, substitute the result for connection.   call the function check_for_migrations with 2 arguments: app_config and connection.
models = app_config . get_models ( include_auto_created = True )	call the method app_config.get_models with include_auto_created set to boolean True, substitute the result for models.
statements = connection . ops . sequence_reset_sql ( self . style , models )	call the method connection.ops.sequence_reset_sql with 2 arguments self.style and models, substitute the result for statements.
\return '\\n' . join ( statements )\	join statements into a string, separated by newline characters, return it.
from django . core . management . base import BaseCommand , CommandError	from django.core.management.base import BaseCommand and CommandError into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . db import connections , DEFAULT_DB_ALIAS , migrations	from django.db import connections,  DEFAULT_DB_ALIAS and migrations into default name space.
from django . db . migrations . loader import AmbiguityError	from django.db.migrations.loader import AmbiguityError into default name space.
from django . db . migrations . executor import MigrationExecutor	from django.db.migrations.executor import MigrationExecutor into default name space.
from django . db . migrations . writer import MigrationWriter	from django.db.migrations.writer import MigrationWriter into default name space.
from django . db . migrations . optimizer import MigrationOptimizer	from django.db.migrations.optimizer import MigrationOptimizer into default name space.
class Command ( BaseCommand ) :	derive the class Command from the BaseCommand class.
help = 'Squashes an existing set of migrations (from first until specified) into a single new one.'	help is a string 'Squashes an existing set of migrations (from first until specified) into a single new one.'.
def add_arguments ( self , parser ) :	define the method add_arguments with 2 arguments self and parser.
parser . add_argument ( 'app_label' ,  help = 'App label of the application to squash migrations for.' )	call the method parser.add_argument with 2 arguments: string 'app_label',
parser . add_argument ( 'migration_name' ,  help = 'Migrations will be squashed until and including this migration.' )	and help is a string 'App label of the application to squash migrations for.'.   call the method parser.add_argument with 2 arguments: string 'migration_name',
parser . add_argument ( '--no-optimize' , action = 'store_true' , dest = 'no_optimize' , default = False ,  help = 'Do not try to optimize the squashed operations.' )	and help is a string 'Migrations will be squashed until and including this migration.'.   call the method parser.add_argument with 5 arguments: string '--no-optimize', action as a string 'store_true',
parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )	dest as a string 'no_optimize', default set to boolean False and help as a string 'Do not try to optimize the squashed operations.'.   call the method parser.add_argument with 5 arguments: string '--noinput', action set to string 'store_false',
def handle ( self , ** options ) :	dest as a string 'interactive', default as boolean True help as a string 'Tells Django to NOT prompt the user for input of any kind.'.   define the method handle with 3 arguments: self and unpacked dictionary options.
self . verbosity = options . get ( 'verbosity' )	get the value under the 'verbosity' key of the options dictionary, substitute it for self.verbosity.
self . interactive = options . get ( 'interactive' )	get the value under the 'interactive' key of the options dictionary, substitute it for self.interactive.
app_label , migration_name = options [ 'app_label' ] , options [ 'migration_name' ]	get the values under the 'app_label' and 'migration_name' keys of the options dictionary,
executor = MigrationExecutor ( connections [ DEFAULT_DB_ALIAS ] )	substitute them for app_label and migration_name, respectively.   executor is an instance of MigrationExecutor, created with value under the DEFAULT_DB_ALIAS key of the connections dictionary.
if app_label not in executor . loader . migrated_apps :	if app_label is not contained in executor.loader.migrated_apps,
raise CommandError ( 'App '%s' does not have migrations (so squashmigrations on it makes no sense)' % app_label )	raise an CommandError with an argument string 'App '%s' does not have migrations (so squashmigrations on it makes no sense)',
try :	where '%s' is replaced with app_label.   try,
migration = executor . loader . get_migration_by_prefix ( app_label , migration_name )	call the method executor.loader.get_migration_by_prefix with arguments app_label, migration_name, substitute the result for migration.
except AmbiguityError :	if AmbiguityError exception is caught,
raise CommandError ( 'More than one migration matches '%s' in app '%s'. Please be more specific.' % ( migration_name , app_label ) )	raise an CommandError with an argument string 'More than one migration matches '%s' in app '%s'. Please be more specific.',
except KeyError :	where '%s' is replaced with migration_name and app_label.   if KeyError exception is caught,
raise CommandError ( 'Cannot find a migration matching '%s' from app '%s'.' % ( migration_name , app_label ) )	raise an CommandError with an argument string 'Cannot find a migration matching '%s' from app '%s'.',
migrations_to_squash = [  executor . loader . get_migration ( al , mn )  for al , mn in executor . loader . graph . forwards_plan ( ( migration . app_label , migration . name ) )  if al == migration . app_label  ]	where '%s' is replaced with migration_name and app_label.   migrations_to_squash is a list created dynamically with elements: return value of the method executor.loader.get_migration called,
if self . verbosity > 0 or self . interactive :	with arguments al and mn, for every al, mn in executor.loader.graph.forwards_plan method return value called with 2 arguments:   migration.app_label, migration.name, only if al equals migration.app_label.   if self.verbosity is greater than integer 0 or self.interactive is true,
self . stdout . write ( self . style . MIGRATE_HEADING ( 'Will squash the following migrations:' ) )	call the method self.style.MIGRATE_HEADING with an argument string 'Will squash the following migrations:',
for migration in migrations_to_squash :	write it to self.stdout.   for every migration in migrations_to_squash,
self . stdout . write ( ' - %s' % migration . name )	append migration.name to string ' - ', write it to self.stdout stream.
if self . interactive :	if self.interactive is true,
answer = None	answer is None.
while not answer or answer not in 'yn' :	while answer is false or answer is not contained in string 'yn', perform the following,
answer = six . moves . input ( 'Do you wish to proceed? [yN] ' )	call the method six.moves.input with an argument string 'Do you wish to proceed? [yN] ', substitute the result for answer.
if not answer :	if answer is false,
    answer = 'n'	substitute 'n' for answer.
break	break from the loop execution,
else :	if not,
    answer = answer [ 0 ] . lower ( )	convert first element of answer to lowercase and substitute it for answer.
if answer != 'y' :	if answer equals a string 'y',
return	return nothing.
operations = [ ]	operations is an empty list.
for smigration in migrations_to_squash :	for every smigration in migrations_to_squash,
operations . extend ( smigration . operations )	call the method operations.extend with an argument smigration.operations.
if self . verbosity > 0 :	if self.verbosity is greater than integer 0,
self . stdout . write ( self . style . MIGRATE_HEADING ( 'Optimizing...' ) )	call the method self.style.MIGRATE_HEADING with an argument string 'Optimizing...', write it to self.stdout.
optimizer = MigrationOptimizer ( )	optimizer is an instance of MigrationOptimizer class.
new_operations = optimizer . optimize ( operations , migration . app_label )	call the method optimizer.optimize with 2 arguments operations and migration.app_label, substitute the result for new_operations.
if self . verbosity > 0 :	if self.verbosity is greater than integer 0,
if len ( new_operations ) == len ( operations ) :	if lengths of new_operations and operations are the same,
self . stdout . write ( '  No optimizations possible.' )	write string '  No optimizations possible.' to self.stdout stream.
else :	if not,
self . stdout . write ( '  Optimized from %s operations to %s operations.' % ( len ( operations ) , len ( new_operations ) ) )	replace '%s' in string '  Optimized from %s operations to %s operations.' with lengths of operations and ew_operations, respectively,
replaces = [ ]	write it to self.stdout stream.   replaces is an empty list.
for migration in migrations_to_squash :	for every migration in migrations_to_squash,
if migration . replaces :	if migration.replaces is true,
replaces . extend ( migration . replaces )	extend replaces list with migration.replaces,
else :	if not,
replaces . append ( ( migration . app_label , migration . name ) )	append tuple with 2 elements: migration.app_label and migration.name to replaces.
subclass = type ( 'Migration' , ( migrations . Migration , ) , {  'dependencies' : [ ] ,  'operations' : new_operations ,  'replaces' : replaces ,  } )	subclass is a class named Migration, sub classed from migrations.Migration base class, with fields dependencies set to an empty list,
new_migration = subclass ( '0001_squashed_%s' % migration . name , app_label )	dependencies set to new_operations and replaces set to replaces.   call the function subclass with 2 arguments string '0001_squashed_%s', where '%s' is replaced with migration.name and app_label,
writer = MigrationWriter ( new_migration )	substitute the result for new_migration.   writer is an instance of a class MigrationWriter, created with an argument new_migration.
with open ( writer . path , 'wb' ) as fh :	open writer.path file in write mode, with file descriptor as fh, perform the following,
fh . write ( writer . as_string ( ) )	call the method writer.as_string, write the result to file fh.
if self . verbosity > 0 :	if self.verbosity is greater than integer 0,
self . stdout . write ( self . style . MIGRATE_HEADING ( 'Created new squashed migration %s' % writer . path ) )	replace '%s' in a string 'Created new squashed migration %s' with writer.path, use it as an argument for the call to the method,
self . stdout . write ( '  You should commit this migration but leave the old ones in place;' )	self.style.MIGRATE_HEADING, write the result to self.stdout.   write string '  You should commit this migration but leave the old ones in place;' to self.stdout.
self . stdout . write ( '  the new migration will be used for new installs. Once you are sure' )	write string '  the new migration will be used for new installs. Once you are sure' to self.stdout.
self . stdout . write ( '  all instances of the codebase have applied the migrations you squashed,' )	write string '  all instances of the codebase have applied the migrations you squashed,' to self.stdout.
self . stdout . write ( '  you can delete them.' )	write string '  you can delete them.' to self.stdout.
from importlib import import_module	from importlib import import_module into default name space.
from django . core . management . base import CommandError	from django.core.management.base import CommandError into default name space.
from django . core . management . templates import TemplateCommand	from django.core.management.templates import TemplateCommand into default name space.
class Command ( TemplateCommand ) :	derive the class Command from the TemplateCommand base class.
help = ( 'Creates a Django app directory structure for the given app '  'name in the current directory or optionally in the given '  'directory.' )	help is a tuple containing a string 'Creates a Django app directory structure for the given app name in the current directory or optionally in the given directory.'.
missing_args_message = 'You must provide an application name.'	missing_args_message is a string 'You must provide an application name.'.
def handle ( self , ** options ) :	define the method handle with 2 arguments: self and unpacked dictionary options.
app_name , target = options . pop ( 'name' ) , options . pop ( 'directory' )	remove values under the keys 'name' and 'directory' of the options dictionary and substitute it for app_name and target, respectively.
self . validate_name ( app_name , 'app' )	call the method self.validate_name with 2 arguments: app_name and string 'app'.
try :	try,
import_module ( app_name )	call the function import_module with an argument app_name.
except ImportError :	if ImportError exception is caught,
pass	do nothing.
else :	in not,
raise CommandError ( '%r conflicts with the name of an existing '  'Python module and cannot be used as an app '  'name. Please try another name.' % app_name )	raise an CommandError exception with an argument string '%r conflicts with the name of an existing Python module and cannot be used '
super ( Command , self ) . handle ( 'app' , app_name , target , ** options )	as an app name. Please try another name., where '%r' is replaced with app_name.   call the method handle from the base class of Command class, with 4 arguments: string 'app', app_name, target and unpacked dictionary options.
from importlib import import_module	from importlib import import_module into default name space.
from django . core . management . base import CommandError	from django.core.management.base import CommandError into default name space.
from django . core . management . templates import TemplateCommand	from django.core.management.templates import TemplateCommand into default name space.
from django . utils . crypto import get_random_string	from django.utils.crypto import get_random_string into default name space.
class Command ( TemplateCommand ) :	derive class Command from the TemplateCommand base class.
help = ( 'Creates a Django project directory structure for the given '  'project name in the current directory or optionally in the '  'given directory.' )	help is a tuple containing string 'Creates a Django project directory structure for the given '
missing_args_message = 'You must provide a project name.'	project name in the current directory or optionally in the given directory..   missing_args_message is a string 'You must provide a project name.'.
def handle ( self , ** options ) :	define the method handle with arguments self and unpacked dictionary options.
project_name , target = options . pop ( 'name' ) , options . pop ( 'directory' )	remove the elements from the 'name' and 'dictionary' keys of the options dictionary, substitute them for project_name and target, respectively.
self . validate_name ( project_name , 'project' )	call the method self.validate_name with arguments project_name and string 'project'.
try :	try,
import_module ( project_name )	call the function import_module with an argument project_name.
except ImportError :	if ImportError exception is caught,
pass	do nothing.
else :	if not,
raise CommandError ( '%r conflicts with the name of an existing '  'Python module and cannot be used as a '  'project name. Please try another name.' %  project_name )	raise an exception CommandError, with argument string '%r conflicts with the name of an existing Python module and cannot be used as a project name. Please try another name.', where '%r' is replaced with project_name.
chars = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'	chars is a string 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'.
options [ 'secret_key' ] = get_random_string ( 50 , chars )	call the function get_random_string with 2 arguments: integer 50 and chars, substitute it for value under the 'secret_key' of the options dictionary.
super ( Command , self ) . handle ( 'project' , project_name , target , ** options )	call the handle method of the base class of the Command class, with 4 arguments: string 'project', project_name, target,
import warnings	import module warnings.
from django . apps import apps	from django.apps import apps into default name space.
from django . contrib . auth import get_user_model	from django.contrib.auth import get_user_model into default name space.
from django . db import DEFAULT_DB_ALIAS	from django.db import DEFAULT_DB_ALIAS into default name space.
from django . core . management import call_command	from django.core.management import call_command into default name space.
from django . core . management . base import BaseCommand	from django.core.management.base import BaseCommand into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
from django . utils . six . moves import input	from django.utils.six.moves import input into default name space.
class Command ( BaseCommand ) :	derive class Command from the BaseCommand base class.
help = 'Deprecated - use 'migrate' instead.'	help is a string 'Deprecated - use 'migrate' instead.'.
def add_arguments ( self , parser ) :	define the method add_arguments with self and parser as arguments.
parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )	call the method parser.add_argument with 5 arguments: string '--noinput', action set to string 'store_false',
parser . add_argument ( '--no-initial-data' , action = 'store_false' , dest = 'load_initial_data' , default = True ,  help = 'Tells Django not to load any initial data after database synchronization.' )	dest set to string 'interactive', default set to boolean True and help as 'Tells Django to NOT prompt the user for input of any kind.'   call the method parser.add_argument with 5 arguments: string '--no-initial-data', action set to string 'store_false',
parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to synchronize. Defaults to the 'default' database.' )	dest set to string 'load_initial_data', default set to boolean True,   and help as a string 'Tells Django not to load any initial data after database synchronization.'   call the method parser.add_argument with 3 arguments: string '--database', default set to DEFAULT_DB_ALIAS,
def handle ( self , ** options ) :	and help set to string 'Nominates a database to synchronize. Defaults to the 'default' database.'.   define the method handle with 2 arguments: self and unpacked dictionary options.
warnings . warn ( 'The syncdb command will be removed in Django 1.9' , RemovedInDjango19Warning )	call the method warnings.warn with 2 arguments: string 'The syncdb command will be removed in Django 1.9' and RemovedInDjango19Warning.
call_command ( 'migrate' , ** options )	call the function call_command with 2 arguments: string migrate and unpacked dictionary options.
try :	try,
apps . get_model ( 'auth' , 'Permission' )	call the method apps.get_model with 2 arguments: string 'auth' and string 'Permission'.
except LookupError :	if LookupError exception is caught.
return	return nothing.
UserModel = get_user_model ( )	call the function get_user_model, substitute the result for UserModel.
if not UserModel . _default_manager . exists ( ) and options . get ( 'interactive' ) :	if return value of the method UserModel._default_manager.exists is false and value under the 'interactive' key of the options dictionary is true,
\msg = ( '\\nYou have installed Django's auth system, and '  'don't have any superusers defined.\\nWould you like to create one '  'now? (yes/no): ' )\	\msg is a tuple containing string '\\nYou have installed Django's auth system, and don't have any superusers defined.\\nWould you like to create one now? (yes/no): '.\
confirm = input ( msg )	call the method input with an argument msg and store the result in confirm.
while 1 :	endless loop,
if confirm not in ( 'yes' , 'no' ) :	if confirm is not equal to string 'yes' or string 'no',
confirm = input ( 'Please enter either 'yes' or 'no': ' )	query a string 'Please enter either 'yes' or 'no': ' and store the result in confirm.
continue	skip this loop iteration.
if confirm == 'yes' :	if confirm equals string 'yes',
call_command ( 'createsuperuser' , interactive = True , database = options [ 'database' ] )	call the function call_command with 3 arguments: string 'createsuperuser', interactive is boolean True,
break	and database set to value under the 'database' key of the options dictionary.   break the loop execution.
import logging	import module logging.
import sys	import module sys.
import os	import module os.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . management . base import BaseCommand	from django.core.management.base import BaseCommand into default name space.
from django . test . utils import get_runner	from django.test.utils import get_runner into default name space.
class Command ( BaseCommand ) :	derive class Command from the BaseCommand base class.
help = 'Discover and run tests in the specified modules or the current directory.'	help is a string 'Discover and run tests in the specified modules or the current directory.'.
requires_system_checks = False	requires_system_checks is boolean False.
def __init__ ( self ) :	define the method __init__ with an argument self.
self . test_runner = None	self.test_runner is None.
super ( Command , self ) . __init__ ( )	call the method __init__ form the base class of the Command class.
def run_from_argv ( self , argv ) :	define the method run_from_argv with arguments self and argv.
option = '--testrunner='	option is a string '--testrunner='.
for arg in argv [ 2 : ] :	for arg in argv list without the first two elements,
if arg . startswith ( option ) :	if arg starts with options,
self . test_runner = arg [ len ( option ) : ]	get the length of the options, use it as a starting index for the slicing arg list, substitute it for self.test_runner.
break	break the loop execution.
super ( Command , self ) . run_from_argv ( argv )	call the run_from_argv function from the base class of the Command class with argv as a argument,.
def add_arguments ( self , parser ) :	define the method add_arguments with arguments self and parser.
parser . add_argument ( 'args' , metavar = 'test_label' , nargs = '*' ,  help = 'Module paths to test; can be modulename, modulename.TestCase or modulename.TestCase.test_method' )	call the method parser.add_argument with 4 arguments: string 'args', metavar set to string 'test_label', nargs set to string '*',
parser . add_argument ( '--noinput' ,  action = 'store_false' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' ) ,	and help is a string 'Module paths to test; can be modulename, modulename.TestCase or modulename.TestCase.test_method'.   call the method parser.add_argument with 5 arguments: string '--noinput', action set to 'store_false', dest set to 'interactive',
parser . add_argument ( '--failfast' ,  action = 'store_true' , dest = 'failfast' , default = False ,  help = 'Tells Django to stop running the test suite after first '  'failed test.' ) ,	default set to boolean True, help set to string 'Tells Django to NOT prompt the user for input of any kind.'.   call the method parser.add_argument with 5 arguments: string '--failfast', action set to string 'store_true', dest set to 'failfast',
parser . add_argument ( '--testrunner' ,  action = 'store' , dest = 'testrunner' ,  help = 'Tells Django to use specified test runner class instead of '  'the one specified by the TEST_RUNNER setting.' ) ,	default set to boolean False and help  set to string 'Tells Django to stop running the test suite after first failed test.'.   call the method parser.add_argument with 4 arguments: string '--testrunner', action set to string 'store', dest set to 'testrunner',
parser . add_argument ( '--liveserver' ,  action = 'store' , dest = 'liveserver' , default = None ,  help = 'Overrides the default address where the live server (used '  'with LiveServerTestCase) is expected to run from. The '  'default value is localhost:8081.' ) ,	and help set to a string 'Tells Django to use specified test runner class instead of the one specified by the TEST_RUNNER setting.'.   call the method parser.add_argument with 5 arguments: string '--liveserver', action set to string 'store', dest set to 'liveserver',
test_runner_class = get_runner ( settings , self . test_runner )	default set to None and help set to string 'Overrides the default address where the live server (used '  'with LiveServerTestCase) is expected to run from. The default value is localhost:8081.'   call the function get_runner with arguments settings and self.test_runner, substitute the result for test_runner_class.
if hasattr ( test_runner_class , 'option_list' ) :	if test_runner_class has an 'option_list' attribute,
raise RuntimeError (  'The method to extend accepted command-line arguments by the '  'test management command has changed in Django 1.8. Please '  'create an add_arguments class method to achieve this.' )	raise an RuntimeError exception with an argument string 'The method to extend accepted command-line arguments by the '
if hasattr ( test_runner_class , 'add_arguments' ) :	test management command has changed in Django 1.8. Please create an add_arguments class method to achieve this.   if test_runner_class has an attribute 'add_arguments',
test_runner_class . add_arguments ( parser )	call the method test_runner_class.add_arguments with an argument parser.
def execute ( self , * args , ** options ) :	define the method execute with 3 arguments self, unpacked list args and unpacked dictionary options.
if options [ 'verbosity' ] > 0 :	if value under the 'verbosity' key of the options dictionary is greater than zero,
logger = logging . getLogger ( 'py.warnings' )	call the method logging.getLogger with an argument string 'py.warnings', substitute the result for logger.
handler = logging . StreamHandler ( )	call the method logging.StreamHandler, substitute the result for handler.
logger . addHandler ( handler )	call the method logger.addHandler with an argument handler.
super ( Command , self ) . execute ( * args , ** options )	call the method execute form the base class of the class Command, with 2 arguments: unpacked list args and unpacked dictionary options.
if options [ 'verbosity' ] > 0 :	if value under the 'verbosity' key of the options dictionary is greater than zero,
logger . removeHandler ( handler )	call the method logger.removeHandler with an argument handler.
def handle ( self , * test_labels , ** options ) :	define the method handle with 3 arguments: self, unpacked list test_labels and unpacked dictionary options.
from django . conf import settings	from django.conf import settings into default namespace.
from django . test . utils import get_runner	from django.test.utils import get_runner into default namespace.
TestRunner = get_runner ( settings , options . get ( 'testrunner' ) )	call the method get_runner with 2 arguments: settings and value under the 'testrunner' key of the options dictionary, substitute it for the TestRunner.
if options . get ( 'liveserver' ) is not None :	if value under the 'liveserver' key of the options dictionary is not None,
os . environ [ 'DJANGO_LIVE_TEST_SERVER_ADDRESS' ] = options [ 'liveserver' ]	substitute value under the 'liveserver' key of the options dictionary for value under the 'DJANGO_LIVE_TEST_SERVER_ADDRESS' key of the os.environ dictionary.
del options [ 'liveserver' ]	delete the value under the 'liveserver' key of the options dictionary.
test_runner = TestRunner ( ** options )	test_runner is an instance of TestRunner class, called with an argument unpacked dictionary options.
failures = test_runner . run_tests ( test_labels )	call the method test_runner.run_tests with an argument test_labels, substitute it for failures.
if failures :	if failures is true,
sys . exit ( bool ( failures ) )	exit the program with failures converted to boolean as a message.
from django . core . management import call_command	from django.core.management import call_command into default name space.
from django . core . management . base import BaseCommand	from django.core.management.base import BaseCommand into default name space.
from django . db import connection	from django.db import connection into default name space.
class Command ( BaseCommand ) :	derive class Command from the BaseCommand base class.
help = 'Runs a development server with data from the given fixture(s).'	help is a string 'Runs a development server with data from the given fixture(s).'.
args = '[fixture ...]'	args is a string '[fixture ...]'.
requires_system_checks = False	requires_system_checks is boolean False.
def add_arguments ( self , parser ) :	define the method with self class instance and parser as arguments.
parser . add_argument ( 'args' , metavar = 'fixture' , nargs = '*' ,  help = 'Path(s) to fixtures to load before running the server.' )	call parser.add_argument method with 'args', metavar set to string 'fixture', nargs set to string '*' and help set to string 'Path(s) to fixtures to load before running the server.'.
parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )	call parser.add_argument method with '--noinput', action set to string 'store_false', dest set to string 'interactive',
parser . add_argument ( '--addrport' , default = '' ,  help = 'Port number or ipaddr:port to run the server on.' )	default set to boolean True and help set to string 'Tells Django to NOT prompt the user for input of any kind.'.   call the parser.add_argument with string '--addrport', default set to an empty string and help as string 'Port number or ipaddr:port to run the server on.'.
parser . add_argument ( '--ipv6' , '-6' , action = 'store_true' , dest = 'use_ipv6' , default = False ,  help = 'Tells Django to use an IPv6 address.' )	call parser.add_argument method with '--ipv6', string '-6', action set to string 'store_true', dest set to string 'use_ipv6',
def handle ( self , * fixture_labels , ** options ) :	default set to boolean False and help set to string 'Tells Django to use an IPv6 address.'.   define the method handle with self class instance, list of arguments fixture_labels and dictionary options as arguments.
verbosity = options . get ( 'verbosity' )	get the value under the key 'verbosity' of options dictionary, substitute it for verbosity.
interactive = options . get ( 'interactive' )	get the value under the key 'interactive' of options dictionary, substitute it for interactive.
db_name = connection . creation . create_test_db ( verbosity = verbosity , autoclobber = not interactive , serialize = False )	call the method connection.creation.create_test_db with verbosity set to verbosity, autoclobber set to inverse value of interactive,
call_command ( 'loaddata' , * fixture_labels , ** { 'verbosity' : verbosity } )	serialize set to boolean False, substitute the return value for db_name.   call the method call_command with 3 arguments, string 'loaddata', unpacked list fixture_labels and unpacked dictionary containing 1 element: verbosity for 'verbosity'.
\shutdown_message = '\\nServer stopped.\\nNote that the test database, %r, has not been deleted. You can explore it on your own.' % db_name\	\replace '%r' from string '\\nServer stopped.\\nNote that the test database, %r, has not been deleted. You can explore it on your own.',  with db_name, substitute it for shutdown_message.\
use_threading = connection . features . test_db_allows_multiple_connections	substitute connection.features.test_db_allows_multiple_connections for use_threading.
call_command (  'runserver' ,  addrport = options [ 'addrport' ] ,  shutdown_message = shutdown_message ,  use_reloader = False ,  use_ipv6 = options [ 'use_ipv6' ] ,  use_threading = use_threading  )	call the function call_command with 6 arguments, string 'runserver', addrport as the value under the 'addrport' key of options dictionary,
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import warnings	import module warnings.
from django . core . management . commands . check import Command as CheckCommand	from django.core.management.commands.check import Command as CheckCommand into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
class Command ( CheckCommand ) :	derive class Command from CheckCommand base class.
help = 'Deprecated. Use 'check' command instead. ' + CheckCommand . help	concatenate CheckCommand.help to string 'Deprecated. Use 'check' command instead. ', substitute it for help.
def handle ( self , ** options ) :	define the method handle with self class instance and dictionary pair of elements options as arguments.
super ( Command , self ) . handle ( ** options )	call the handle function with dictionary pair of elements options from the base class of the class Command.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import codecs	import module codecs.
import os	import module os.
import re	import module re.
import warnings	import module warnings.
from django . apps import apps	from django.apps import apps into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . management . base import CommandError	from django.core.management.base import CommandError into default name space.
from django . db import models , router	from django.db import models and router into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
def check_for_migrations ( app_config , connection ) :	define the function check_for_migrations with 2 arguments: app_config and connection.
from django . db . migrations . loader import MigrationLoader	from django.db.migrations.loader import MigrationLoader into default name space.
loader = MigrationLoader ( connection )	loader is an instance of MigrationLoader class, created with an argument connection.
if app_config . label in loader . migrated_apps :	if app_config.label is contained in loader.migrated_apps,
raise CommandError ( 'App '%s' has migrations. Only the sqlmigrate and sqlflush commands can be used when an app has migrations.' % app_config . label )	raise an CommandError exception, with an arguent: string 'App '%s' has migrations. Only the sqlmigrate and sqlflush commands can be used when an app has migrations.', where '%s' is replaced for app_config.label.
def sql_create ( app_config , style , connection ) :	define the function sql_create with 3 arguments: app_config, style and connection.
check_for_migrations ( app_config , connection )	call the function check_for_migrations with an arguments app_config, connection.
if connection . settings_dict [ 'ENGINE' ] == 'django.db.backends.dummy' :	if value under the 'ENGINE' key of the connection.settings_dict dictionary equals a string 'django.db.backends.dummy',
\raise CommandError ( 'Django doesn't know which syntax to use for your SQL statements,\\n' +  'because you haven't properly specified the ENGINE setting for the database.\\n' +  'see: https://docs.djangoproject.com/en/dev/ref/settings/#databases' )\	\raise an CommandError exception with an argument string 'Django doesn't know which syntax to use for your SQL statements,\\n'\
app_models = app_config . get_models ( include_auto_created = True )	\because you haven't properly specified the ENGINE setting for the database.\\n see: https://docs.djangoproject.com/en/dev/ref/settings/#databases.   call the method app_config.get_models with an argument include_auto_created set to boolean True, substitute it for app_models.\
final_output = [ ]	final_output is an empty list.
tables = connection . introspection . table_names ( )	call the method connection.introspection.table_names, substitute the result for tables.
known_models = set ( model for model in connection . introspection . installed_models ( tables ) if model not in app_models )	if model is not contained in app_models for every model in return value of the connection.introspection.installed_models function return value,
pending_references = { }	add model to a set, substitute the result for known_models.   pending_references is an empty dictionary.
for model in router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) :	for every model in return value of the function router.get_migratable_models, called with arguments:
output , references = connection . creation . sql_create_model ( model , style , known_models )	app_config, connection.alias and include_auto_created set to boolean True.   call the method connection.creation.sql_create_model with arguments model, style and known_models, substitute the result for output and references.
final_output . extend ( output )	call the method final_output.extend with an argument output.
for refto , refs in references . items ( ) :	for every refto and refs in return value of the method references.items,
pending_references . setdefault ( refto , [ ] ) . extend ( refs )	call the method pending_references.setdefault with 2 arguments: refto and an empty list, extend the result with refs.
if refto in known_models :	if refto is contained in known_models,
final_output . extend ( connection . creation . sql_for_pending_references ( refto , style , pending_references ) )	call the method connection.creation.sql_for_pending_references with 3 arguments: refo, style and pending_references,
final_output . extend ( connection . creation . sql_for_pending_references ( model , style , pending_references ) )	use the result as an argument for the call to the method final_output.extend.   call the method connection.creation.sql_for_pending_references with 3 arguments: refo, style and pending_references,
known_models . add ( model )	use the result as an argument for the call to the method final_output.extend.   add model to known_models set.
not_installed_models = set ( pending_references . keys ( ) )	call the method pending_references.keys, put the result into a set and substitute it for not_installed_models.
if not_installed_models :	if not_installed_models is true,
alter_sql = [ ]	alter_sql is an empty list.
for model in not_installed_models :	for every model in not_installed_models,
alter_sql . extend ( [ '-- ' + sql for sql in  connection . creation . sql_for_pending_references ( model , style , pending_references ) ] )	for every sql in return value of the function connection.creation.sql_for_pending_references called with arguments: model, style,
if alter_sql :	and pending_references append sql to the string '-- ', put the results in a list, extend alter_sql with the result.   if alter_sql,
final_output . append ( '-- The following references should be added but depend on non-existent tables:' )	append string '-- The following references should be added but depend on non-existent tables:' to the final_output.
final_output . extend ( alter_sql )	extend final_output with alter_sql.
return final_output	return final_output.
def sql_delete ( app_config , style , connection , close_connection = True ) :	define the function sql_delete with 4 arguments: app_config, style, connection and close_connection set to boolean True.
check_for_migrations ( app_config , connection )	call the function check_for_migrations with arguments app_config and connection.
try :	try,
cursor = connection . cursor ( )	call the method connection.cursor, substitute the result for cursor.
except Exception :	if Exception exception is caught,
cursor = None	cursor is None.
try :	try,
if cursor :	if cursor is true,
table_names = connection . introspection . table_names ( cursor )	call the method connection.introspection.table_names with an argument cursor, substitute the result for table_names.
else :	if not,
table_names = [ ]	table_names is an empty list.
output = [ ]	output is an empty list.
to_delete = set ( )	to_delete is an empty set.
references_to_delete = { }	references_to_delete is an empty dictionary.
app_models = router . get_migratable_models ( app_config , connection . alias , include_auto_created = True )	call the method router.get_migratable_models with argument: app_config, connection.alias and include_auto_created set to True, substitute the result for app_models.
for model in app_models :	for every model in app_models,
if cursor and connection . introspection . table_name_converter ( model . _meta . db_table ) in table_names :	if cursor is true and return value of the function connection.introspection.table_name_converter called with an arugment:  model._meta.db_table is contained in table_names,
opts = model . _meta	substitute model._meta for opts.
for f in opts . local_fields :	for every f in opts.local_fields,
if f . rel and f . rel . to not in to_delete :	if f.rel and f.rel.to are not contained in to_delete,
    references_to_delete . setdefault ( f . rel . to , [ ] ) . append ( ( model , f ) )	call the method references_to_delete.setdefault with arguments: r.rel.to and an empty list, append to the result tuple with 2 entries: model and f.
to_delete . add ( model )	call the method to_delete.add with an argument model.
for model in app_models :	for every model in app_models,
if connection . introspection . table_name_converter ( model . _meta . db_table ) in table_names :	if return value of the function connection.introspection.table_name_converter called with an arugment: model._meta.db_table is contained in table_names
output . extend ( connection . creation . sql_destroy_model ( model , references_to_delete , style ) )	call the method connection.creation.sql_destroy_model with arguments: model, references_to_delete and style, extend with the result the list output.
finally :	finally perform,
if cursor and close_connection :	if both cursor and close_connection are true,
cursor . close ( )	call the method cursor.close,
connection . close ( )	call the method connection.close,
return output [ : : - 1 ]	return reversed list output.
def sql_flush ( style , connection , only_django = False , reset_sequences = True , allow_cascade = False ) :	define the function sql_flush with 4 arguments: style, connection, only_django set to boolean False,
if only_django :	if only_django,
tables = connection . introspection . django_table_names ( only_existing = True )	call the method connection.introspection.django_table_names with an argument boolean true, substitute the result for tables.
else :	if not,
tables = connection . introspection . table_names ( )	call the method connection.introspection.table_names, substitute the result for tables.
seqs = connection . introspection . sequence_list ( ) if reset_sequences else ( )	call the method connection.introspection.sequence_list if reset_sequences is true, substitute the result for seqs, if not, seqs is an empty tuple.
statements = connection . ops . sql_flush ( style , tables , seqs , allow_cascade )	call the method connection.ops.sql_flush with arguments: style, tables, seqs and allow_cascade, substitute the result for statements.
return statements	return statements.
def sql_custom ( app_config , style , connection ) :	define the function sql_custom with 3 arguments: app_config, style and connection.
check_for_migrations ( app_config , connection )	call the method check_for_migrations with arguments: app_config and connection.
output = [ ]	output is an empty list.
app_models = router . get_migratable_models ( app_config , connection . alias )	call the method router.get_migratable_models with arguments app_config and connection.alias.
for model in app_models :	for every model in app_models,
output . extend ( custom_sql_for_model ( model , style , connection ) )	call the function custom_sql_for_model with 3 arguments: model, style and connection, extend the output with the result.
return output	return output.
def sql_indexes ( app_config , style , connection ) :	define the function sql_indexes with 3 arguments: app_config, style and connection.
check_for_migrations ( app_config , connection )	call the function check_for_migrations with an arguments app_config and connection.
output = [ ]	outut is an empty list.
for model in router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) :	for model in router.get_migratable_models method return value, called with 3 arguments: app_config, connection.alias,
output . extend ( connection . creation . sql_indexes_for_model ( model , style ) )	and include_auto_created set to boolean True,   call the method connection.creation.sql_indexes_for_model with arguments model and style, extend output with the result.
return output	return output.
def sql_destroy_indexes ( app_config , style , connection ) :	define the function sql_destroy_indexes with 3 arguments: app_config, style and connection.
check_for_migrations ( app_config , connection )	call the function check_for_migrations with arguments app_config and connection.
output = [ ]	output is an empty list.
for model in router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) :	for model in return value of the method router.get_migratable_models with arguments app_config, connection.alias,
output . extend ( connection . creation . sql_destroy_indexes_for_model ( model , style ) )	and include_auto_created set to boolean True,   call the method connection.creation.sql_destroy_indexes_for_model with arguments model and style, extend the output with the result.
return output	return output.
def sql_all ( app_config , style , connection ) :	define the function sql_all with 3 arguments: app_config, style and connection.
check_for_migrations ( app_config , connection )	call the function check_for_migrations with arguments app_config and connection.
return sql_create ( app_config , style , connection ) + sql_custom ( app_config , style , connection ) + sql_indexes ( app_config , style , connection )	use the app_config, style and connection as arguments for the call to the sql_create, sql_custom and sql_indexes functions,  append the results respectively, return the result.
def _split_statements ( content ) :	define the function _split_statements with an argument content.
comment_re = re . compile ( r'^((?:'[^']*'|[^'])*?)--.*$' )	call the function re.compile with an argument raw string '^((?:'[^']*'|[^'])*?)--.*$', substitute the result for comment_re.
statements = [ ]	statements is an empty list.
statement = [ ]	statement is an empty list.
\for line in content . split ( '\\n' ) :\	split content by newline character, for every line in result,
\cleaned_line = comment_re . sub ( r'\\1' , line ) . strip ( )\	\call the method comment_re.sub with an arguments: raw string '\\1' and line, strip the whitespaces surrounding the result, return it.\
if not cleaned_line :	if cleaned_line is false,
continue	skip this loop iteration,
statement . append ( cleaned_line )	append cleaned_lien to statement.
if cleaned_line . endswith ( ';' ) :	if cleaned_line ends with ';' character,
statements . append ( ' ' . join ( statement ) )	join statements into a string, separated by white spaces, append it to statements.
statement = [ ]	statement is an empty list.
return statements	return statements.
def custom_sql_for_model ( model , style , connection ) :	define the function custom_sql_for_model with 3 arguments: app_config, style and connection.
opts = model . _meta	substitute model._meta for opts.
app_dirs = [ ]	app_dirs is an empty list.
app_dir = apps . get_app_config ( model . _meta . app_label ) . path	call the method apps.get_app_config with an argument model._met.app_label, substitute path field of the result for app_dir.
app_dirs . append ( os . path . normpath ( os . path . join ( app_dir , 'sql' ) ) )	join app_dir and string 'sql' into a file path, use the result as an argument for the call to the function os.path.normpath,
old_app_dir = os . path . normpath ( os . path . join ( app_dir , 'models/sql' ) )	append the result to app_dirs.   join app_dir and string 'models/sql' into a file path, use the result as an argument for the call to the function os.path.normpath,
if os . path . exists ( old_app_dir ) :	append the result to old_app_dirs.   if file path old_app_dir exists,
warnings . warn ( 'Custom SQL location '<app_label>/models/sql' is '  'deprecated, use '<app_label>/sql' instead.' ,  RemovedInDjango19Warning )	call the function warnings.warn with 2 arguments: string 'Custom SQL location '<app_label>/models/sql' is deprecated, use '<app_label>/sql' instead.' and RemovedInDjango19Warning.
app_dirs . append ( old_app_dir )	append old_app_dir to app_dirs.
output = [ ]	output is an empty list.
if opts . managed :	if opts.managed is true,
post_sql_fields = [ f for f in opts . local_fields if hasattr ( f , 'post_create_sql' ) ]	for every f in opts.local_fields that has an 'post_create_sql' attribute, append f to a list, substitute the resulting list for post_sql_fields.
for f in post_sql_fields :	for every f in post_sql_fields,
output . extend ( f . post_create_sql ( style , model . _meta . db_table ) )	call the method f.post_create_sql with arguments: style and model._meta.db_table, extend the output with the result.
backend_name = connection . settings_dict [ 'ENGINE' ] . split ( '.' ) [ - 1 ]	once split at the '.' value under the 'ENGINE' key of the connection.settings_dict dictionary, substitute last element of the result for backend_name.
sql_files = [ ]	sql_files is an empty list.
for app_dir in app_dirs :	for every app_dir in app_dirs,
sql_files . append ( os . path . join ( app_dir , '%s.%s.sql' % ( opts . model_name , backend_name ) ) )	join into a file path: app_dir and string %s.%s.sql, where '%s' is replaced by opts.model_name and backend_name, respectively,
sql_files . append ( os . path . join ( app_dir , '%s.sql' % opts . model_name ) )	append the result to sql_files.   join into a file path: app_dir and string %s.%s.sql, where '%s' is replaced by opts.model_name, append the result to sql_files.
for sql_file in sql_files :	for every sql_file in sql_files,
if os . path . exists ( sql_file ) :	if file path sql_file exists,
with codecs . open ( sql_file , 'r' , encoding = settings . FILE_CHARSET ) as fp :	call the function codecs.open with 3 arguments: sql_file, string 'r' and  encoding set to settings.FILE_CHARSET, with the result renamed to fp,
output . extend ( connection . ops . prepare_sql_script ( fp . read ( ) , _allow_fallback = True ) )	call the method connection.ops.prepare_sql_script with 2 arguments: return value of the function fp.read,
return output	and _allow_fallback set to boolean True, extend the output with the result.   return output.
def emit_pre_migrate_signal ( create_models , verbosity , interactive , db ) :	define the function emit_pre_migrate_signal with 4 arguments: create_models, verbosity, interactive and db.
for app_config in apps . get_app_configs ( ) :	for app_config in return value of the method apps.get_app_configs,
if app_config . models_module is None :	if app_config.models_module is None,
continue	skip this loop iteration,
if verbosity >= 2 :	if verbosity is greater or equal to integer 2,
print ( 'Running pre-migrate handlers for application %s' % app_config . label )	replace '%s' in string 'Running pre-migrate handlers for application %s' with app_config.label, print it to the standard output.
models . signals . pre_migrate . send (  sender = app_config ,  app_config = app_config ,  verbosity = verbosity ,  interactive = interactive ,  using = db )	call the method models.signals.pre_migrate.send with 5 arguments: sender set to app_config, app_config set to app_config,
models . signals . pre_syncdb . send (  sender = app_config . models_module ,  app = app_config . models_module ,  create_models = create_models ,  verbosity = verbosity ,  interactive = interactive ,  db = db )	verbosity set to verbosity, interactive set to interactive and using set to db.   call the method models.signals.pre_syncdb.send with 6 arguments: sender set to app_config.models_module,
def emit_post_migrate_signal ( created_models , verbosity , interactive , db ) :	app set to app_config.models_module, create_models set to create_models, verbosity set to verbosity, interactive set to interactive,   and db set to db.   define the function emit_post_migrate_signal with 4 arguments: created_models, verbosity, interactive and db.
for app_config in apps . get_app_configs ( ) :	for app_config in return value of the method apps.get_app_configs,
if app_config . models_module is None :	if app_config.models_module is None,
continue	skip this loop iteration,
if verbosity >= 2 :	if verbosity is greater or equal to integer 2,
print ( 'Running post-migrate handlers for application %s' % app_config . label )	replace '%s' in string 'Running post-migrate handlers for application %s' with app_config.label, print it to the standard output.
models . signals . post_migrate . send (  sender = app_config ,  app_config = app_config ,  verbosity = verbosity ,  interactive = interactive ,  using = db )	call the method models.signals.post_migrate.send with 5 arguments: sender set to app_config, app_config set to app_config,
models . signals . post_syncdb . send (  sender = app_config . models_module ,  app = app_config . models_module ,  created_models = created_models ,  verbosity = verbosity ,  interactive = interactive ,  db = db )	verbosity set to verbosity, interactive set to interactive and using set to db.   call the method models.signals.post_syncdb.send with 6 arguments: sender set to app_config.models_module,
import cgi	import module cgi.
import errno	import module errno.
import mimetypes	import module mimetypes.
import os	import module os.
import posixpath	import module posixpath.
import re	import module re.
import shutil	import module shutil.
import stat	import module stat.
import sys	import module sys.
import tempfile	import module tempfile.
from os import path	from os import path into default name space.
import django	import module django.
from django . template import Template , Context	from django.template import Template and Context into default name space.
from django . utils import archive	from django.utils import archive into default name space.
from django . utils . six . moves . urllib . request import urlretrieve	from django.utils.six.moves.urllib.request import urlretrieve into default name space.
from django . utils . _os import rmtree_errorhandler	from django.utils._os import rmtree_errorhandle into default name space.
from django . core . management . base import BaseCommand , CommandError	from django.core.management.base import BaseCommand and CommandError into default name space.
from django . core . management . utils import handle_extensions	from django.core.management.utils import handle_extensions into default name space.
_drive_re = re . compile ( '^([a-z]):' , re . I )	call the function re.compile with 2 arguments: string '^([a-z]):' and re.I, substitute the result for _drive_re.
_url_drive_re = re . compile ( '^([a-z])[:|]' , re . I )	call the function re.compile with 2 arguments: string '^([a-z])[:|]' and re.I, substitute the result for _url_drive_re.
class TemplateCommand ( BaseCommand ) :	derive the class TemplateCommand from the BaseCommand base class.
requires_system_checks = False	requires_system_checks is boolean False.
can_import_settings = False	can_import_settings is boolean False.
url_schemes = [ 'http' , 'https' , 'ftp' ]	url_schemes is list of strings 'http', 'https' and 'ftp'.
leave_locale_alone = True	leave_locale_alone is boolean True.
def add_arguments ( self , parser ) :	define the method add_aguments with arguments self and parser.
parser . add_argument ( 'name' , help = 'Name of the application or project.' )	call the method parser.add_argument with 2 arguments: string 'name' and help set to string 'Name of the application or project.'.
parser . add_argument ( 'directory' , nargs = '?' , help = 'Optional destination directory' )	call the method parser.add_argument with 3 arguments: string 'directory', nargs set to '?' and help set to string 'Name of the application or project.'.
parser . add_argument ( '--template' ,  help = 'The path or URL to load the template from.' )	call the method parser.add_argument with 2 arguments: string '--template' and help set to string 'The path or URL to load the template from.'.
parser . add_argument ( '--extension' , '-e' , dest = 'extensions' ,  action = 'append' , default = [ 'py' ] ,  help = 'The file extension(s) to render (default: 'py'). '  'Separate multiple extensions with commas, or use '  '-e multiple times.' )	call the method parser.add_argument with 6 arguments: string '--extension', string '-e', dest set to string 'extensions',
parser . add_argument ( '--name' , '-n' , dest = 'files' ,  action = 'append' , default = [ ] ,  help = 'The file name(s) to render. '  'Separate multiple extensions with commas, or use '  '-n multiple times.' )	action set to 'append', default is a list containing string 'py' and help set to string:   'The file extension(s) to render (default: 'py'). Separate multiple extensions with commas, or use -e multiple times.'.   call the method parser.add_argument with 6 arguments: string '--name', string '-n', dest set to string 'files',
def handle ( self , app_or_project , name , target = None , ** options ) :	action set to string 'append', default as an empty list and help set to a string:   'The file name(s) to render. Separate multiple extensions with commas, or use -n multiple times.'.   define the method handle with 5 arguments: self, app_or_project, name, target set to None and unpacked dictionary options.
self . app_or_project = app_or_project	substitute app_or_project for self.app_or_project.
self . paths_to_remove = [ ]	self.paths_to_remove is an empty list.
self . verbosity = options [ 'verbosity' ]	substitute value under the 'verbosity' key of the options dictionary for self.verbosity.
self . validate_name ( name , app_or_project )	call the method self.validate_name with 2 arguments name and app_or_project.
if target is None :	if target is None,
top_dir = path . join ( os . getcwd ( ) , name )	join the current working directory and name into a file path, substitute it for top_dir.
try :	try,
os . makedirs ( top_dir )	make a directory top_dir.
except OSError as e :	if OSError renamed to e, exception is caught,
if e . errno == errno . EEXIST :	if e.errno equals errno.EEXIST,
else :	if not,
message = e	substitute e for message.
raise CommandError ( message )	raise an CommandError exception with an argument message.
else :	if not,
top_dir = os . path . abspath ( path . expanduser ( target ) )	ge the absolute path of the return value of the function path.expanduser with the argument target, substitute it for top_dir.
if not os . path . exists ( top_dir ) :	if file path top_dir doesnt exists,
raise CommandError ( 'Destination directory '%s' does not '  'exist, please create it first.' % top_dir )	raise an CommandError exception with an argument string 'Destination directory '%s' does not exist, please create it first.',
extensions = tuple (  handle_extensions ( options [ 'extensions' ] , ignored = ( ) ) )	where '%s' is replaced with top_dir.   call the function handle_extensions with 2 arguments: value under the 'extensions' key of the options dictionary,
extra_files = [ ]	and ignored as an empty tuple, convert the result into a tuple and substitute it for extensions.   extra_files is an empty list.
for file in options [ 'files' ] :	for every file in value under the 'files' key of the options dictionary.
extra_files . extend ( map ( lambda x : x . strip ( ) , file . split ( ',' ) ) )	split file by ',' character, apply on its every element a lambda function which takes an argument x,
if self . verbosity >= 2 :	and returns x striped of the surrounding whitespaces, extend the extra_files with the mapped list.   if self.verbosity is greater or equal to integer 2,
\self . stdout . write ( 'Rendering %s template files with '  'extensions: %s\\n' %  ( app_or_project , ', ' . join ( extensions ) ) )\	\call the method self.stdout.write, with an argument string 'Rendering %s template files with extensions: %s\\n',\
\self . stdout . write ( 'Rendering %s template files with '  'filenames: %s\\n' %  ( app_or_project , ', ' . join ( extra_files ) ) )\	\where '%s' is replaced with app_or_project and extensions joined into a string, separated by a string ', '.   call the method self.stdout.write, with an argument string 'Rendering %s template files with filenames: %s\\n',\
base_name = '%s_name' % app_or_project	where '%s' is replaced with app_or_project and extra_files joined into a string, separated by a string ', '.   append string '_name' to app_or_project, substitute it for base_name.
base_subdir = '%s_template' % app_or_project	append string '_template' to app_or_project, substitute it for base_subdir.
base_directory = '%s_directory' % app_or_project	append string '_directory' to app_or_project, substitute it for base_directory.
if django . VERSION [ - 2 ] != 'final' :	if second last element of django.VERSION is not equal to a string 'final',
docs_version = 'dev'	docs_version is a string 'dev'.
else :	if not,
docs_version = '%d.%d' % django . VERSION [ : 2 ]	convert first 2 elements of django.VERSION into a strings, join them together, separated by a '.', substitute the result for docs_version.
context = Context ( dict ( options , ** {  base_name : name ,  base_directory : top_dir ,  'docs_version' : docs_version ,  } ) , autoescape = False )	context is an instance of a class Context, created with 2 arguments: dictionary created by apllying options to unpacked dictionary containing 3 entries:
from django . conf import settings	name for base_name, top_dir for base_directory and docs_version for 'docs_version' and autoescape set to boolean False.   from django.conf import settings into a default name space,
if not settings . configured :	if settings.configured is false,
settings . configure ( )	call the method settings.configure.
template_dir = self . handle_template ( options [ 'template' ] ,  base_subdir )	call the method self.handle_template with 2 arguments: value under the 'template' key of the options dictionary and base_subdir.
prefix_length = len ( template_dir ) + 1	increment length of template_dir by one and substitute it for prefix_length.
for root , dirs , files in os . walk ( template_dir ) :	for every root, dirs and files in subdirectory tree starting from the base dir template_dir,
path_rest = root [ prefix_length : ]	slice root starting from the prefix_length index to the end, substitute it for path_rest.
relative_dir = path_rest . replace ( base_name , name )	call the method path_rest.replace with arguments base_name and name, substitute the result for relative_dir.
if relative_dir :	if relative_dir is true,
target_dir = path . join ( top_dir , relative_dir )	join top_dir and relative_dir into a file path, substitute it for target_dir.
if not path . exists ( target_dir ) :	if target_dir path doesnt exists,
os . mkdir ( target_dir )	make target_dir directory,
for dirname in dirs [ : ] :	for dirname in dirs,
if dirname . startswith ( '.' ) or dirname == '__pycache__' :	if dirname starts with character '.' or dirname equals a string '__pycache__',
dirs . remove ( dirname )	remove dirname key from dirs.
for filename in files :	for every filename in files,
if filename . endswith ( ( '.pyo' , '.pyc' , '.py.class' ) ) :	if filename ends with '.pyo', '.pyc' or '.py.class',
  continue	skip this loop iteration,
old_path = path . join ( root , filename )	join root and filename into a file path, substitute it for old_path.
new_path = path . join ( top_dir , relative_dir ,  filename . replace ( base_name , name ) )	join top_dir, relative_dir and return value of the function filename.replace called with 2 arguments: base_name and name,
if path . exists ( new_path ) :	into a file path, substitute it for new_path.   if new_path file path exists,
raise CommandError ( '%s already exists, overlaying a '  'project or app into an existing '  'directory won't replace conflicting '  'files' % new_path )	raise a CommandError exception with an argument:
with open ( old_path , 'rb' ) as template_file :	string '%s already exists, overlaying a project or app into an existing directory won't replace conflicting files',   where '%s' is replaced with new_path.   open old_path file in 'rb' mode, with file descriptor renamed to template_file,
content = template_file . read ( )	call the method template_file.read, substitute it for content.
if filename . endswith ( extensions ) or filename in extra_files :	if filename ends with extensions or filename is contained in extra_files,
content = content . decode ( 'utf-8' )	call the method content.decode with an argument string 'utf-8', substitute it for content.
template = Template ( content )	template is an instance of Template class, created with an argument content.
content = template . render ( context )	call the method template.render with an argument context, substitute it for content.
content = content . encode ( 'utf-8' )	call the method content.encode with an argument string 'utf-8', substitute it for content.
with open ( new_path , 'wb' ) as new_file :	open new_path file in 'wb' mode, with file descriptor renamed to new_file,
new_file . write ( content )	write content to new_file file.
if self . verbosity >= 2 :	if self.verbosity is greater or equal to integer 2,
\self . stdout . write ( 'Creating %s\\n' % new_path )\	\replace '%s' in string 'Creating %s\\n' with new_path, write it to the self.stdout stream.\
try :	try,
shutil . copymode ( old_path , new_path )	call the function shutil.copymode with arguments old_path and new_path.
self . make_writeable ( new_path )	call the method self.make_writeable with an argument new_path.
except OSError :	if OSError exception is caught,
self . stderr . write (  'Notice: Couldn't set permission bits on %s. You're '  'probably using an uncommon filesystem setup. No '  'problem.' % new_path , self . style . NOTICE )	replace '%s' in string 'Notice: Couldn't set permission bits on %s. You're probably using an uncommon filesystem setup. No problem.',
if self . paths_to_remove :	with new_path and self.style.NOTICE, respectively, write it to self.stderr stream.   if self.paths_to_remove is true,
if self . verbosity >= 2 :	if self.verbosity is greater or equal to integer 2,
\self . stdout . write ( 'Cleaning up temporary files.\\n' )\	\write string 'Cleaning up temporary files.\\n' to self.stdout stream.\
for path_to_remove in self . paths_to_remove :	for every path_to_remove in self.paths_to_remove,
if path . isfile ( path_to_remove ) :	if path_to_remove is file,
os . remove ( path_to_remove )	remove file path_to_remove,
else :	if not,
shutil . rmtree ( path_to_remove ,  onerror = rmtree_errorhandler )	call the function shutil.rmtree with 2 arguments: path_to_remove and onerror set to rmtree_errorhandler.
def handle_template ( self , template , subdir ) :	define the method handle_template with 3 arguments: self, template and subdir.
if template is None :	if template is None,
return path . join ( django . __path__ [ 0 ] , 'conf' , subdir )	join first element of django.__path__, string 'conf' and subdir into a valid file path, return it.
else :	if not,
if template . startswith ( 'file://' ) :	if template starts with a string 'file://',
template = template [ 7 : ]	remove first 7 elements form template.
expanded_template = path . expanduser ( template )	call the method path.expanduser with an argument template, substitute it for expanded_template.
expanded_template = path . normpath ( expanded_template )	call the method path.normpath with an argument expanded_template, substitute it for expanded_template.
if path . isdir ( expanded_template ) :	if expanded_template is a directory,
return expanded_template	return expanded_template.
if self . is_url ( template ) :	call the method self.is_url with an argument template, if it evaluates to true,
absolute_path = self . download ( template )	call the method self.download with an argument template, substitute the result for absolute_path.
else :	if not,
absolute_path = path . abspath ( expanded_template )	get the absolute file path of the expanded_template, substitute it for absolute_path.
if path . exists ( absolute_path ) :	if file path absolute_path exists,
return self . extract ( absolute_path )	call the method self.extract with an argument absolute_path, return the result.
raise CommandError ( 'couldn't handle %s template %s.' %  ( self . app_or_project , template ) )	raise an CommandError exception with an argument string 'couldn't handle %s template %s.', replace '%s' with self.app_or_project and template.
def validate_name ( self , name , app_or_project ) :	define validate_name with 3 arguments: self, name and app_or_project.
if name is None :	if name is None,
raise CommandError ( 'you must provide %s %s name' % (  'an' if app_or_project == 'app' else 'a' , app_or_project ) )	raise an CommandError exception with an argument string 'you must provide %s %s name', where '%s' is replaced with string 'an',
\if not re . search ( r'^[_a-zA-Z]\\w*$' , name ) :\	\and app_or_project if app_or_project equals to string 'app', if not, it is replaced with 'a' and app_or_project.   call the method re.search with 2 arguments: raw string '^[_a-zA-Z]\\w*$' and name, if it evaluates to false,\
if not re . search ( r'^[_a-zA-Z]' , name ) :	call the method re.search with 2 arguments: raw string '^[_a-zA-Z]' and name, if it evaluates to false,
message = 'make sure the name begins with a letter or underscore'	message is a string 'make sure the name begins with a letter or underscore'.
else :	if not,
message = 'use only numbers, letters and underscores'	message is a string 'use only numbers, letters and underscores'.
raise CommandError ( '%r is not a valid %s name. Please %s.' %  ( name , app_or_project , message ) )	raise an CommandError with an argument string '%r is not a valid %s name. Please %s.', were '%r' is replaced with name,
def download ( self , url ) :	and '%s' is replaced with app_or_project and message, respectively.   define the method download with arguments self and url.
def cleanup_url ( url ) :	define the function cleanup_url with an argument url.
tmp = url . rstrip ( '/' )	strip url of surrounding '/' characters, substitute it for tmp.
filename = tmp . split ( '/' ) [ - 1 ]	split tmp at '/' character, substitute the last element of the result for filename.
if url . endswith ( '/' ) :	if url ends with '/' character,
display_url = tmp + '/'	append '/' to tmp, substitute it for display_url.
else :	if not,
display_url = url	substitute url for display_url.
return filename , display_url	return filename and display_url.
prefix = 'django_%s_template_' % self . app_or_project	replace '%s' in string 'django_%s_template_' with self.app_or_project.
tempdir = tempfile . mkdtemp ( prefix = prefix , suffix = '_download' )	call the function tempfile.mkdtemp with arguments: prefix set to prefix and suffix  set to string '_download'.
self . paths_to_remove . append ( tempdir )	append the tempdir to self.paths_to_remove.
filename , display_url = cleanup_url ( url )	call the function cleanup_url with an argument url, assign the result to filename and display_url, respectively.
if self . verbosity >= 2 :	if self.verbosity is greater or equal to integer 2,
\self . stdout . write ( 'Downloading %s\\n' % display_url )\	\replace '%s' in string 'Downloading %s\\n', with display_url, write it to self.stdout stream.\
try :	try,
the_path , info = urlretrieve ( url , path . join ( tempdir , filename ) )	call the function urlretrieve with arguments url and tempdir and filename joined into a file path, assign the result to the_path,  and info, respectively.
except IOError as e :	if IOErro, renamed to e, exception is caught,
raise CommandError ( 'couldn't download URL %s to %s: %s' %  ( url , filename , e ) )	raise an CommandError exception with an argument string 'couldn't download URL %s to %s: %s', where '%s' is replaced with url,
used_name = the_path . split ( '/' ) [ - 1 ]	filename and e.   split the_path at the '/' character, substitute last element of the result for used_name.
content_disposition = info . get ( 'content-disposition' )	get the value under the 'content-disposition' key of the info dictionary, substitute it for content_disposition.
if content_disposition :	if content_disposition is true,
_ , params = cgi . parse_header ( content_disposition )	call the method cgi.parse_header with an argument content_disposition, assign the result to _ and params, respectively.
guessed_filename = params . get ( 'filename' ) or used_name	get the value under the 'filename' key of the params dictionary, if the key exists substitute it for guessed_filename,
else :	if not, substitute used_name for guessed_filename.   if not,
guessed_filename = used_name	substitute used_name for guessed_filename.
ext = self . splitext ( guessed_filename ) [ 1 ]	call the method self.splitext with an argument guessed_filename, substitute the second element of the result for ext.
content_type = info . get ( 'content-type' )	get the value under the 'content-type' key of the info dictionary, substitute it for content_type.
if not ext and content_type :	if ext is false and content_type is true,
ext = mimetypes . guess_extension ( content_type )	call the method mimetypes.guess_extension with an argument content_type, substitute result for ext.
if ext :	if ext is true,
guessed_filename += ext	append ext to guessed_filename.
if used_name != guessed_filename :	if used_name is not equal to guessed_filename,
guessed_path = path . join ( tempdir , guessed_filename )	join tempdir and guessed_filename into a file path, substitute it for guessed_path.
shutil . move ( the_path , guessed_path )	call the function shutil.move with arguments the_path and guessed_path.
return guessed_path	return guessed_path.
return the_path	return the_path.
def splitext ( self , the_path ) :	define the method splitext with arguments self and the_path.
base , ext = posixpath . splitext ( the_path )	call the method posixpath.splitext with an argument the_path.
if base . lower ( ) . endswith ( '.tar' ) :	convert base to lowercase, if it ends with string '.tar',
ext = base [ - 4 : ] + ext	take last four elements of base and append ext to it, substitute result for ext.
base = base [ : - 4 ]	substitute last four elements of base for base.
return base , ext	return base and ext.
def extract ( self , filename ) :	define the function with arguments self and filename.
prefix = 'django_%s_template_' % self . app_or_project	replace '%s' in string 'django_%s_template_' with self.app_or_project, substitute it for prefix.
tempdir = tempfile . mkdtemp ( prefix = prefix , suffix = '_extract' )	call the method tempfile.mkdtemp with 2 arguments: prefix set to prefix, suffix set to string '_extract', substitute the result for tempdir.
self . paths_to_remove . append ( tempdir )	append tempdir to self.self.paths_to_remove.
if self . verbosity >= 2 :	if self.verbosity is greater or equal to integer 2.
\self . stdout . write ( 'Extracting %s\\n' % filename )\	\substitute '%s' in string 'Extracting %s\\n' with filename, write it to self.stdout stream.\
try :	try,
archive . extract ( filename , tempdir )	call the method archive.extract with arguments: filename and tempdir.
return tempdir	return tempdir.
except ( archive . ArchiveException , IOError ) as e :	if archive.ArchiveException or IOError, renamed to e, exception are caught,
raise CommandError ( 'couldn't extract file %s to %s: %s' %  ( filename , tempdir , e ) )	raise an CommandError with an argument string 'couldn't extract file %s to %s: %s', where '%s' is replaced with filename, tempdir and e.
def is_url ( self , template ) :	define the method is_url with arguments self and template.
if ':' not in template :	if character ':' is not contained in template,
return False	return boolean False.
scheme = template . split ( ':' , 1 ) [ 0 ] . lower ( )	split template once at the first character ':', convert the first element to lowercase and substitute it for scheme.
return scheme in self . url_schemes	if scheme is countaine in self.url_schemes return boolean True, otherwise return False.
def make_writeable ( self , filename ) :	define the method make_writeable with arguments self and filename.
if sys . platform . startswith ( 'java' ) :	if sys.platform starts with string 'java',
return	return nothing.
if not os . access ( filename , os . W_OK ) :	if call to the method os.access with arguments: filename and os.W_OK, evaluates to false,
st = os . stat ( filename )	call the function os.stat with an argument filename, substitute the result for st.
new_permissions = stat . S_IMODE ( st . st_mode ) | stat . S_IWUSR	call the method stat.S_IMODE with an argument st.st_mode, calculate binary OR with the result and stat.S_IWUSR, as operands,
os . chmod ( filename , new_permissions )	substitute the result for new_permission.   call the function os.chmod wiht arguments filename and new_permissions.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import os	import module os.
from subprocess import PIPE , Popen	from subprocess import PIPE and Popen into default name space.
import sys	import module sys.
from django . utils . encoding import force_text , DEFAULT_LOCALE_ENCODING	from django.utils.encoding import force_text and DEFAULT_LOCALE_ENCODING into default name space.
from django . utils import six	from django.utils import six into default name space.
from . base import CommandError	from .base import CommandError into default name space.
def popen_wrapper ( args , os_err_exc_type = CommandError ) :	define the function popen_wrapper with 2 arguments: args and os_err_exc_type set to CommandError.
try :	try,
p = Popen ( args , shell = False , stdout = PIPE , stderr = PIPE ,  close_fds = os . name != 'nt' , universal_newlines = True )	p is a instance of Popen class, created with 6 arguments: args, shell set to boolean False, stdout set to PIPE,
except OSError as e :	stderr set to PIPE, close_fds set to boolean True is os.name is not equal to 'nt', universal_newlines set to boolean True.   if OSError, renamed to e, exception is caught,
strerror = force_text ( e . strerror , DEFAULT_LOCALE_ENCODING ,  strings_only = True )	call the force_text function with 3 arguments: e.strerror, DEFAULT_LOCALE_ENCODING and strings_only set to boolean True.
six . reraise ( os_err_exc_type , os_err_exc_type ( 'Error executing %s: %s' %  ( args [ 0 ] , strerror ) ) , sys . exc_info ( ) [ 2 ] )	call the method six.reraise 3 with arguments: os_err_exc_type, return value of the function os_err_exc_type,
output , errors = p . communicate ( )	called with string as an argument 'Error executing %s: %s', where '%s' is replaced by: first element of args and strerror, respective,   and third element of the result of the function sys.exc_info.   call the method p.communicate, assign the result to output and errors, respectively.
return (  output ,  force_text ( errors , DEFAULT_LOCALE_ENCODING , strings_only = True ) ,  p . returncode  )	return a tuple containing 3 entries: output, result of the function force_text, called with 3 arguments: errors,
def handle_extensions ( extensions = ( 'html' , ) , ignored = ( 'py' , ) ) :	DEFAULT_LOCALE_ENCODING and strings_only set to boolean True and p.returncode.   define the function handle_extensions with 2 arguments: extensions set to tuple containing string 'html' and ignored set to tuple containing string 'py'.
ext_list = [ ]	ext_list is an empty list,
for ext in extensions :	for every ext in extensions,
ext_list . extend ( ext . replace ( ' ' , '' ) . split ( ',' ) )	delete all the whitespaces from ext, split it by ',' character, extend ext_list with the result.
for i , ext in enumerate ( ext_list ) :	for every i and ext in enumerated iterable ext_list,
if not ext . startswith ( '.' ) :	if ext doesnt start with '.' character,
ext_list [ i ] = '.%s' % ext_list [ i ]	prepend '.' to the i-th element of the ext_list.
return set ( x for x in ext_list if x . strip ( '.' ) not in ignored )	if striped x by '.' character is not contained in ignored, for every x in ext_list put x into a set, return the resulting set.
def find_command ( cmd , path = None , pathext = None ) :	define the function find_command with 3 arguments: cmd, path set to None and pathext set to None.
if path is None :	if path is None,
path = os . environ . get ( 'PATH' , '' ) . split ( os . pathsep )	call the function os.environ.get with 2 arguments: string 'PATH' and an empty string, split the result at the os.pathsep, substitute the result for path.
if isinstance ( path , six . string_types ) :	if path is an instance of six.string_types,
path = [ path ]	path is an list containing path.
if pathext is None :	if pathext is None,
pathext = os . environ . get ( 'PATHEXT' , '.COM;.EXE;.BAT;.CMD' ) . split ( os . pathsep )	call the method os.environ.get with 2 arguments: strings 'PATHEXT' and '.COM;.EXE;.BAT;.CMD', split the result at os.pathsep, substitute it for pathext.
for ext in pathext :	for ext in pathext,
if cmd . endswith ( ext ) :	if cmd ends with ext,
pathext = [ '' ]	pathext is an list containing an empty string.
break	break the loop execution.
for p in path :	  for every p in path,
f = os . path . join ( p , cmd )	join p and cmd into a file path, substitute it for f.
if os . path . isfile ( f ) :	if f is a file,
return f	return f.
for ext in pathext :	for every ext in pathext,
fext = f + ext	add ext to f, substitute the result for fext.
if os . path . isfile ( fext ) :	if fext is a file,
return fext	return fext.
return None	return None.
import collections	import module collections.
from math import ceil	from math import ceil into default name space.
from django . utils import six	from django.utils import six into default name space.
class InvalidPage ( Exception ) :	derive the class InvalidPage from the Exception base class.
pass	do nothing.
class PageNotAnInteger ( InvalidPage ) :	derive the class PageNotAnInteger from the InvalidPage base class.
pass	do nothing.
class EmptyPage ( InvalidPage ) :	derive the class EmptyPage from the InvalidPage base class.
pass	do nothing.
class Paginator ( object ) :	derive the class Paginator from the object base class.
def __init__ ( self , object_list , per_page , orphans = 0 ,  allow_empty_first_page = True ) :	def the method __init__ with 5 arguments: self, object_list, per_page, orphans set to integer 0 and allow_empty_first_page set to boolean True.
self . object_list = object_list	substitute object_list for self.object_list.
self . per_page = int ( per_page )	convert per_page into an integer and substitute it for self.per_page.
self . orphans = int ( orphans )	convert orphans into an integer and substitute it for self.orphans.
self . allow_empty_first_page = allow_empty_first_page	substitute allow_empty_first_page for self.allow_empty_first_page.
self . _num_pages = self . _count = None	self._num_pages and self._count are None.
def validate_number ( self , number ) :	define the method validate_number with self class instance and number as arguments.
try :	try,
number = int ( number )	convert number into an integer and substitute it for number
except ( TypeError , ValueError ) :	if TypeError or ValueError exceptions are caught,
raise PageNotAnInteger ( 'That page number is not an integer' )	raise an exception PageNotAnInteger with string 'That page number is not an integer' as an argument.
if number < 1 :	if number is lesser than integer 1,
raise EmptyPage ( 'That page number is less than 1' )	raise an EmptyPage exception with string 'That page number is less than 1' as an argument.
if number > self . num_pages :	if number is greater than self.num_pages,
if number == 1 and self . allow_empty_first_page :	if number equals a integer 1 and self.allow_empty_first_page is true,
pass	do nothing.
else :	if not,
raise EmptyPage ( 'That page contains no results' )	raise an EmptyPage exception with string 'That page contains no results' as an argument.
return number	return number.
def page ( self , number ) :	define the method page with self class instance and number as arguments.
number = self . validate_number ( number )	call the method self.validate_number with an argument number, substitute it for number.
bottom = ( number - 1 ) * self . per_page	decrement number by one, multiply it with self.per_page, substitute the result for bottom.
top = bottom + self . per_page	sum bottom and self.per_page, substitute the result for top.
if top + self . orphans >= self . count :	if sum of the top and self.orphans is greater or equal to self.count,
top = self . count	substitute self.count for top.
return self . _get_page ( self . object_list [ bottom : top ] , number , self )	call the self._get_pages method with 3 arguments: self.object_list from the bottom to the top index, number and self, return the result.
def _get_page ( self , * args , ** kwargs ) :	define the method _get_page with self class instance, unpacked list args and unpacked dictionary kwargs as arguments.
return Page ( * args , ** kwargs )	return a instance of the class Page, created with 2 arguments: unpacked list args and unpacked dictionary kwargs.
def _get_count ( self ) :	define the method _get_count with an argument self.
if self . _count is None :	if self._count is None,
try :	try,
self . _count = self . object_list . count ( )	substitute the return value of the method self.object_list.count for self._count.
except ( AttributeError , TypeError ) :	if TypeError or AttributeError exceptions are caught,
self . _count = len ( self . object_list )	substitute length of self.object_list for self._count.
return self . _count	return self._count.
count = property ( _get_count )	count is a property object with _get_count as a getter method.
def _get_num_pages ( self ) :	define the method _get_num_pages with an argument self.
if self . _num_pages is None :	if self._num_pages is None,
if self . count == 0 and not self . allow_empty_first_page :	if self.count equals a integer 0 and self.allow_empty_first_page is false,
self . _num_pages = 0	self._num_pages is a integer 0.
else :	if not,
hits = max ( 1 , self . count - self . orphans )	get greater value between integer 1 and result of subtraction of self.orphans from self.count, substitute it for hits.
self . _num_pages = int ( ceil ( hits / float ( self . per_page ) ) )	divide hits by a floating point number self.per_page, convert its ceiling value to an integer and substitute it for self._num_pages.
return self . _num_pages	return self._num_pages.
num_pages = property ( _get_num_pages )	num_pages is a property object with _get_num_pages as a getter method.
def _get_page_range ( self ) :	define the method _get_page_range with an argument self.
return range ( 1 , self . num_pages + 1 )	return all the integers from the integer 1 to the self.num_pages.
page_range = property ( _get_page_range )	page_range is a property object with _get_page_range as a getter method.
QuerySetPaginator = Paginator	substitute Paginator for QuerySetPaginator.
class Page ( collections . Sequence ) :	derive the class Page from the collections.Sequence base class.
def __init__ ( self , object_list , number , paginator ) :	define the method __init__ with 4 arguments: self, object_list, number, and paginator.
self . object_list = object_list	substitute object_list for self.object_list.
self . number = number	substitute number for self.number.
self . paginator = paginator	substitute paginator for self.paginator.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return '<Page %s of %s>' % ( self . number , self . paginator . num_pages )	return the string '<Page %s of %s>', with occurrences of '%s' replaced by self.number and self.paginator.num_pages, respectively.
def __len__ ( self ) :	define the method __len__ with an argument self.
return len ( self . object_list )	return the length of self.object_list.
def __getitem__ ( self , index ) :	define the method __getitem__ with arguments self and index.
if not isinstance ( index , ( slice , ) + six . integer_types ) :	if index is not an instance of six.integer_types or tuple type,
raise TypeError	raise a TypeError exception,
if not isinstance ( self . object_list , list ) :	if self.object is not an instance of list type,
self . object_list = list ( self . object_list )	convert self.object_list to a list.
return self . object_list [ index ]	return self.object_list element at index.
def has_next ( self ) :	define the method has_next with an argument self.
return self . number < self . paginator . num_pages	if self.number is lesser than self.paginator.num_pages, return boolean True, otherwise return boolean False.
def has_previous ( self ) :	define the method has_previous with an argument self.
return self . number > 1	if self.number is greater than integer 1, return boolean True, otherwise return boolean False.
def has_other_pages ( self ) :	define the method has_other_pages with an argument self.
return self . has_previous ( ) or self . has_next ( )	call the method self.has_previous, if it evaluate to false, call the self.has_next method, return the result.
def next_page_number ( self ) :	define the method next_page_number with an argument self.
return self . paginator . validate_number ( self . number + 1 )	call the method self.paginator.validate_number with self.number incremented by 1 as argument, return the result.
def previous_page_number ( self ) :	define the method previous_page_number with an argument self.
return self . paginator . validate_number ( self . number - 1 )	call the method self.paginator.validate_number with self.number decremented by 1 as argument, return the result.
def start_index ( self ) :	define the method start_index with an argument self.
if self . paginator . count == 0 :	if self.paginator.count equals a integer 0,
return 0	return integer 0.
return ( self . paginator . per_page * ( self . number - 1 ) ) + 1	decrement self.number by one, multiply it by self.paginator.per_page, increment the result by one, return it.
def end_index ( self ) :	define the method end_index with an argument self.
if self . number == self . paginator . num_pages :	if self.number equals to self.paginator.num_pages,
return self . paginator . count	return self.paginator.count.
return self . number * self . paginator . per_page	multiply self.number and self.paginator.per_page, return the result.
import importlib	import module importlib.
from django . conf import settings	from django.conf import settings into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . core . serializers . base import SerializerDoesNotExist	from django.core.serializers.base import SerializerDoesNotExist into default name space.
BUILTIN_SERIALIZERS = {  'xml' : 'django.core.serializers.xml_serializer' ,  'python' : 'django.core.serializers.python' ,  'json' : 'django.core.serializers.json' ,  'yaml' : 'django.core.serializers.pyyaml' ,  }	BUILTIN_SERIALIZERS is a dictionary containing 4 inital entries: 'django.core.serializers.xml_serializer' for 'xml',
_serializers = { }	django.core.serializers.python for 'python', 'django.core.serializers.json' for 'json',   and 'django.core.serializers.pyyaml' for 'yaml'.   _serializers is an empty dictionary.
class BadSerializer ( object ) :	derive the class BadSerializer from the object base class.
internal_use_only = False	internal_use_only is boolean False.
def __init__ ( self , exception ) :	define the __init__method with arguments self and exception.
self . exception = exception	substitute exception for self.exception.
def __call__ ( self , * args , ** kwargs ) :	define the __call__method with arguments self, unpacked list args and unpacked dictionary kwargs.
raise self . exception	raise an self.exception exception.
def register_serializer ( format , serializer_module , serializers = None ) :	define the function register_serializer with 3 arguments: format, serializer_module and serializers set to None.
if serializers is None and not _serializers :	if serializers is None and _serializers is false,
_load_serializers ( )	call the function _load_serializers.
try :	try,
module = importlib . import_module ( serializer_module )	call the function importlib.import_module with an argument serializer_module, substitute it for module.
except ImportError as exc :	if ImportError, renamed to exc, exception is caught,
bad_serializer = BadSerializer ( exc )	ba_serializer is a instance of BadSerializer class, created with an argument exc.
module = type ( 'BadSerializerModule' , ( object , ) , {  'Deserializer' : bad_serializer ,  'Serializer' : bad_serializer ,  } )	create a instance of a class BadSerializerModule from the object base class, with elements Deserializer set to bad_serializer and Serializer set to bad_serializer.
if serializers is None :	if serializers is None,
_serializers [ format ] = module	substitute module for the value under the format key of the _serializers dictionary.
else :	if not,
serializers [ format ] = module	substitute module for the value under the format key of the serializers dictionary.
def unregister_serializer ( format ) :	define the function unregister_serializer with an argument format.
if not _serializers :	  if _serializers is false,
_load_serializers ( )	call the function _load_serializers.
if format not in _serializers :	if format is not contained in _serializers,
raise SerializerDoesNotExist ( format )	raise a SerializerDoesNotExist exception with an argument format.
del _serializers [ format ]	delete the _serializers dictionary entry at the format key.
def get_serializer ( format ) :	define the function get_serializer with an argument format.
if not _serializers :	if _serializers is false,
_load_serializers ( )	call the function _load_serializers.
if format not in _serializers :	if format is not contained in _serializers,
raise SerializerDoesNotExist ( format )	raise a SerializerDoesNotExist exception with an argument format.
return _serializers [ format ] . Serializer	get the value under the format key of the _serializers dictionary, return the Serializer filed of the result.
def get_serializer_formats ( ) :	define the function get_serializer_formats.
if not _serializers :	if _serializers is false,
_load_serializers ( )	call the function _load_serializers.
return list ( _serializers )	convert _serializers into a list, return it.
def get_public_serializer_formats ( ) :	define the function get_public_serializer_formats.
if not _serializers :	f _serializers is false,
_load_serializers ( )	call the function _load_serializers.
return [ k for k , v in six . iteritems ( _serializers ) if not v . Serializer . internal_use_only ]	append k into a list for every k and v in return value of the six.iteritems function with an argument _serializers,
def get_deserializer ( format ) :	only if v.Serializer.internal_use_only is false, return the resulting list.   define the function get_deserializer with an argument format.
if not _serializers :	f _serializers is false,
_load_serializers ( )	call the function _load_serializers.
if format not in _serializers :	if format is not contained in _serializers,
raise SerializerDoesNotExist ( format )	raise a SerializerDoesNotExist exception with an argument format.
return _serializers [ format ] . Deserializer	get the value under the format key of the _serializers dictionary, return the Deserializer filed of the result.
def serialize ( format , queryset , ** options ) :	define the function serializer with 3 arguments: format, queryset and unpacked dictionary options.
s = get_serializer ( format ) ( )	call the get_serializer function with an argument format, call the return value object and substitute it for s.
s . serialize ( queryset , ** options )	call the s.serialize method with arguments queryset and unpacked dictionary options.
return s . getvalue ( )	evaluate the method s.getvalue, return the result.
def deserialize ( format , stream_or_string , ** options ) :	define the function deserialize with 3 arguments: format, stream_or_string and unpacked dictionary options.
d = get_deserializer ( format )	call the get_deserializer function with an argument format, substitute the result for d.
return d ( stream_or_string , ** options )	call the object d with arguments stream_or_string and unpacked dictionary options, return the result.
def _load_serializers ( ) :	define the function _load_serializers.
global _serializers	use the global variable _serializers.
serializers = { }	serializers is an empty dictionary.
for format in BUILTIN_SERIALIZERS :	for every format in BUILTIN_SERIALIZERS,
register_serializer ( format , BUILTIN_SERIALIZERS [ format ] , serializers )	call the function register_serializer with 3 arguments: format, value under the format key of the BUILTIN_SERIALIZERS dictionary and serializers.
if hasattr ( settings , 'SERIALIZATION_MODULES' ) :	if setting has an 'SERIALIZATION_MODULES' attribute,
for format in settings . SERIALIZATION_MODULES :	for every format in settings.SERIALIZATION_MODULES,
register_serializer ( format , settings . SERIALIZATION_MODULES [ format ] , serializers )	call the function register_serializer with 3 arguments: format, value under the format key of the settings.SERIALIZATION_MODULES dictionary and serializers.
_serializers = serializers	substitute serializers for _serializers.
import warnings	import module warnings.
from django . db import models	from django.db import models into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
class SerializerDoesNotExist ( KeyError ) :	derive the class SerializerDoesNotExist from the KeyError base class.
pass	do nothing.
class SerializationError ( Exception ) :	derive the class SerializationError from the Exception base class.
pass	do nothing.
class DeserializationError ( Exception ) :	derive the class DeserializationError from the Exception base class.
pass	do nothing.
class Serializer ( object ) :	derive the class Serializer from the object base class.
internal_use_only = False	internal_use_only is a boolean False.
def serialize ( self , queryset , ** options ) :	define the method serialize with 3 arguments: self, queryset and unpacked dictionary options.
self . options = options	substitute options for self.options.
self . stream = options . pop ( 'stream' , six . StringIO ( ) )	remove the 'stream' key from the options dictionary and substitute it for self.stream,
self . selected_fields = options . pop ( 'fields' , None )	if the key doesnt exists call the six.String function and substitute the result for self.stream.   remove the 'fields' key from the options dictionary and substitute it for self.selected_fields,
self . use_natural_keys = options . pop ( 'use_natural_keys' , False )	if the key doesnt exists substitute None for self.selected_fields.   remove the 'use_natural_keys' key from the options dictionary and substitute it for self.use_natural_keys,
if self . use_natural_keys :	if the key doesnt exists substitute boolean False for self.use_natural_keys.   if self.use_natural_keys is true,
warnings . warn ( '``use_natural_keys`` is deprecated; use ``use_natural_foreign_keys`` instead.' ,  RemovedInDjango19Warning )	call the function warnings.warn with 2 arguments: string '``use_natural_keys`` is deprecated; use ``use_natural_foreign_keys`` instead.' and RemovedInDjango19Warning.
self . use_natural_foreign_keys = options . pop ( 'use_natural_foreign_keys' , False ) or self . use_natural_keys	remove the 'use_natural_primary_keys' key from the options dictionary and substitute it for self.use_natural_foreign_keys,
self . use_natural_primary_keys = options . pop ( 'use_natural_primary_keys' , False )	if the key doesnt exists substitute self.use_natural_keys for self.use_natural_foreign_keys.   remove the 'use_natural_primary_keys' key from the options dictionary and substitute it for self.use_natural_primary_keys,
self . start_serialization ( )	if the key doesnt exists substitute boolean False for self.use_natural_primary_keys.   call the method self.start_serialization
self . first = True	self.first is boolean True.
for obj in queryset :	for every obj in queryset,
self . start_object ( obj )	call the self.start_object with an argument obj.
concrete_model = obj . _meta . concrete_model	substitute obj._meta.concrete_model for concrete_model.
for field in concrete_model . _meta . local_fields :	for every field in concrete_model._meta.local_fields,
if field . serialize :	if field.serialize is true,
if field . rel is None :	if field.rel is None,
    if self . selected_fields is None or field . attname in self . selected_fields :	if self.selected_fields is None or field.attname is contained in self.selected_fields
        self . handle_field ( obj , field )	call the method self.handle_field with arguments obj and filed.
else :	if not,
    if self . selected_fields is None or field . attname [ : - 3 ] in self . selected_fields :	if self.selected_fields is None or last three elements of field.attname are contained in self.selected_fields:
        self . handle_fk_field ( obj , field )	call the method self.handle_fk_field with arguments obj and field.
for field in concrete_model . _meta . many_to_many :	for every field in concrete_model._meta.many_to_many,
if field . serialize :	if field.serialize is true,
if self . selected_fields is None or field . attname in self . selected_fields :	if self.selected_fields is None or field.attname is contained in self.selected_fields,
    self . handle_m2m_field ( obj , field )	call the method self.handle_m2m_field with arguments obj and filed.
self . end_object ( obj )	call the method self.end_object with an argument obj.
if self . first :	if self.first is true,
self . first = False	self.first is boolean False.
self . end_serialization ( )	call the method self.end_serialization.
return self . getvalue ( )	call the method self.getvalue, return the result.
def start_serialization ( self ) :	define the method start_serialization with an argument self.
raise NotImplementedError ( 'subclasses of Serializer must provide a start_serialization() method' )	raise a NotImplementedError with an argument string 'subclasses of Serializer must provide a start_serialization() method'.
def end_serialization ( self ) :	define the method end_serialization with an argument self.
pass	do nothing.
def start_object ( self , obj ) :	define the method start_object with argument self and obj.
raise NotImplementedError ( 'subclasses of Serializer must provide a start_object() method' )	raise a NotImplementedError with an argument string 'subclasses of Serializer must provide a start_object() method'.
def end_object ( self , obj ) :	define the method end_object with argument self and obj.
pass	do nothing.
def handle_field ( self , obj , field ) :	define the method handle_field with argument self, obj and field.
raise NotImplementedError ( 'subclasses of Serializer must provide an handle_field() method' )	raise a NotImplementedError with an argument string
def handle_fk_field ( self , obj , field ) :	define the method handle_fk_field with argument self, obj and field.
raise NotImplementedError ( 'subclasses of Serializer must provide an handle_fk_field() method' )	raise a NotImplementedError with an argument string
def handle_m2m_field ( self , obj , field ) :	define the method handle_m2m_field with argument self, obj and field.
raise NotImplementedError ( 'subclasses of Serializer must provide an handle_m2m_field() method' )	raise a NotImplementedError with an argument string 'subclasses of Serializer must provide an handle_m2m_field() method'.
def getvalue ( self ) :	define the method getvalue with an argument self.
if callable ( getattr ( self . stream , 'getvalue' , None ) ) :	get 'getvalue' attribute of the self.stream object, if it exists and is callable,
return self . stream . getvalue ( )	evaluate self.stream.getvalue method, return the result.
class Deserializer ( six . Iterator ) :	derive the class Deserializer from the six.Iterator base class.
def __init__ ( self , stream_or_string , ** options ) :	define the method __init__, with 3 arguments: self, stream_or_string and unpacked dictionary options.
self . options = options	substitute options for self.options.
if isinstance ( stream_or_string , six . string_types ) :	if stream_or_string is an instance of six.string_types type.
self . stream = six . StringIO ( stream_or_string )	call the function six.StringIO with an argument stream_or_string, substitute the result for self.stream.
else :	if not,
self . stream = stream_or_string	substitute stream_or_string for self.stream.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
return self	return self.
def __next__ ( self ) :	define the method __next__ with an argument self.
raise NotImplementedError ( 'subclasses of Deserializer must provide a __next__() method' )	raise a NotImplementedError with an argument string 'subclasses of Deserializer must provide a __next__() method'.
class DeserializedObject ( object ) :	derive the class DeserializedObject from the object base class.
def __init__ ( self , obj , m2m_data = None ) :	define the method __init__, with 3 arguments: self, m2m and data set None.
self . object = obj	substitute obj for self.object.
self . m2m_data = m2m_data	substitute m2m_data for self.m2m_data.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return '<DeserializedObject: %s.%s(pk=%s)>' % (  self . object . _meta . app_label , self . object . _meta . object_name , self . object . pk )	return a string '<DeserializedObject: %s.%s(pk=%s)>', where '%s' are replaced with self.object._meta.app_label,
def save ( self , save_m2m = True , using = None ) :	self.object._meta.object_name and self.object.pk, respectively.   define the method save, with 3 arguments: self, save_m2m set to boolean True and using set to boolean True.
models . Model . save_base ( self . object , using = using , raw = True )	call the models.Model.save_base method with arguments self.object, using as using and raw set to boolean True.
if self . m2m_data and save_m2m :	if self.m2m.data and save_m2m are true,
for accessor_name , object_list in self . m2m_data . items ( ) :	for every accessor_name and object_list is return value of the method self.m2m_data.items.
setattr ( self . object , accessor_name , object_list )	set accessor_name of the self.object to object_list.
self . m2m_data = None	self.m2m_data is None.
def build_instance ( Model , data , db ) :	define the function build_instance with 3 arguments: Model, data and db.
obj = Model ( ** data )	obj is an instance of Model class, created with an unpacked dictionary data as argument.
if ( obj . pk is None and hasattr ( Model , 'natural_key' ) and  hasattr ( Model . _default_manager , 'get_by_natural_key' ) ) :	if obj.pk is None, and Model has an 'natural_key' attribute, and Model._default_manager has and 'get_by_natural_key',
natural_key = obj . natural_key ( )	call the method obj.natural_key, substitute the result for natural_key.
try :	try,
obj . pk = Model . _default_manager . db_manager ( db ) . get_by_natural_key ( * natural_key ) . pk	call the method Model._default_manager.db_manager with an argument db, on the result call the get_by_natural_key with,
except Model . DoesNotExist :	an unpacked list natural_key as argument, substitute the pk filed of the resulting object for obj.pk.   if Model.DoesNotExist exception is caught,
pass	do nothing.
return obj	return obj.
from __future__ import absolute_import	from __future__ import absolute_import into default name space.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import datetime	import module datetime.
import decimal	import module decimal.
import json	import module json.
import sys	import module sys.
from django . core . serializers . base import DeserializationError	from django.core.serializers.base import DeserializationError into default name space.
from django . core . serializers . python import Serializer as PythonSerializer	from django.core.serializers.python import Serializer as PythonSerializer into default name space.
from django . core . serializers . python import Deserializer as PythonDeserializer	from django.core.serializers.python import Deserializer as PythonDeserializer into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . timezone import is_aware	from django.utils.timezone import is_aware into default name space.
class Serializer ( PythonSerializer ) :	define the class Serializer from the PythonSerializer base class.
internal_use_only = False	internal_use_only is boolean False.
def start_serialization ( self ) :	define the method start_serialization with an argument self.
if json . __version__ . split ( '.' ) >= [ '2' , '1' , '3' ] :	call the method json.__version__.split with an argument '.', if the result is respectively greater than list containing strings '2', '1' and '3',
self . options . update ( { 'use_decimal' : False } )	call the method self.options.update with dictionary as an argument, containing 1 element: boolean False for 'use_decimal'.
self . _current = None	self._current is None.
self . json_kwargs = self . options . copy ( )	call the method self.options.copy, substitute the result for self.json_kwargs.
self . json_kwargs . pop ( 'stream' , None )	remove the entry under the 'stream' key of the self.json_kwargs dictionary.
self . json_kwargs . pop ( 'fields' , None )	remove the entry under the 'fields' key of the self.json_kwargs dictionary.
if self . options . get ( 'indent' ) :	get the value under the 'indent' key of self.options dictionary, if it is true,
self . json_kwargs [ 'separators' ] = ( ',' , ': ' )	substitute a tuple with 2 elements: characters ',' and ': ' for value under the 'separators' key of the self.json_kwargs dictionary.
self . stream . write ( '[' )	write a '[' to the self.stream file stream.
def end_serialization ( self ) :	define the method end_serialization with an argument self.
if self . options . get ( 'indent' ) :	if value under the 'indent' key of the self.options dictionary is true,
\self . stream . write ( '\\n' )\	write a new line to the self.stream file stream.
self . stream . write ( ']' )	write ']' to the self.stream file stream.
if self . options . get ( 'indent' ) :	if value under the 'indent' key of the self.options dictionary is true,
\self . stream . write ( '\\n' )\	write a new line to the self.stream file stream.
def end_object ( self , obj ) :	define the method end_object with arguments self and obj.
indent = self . options . get ( 'indent' )	get the value under the 'indent' key of the self.options dictionary, substitute it for indent.
if not self . first :	if self.first is false,
self . stream . write ( ',' )	write ',' to the self.stream file stream.
if not indent :	if indent is false,
self . stream . write ( ' ' )	write a white space to the self.stream file stream.
if indent :	if indent is true,
\self . stream . write ( '\\n' )\	write new line to the self.stream file stream.
json . dump ( self . get_dump_object ( obj ) , self . stream ,  cls = DjangoJSONEncoder , ** self . json_kwargs )	call the json.dump function with 4 arguments: return value of the method self.get_dump_object called with an argument obj,  self.stream, cls set to DjangoJSONEncoder and unpacked dictionary self.json_kwargs.
self . _current = None	self._current is None.
def getvalue ( self ) :	define the method getvalue with an argument self.
return super ( PythonSerializer , self ) . getvalue ( )	call the getvalue method from the base class of the class PythonSerializer, return the result.
def Deserializer ( stream_or_string , ** options ) :	define the function Deserializer with arguments stream_or_string and unpacked dictionary options.
if not isinstance ( stream_or_string , ( bytes , six . string_types ) ) :	if stream_or_string is not an instance of bytes or six.string_types,
stream_or_string = stream_or_string . read ( )	call the stream_or_string.read function, substitute the result for stream_or_string.
if isinstance ( stream_or_string , bytes ) :	if stream_or_string is instance of bytes type,
stream_or_string = stream_or_string . decode ( 'utf-8' )	call the method stream_or_string.decode with an argument string 'utf-8', substitute the result for stream_or_string.
try :	try,
objects = json . loads ( stream_or_string )	call the function json.loads with an argument stream_or_string, substitute the result for objects.
for obj in PythonDeserializer ( objects , ** options ) :	for every obj in PythonDeserializer called with arguments objects and unpacked dictionary options,
yield obj	yield obj as generator return value,
except GeneratorExit :	if GeneratorExit exception is caught,
raise	raise an exception,
except Exception as e :	if Exception, renamed to e, exception is caught,
six . reraise ( DeserializationError , DeserializationError ( e ) , sys . exc_info ( ) [ 2 ] )	call the six.reraise function with 3 arguments: DeserializationError, DeserializationError called with an argument e,
class DjangoJSONEncoder ( json . JSONEncoder ) :	third element of the return value of the function sys.exc_info.   define the class DjangoJSONEncoder from the json.JSONEncoder base class.
def default ( self , o ) :	define the method defalt with arguments self and o.
if isinstance ( o , datetime . datetime ) :	if o is an instance of datetime.datetime object.
r = o . isoformat ( )	call the method o.isoformat substitute the result for r.
if o . microsecond :	if o.microsecond is true,
r = r [ : 23 ] + r [ 26 : ]	remove 3 elements from r starting at the index 23.
if r . endswith ( '+00:00' ) :	if r ends with string '+00:00',
r = r [ : - 6 ] + 'Z'	cut the last 6 elemetns from r, append character 'Z' to it, substitute the result for r.
return r	return r.
elif isinstance ( o , datetime . date ) :	otherwise if o is an instance of datetime.date object,
return o . isoformat ( )	call the method o.isoformat, return the result.
elif isinstance ( o , datetime . time ) :	otherwise if o is an instance of datetime.time object,
if is_aware ( o ) :	call the function is_aware with an argument o, if it evaluates to true,
raise ValueError ( 'JSON can't represent timezone-aware times.' )	raise a ValueError exception with an argument string 'JSON can't represent timezone-aware times.'.
r = o . isoformat ( )	call the method o.isoformat substitute the result for r.
if o . microsecond :	if o.microsecond is true,
r = r [ : 12 ]	substitute first 12 elements of r for r.
return r	return r.
elif isinstance ( o , decimal . Decimal ) :	otherwise if o is an instance of decimal.Decimal object,
return str ( o )	convert o to an string, return it.
else :	if not,
return super ( DjangoJSONEncoder , self ) . default ( o )	call the method default with an argument o from the base class of the class DjangoJSONEncoder, return the result.
DateTimeAwareJSONEncoder = DjangoJSONEncoder	substitute DjangoJSONEncoder for DateTimeAwareJSONEncoder.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . apps import apps	from django.apps import apps into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . serializers import base	from django.core.serializers import base into default name space.
from django . db import models , DEFAULT_DB_ALIAS	from django.db import models and DEFAULT_DB_ALIAS into default name space.
from django . utils . encoding import smart_text , is_protected_type	from django.utils.encoding import smart_text and is_protected_type into default name space.
from django . utils import six	from django.utils import six into default name space.
class Serializer ( base . Serializer ) :	derive Serializer from the base.Serializer base class.
internal_use_only = True	internal_use_only is boolean True.
def start_serialization ( self ) :	define the method start_serialization with an argument self.
self . _current = None	self._current is None.
self . objects = [ ]	self.objects is an empty list.
def end_serialization ( self ) :	define the method end_serialization with an argument self.
pass	do nothing.
def start_object ( self , obj ) :	define the method start_object with arguments self and obj.
self . _current = { }	self.current is an empty dictionary.
def end_object ( self , obj ) :	define the method end_object with arguments self and obj.
self . objects . append ( self . get_dump_object ( obj ) )	call the self.get_dum_object method with an argument obj, use the result as an argument for the self.objects.append method.
self . _current = None	self._current is None.
def get_dump_object ( self , obj ) :	define the method get_dump_object with arguments self and obj.
data = {  'model' : smart_text ( obj . _meta ) ,  'fields' : self . _current ,  }	data is an dictionary with 2 initial entries: return value of the smart_text function with the argument obj._meta for 'model',
if not self . use_natural_primary_keys or not hasattr ( obj , 'natural_key' ) :	and self._current for 'fields'.   if self.use_natural_primary_keys is false or obj doesnt have a 'natural_key' attribute.
data [ 'pk' ] = smart_text ( obj . _get_pk_val ( ) , strings_only = True )	call the smart_text function with 2 arguments: return value of the obj._get_pk_val function and string_only set to boolean True,
return data	substitute it for value under the 'pk' key of data dictionary.   return data.
def handle_field ( self , obj , field ) :	define handle_field method with self, obj and field arguments.
value = field . _get_val_from_obj ( obj )	call the method field._get_val_from_obj with obj argument, substitute the result for value.
if is_protected_type ( value ) :	call the function is_protected_type with an argument value, if it evaluates to true,
self . _current [ field . name ] = value	substitute value for field.name key of self._current dictionary.
else :	if not,
self . _current [ field . name ] = field . value_to_string ( obj )	call the function field.value_to_string with an argument obj, substitute the result for value under the field.name key of self._current dictionary.
def handle_fk_field ( self , obj , field ) :	define the method handle_fk_field with self, obj and field arguments.
if self . use_natural_foreign_keys and hasattr ( field . rel . to , 'natural_key' ) :	if self.use_natural_foreign_keys is true and field.rel.to has an 'natural_key' attribute.
related = getattr ( obj , field . name )	get field.name from the obj, substitute it for related.
if related :	if related is true,
value = related . natural_key ( )	call the method related.natural_key, substitute the result for value.
else :	if not,
value = None	value is None.
else :	if not,
value = getattr ( obj , field . get_attname ( ) )	get return value of the field.get_attname function attribute of the obj object, substitute it for value.
self . _current [ field . name ] = value	substitute value for value under the field.name key of the self._current dictionary.
def handle_m2m_field ( self , obj , field ) :	define the method handle_m2m_field with self, obj and field arguments.
if field . rel . through . _meta . auto_created :	if field.rel.through._meta.auto_created is true,
if self . use_natural_foreign_keys and hasattr ( field . rel . to , 'natural_key' ) :	if self.use_natural_foreign_keys is true and field.rel.to has an 'natural_key' attribute,
m2m_value = lambda value : value . natural_key ( )	m2m_value is an lambda function with value as an argument, return value is the result of the method value.natural_key.
else :	if not,
m2m_value = lambda value : smart_text ( value . _get_pk_val ( ) , strings_only = True )	m2m_value is a lambda function with an argument value, return value is the result of the function smart_text called with arguments:
self . _current [ field . name ] = [ m2m_value ( related )  for related in getattr ( obj , field . name ) . iterator ( ) ]	return value of the value._get_pk_val method and strings_only set to boolean True.   call the function m2m_value with the argument related, for every related in itterator object generated from the attribute field.name,
def getvalue ( self ) :	of the obj object, append the results in a list, substitute it for value under the field.name key of the self._current dictionary.   define the method getvalue with an argument self.
return self . objects	return self.objects.
def Deserializer ( object_list , ** options ) :	define the function Deserializer with arguments object_list and unpacked dictionary options.
db = options . pop ( 'using' , DEFAULT_DB_ALIAS )	remove the value under the 'using' key from the options dictionary, assign it to the db, if the entry doesnt exists,
ignore = options . pop ( 'ignorenonexistent' , False )	substitute DEFAULT_DB_ALIAS for db.   remove the value under the 'ignorenonexistent' key from the options dictionary, assign it to the ignore, if the entry doesnt exists,
for d in object_list :	substitute boolean False for ignore.   for every d in object_list,
try :	try,
Model = _get_model ( d [ 'model' ] )	call the function _get_model with an argument value under the 'model' key of the d dictionary, substitute the result for Model.
except base . DeserializationError :	if base.DeserializationError exception is caught,
if ignore :	if ignore is true,
continue	skip this loop iteration,
else :	if not,
raise	raise an exception.
data = { }	data is an empty dictionary,
if 'pk' in d :	if 'pk' is contained in d,
data [ Model . _meta . pk . attname ] = Model . _meta . pk . to_python ( d . get ( 'pk' , None ) )	call the method Model._meta.pk.to_python with one argument: value under the 'pk' key of dictionary d, or None if previous doesnt exists,
m2m_data = { }	substitute the result for the value under the Model._meta.pk.attname key of data dictionary.   m2m_data is an empty dictionary.
model_fields = Model . _meta . get_all_field_names ( )	call the method Model._meta.get_all_field_names, substitute the result for model_fields.
for ( field_name , field_value ) in six . iteritems ( d [ 'fields' ] ) :	for every field_name and field_value in return value of the function six.iteritems called with value under the 'fields' key of dictionary d,
if ignore and field_name not in model_fields :	if ignore is true and field_name is not contained in model_fields,
continue	skip this loop iteration,
if isinstance ( field_value , str ) :	if field_value is an instance of the str type,
field_value = smart_text ( field_value , options . get ( 'encoding' , settings . DEFAULT_CHARSET ) , strings_only = True )	call the smart_text function with 3 arguments: field_value, value under the 'encoding' key of the options dictionary or,
field = Model . _meta . get_field ( field_name )	settings.DEFAULT_CHARSET if the key doesnt exists and strings_only set to boolean True.   call the Model._meta.get_field method with an argument field_name, substitute the result for field.
if field . rel and isinstance ( field . rel , models . ManyToManyRel ) :	if field.rel is true, and field.rel is an instance of models.ManyToManyRel,
if hasattr ( field . rel . to . _default_manager , 'get_by_natural_key' ) :	if field.rel.to._default_manager has an attribute 'get_by_natural_key',
def m2m_convert ( value ) :	define the function m2m_convert with an argument value.
    if hasattr ( value , '__iter__' ) and not isinstance ( value , six . text_type ) :	if value has an attribute '__iter__' and value is not an instance of six.text_type,
        return field . rel . to . _default_manager . db_manager ( db ) . get_by_natural_key ( * value ) . pk	call the method field.rel.to._default_manager.db_manager with an argument db on the return value call the method  get_by_natural_key,
else :	with unpacked list value as an argument, return the pk field of the result.   if not,
        return smart_text ( field . rel . to . _meta . pk . to_python ( value ) )	call the method field.rel.to._meta.pk.to_python with an argument value, use the result as an argument for the call to the,
else :	smart_text function, return the result.   if not,
m2m_convert = lambda v : smart_text ( field . rel . to . _meta . pk . to_python ( v ) )	m2m_convert is a lambda function with an argument v, return value is the result of the function smart_text called with an argument:
m2m_data [ field . name ] = [ m2m_convert ( pk ) for pk in field_value ]	return value of the method field.rel.to._meta.pk.to_python called with an argument v.   call the m2m_convert function with pk as argument, for every pk in field_value, substitute the value under the field.name key of the m2m_data dictionary.
elif field . rel and isinstance ( field . rel , models . ManyToOneRel ) :	otherwise if field.rel is true and field.rel is an instance of the models.ManyToOneRel object,
if field_value is not None :	if field_value is not None,
if hasattr ( field . rel . to . _default_manager , 'get_by_natural_key' ) :	if field.rel.to._default_manager has an 'get_by_natural_key' attribute,
    if hasattr ( field_value , '__iter__' ) and not isinstance ( field_value , six . text_type ) :	if field_value has an attribute '__iter__' and is not an instance of six.text_type object,
        obj = field . rel . to . _default_manager . db_manager ( db ) . get_by_natural_key ( * field_value )	call the method field.rel.to._default_manager.db_manager with db as argument, call the get_by_natural_key method on the result with,
value = getattr ( obj , field . rel . field_name )	unpacked list field_value as an argument, substitute the result for obj.   get field.rel.field_name attribute of the object obj, substitute it for value.
if field . rel . to . _meta . pk . rel :	if field.rel.to._meta.pk.rel is true,
            value = value . pk	substitute value.pk for value.
else :	if not,
        value = field . rel . to . _meta . get_field ( field . rel . field_name ) . to_python ( field_value )	all the method field.rel.to._meta.get_field with field.rel.field_name as argument, call the to_python method on the result with,
data [ field . attname ] = value	unpacked list field_value as an argument, substitute the result for value.   substitute value for value under the field.attname key of the data dictionary.
else :	if not,
    data [ field . attname ] = field . rel . to . _meta . get_field ( field . rel . field_name ) . to_python ( field_value )	all the method field.rel.to._meta.get_field with field.rel.field_name as argument, call the to_python method on the result with,
else :	unpacked list field_value as an argument, substitute the result for value of under the field.attname key of the data dictionary.   if not,
data [ field . attname ] = None	value under the field.attname key of the data dictionary is None.
else :	if not,
data [ field . name ] = field . to_python ( field_value )	call the field.to_python method with field_value, substitute the result for field.name key of the data dictionary.
obj = base . build_instance ( Model , data , db )	call the method base.build_instance with arguments Model, data and db, substitute the result for obj.
yield base . DeserializedObject ( obj , m2m_data )	call the function base.DeserializedObject with obj and m2m_data as arguments, yield the result as the generator return value.
def _get_model ( model_identifier ) :	define the function _get_model with an argument model_identifier.
try :	try,
return apps . get_model ( model_identifier )	call the method apps.get_model with an argument model_identifier.
except ( LookupError , TypeError ) :	if LookupError or TypeError exceptions are caught,
import decimal	import module decimal.
import yaml	import module yaml.
import sys	import module sys.
from io import StringIO	from io import StringIO into default name space.
from django . db import models	from django.db import models into default name space.
from django . core . serializers . base import DeserializationError	from django.core.serializers.base import DeserializationError into default name space.
from django . core . serializers . python import Serializer as PythonSerializer	from django.core.serializers.python import Serializer as PythonSerializer into default name space.
from django . core . serializers . python import Deserializer as PythonDeserializer	from django.core.serializers.python import Deserializer as PythonDeserializer into default name space.
from django . utils import six	from django.utils import six into default name space.
try :	try,
from yaml import CSafeLoader as SafeLoader	from yaml import CSafeLoader as SafeLoader into default name space.
from yaml import CSafeDumper as SafeDumper	yaml import CSafeDumper as SafeDumper into default name space.
except ImportError :	if ImportError exception is caught,
from yaml import SafeLoader , SafeDumper	from yaml import SafeLoader, SafeDumper into default name space.
class DjangoSafeDumper ( SafeDumper ) :	derive the class DjangoSafeDumper from the SafeDumper base class.
def represent_decimal ( self , data ) :	define the method represent_decimal with arguments self and data.
return self . represent_scalar ( 'tag:yaml.org,2002:str' , str ( data ) )	call the method self.represent_scalar with 2 arguments: string 'tag:yaml.org,2002:str' and data converted into a string, return the result.
DjangoSafeDumper . add_representer ( decimal . Decimal , DjangoSafeDumper . represent_decimal )	call the method DjangoSafeDumper.add_representer with arguments decimal.Decimal and DjangoSafeDumper.represent_decimal.
class Serializer ( PythonSerializer ) :	derive the class Serializer from the PythonSerializer base class.
internal_use_only = False	internal_use_only is a boolean False.
def handle_field ( self , obj , field ) :	define the method handle_field with arguments self, obj and field.
if isinstance ( field , models . TimeField ) and getattr ( obj , field . name ) is not None :	if field is an instance of models.TimeField and filed.name attribute of obj is not None,
self . _current [ field . name ] = str ( getattr ( obj , field . name ) )	get field.name attribute of obj, convert it to a string, substitute it for the value under the filed.name key of self._current dictionary.
else :	if not,
super ( Serializer , self ) . handle_field ( obj , field )	call the handle_filed method of the base class of the Serializer class, with arguments obj and field.
def end_serialization ( self ) :	define the method end_serialization with an argument self.
yaml . dump ( self . objects , self . stream , Dumper = DjangoSafeDumper , ** self . options )	call the function yaml.dump with 4 arguments: self.objects, self.stream, Dumper=DjangoSafeDumper and unpacked dictionary self.options.
def getvalue ( self ) :	define the method getvalue with an argument self.
return super ( PythonSerializer , self ) . getvalue ( )	call the getvalue method of the base class of the PythonSerializer class, return the result.
def Deserializer ( stream_or_string , ** options ) :	define the function Deserializer with 2 arguments: stream_or_string and unpacked dictionary options.
if isinstance ( stream_or_string , bytes ) :	if stream_or_string is an instance of bytes,
stream_or_string = stream_or_string . decode ( 'utf-8' )	call the method stream_or_string.decode with string 'utf-8' as argument, substitute the result for stream_or_string.
if isinstance ( stream_or_string , six . string_types ) :	if stream_or_string is an instance of the six.string_types,
stream = StringIO ( stream_or_string )	call the function StringIO with an argument stream_or_string, substitute the result for stream.
else :	if not,
stream = stream_or_string	substitute stream_or_string for stream.
try :	try,
for obj in PythonDeserializer ( yaml . load ( stream , Loader = SafeLoader ) , ** options ) :	for every obj in return value of the PythonDeserializer created with 2 arguments: return value of the function yaml.load,
yield obj	with 2 arguments: stream and Loader set to SafeLoader, and unpacked dictionary options,   yield one element of the itterable obj.
except GeneratorExit :	if exception GeneratorExit is caught,
raise	raise an exception.
except Exception as e :	if Exception, renamed to e, exception is caught,
six . reraise ( DeserializationError , DeserializationError ( e ) , sys . exc_info ( ) [ 2 ] )	call the function six.reraise with 3 arguments: DeserializationError, return value of the DeserializationError called with an argument e,
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . apps import apps	from django.apps import apps into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . serializers import base	from django.core.serializers import base into default name space.
from django . db import models , DEFAULT_DB_ALIAS	from django.db import models and DEFAULT_DB_ALIAS into default name space.
from django . utils . xmlutils import SimplerXMLGenerator	from django.utils.xmlutils import SimplerXMLGenerator into default name space.
from django . utils . encoding import smart_text	from django.utils.encoding import smart_text into default name space.
from xml . dom import pulldom	from xml.dom import pulldom into default name space.
from xml . sax import handler	from xml.sax import handler into default name space.
from xml . sax . expatreader import ExpatParser as _ExpatParser	from xml.sax.expatreader import ExpatParser as _ExpatParser into default name space.
class Serializer ( base . Serializer ) :	derive the class Serializer from the base.Serializer base class.
def indent ( self , level ) :	define the method indent with argument self and level.
if self . options . get ( 'indent' , None ) is not None :	if value under the 'indend' key of the options dictionary exists and is not None,
\self . xml . ignorableWhitespace ( '\\n' + ' ' * self . options . get ( 'indent' , None ) * level )\	get the value under the 'indent' key of the options dictionary, multiply it with level, create a string containing number of  whitespaces equal to the previous result, append it to the string containing newline character, use the result as the argument for  the call to the self.xml.ignorableWhitespace method.
def start_serialization ( self ) :	define the method start_serialization with an argument self.
self . xml = SimplerXMLGenerator ( self . stream , self . options . get ( 'encoding' , settings . DEFAULT_CHARSET ) )	self.xml is a instance of SimplerXMLGenerator class created with 2 arguments: self.stream and value under the 'encoding' key of the
self . xml . startDocument ( )	options dictionary, if the key doesnt exists use settings.DEFAULT_CHARSET instead.   call the self.xml.startDocument method.
self . xml . startElement ( 'django-objects' , { 'version' : '1.0' } )	call the method self.xml.startElement with 2 arguments, string 'django-objects' and a dictionary containing 1 element: '1.0' for 'version'.
def end_serialization ( self ) :	define the method end_serialization with an argument self.
self . indent ( 0 )	call the self.indent method with integer 0 as an argument.
self . xml . endElement ( 'django-objects' )	call the method self.xml.endElement with an argument string 'django-objects'.
self . xml . endDocument ( )	call the self.xml.endDocument method.
def start_object ( self , obj ) :	define the method start_object with arguments self and obj.
if not hasattr ( obj , '_meta' ) :	if '_meta' is not an attribute of obj,
raise base . SerializationError ( 'Non-model object (%s) encountered during serialization' % type ( obj ) )	raise an base.SerializationError exception with argument string 'Non-model object (%s) encountered during serialization',
self . indent ( 1 )	replace '%s' with type of the obj object.   call the method self.indent with argument integer 1.
attrs = { 'model' : smart_text ( obj . _meta ) }	attrs is a dictionary containing 1 entry: return value of the smart_text function with argument obj._meta for 'model'.
if not self . use_natural_primary_keys or not hasattr ( obj , 'natural_key' ) :	if self.use_natural_primary_keys is false and obj doesnt have 'natural_key' argument.
obj_pk = obj . _get_pk_val ( )	substitute return value of the method obj._get_pk_val for obj_pk.
if obj_pk is not None :	if obj_pk is not None,
attrs [ 'pk' ] = smart_text ( obj_pk )	substitute the return value of the smart_text function with an argument obj_pk for the value under the 'pk' key of the attrs dictionary.
self . xml . startElement ( 'object' , attrs )	call the method self.xml.startElement with arguments string 'object' and attrs.
def end_object ( self , obj ) :	define the method end_object with arguments self and obj.
self . indent ( 1 )	call the method self.indent with argument integer 1.
self . xml . endElement ( 'object' )	call the method self.xml.endElement with an argument string 'object'.
def handle_field ( self , obj , field ) :	define the method handle_field with arguments self, obj and field.
self . indent ( 2 )	call the method self.indent with argument integer 2.
self . xml . startElement ( 'field' , {  'name' : field . name ,  'type' : field . get_internal_type ( )  } )	call the method self.xml.startElement with 2 arguments: string 'field' and a dictionary containing 2 entries: field.name for 'name',
if getattr ( obj , field . name ) is not None :	and return value of the field.get_internal_type method for 'type'.   if field.name attribute of obj is not None,
self . xml . characters ( field . value_to_string ( obj ) )	call the method field.value_to_string with an argument obj, use the result as an argument for the call the method self.xml.characters.
else :	if not,
self . xml . addQuickElement ( 'None' )	call the method self.xml.addQuickElement with an argument string 'None'.
self . xml . endElement ( 'field' )	call the method self.xml.endElement with an argument string 'field'
def handle_fk_field ( self , obj , field ) :	define the method handle_fk_field with arguments self, obj and field.
self . _start_relational_field ( field )	call the method self._start_relational_field with an argument field.
related_att = getattr ( obj , field . get_attname ( ) )	evaluate the field.get_attname, use the result as the name of the obj attribute to get, substitute it for related_att.
if related_att is not None :	if related_att is not None,
if self . use_natural_foreign_keys and hasattr ( field . rel . to , 'natural_key' ) :	if self.use_natural_foreign_keys is true and field.rel.to has an attribute 'natural_key',
related = getattr ( obj , field . name )	get field.name attribute of the obj, substitute it for related.
related = related . natural_key ( )	call the method related.natural_key, substitute the result for related.
for key_value in related :	for every key_value in related,
self . xml . startElement ( 'natural' , { } )	call the method self.xml.startElement with arguments string 'natural' and an empty dictionary.
self . xml . characters ( smart_text ( key_value ) )	call the function smart_text with argument key_value, use the result as an argument for the call to the self.xml.characters method.
self . xml . endElement ( 'natural' )	call the method self.xml.endElement with an argument string 'natural'
else :	if not,
self . xml . characters ( smart_text ( related_att ) )	call the function smart_text with argument related_att, use the result as an argument for the call to the self.xml.characters method.
else :	if not,
self . xml . addQuickElement ( 'None' )	call the method self.xml.addQuickElement with an argument string 'None'.
self . xml . endElement ( 'field' )	call the method self.xml.endElement with an argument string 'field'.
def handle_m2m_field ( self , obj , field ) :	define the method handle_m2m_field with arguments self, obj and field.
if field . rel . through . _meta . auto_created :	if field.rel.through._meta.auto_created is true,
self . _start_relational_field ( field )	call the method self._start_relational_field with the argument field.
if self . use_natural_foreign_keys and hasattr ( field . rel . to , 'natural_key' ) :	if self.use_natural_foreign_keys is true and field.rel.to has an attribute 'natural_key',
def handle_m2m ( value ) :	define the function handle_m2m with an argument value,
natural = value . natural_key ( )	call the value.natural_key method, substitute the result for natural.
self . xml . startElement ( 'object' , { } )	call the method self.xml.startElement with argument string 'object' and an empty dictionary.
for key_value in natural :	for every key_value in natural,
    self . xml . startElement ( 'natural' , { } )	call the method self.xml.startElement with argument string 'natural' and an empty dictionary.
self . xml . characters ( smart_text ( key_value ) )	call the function smart_text with argument key_value, use the result as an argument for the call to the self.xml.characters method.
self . xml . endElement ( 'natural' )	call the method self.xml.startElement with an argument string 'natural'.
self . xml . endElement ( 'object' )	call the method self.xml.startElement with an argument string 'object'.
else :	if not,
def handle_m2m ( value ) :	define the function handle_m2m with an argument value,
self . xml . addQuickElement ( 'object' , attrs = {  'pk' : smart_text ( value . _get_pk_val ( ) )  } )	call the self.xml.addQuickElement method with 2 arguments: string 'object' and attr dictionary containing 1 entry:
for relobj in getattr ( obj , field . name ) . iterator ( ) :	return value of the function smart_text with return value of the method value._get_pk_val as an argument for 'pk'.   for every relobj in iterator generated from the field.name attribute of the obj object.
handle_m2m ( relobj )	call the function handle_m2m with an argument relobj.
self . xml . endElement ( 'field' )	call the method self.xml.endElement with an argument string 'field'.
def _start_relational_field ( self , field ) :	define the method _start_relational_field with arguments self and field.
self . indent ( 2 )	call the method self.indent with argument integer 2.
self . xml . startElement ( 'field' , {  'name' : field . name ,  'rel' : field . rel . __class__ . __name__ ,  'to' : smart_text ( field . rel . to . _meta ) ,  } )	call the method self.xml.startElement with 2 arguments: string 'field' and dictionary containing 3 entries: field.name for 'name',
class Deserializer ( base . Deserializer ) :	field.rel.__class__.__name__ for 'rel' and return value of the function smart_text with an argument field.rel.to._meta for 'to'.   derive the class Deserializer from the base.Deserializer base class.
def __init__ ( self , stream_or_string , ** options ) :	define the method __init__ with 3 arguments: self, stream_or_string and unpacked dictionary options.
super ( Deserializer , self ) . __init__ ( stream_or_string , ** options )	call the method __init__ from the base class of the Deserializer class with arguments stream_or_string and unpacked dictionary options.
self . event_stream = pulldom . parse ( self . stream , self . _make_parser ( ) )	call the method pulldom.parse with arguments: self.stream and return value of the method self._make_parser,
self . db = options . pop ( 'using' , DEFAULT_DB_ALIAS )	substitute the result for self.event_stream.   remove the 'using' key from the options dictionary, substitute the return value for self.db, if the key doesnt exists substitute
self . ignore = options . pop ( 'ignorenonexistent' , False )	DEFAULT_DB_ALIAS for self.db.   remove the 'ignorenonexistent' key from the options dictionary, substitute the return value for self.db,
def _make_parser ( self ) :	if the key doesnt exists substitute boolean False for self.ignore.   define the method _make_parser with an argument self.
return DefusedExpatParser ( )	return the instance of DefusedExpatParser class.
def __next__ ( self ) :	define the method __next__ with an argument self.
for event , node in self . event_stream :	for every event and node in self.event_stream,
if event == 'START_ELEMENT' and node . nodeName == 'object' :	if event equals a string 'START_ELEMENT' and node.nodeName equals a string 'object',
self . event_stream . expandNode ( node )	call the method self.event_stream.expandNode with an argument node.
return self . _handle_object ( node )	call the method self._handle_object with an argument node, return the result.
raise StopIteration	raise an StopIteration exception.
def _handle_object ( self , node ) :	define the method _handle_object with arguments self and node.
Model = self . _get_model_from_node ( node , 'model' )	call the method self._get_model_from_node with arguments node and string 'model'.
data = { }	data is an empty dictionary.
if node . hasAttribute ( 'pk' ) :	call the method node.hasAttribute with string 'pk' as an argument, if it evaluates to true,
data [ Model . _meta . pk . attname ] = Model . _meta . pk . to_python (  node . getAttribute ( 'pk' ) )	call the method node.getAttribute with an argument string 'pk', use the result as the argument for the call to the method,  Model._meta.pk.to_python with, substitute the result for value under the Model._meta.pk.attname key of the data dictionary.
m2m_data = { }	m2m_data is an empty dictionary.
model_fields = Model . _meta . get_all_field_names ( )	call the method Model._meta.get_all_field_names, substitute the result for model_fields.
for field_node in node . getElementsByTagName ( 'field' ) :	for every field_node in return value of the method node.getElementsByTagName with an argument string 'field'.
field_name = field_node . getAttribute ( 'name' )	call the method field_node.getAttribute with an argument string 'name', substitute the result for field_name.
if not field_name :	if field_name is false,
raise base . DeserializationError ( '<field> node is missing the 'name' attribute' )	raise an base.DeserializationError exception with string '<field> node is missing the 'name' attribute' as argument.
if self . ignore and field_name not in model_fields :	if self.ignore is true and field_name is not contained in model_fields,
continue	skip this loop iteration.
field = Model . _meta . get_field ( field_name )	call the method Model._meta.get_field with an argument field_name, substitute it for field.
if field . rel and isinstance ( field . rel , models . ManyToManyRel ) :	if field.rel is true and field.rel is an instance of models.ManyToManyRel,
m2m_data [ field . name ] = self . _handle_m2m_field_node ( field_node , field )	call the method self._handle_m2m_field_node with an argument field_node and field, substitute the result for value under the field.name key of m2m_data dictionary.
elif field . rel and isinstance ( field . rel , models . ManyToOneRel ) :	otherwise, if field.rel is true and field.rel is an instance of models.ManyToOneRel,
data [ field . attname ] = self . _handle_fk_field_node ( field_node , field )	call the method self._handle_fk_field_node with field_node and field as arguments, substitute the result for the value under the
else :	field.attname of the data dictionary.   if not,
if field_node . getElementsByTagName ( 'None' ) :	call the method field_node.getElementsByTagName with an argument string 'None', if it evaluates to true,
value = None	value is None.
else :	if not,
value = field . to_python ( getInnerText ( field_node ) . strip ( ) )	call the function getInnerText with argument field_node, on the result call the method strip, use the result as an argument for the
data [ field . name ] = value	call to the field.to_python method, substitute the result for value.   substitute value for value under the field.name key of the data dictionary.
obj = base . build_instance ( Model , data , self . db )	call the method base.build_instance with arguments Model, data and self.db, substitute the result for obj.
return base . DeserializedObject ( obj , m2m_data )	call the method base.DeserializedObject with arguments obj and m2m_data, return the result.
def _handle_fk_field_node ( self , node , field ) :	define the method _handle_fk_field_node with arguments self, node and field.
if node . getElementsByTagName ( 'None' ) :	call the method node.getElementsByTagName with an argument string 'None', if it evaluates to true,
return None	return None.
else :	if not,
if hasattr ( field . rel . to . _default_manager , 'get_by_natural_key' ) :	if field.rel.to._default_manager has an atttribute 'get_by_natural_key',
keys = node . getElementsByTagName ( 'natural' )	call the method node.getElementsByTagName with the argument string 'natural', substitute the result for keys.
if keys :	if keys is true,
  field_value = [ getInnerText ( k ) . strip ( ) for k in keys ]	call the function getInnerText with argument k, on the result call the method strip, for every k in keys, append the results to field_value list.
obj = field . rel . to . _default_manager . db_manager ( self . db ) . get_by_natural_key ( * field_value )	call the method field.rel.to._default_manager.db_manager with an argument self.db, on the result call the method get_by_natural_key,
obj_pk = getattr ( obj , field . rel . field_name )	with unpacked list field_value as an argument, substitute the result for obj.   get the field.rel.field_name from the obj, substitute it for obj_pk.
if field . rel . to . _meta . pk . rel :	if field.rel.to._meta.pk.rel is true,
    obj_pk = obj_pk . pk	substitute obj_pk.pk for obj_pk.
else :	if not,
  field_value = getInnerText ( node ) . strip ( )	call the function getInnerText with an argument node, call the strip method on the result, substitute the result for field_value.
obj_pk = field . rel . to . _meta . get_field ( field . rel . field_name ) . to_python ( field_value )	call the field.rel.to._meta.get_field method with an field.rel.field_name argument, on the result call the method to_python,
return obj_pk	with field_value as an argument, substitute the result for obj_pk.   return obj_pk.
else :	if not,
field_value = getInnerText ( node ) . strip ( )	call the function getInnerText with an argument node, call the strip method on the result, substitute the result for field_value.
return field . rel . to . _meta . get_field ( field . rel . field_name ) . to_python ( field_value )	call the field.rel.to._meta.get_field method with an field.rel.field_name argument, on the result call the method to_python,
def _handle_m2m_field_node ( self , node , field ) :	with field_value as an argument, return the result.   define the method _handle_m2m_field_node with arguments self, node and field.
if hasattr ( field . rel . to . _default_manager , 'get_by_natural_key' ) :	if field.rel.to._default_manager has an attribute 'get_by_natural_key',
def m2m_convert ( n ) :	define the function m2m_convert with an argument n,
keys = n . getElementsByTagName ( 'natural' )	call the method n.getElementsByTagName with string 'natural' as argument, substitute result for keys.
if keys :	if keys is true,
  field_value = [ getInnerText ( k ) . strip ( ) for k in keys ]	call the function getInnerText with argument k, on the result call the method strip, for every k in keys, append the results to field_value list.
obj_pk = field . rel . to . _default_manager . db_manager ( self . db ) . get_by_natural_key ( * field_value ) . pk	call the method field.rel.to._default_manager.db_manager with an argument self.db, on the result call the method get_by_natural_key,
else :	with unpacked list field_value as an argument, substitute the field pk of the result for obj_pk.   if not,
  obj_pk = field . rel . to . _meta . pk . to_python ( n . getAttribute ( 'pk' ) )	call the method n.getAttribute with string 'pk' as argument, use the result as an argument for the call to the field.rel.to._meta.pk.to_python method, substitute the result for obj_pk.
return obj_pk	return obj_pk.
else :	if not,
m2m_convert = lambda n : field . rel . to . _meta . pk . to_python ( n . getAttribute ( 'pk' ) )	m2m_convert is an lambda function with an argument n, return value is the return value of the method field.rel.to._meta.pk.to_python,
return [ m2m_convert ( c ) for c in node . getElementsByTagName ( 'object' ) ]	called with n.getAttribute('pk') method.   call the m2m_convert function with an argument c, for every c in return value of the method node.getElementsByTagName,
def _get_model_from_node ( self , node , attr ) :	with an argument string 'object', return the result.   define the method _get_model_from_node with arguments self, node and attr.
model_identifier = node . getAttribute ( attr )	call the method node.getAttribute with an argument attr, substitute the result for model_identifier.
if not model_identifier :	if model_identifier is false,
raise base . DeserializationError (  '<%s> node is missing the required '%s' attribute'  % ( node . nodeName , attr ) )	raise an base.DeserializationError exception with an argument string '<%s> node is missing the required '%s' attribute',
try :	where '%s' is replaced with node.nodeName and attr.   try,
return apps . get_model ( model_identifier )	call the method apps.get_model with an argument model_identifier, return the result.
except ( LookupError , TypeError ) :	if LookupError or TypeError exceptions are caught,
def getInnerText ( node ) :	where '%s' is replaced with node.nodeName and attr.   define the function getInnerText with an argument node.
inner_text = [ ]	inner_text is an empty list.
for child in node . childNodes :	for every child in node.childNodes,
if child . nodeType == child . TEXT_NODE or child . nodeType == child . CDATA_SECTION_NODE :	if child.nodeType equals to child.TEXT_NODE or child.nodeType equals to child.CDATA_SECTION_NODE,
inner_text . append ( child . data )	append child.data to the inner_text list.
elif child . nodeType == child . ELEMENT_NODE :	otherwise if child.nodeType equals to child.ELEMENT_NODE,
inner_text . extend ( getInnerText ( child ) )	call the function getInnerText with an argument child, use the result as an argument for the call to the method inner_text.extend.
else :	if not,
pass	do nothing.
return '' . join ( inner_text )	join inner_text elements into a string.
class DefusedExpatParser ( _ExpatParser ) :	derive the class DefusedExpatParser from the _ExpatParser base class.
def __init__ ( self , * args , ** kwargs ) :	define the method __init__ with arguments self, unpacked list args and unpacked dictionary kwargs.
_ExpatParser . __init__ ( self , * args , ** kwargs )	call the method _ExpatParser.__init__ with arguments self, unpacked list args and unpacked dictionary kwargs.
self . setFeature ( handler . feature_external_ges , False )	call the method self.setFeature with 2 arguments: handler.feature_external_ges and boolean False.
self . setFeature ( handler . feature_external_pes , False )	call the method self.setFeature with 2 arguments: handler.feature_external_pes and boolean False.
def start_doctype_decl ( self , name , sysid , pubid , has_internal_subset ) :	define the method start_doctype_decl with an arguments self, name, sysid, pubid and has_internal_subset.
raise DTDForbidden ( name , sysid , pubid )	raise an DTDForbidden exception with arguments name, sysid and pubid.
def entity_decl ( self , name , is_parameter_entity , value , base ,  sysid , pubid , notation_name ) :	define the method entity_decl with arguments self, name, is_parameter_entity, value, base, sysid, pubid and notation_name.
raise EntitiesForbidden ( name , value , base , sysid , pubid , notation_name )	raise an EntitiesForbidden exception with arguments name, value, base, sysid, pubid and notation_name.
def unparsed_entity_decl ( self , name , base , sysid , pubid , notation_name ) :	define the method unparsed_entity_decl with arguments self, name, base, sysid, pubid and notation_name.
raise EntitiesForbidden ( name , None , base , sysid , pubid , notation_name )	raise an EntitiesForbidden exception with arguments name, None, base, sysid, pubid and notation_name.
def external_entity_ref_handler ( self , context , base , sysid , pubid ) :	define the method external_entity_ref_handler with arguments self, context, base, sysid and pubid.
raise ExternalReferenceForbidden ( context , base , sysid , pubid )	raise an ExternalReferenceForbidden exception with arguments context, base, sysid and pubid.
def reset ( self ) :	define the method reset with an argument self.
_ExpatParser . reset ( self )	call the method _ExpatParser.reset with an argumen sefl.
parser = self . _parser	substitute self._parser for parser.
parser . StartDoctypeDeclHandler = self . start_doctype_decl	substitute self.start_doctype_decl for parser.StartDoctypeDeclHandler.
parser . EntityDeclHandler = self . entity_decl	substitute self.entity_decl for parser.EntityDeclHandler.
parser . UnparsedEntityDeclHandler = self . unparsed_entity_decl	substitute self.unparsed_entity_decl for parser.UnparsedEntityDeclHandler.
parser . ExternalEntityRefHandler = self . external_entity_ref_handler	substitute self.external_entity_ref_handler for parser.ExternalEntityRefHandler.
class DefusedXmlException ( ValueError ) :	derive the class DefusedXmlException from the ValueError base class.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return str ( self )	convert self into a string and return it.
class DTDForbidden ( DefusedXmlException ) :	derive the class DTDForbidden from the DefusedXmlException base class.
def __init__ ( self , name , sysid , pubid ) :	define the method __init__ with arguments self, name, sysid and pubid.
super ( DTDForbidden , self ) . __init__ ( )	call the method __init__ from the base class of the DTDForbidden class.
self . name = name	substitute name for self.name.
self . sysid = sysid	substitute sysid for self.sysid.
self . pubid = pubid	substitute pubid for self.pubid.
def __str__ ( self ) :	define the method __str__ with an argument self.
tpl = 'DTDForbidden(name='{}', system_id={!r}, public_id={!r})'	tpl is an string 'DTDForbidden(name='{}', system_id={!r}, public_id={!r})'.
return tpl . format ( self . name , self . sysid , self . pubid )	call the method tpl.format with an arguments self.name, self.sysid and self.pubid.
class EntitiesForbidden ( DefusedXmlException ) :	derive the class EntitiesForbidden from the DefusedXmlException base class.
def __init__ ( self , name , value , base , sysid , pubid , notation_name ) :	define the method __init__ with arguments self, name, value, base, sysid, pubid and notation_name.
super ( EntitiesForbidden , self ) . __init__ ( )	call the method __init__ from the base class of the EntitiesForbidden class.
self . name = name	substitute name for self.name.
self . value = value	substitute value for self.value.
self . base = base	substitute base for self.base.
self . sysid = sysid	substitute sysid for self.sysid.
self . pubid = pubid	substitute pubid for self.pubid.
self . notation_name = notation_name	substitute notation_name for self.notation_name.
def __str__ ( self ) :	define the method __str__ with an argument self.
tpl = 'EntitiesForbidden(name='{}', system_id={!r}, public_id={!r})'	tpl is an string 'EntitiesForbidden(name='{}', system_id={!r}, public_id={!r})'.
return tpl . format ( self . name , self . sysid , self . pubid )	call the method tpl.format with an arguments self.name, self.sysid and self.pubid.
class ExternalReferenceForbidden ( DefusedXmlException ) :	derive the class ExternalReferenceForbidden from the DefusedXmlException base class.
def __init__ ( self , context , base , sysid , pubid ) :	define the method __init__ with arguments self, context, base, sysid and pubid.
super ( ExternalReferenceForbidden , self ) . __init__ ( )	call the method __init__ from the base class of the ExternalReferenceForbidden class.
self . context = context	substitute context for self.context.
self . base = base	substitute base for self.base.
self . sysid = sysid	substitute sysid for self.sysid.
self . pubid = pubid	substitute pubid for self.pubid.
def __str__ ( self ) :	define the method __str__ with an argument self.
tpl = 'ExternalReferenceForbidden(system_id='{}', public_id={})'	tpl is an string 'ExternalReferenceForbidden(system_id='{}', public_id={})'.
return tpl . format ( self . sysid , self . pubid )	call the method tpl.format with an arguments self.sysid and self.pubid.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import socket	import module socket.
import sys	import module sys.
from wsgiref import simple_server	from wsgiref import simple_server into default name space.
from wsgiref . util import FileWrapper	from wsgiref.util import FileWrapper
from django . core . exceptions import ImproperlyConfigured	from django.core.exceptions import ImproperlyConfigured into default name space.
from django . core . management . color import color_style	from django.core.management.color import color_style into default name space.
from django . core . wsgi import get_wsgi_application	from django.core.wsgi import get_wsgi_application into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . module_loading import import_string	from django.utils.module_loading import import_string into default name space.
from django . utils . six . moves import socketserver	from django.utils.six.moves import socketserver into default name space.
__all__ = ( 'WSGIServer' , 'WSGIRequestHandler' )	__all__ is a tuple containing 2 initial elements: strigs 'WSGIServer' and 'WSGIRequestHandler'.
def get_internal_wsgi_application ( ) :	define the funtion get_internal_wsgi_application.
from django . conf import settings	from django.conf import settings into default name space.
app_path = getattr ( settings , 'WSGI_APPLICATION' )	get 'WSGI_APPLICATION' attribute from the settings, substitute it for app_path.
if app_path is None :	if app_path is None,
return get_wsgi_application ( )	call the function get_wsgi_application, return the result.
try :	try,
return import_string ( app_path )	call the import_string with app_path as an argument, return the result.
except ImportError as e :	if ImportError, rename it to e, exception is caught,
six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) ,  sys . exc_info ( ) [ 2 ] )	call the function six.reraise with 3 arguments: ImproperlyConfigured, ImproperlyConfigured(msg) and third element of return value of the function sys.exc_info.
class WSGIServer ( simple_server . WSGIServer , object ) :	derive the class WSGIServer from simple_server.WSGIServer and object base classes.
request_queue_size = 10	request_queue_size is integer 10.
def __init__ ( self , * args , ** kwargs ) :	define the __init__ method with 3 arguments: self, unpacked list args and unpacked dictionary **kwargs.
if kwargs . pop ( 'ipv6' , False ) :	pop value under the 'ipv6' key of the kwargs dictionary, if it is true,
self . address_family = socket . AF_INET6	substitute socket.AF_INET6 for self.address_family.
super ( WSGIServer , self ) . __init__ ( * args , ** kwargs )	call the __init__ method from the base class of the WSGIServer class, with 2 arguments: unpacked list args and unpacked dictionary kwargs.
def server_bind ( self ) :	define the function server_bind with an argument self.
super ( WSGIServer , self ) . server_bind ( )	call the server_bind method from the base class of the WSGIServer class.
self . setup_environ ( )	call the self.setup_environ method.
class WSGIRequestHandler ( simple_server . WSGIRequestHandler , object ) :	derive the class WSGIRequestHandler from simple_server.WSGIRequestHandler and object base classes.
def __init__ ( self , * args , ** kwargs ) :	define the __init__ method with 3 arguments: self, unpacked list args and unpacked dictionary **kwargs.
self . style = color_style ( )	call the color_style method, substitute the result for self.style.
super ( WSGIRequestHandler , self ) . __init__ ( * args , ** kwargs )	call the __init__ method from the base class of the WSGIRequestHandler class, with 2 arguments: unpacked list args and unpacked dictionary kwargs.
def address_string ( self ) :	define the function address_string with an argument self.
return self . client_address [ 0 ]	return the first element of self.client_address.
def log_message ( self , format , * args ) :	define the function server_bind with an argument self.
\msg = '[%s] %s\\n' % ( self . log_date_time_string ( ) , format % args )\	\msg is a string '[%s] %s\\n', where '%s' are replaced with return value of the method self.log_date_time_string and formated args.\
if args [ 1 ] [ 0 ] == '2' :	if first element of the second row of args equals a string '2',
msg = self . style . HTTP_SUCCESS ( msg )	call the self.style.HTTP_SUCCESS with an argument msg, substitute it for msg.
elif args [ 1 ] [ 0 ] == '1' :	otherwise if first element of second row of args equals a string '1',
msg = self . style . HTTP_INFO ( msg )	call the self.style.HTTP_INFO with an argument msg, substitute it for msg.
elif args [ 1 ] == '304' :	otherwise if second element of args equals a string '304',
msg = self . style . HTTP_NOT_MODIFIED ( msg )	call the self.style.HTTP_NOT_MODIFIED with an argument msg, substitute it for msg.
elif args [ 1 ] [ 0 ] == '3' :	otherwise if first element of second row of args equals a string '3',
msg = self . style . HTTP_REDIRECT ( msg )	call the self.style.HTTP_REDIRECT with an argument msg, substitute it for msg.
elif args [ 1 ] == '404' :	otherwise if second element of args equals a string '404',
msg = self . style . HTTP_NOT_FOUND ( msg )	call the self.style.HTTP_NOT_FOUND with an argument msg, substitute it for msg.
elif args [ 1 ] [ 0 ] == '4' :	otherwise if first element of second row of args equals a string '4',
msg = self . style . HTTP_BAD_REQUEST ( msg )	call the self.style.HTTP_BAD_REQUEST with an argument msg, substitute it for msg.
else :	if not,
msg = self . style . HTTP_SERVER_ERROR ( msg )	call the self.style.HTTP_SERVER_ERROR with an argument msg, substitute it for msg.
sys . stderr . write ( msg )	call the sys.stderr.write function with an argument msg.
def run ( addr , port , wsgi_handler , ipv6 = False , threading = False ) :	define the function run with 5 arguments: addr, port, wsgi_handler, ipv6 set to boolean False and threading set to boolean False.
server_address = ( addr , port )	server_address is a tuple containing 2 initial elements: addr and port.
if threading :	if threading is true,
httpd_cls = type ( str ( 'WSGIServer' ) , ( socketserver . ThreadingMixIn , WSGIServer ) , { } )	call the function type with 3 arguments: string 'WSGIServer', tuple containing 2 elements: socketserver.ThreadingMixIn and WSGIServer,
else :	and an empty dictionary, substitute the result for httpd_cls.   if not,
httpd_cls = WSGIServer	substitute WSGIServer for httpd_cls.
httpd = httpd_cls ( server_address , WSGIRequestHandler , ipv6 = ipv6 )	call the httpd_cls function with 4 arguments: server_address, WSGIRequestHandler and ipv6 set to ipv6, substitute the result for httpd.
if threading :	if threading is true,
httpd . daemon_threads = True	httpd.daemon_threads is boolean True.
httpd . set_app ( wsgi_handler )	call the method httpd.set_app with an argument wsgi_handler.
httpd . serve_forever ( )	call the method httpd.serve_forever.
import importlib	import module importlib.
import os	import module os.
import sys	import module sys.
__version__ = '0.1'	__version__ is a string '0.1'.
__all__ = [ 'runfastcgi' ]	__all__ is a list containing a string 'runfastcgi'.
FASTCGI_OPTIONS = {  'protocol' : 'fcgi' ,  'host' : None ,  'port' : None ,  'socket' : None ,  'method' : 'fork' ,  'daemonize' : None ,  'workdir' : '/' ,  'pidfile' : None ,  'maxspare' : 5 ,  'minspare' : 2 ,  'maxchildren' : 50 ,  'maxrequests' : 0 ,  'debug' : None ,  'outlog' : None ,  'errlog' : None ,  'umask' : None ,  }	FASTCGI_OPTIONS is a dictionary containing 16 initial entries: 'fcgi' for 'protocol', None for 'host', None for 'port',
def fastcgi_help ( message = None ) :	define the method fastcgi_help with an argument message set to None.
print ( FASTCGI_HELP )	print FASTCGI_HELP to the standard output.
if message :	if message is true,
print ( message )	print message to the standard output.
return False	return boolean False.
def runfastcgi ( argset = [ ] , ** kwargs ) :	define the function runfastcgi with 2 arguments: argset set to an empty list and unpacked dictionary kwargs.
options = FASTCGI_OPTIONS . copy ( )	call the method FASTCGI_OPTIONS.copy, substitute the result for options.
options . update ( kwargs )	call the options.update method with an argument kwargs.
for x in argset :	for every x in argset,
if '=' in x :	if character '=' is contained in x,
k , v = x . split ( '=' , 1 )	call the x.split method with arguments: character '=' and integer 1, store the result in k and v, respectively.
else :	if not,
k , v = x , True	substitute x for k and boolean True for v.
options [ k . lower ( ) ] = v	substitute v for value under the k converted to lower case key of options dictionary.
if 'help' in options :	if string 'help' is contained in options,
return fastcgi_help ( )	call the fastcgi_help function, return the result.
try :	try,
import flup	import flup
except ImportError as e :	if ImportError, renamed to e, exception is caught,
\sys . stderr . write ( 'ERROR: %s\\n' % e )\	\call the method sys.stderr.write with an argument string 'ERROR: %s\\n', where '%s' is replaced by e.\
\sys . stderr . write ( '  Unable to load the flup package.  In order to run django\\n' )\	\call the method sys.stderr.write with an argument string '  Unable to load the flup package.  In order to run django\\n'.\
\sys . stderr . write ( '  as a FastCGI application, you will need to get flup from\\n' )\	\call the method sys.stderr.write with an argument string '  as a FastCGI application, you will need to get flup from\\n'.\
\sys . stderr . write ( '  http://www.saddi.com/software/flup/   If you've already\\n' )\	\call the method sys.stderr.write with an argument string '  http://www.saddi.com/software/flup/   If you've already\\n'.\
\sys . stderr . write ( '  installed flup, then make sure you have it in your PYTHONPATH.\\n' )\	\call the method sys.stderr.write with an argument string '  installed flup, then make sure you have it in your PYTHONPATH.\\n'.\
return False	return boolean False.
flup_module = 'server.' + options [ 'protocol' ]	append value under the 'protocol' key of the options dictionary to the string 'server.', substitute it for flup_module.
if options [ 'method' ] in ( 'prefork' , 'fork' ) :	if value under the 'method' key of the options dictionary equals to string 'perfork' or 'fork',
wsgi_opts = {  'maxSpare' : int ( options [ 'maxspare' ] ) ,  'minSpare' : int ( options [ 'minspare' ] ) ,  'maxChildren' : int ( options [ 'maxchildren' ] ) ,  'maxRequests' : int ( options [ 'maxrequests' ] ) ,  }	wsgi_opts is a dictionary with 4 initial entries: value under the key 'maxspare' of options dictionary converted to an integer,
flup_module += '_fork'	for 'maxSpare', value under the key 'minspare' of options dictionary converted to an integer for 'minSpare',   value under the key 'maxchildren' of options dictionary converted to an integer, for 'maxChildren',   and value under the key 'maxrequests' of options dictionary converted to an integer, for 'maxRequests'.   append string '_fork' to flup_module.
elif options [ 'method' ] in ( 'thread' , 'threaded' ) :	otherwise if value under the 'method' key of optins dictionary equals to string 'thread' or 'threaded',
wsgi_opts = {  'maxSpare' : int ( options [ 'maxspare' ] ) ,  'minSpare' : int ( options [ 'minspare' ] ) ,  'maxThreads' : int ( options [ 'maxchildren' ] ) ,  }	wsgi_opts is a dictionary with 4 initial entries: value under the key 'maxspare' of options dictionary converted to an integer,
else :	for 'maxSpare', value under the key 'minspare' of options dictionary converted to an integer for 'minSpare',   and value under the key 'maxchildren' of options dictionary converted to an integer, for 'maxThreads'.   if not,
return fastcgi_help ( 'ERROR: Implementation must be one of prefork or '  'thread.' )	call the function fastcgi_help with an argument string 'ERROR: Implementation must be one of prefork or thread.', return the result.
wsgi_opts [ 'debug' ] = options [ 'debug' ] is not None	if value under the 'debug' key of options dictionary is not None, substitute it for value under the 'debug' key of wsgi_opts dictionary.
try :	try,
module = importlib . import_module ( '.%s' % flup_module , 'flup' )	call the function importlib.import_module with 2 arguments: flup_module converted to string and appended to '.' character, and string 'flup', substitute the result for module.
WSGIServer = module . WSGIServer	substitute module.WSGIServer for WSGIServer.
except Exception :	if Exception exception is caught,
print ( 'Can't import flup.' + flup_module )	append flup_module to string 'Can't import flup.', print it to the standard output.
return False	return boolean False.
from django . core . servers . basehttp import get_internal_wsgi_application	from django.core.servers.basehttp import get_internal_wsgi_application into default name space.
if options [ 'host' ] and options [ 'port' ] and not options [ 'socket' ] :	if value under the 'socket' key of the options dictionary is false and values under the 'host' and 'port' keys of the options dictionary are true,
wsgi_opts [ 'bindAddress' ] = ( options [ 'host' ] , int ( options [ 'port' ] ) )	set the value under the 'bindAddress' key of the wsgi_opts dictionary to a tuple containing 2 elements: value under the 'host' key,
elif options [ 'socket' ] and not options [ 'host' ] and not options [ 'port' ] :	of the options dictionary and value under the 'port' key of the options dictionary converted into an integer.   if value under the 'socket' key of the options dictionary is true and values under the 'host' and 'port' keys of the options dictionary are false,
wsgi_opts [ 'bindAddress' ] = options [ 'socket' ]	substitute the value under the 'socket' key of options dictionary for value under the 'bindAddress' key of wsgi_opts dictionary.
elif not options [ 'socket' ] and not options [ 'host' ] and not options [ 'port' ] :	if values under the 'socket', 'host' and 'port' keys of the options dictionary are false,
wsgi_opts [ 'bindAddress' ] = None	set value under the 'bindAddress' key of wsgi_opts to None.
else :	if not,
return fastcgi_help ( 'Invalid combination of host, port, socket.' )	call the fastcgi_help function with an argument string 'Invalid combination of host, port, socket.', return it.
if options [ 'daemonize' ] is None :	if value under the 'daemonize' of options dictionary is None,
daemonize = ( wsgi_opts [ 'bindAddress' ] is not None )	if the value under the 'bindAddress' key of the wsgi_opts dictionary is not None, set daemonize to boolean True, if not, set it to boolean False.
else :	if not,
if options [ 'daemonize' ] . lower ( ) in ( 'true' , 'yes' , 't' ) :	convert the value under the 'daemonize' key of options dictionary to lowercase, if it equals to string 'true', 'yes' or 't',
daemonize = True	daemonize is boolean True.
elif options [ 'daemonize' ] . lower ( ) in ( 'false' , 'no' , 'f' ) :	convert the value under the 'daemonize' key of options dictionary to lowercase, if it equals to string 'false', 'no' or 'f',
daemonize = False	daemonize is boolean False.
else :	if not,
return fastcgi_help ( 'ERROR: Invalid option for daemonize '  'parameter.' )	call the fastcgi_help function with an argument string 'ERROR: Invalid option for daemonize parameter.', return it.
daemon_kwargs = { }	daemon_kwargs is an empty dictionary.
if options [ 'outlog' ] :	if value under the 'outlog' key of options dictionary is true,
daemon_kwargs [ 'out_log' ] = options [ 'outlog' ]	substitute the value under the 'outlog' key of options dictionary for value under the 'out_log' key of daemon_kwargs dictionary.
if options [ 'errlog' ] :	if value under the 'errlog' key of options dictionary is true,
daemon_kwargs [ 'err_log' ] = options [ 'errlog' ]	substitute the value under the 'errlog' key of options dictionary for value under the 'err_log' key of daemon_kwargs dictionary.
if options [ 'umask' ] :	if value under the 'umask' key of options dictionary is true,
daemon_kwargs [ 'umask' ] = int ( options [ 'umask' ] , 8 )	convert the value under the 'umask' key of options dictionary into an integer of base 8, substitute it for value under the 'umask' key of daemon_kwargs dictionary.
if daemonize :	if daemonize is true,
from django . utils . daemonize import become_daemon	from django.utils.daemonize import become_daemon into default name space.
become_daemon ( our_home_dir = options [ 'workdir' ] , ** daemon_kwargs )	call the function become_daemon with 2 arguments: our_home_dir set to the value under the 'workdir' key of options dictionary and,
if options [ 'pidfile' ] :	unpacked dictionary daemon_kwargs.   if value under the 'pidfile' of options dictionary exists,
with open ( options [ 'pidfile' ] , 'w' ) as fp :	open the file whose name is stored in the value under the 'pidfile' key of options dictionary and mode 'w', with the file descriptor as fp,
\fp . write ( '%d\\n' % os . getpid ( ) )\	\call the method fp.write with an argument string '%d\\n', with '%d' replaced by os.getpid function return value.\
WSGIServer ( get_internal_wsgi_application ( ) , ** wsgi_opts ) . run ( )	create the object WSGIServer with 2 arguments: get_internal_wsgi_application return value and unpacked dictionary wsgi_opts, call the method run on it.
if __name__ == '__main__' :	if __name__ equals a string '__main__'.
runfastcgi ( sys . argv [ 1 : ] )	call the function runfastcgi with an argument all the elements, except the first from the sys.argv list.
from django . dispatch import Signal	from django.dispatch import Signal into default name space.
request_started = Signal ( )	request_started is a instance of a Signal class.
request_finished = Signal ( )	request_finished is a instance of a Signal class.
got_request_exception = Signal ( providing_args = [ 'request' ] )	got_request_exception is a instance of a Signal class, created with an argument providing_args as the list containing string 'request'.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import base64	import module base64.
import json	import module json.
import time	import module time.
import zlib	import module zlib.
from django . conf import settings	from django.conf import settings into default name space.
from django . utils import baseconv	from django.utils import baseconv into default name space.
from django . utils . crypto import constant_time_compare , salted_hmac	from django.utils.crypto import constant_time_compare and salted_hmac into default name space.
from django . utils . encoding import force_bytes , force_str , force_text	from django.utils.encoding import force_bytes, force_str and force_text into default name space.
from django . utils . module_loading import import_string	from django.utils.module_loading import import_string into default name space.
class BadSignature ( Exception ) :	derive the class BadSignature from the Exception base class.
pass	do nothing.
class SignatureExpired ( BadSignature ) :	derive the class SignatureExpired from the BadSignature base class.
pass	do nothing.
def b64_encode ( s ) :	define the function b64_encode with an argument s.
return base64 . urlsafe_b64encode ( s ) . strip ( b'=' )	call the method base64.urlsafe_b64encode with an argument s, on the result call the strip function with '=' as the argument, return the result.
def b64_decode ( s ) :	define the function b64_decode with an argument s.
pad = b'=' * ( - len ( s ) % 4 )	calculate negative length of s, by modulus integer 4, use the result as the number of '=' characters to be stored in pad.
return base64 . urlsafe_b64decode ( s + pad )	call the method base64.urlsafe_b64decode with sum of s and pad as argument.
def base64_hmac ( salt , value , key ) :	define the function b64_hmac with arguments salt, value and key.
return b64_encode ( salted_hmac ( salt , value , key ) . digest ( ) )	call the salted_hmac with 3 arguments: salt, value and key, call the digest method on the result,
def get_cookie_signer ( salt = 'django.core.signing.get_cookie_signer' ) :	use the result as an argument for the call to the b64_encode function, return the result.   define the function get_cookie_signer with an argument salt set to string 'django.core.signing.get_cookie_signer'.
Signer = import_string ( settings . SIGNING_BACKEND )	call the import_string function with an argument settings.SIGNING_BACKEND, substitute the result for Signer.
key = force_bytes ( settings . SECRET_KEY )	call the force_bytes function with an argument settings.SECRET_KEY, substitute the result for key.
return Signer ( b'django.http.cookies' + key , salt = salt )	create the Singer class with 2 arguments: key appended to string 'django.http.cookies' and salt set to salt, return it.
class JSONSerializer ( object ) :	derive the class JSONSerializer from the object base class.
def dumps ( self , obj ) :	define the method dumps with arguments self and obj.
return json . dumps ( obj , separators = ( ',' , ':' ) ) . encode ( 'latin-1' )	call the json.dumps function with 2 arguments: obj and separators set to tuple containing ',' and ':' characters,
def loads ( self , data ) :	call the encode method on the result with string 'latin-1' as an argument, return the result.   define the method loads with arguments self and data.
return json . loads ( data . decode ( 'latin-1' ) )	call the data.decode method with a string 'latin-1' as an argument, use the result as an argument for the call to the json.load function, return the result.
def dumps ( obj , key = None , salt = 'django.core.signing' , serializer = JSONSerializer , compress = False ) :	define the function dumps with 5 arguments: obj, key set to None, salt set to string 'django.core.signing',
data = serializer ( ) . dumps ( obj )	call the serializer function, call the dumps method on the result with an argument obj, substitute result for data.
is_compressed = False	is_compressed is boolean False.
if compress :	if compress is true,
compressed = zlib . compress ( data )	call the function zlib.compress with an argument data, substitute the result for compressed.
if len ( compressed ) < ( len ( data ) - 1 ) :	if length of compressed is lesser than length of data decremented by 1,
data = compressed	substitute compressed for data.
is_compressed = True	is_compressed is boolean True.
base64d = b64_encode ( data )	call the b64_encode function with an argument data, substitute the result for base64d.
if is_compressed :	if is_compressed is true,
base64d = b'.' + base64d	prefix the base64d with a '.' character.
return TimestampSigner ( key , salt = salt ) . sign ( base64d )	instantiate the TimestampSigner object with arguments key and salt set to salt, call its method sign with an argument base64, return it.
def loads ( s , key = None , salt = 'django.core.signing' , serializer = JSONSerializer , max_age = None ) :	define the function loads with 5 arguments: s, key set to None, salt set to string 'django.core.signing',
base64d = force_bytes ( TimestampSigner ( key , salt = salt ) . unsign ( s , max_age = max_age ) )	instantiate TimestampSigner object with arguments key and salt set to salt, call its method unsign with arguments:
decompress = False	s and max_age set to max_age, use it as an argument for the force_bytes function, substitute the result for base64d.   decompress is boolean False.
if base64d [ : 1 ] == b'.' :	if first element of base64d equals to a '.' character,
base64d = base64d [ 1 : ]	substitute first element of base64d for base64d.
decompress = True	decompress is boolean True.
data = b64_decode ( base64d )	call the method b64_decode with an argument base64, substitute the result for data.
if decompress :	if decompress is true,
data = zlib . decompress ( data )	call the function zlib.decompress with an argument data, substitute the result for data.
return serializer ( ) . loads ( data )	call the serializer function, call the loads method on the return value with an argument data, return the result.
class Signer ( object ) :	derive the class Signer from the object base class.
def __init__ ( self , key = None , sep = ':' , salt = None ) :	define the method __init__ with 4 arguments: self, key set to None, sep set to ':' and salt set to None.
self . sep = force_str ( sep )	call the function force_str with an argument sep, substitute the result for self.sep.
self . key = key or settings . SECRET_KEY	if key exists, substitute it for self.key, if not substitute settings.SECRET_KEY for key.
self . salt = force_str ( salt or  '%s.%s' % ( self . __class__ . __module__ , self . __class__ . __name__ ) )	call the force_str function with an argument: salt, if it exists, if not with a string '%s.%s', with '%s' replaced by,
def signature ( self , value ) :	self.__class__.__module__ and self.__class__.__name__, respectively, substitute the result for self.salt.   define the method signature with arguments self and value.
signature = base64_hmac ( self . salt + 'signer' , value , self . key )	call the function base64_hmac with 3 arguments: string 'signer' appended to self.salt, value and self.key, substitute the result for signature.
return force_str ( signature )	call the function force_str with an argument signature, return the result.
def sign ( self , value ) :	define the method sign with arguments self and value.
value = force_str ( value )	call the function force_str with an argument value, substitute the result for value.
return str ( '%s%s%s' ) % ( value , self . sep , self . signature ( value ) )	convert value, self.sep and return value of a method self.signature called with an argument value, concatenate them together, return the result.
def unsign ( self , signed_value ) :	define the method unsign with arguments self and signed_value.
signed_value = force_str ( signed_value )	call the function signed_value with an argument value, substitute the result for signed_value.
if self . sep not in signed_value :	if self.sep is not contained in signed_value,
raise BadSignature ( 'No '%s' found in value' % self . sep )	raise an BadSignature exception with an argument string 'No '%s' found in value', where '%s' is replaced by self.sep.
value , sig = signed_value . rsplit ( self . sep , 1 )	call the signed_value.rsplit method with arguments self.sep and integer 1, substitute the result for value and sig, respectively.
if constant_time_compare ( sig , self . signature ( value ) ) :	call the function constant_time_compare with 2 arguments: sig and return value of the self.signature method with an argument value,  if it evaluates to true,
return force_text ( value )	call the force_text function with an argument value, return the result.
raise BadSignature ( 'Signature '%s' does not match' % sig )	raise an BadSignature exception with an argument string 'Signature '%s' does not match', where '%s' is replaced by sig.
class TimestampSigner ( Signer ) :	derive the class TimestampSigner from the Signer base class.
def timestamp ( self ) :	define the method timestamp with an argument self.
return baseconv . base62 . encode ( int ( time . time ( ) ) )	call the method baseconv.base62.encode with result of the time.time function converted to an integer, as an argument, return the result.
def sign ( self , value ) :	define the method sign with arguments self and value.
value = force_str ( value )	call the force_str function with an argument value, substitute the result for value.
value = str ( '%s%s%s' ) % ( value , self . sep , self . timestamp ( ) )	convert value, self.sep and return value of the function timestamp, concatenate them, substitute the result for value.
return super ( TimestampSigner , self ) . sign ( value )	call the sign method from the base class of the TimestampSigner class with an argument value, return the result
def unsign ( self , value , max_age = None ) :	define the method unsign with arguments self, value and max_age set to None.
result = super ( TimestampSigner , self ) . unsign ( value )	call the unsign method from the base class of the TimestampSigner class with an argument value, substitute the result for result.
value , timestamp = result . rsplit ( self . sep , 1 )	call the result.rsplit method with arguments self.sep and integer 1, substitute the result for value and timestamp, respectively.
timestamp = baseconv . base62 . decode ( timestamp )	call the baseconv.base62.decode method with an argument timestamp, substitute the result for timestamp.
if max_age is not None :	if max_age is not None,
age = time . time ( ) - timestamp	subtract timestamp from the return value of the function time.time, substitute the result for age.
if age > max_age :	if age is greater than max_age,
raise SignatureExpired (  'Signature age %s > %s seconds' % ( age , max_age ) )	raise an SignatureExpired exception with an argument string 'Signature age %s > %s seconds', where '%s' is replaced by age and max_age, respectively.
return value	return value.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import functools	import module functools.
from importlib import import_module	from importlib import import_module into default name space.
import re	import module re.
from threading import local	from threading import local into default name space.
import warnings	import module warnings.
from django . http import Http404	from django.http import Http404 into default name space.
from django . core . exceptions import ImproperlyConfigured , ViewDoesNotExist	from django.core.exceptions import ImproperlyConfigured and ViewDoesNotExist into default name space.
from django . utils . datastructures import MultiValueDict	from django.utils.datastructures import MultiValueDict into default name space.
from django . utils . deprecation import RemovedInDjango20Warning	from django.utils.deprecation import RemovedInDjango20Warning into default name space.
from django . utils . encoding import force_str , force_text , iri_to_uri	from django.utils.encoding import force_str, force_text and iri_to_uri into default name space.
from django . utils . functional import lazy	from django.utils.functional import lazy into default name space.
from django . utils . http import urlquote	from django.utils.http import urlquote into default name space.
from django . utils . module_loading import module_has_submodule	from django.utils.module_loading import module_has_submodule into default name space.
from django . utils . regex_helper import normalize	from django.utils.regex_helper import normalize into default name space.
from django . utils import six , lru_cache	from django.utils import six and lru_cache into default name space.
from django . utils . translation import get_language	from django.utils.translation import get_language into default name space.
_prefixes = local ( )	call the function local, substitute the result for _prefixes.
_urlconfs = local ( )	call the function local, substitute the result _urlconf.
class ResolverMatch ( object ) :	derive the class ResolverMatch with object as base class.
def __init__ ( self , func , args , kwargs , url_name = None , app_name = None , namespaces = None ) :	define the __init__ method with 7 arguments: self, func, args, kwargs, url_name set to None, app_name set to None and namespaces set to None.
self . func = func	substitute func for self.func.
self . args = args	substitute args for self.args.
self . kwargs = kwargs	substitute kwargs for self.kwargs.
self . url_name = url_name	substitute url_name for self.url_name.
self . app_name = app_name	substitute app_name for self.app_name.
if namespaces :	if namespaces is true,
self . namespaces = [ x for x in namespaces if x ]	append x to self.namespaces list for every x in namespaces, only if x is true.
else :	if not,
self . namespaces = [ ]	self.namespaces is an empty list.
self . namespace = ':' . join ( self . namespaces )	join self.namespaces into a string separated with character ':', substitute it for self.namespace.
if not hasattr ( func , '__name__' ) :	if func doesnt have a attribute '__name__',
self . _func_path = '.' . join ( [ func . __class__ . __module__ , func . __class__ . __name__ ] )	join func.__class__.__module__ and func.__class__.__name__ into a string, separated by character '.', substitute it for self._func_path.
else :	if not,
self . _func_path = '.' . join ( [ func . __module__ , func . __name__ ] )	join func.__module__ and func.__name__ into a string, separated by character '.', substitute it for self._func_path.
view_path = url_name or self . _func_path	if url_name exists substitute it for view_path, if not substitute .self._func_path for view_path.
self . view_name = ':' . join ( self . namespaces + [ view_path ] )	append list containing view_path to self.namespaces list, join all the elements into a string separated by character ':',
def __getitem__ ( self , index ) :	substitute it for self.view_name.   define the method __getitem__ with arguments self and index.
return ( self . func , self . args , self . kwargs ) [ index ]	return the element at the index index of the tuple containing 3 elements: self.func, self.args and self.kwargs.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return 'ResolverMatch(func=%s, args=%s, kwargs=%s, url_name=%s, app_name=%s, namespaces=%s)' % (  self . _func_path , self . args , self . kwargs , self . url_name , self . app_name , self . namespaces )	in the string 'ResolverMatch(func=%s, args=%s, kwargs=%s, url_name=%s, app_name=%s, namespaces=%s)', replace all the occurrences of:
class Resolver404 ( Http404 ) :	string '%s' with self._func_path, self.args, self.kwargs, self.url_name, self.app_name and self.namespaces, respectively.   derive the class Resolver404 with Http404 as base class.
pass	do nothing.
class NoReverseMatch ( Exception ) :	derive the class NoReverseMatch with Exception as base class.
pass	do nothing.
@ lru_cache . lru_cache ( maxsize = None )	method lru_cache.lru_cache with an argument maxsize set to None, as a decorator,
def get_callable ( lookup_view , can_fail = False ) :	define the function get_callable with arguments lookup_view and can_fail set to boolean False.
if callable ( lookup_view ) :	if lookup_view is a callable object,
return lookup_view	return lookup_view.
mod_name , func_name = get_mod_func ( lookup_view )	call the function get_mod_func with an argument lookup_view, store the result in mod_name and func_name, respectively.
if not func_name :	if func_name is false,
if can_fail :	if can_fail is true,
return lookup_view	return lookup_view.
else :	if not,
raise ImportError (  'Could not import '%s'. The path must be fully qualified.' %  lookup_view )	raise an ImportError exception with an argument string 'Could not import '%s'. The path must be fully qualified.',
try :	where '%s' is replaced by lookup_view.   try,
mod = import_module ( mod_name )	call the function import_module with an argument mod_name.
except ImportError :	if ImportError exception is caught.
if can_fail :	if can_fail is true,
return lookup_view	return lookup_view
else :	if not,
parentmod , submod = get_mod_func ( mod_name )	call the function get_mod_func with an argument mod_name, store the result in parentmod and submod, respectively.
if submod and not module_has_submodule ( import_module ( parentmod ) , submod ) :	if submod is true and return value of the function module_has_submodule called with 2 arguments: result of the function:
raise ViewDoesNotExist (  'Could not import '%s'. Parent module %s does not exist.' %  ( lookup_view , mod_name ) )	import_module called with an argument parentmod and submod, evaluates to false.   raise an ViewDoesNotExist exception with an argument string 'Could not import '%s'. Parent module %s does not exist.',
else :	where string '%s' is replaced by lookup_view and mod_name, respectively.   if not,
raise	raise an exception.
else :	if not,
try :	try,
view_func = getattr ( mod , func_name )	get func_name attribute from the mod object, substitute it for view_func.
except AttributeError :	if AttributeError exception is caught.
if can_fail :	if can fail is true,
return lookup_view	return lookup_view
else :	if not,
raise ViewDoesNotExist (  'Could not import '%s'. View does not exist in module %s.' %  ( lookup_view , mod_name ) )	raise an ViewDoesNotExist exception with an argument string 'Could not import '%s'. View does not exist in module %s.',
else :	where string '%s' is replaced by lookup_view and mod_name, respectively.   if not,
if not callable ( view_func ) :	if view_function is not a callable function,
raise ViewDoesNotExist (  'Could not import '%s.%s'. View is not callable.' %  ( mod_name , func_name ) )	raise an ViewDoesNotExist exception with an argument string 'Could not import '%s.%s'. View is not callable.',
return view_func	where string '%s' is replaced by mod_name and func_name, respectively.   return view_func.
@ lru_cache . lru_cache ( maxsize = None )	method lru_cache.lru_cache with an argument maxsize set to None, as a decorator,
def get_resolver ( urlconf ) :	define the function get_resolver with an argument urlconf.
if urlconf is None :	if urlconf is None,
from django . conf import settings	from django.conf import settings into default name space.
urlconf = settings . ROOT_URLCONF	substitute settings.ROOT_URLCONF for urlconf.
return RegexURLResolver ( r'^/' , urlconf )	return an instance of a class RegexURLResolver created with arguments: raw string '^/' and urlconf.
@ lru_cache . lru_cache ( maxsize = None )	method lru_cache.lru_cache with an argument maxsize set to None, as a decorator,
def get_ns_resolver ( ns_pattern , resolver ) :	define the function get_ns_resolver with arguments ns_pattern and resolver.
ns_resolver = RegexURLResolver ( ns_pattern , resolver . url_patterns )	ns_resolver is class instance of a class RegexURLResolver, created with 2 arguments: ns_pattern and resolver.url_patterns.
return RegexURLResolver ( r'^/' , [ ns_resolver ] )	return an instance of a class RegexURLResolver created with arguments: raw string '^/' and a list containing an element ns_resolver.
def get_mod_func ( callback ) :	define the function get_mod_func with an argument callback.
try :	try,
dot = callback . rindex ( '.' )	call the method callback.rindex with an argument character '.', substitute the result for dot.
except ValueError :	if ValueError exception is caught,
return callback , ''	return callback and a empty string.
return callback [ : dot ] , callback [ dot + 1 : ]	return callback split into two lists at the dot index, without the element at the dot index.
class LocaleRegexProvider ( object ) :	derive the class LocaleRegexProvider with object as base class.
def __init__ ( self , regex ) :	define the method __init__ with arguments self and regex.
self . _regex = regex	substitute regex for self._regex.
self . _regex_dict = { }	self._regex_dict is an empty dictionary.
@ property	property decorator,
def regex ( self ) :	define the method regex with an argument self.
language_code = get_language ( )	call the function get_language, substitute the result for language_code.
if language_code not in self . _regex_dict :	if language_code is not contained in self._regex_dict,
if isinstance ( self . _regex , six . string_types ) :	if self.regex is not an instance of six.string_types,
regex = self . _regex	substitute self._regex for regex.
else :	if not,
regex = force_text ( self . _regex )	call the function force_text with arguments self and _regex, substitute the result for regex.
try :	try,
compiled_regex = re . compile ( regex , re . UNICODE )	call the function re.compile with arguments regex and re.UNICODE, substitute the result for compiled_regex.
except re . error as e :	if re.error, renamed to e, is caught,
self . _regex_dict [ language_code ] = compiled_regex	where '%s' is replace by regex and return value of the function six.text_type with an argument e.   substitute the compiled_regex for value under the language_code key of the self._regex_dict dictionary.
return self . _regex_dict [ language_code ]	return the value under the language_code key of the self._regex_dict dictionary.
class RegexURLPattern ( LocaleRegexProvider ) :	derive the class RegexURLPattern with LocaleRegexProvider as base class.
def __init__ ( self , regex , callback , default_args = None , name = None ) :	define the method __init__ with 5 arguments: self, regex, callback, default_args set to None and name set to None.
LocaleRegexProvider . __init__ ( self , regex )	call the method LocaleRegexProvider.__init__ with arguments self and regex.
if callable ( callback ) :	if callback is an callable object,
self . _callback = callback	substitute callback for self._callback.
else :	if not,
self . _callback = None	self._callback is None.
self . _callback_str = callback	substitute callback for self._callback_str.
self . default_args = default_args or { }	if default_args exists substitute it for self.default_args, if not, self.default_args is an empty dictionary.
self . name = name	substitute name for self.name.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return force_str ( '<%s %s %s>' % ( self . __class__ . __name__ , self . name , self . regex . pattern ) )	substitute '%s' in string '<%s %s %s>' with self.__class__.__name__, self.name and self.regex.pattern, respectively,
def add_prefix ( self , prefix ) :	use it as an argument for the call to the force_str function, return the result.   define the method add_prefix with arguments self and prefix.
if not prefix or not hasattr ( self , '_callback_str' ) :	if prefix is false, and self doesnt have '_callback_str' attribute,
return	return nothing.
self . _callback_str = prefix + '.' + self . _callback_str	joint prefix, character '.' and self._callback_str together, substitute the result for self._callback_str.
def resolve ( self , path ) :	  define the method resolve with arguments self and path.
match = self . regex . search ( path )	call the method self.regex.search with an argument path, substitute the result for match.
if match :	if match is true,
kwargs = match . groupdict ( )	call the method match.groupdict, substitute the result for kwargs.
if kwargs :	if kwargs is true,
args = ( )	args is an empty tuple.
else :	if not,
args = match . groups ( )	call the method match.groups, substitute the result for args.
kwargs . update ( self . default_args )	call the method kwargs.update with an argument self.default_args.
return ResolverMatch ( self . callback , args , kwargs , self . name )	return an instance of a ResolverMatch class, crated with arguments self.callback, args, kwargs and self.name.
@ property	property decorator,
def callback ( self ) :	define the method callback with an argument self.
if self . _callback is not None :	if self._callback is not None,
return self . _callback	return self._callback.
self . _callback = get_callable ( self . _callback_str )	call the function get_callable with an argument self._callback_str, substitute the result for self._callback.
return self . _callback	return self._callback.
class RegexURLResolver ( LocaleRegexProvider ) :	derive the class RegexURLResolver with LocaleRegexProvider as base class.
def __init__ ( self , regex , urlconf_name , default_kwargs = None , app_name = None , namespace = None ) :	define the method __init__ with 6 arguments: self, regex, urlconf_name, default_kwargs set to None, app_name set to None and namespace set to None.
LocaleRegexProvider . __init__ ( self , regex )	call the method LocaleRegexProvider.__init__ with arguments self and regex.
self . urlconf_name = urlconf_name	substitute urlconf_name for self.urlconf_name.
if not isinstance ( urlconf_name , six . string_types ) :	if urlconf_name is not an instance of six.string_types class,
self . _urlconf_module = self . urlconf_name	substitute self.urlconf_name for self.urlconf_module.
self . callback = None	self.callback is None.
self . default_kwargs = default_kwargs or { }	if default_kwargs exists, substitute it for self.default_kwargs, otherwise self.default_kwargs is an empty dictionary.
self . namespace = namespace	substitute namespace for self.namespace.
self . app_name = app_name	substitute app_name for self.app_name.
self . _reverse_dict = { }	self._reverse_dict is an empty dictionary.
self . _namespace_dict = { }	self._namespace_dict is an empty dictionary.
self . _app_dict = { }	self._app_dict is an empty dictionary.
self . _callback_strs = set ( )	self._callback_strs is an empty set.
self . _populated = False	self._populated is boolean False.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
if isinstance ( self . urlconf_name , list ) and len ( self . urlconf_name ) :	if self.urlconf_name is an instance of a list type and its length is not zero.
urlconf_repr = '<%s list>' % self . urlconf_name [ 0 ] . __class__ . __name__	replace '%s' in string '<%s list>' with __class__.__name__ field of first element of self.urlconf_name, substitute it for urlconf_repr.
else :	if not,
urlconf_repr = repr ( self . urlconf_name )	create a printable representation of self.urlconf_name object, substitute it for urlconf_repr.
return str ( '<%s %s (%s:%s) %s>' ) % (  self . __class__ . __name__ , urlconf_repr , self . app_name ,  self . namespace , self . regex . pattern )	replace all '%s' in string '<%s %s (%s:%s) %s>' with self.__class__.__name__, urlconf_repr, self.app_name,
def _populate ( self ) :	self.namespace and self.regex.pattern, respectively. return it.   define the method _populate with an argument self.
lookups = MultiValueDict ( )	lookups is an instance of the MultiValueDict class.
namespaces = { }	namespaces is an empty dictionary.
apps = { }	apps is an empty dictionary.
language_code = get_language ( )	call the function get_language, substitute the result for language_code.
for pattern in reversed ( self . url_patterns ) :	for every pattern in reversed list self.url_patterns,
if hasattr ( pattern , '_callback_str' ) :	if pattern has an attribute '_callback_str',
self . _callback_strs . add ( pattern . _callback_str )	call the method self._callback_strs.add with an argument pattern._callback_str.
elif hasattr ( pattern , '_callback' ) :	otherwise, if pattern has an '_callback' attribute.
callback = pattern . _callback	substitute pattern._callback for callback.
if isinstance ( callback , functools . partial ) :	if callback is an instance of functools.partial object,
callback = callback . func	substitute callback.func for callback.
if not hasattr ( callback , '__name__' ) :	if callback doesnt have '__name__' attribute,
lookup_str = callback . __module__ + '.' + callback . __class__ . __name__	join callback.__module__, character '.' and callback.__class__.__name__ together, substitute the result for lookup_str.
else :	if not,
lookup_str = callback . __module__ + '.' + callback . __name__	join together callback.__module__, character '.' and callback.__name__, substitute the result for lookup_str.
self . _callback_strs . add ( lookup_str )	call the method self._callback_strs.add with an argument lookup_str.
p_pattern = pattern . regex . pattern	substitute pattern.regex.pattern for p_pattern.
if p_pattern . startswith ( '^' ) :	if p_pattern starts with a string '^',
p_pattern = p_pattern [ 1 : ]	remove the first element from p_pattern.
if isinstance ( pattern , RegexURLResolver ) :	if pattern is an instance of RegexURLResolver class,
if pattern . namespace :	if pattern.namespace is true,
namespaces [ pattern . namespace ] = ( p_pattern , pattern )	substitute the tuple containing 2 elements p_pattern and pattern for value under the pattern.namespace key of the namespaces dictionary.
if pattern . app_name :	if pattern.app_name is true,
    apps . setdefault ( pattern . app_name , [ ] ) . append ( pattern . namespace )	call the method apps.setdefault with 2 arguments: pattern and an empty list, append to the resulting object pattern.namespace.
else :	if not,
parent_pat = pattern . regex . pattern	substitute pattern.regex.pattern for parent_pat.
for name in pattern . reverse_dict :	for every name in pattern.reverse_dict,
    for matches , pat , defaults in pattern . reverse_dict . getlist ( name ) :	for every matches, pat and defaults in return value of the method pattern.reverse_dict.getlist called with an argument name,
        new_matches = normalize ( parent_pat + pat )	call the method normalize with sum of parent_pat and pat as an argument, substitute the result for new_matches.
lookups . appendlist ( name , ( new_matches , p_pattern + pat , dict ( defaults , ** pattern . default_kwargs ) ) )	call the method lookups.appendlist with 2 arguments: name and a tuple containing 3 elements: new_matches, sum of p_pattern and pat,
for namespace , ( prefix , sub_pattern ) in pattern . namespace_dict . items ( ) :	and dictionary created by applying defaults mapping on the pattern.default_kwargs dictionary.   for every namespace and tuple containing: prefix and sub_pattern, in return value of the method pattern.namespace_dict.items,
    namespaces [ namespace ] = ( p_pattern + prefix , sub_pattern )	substitute tuple containing 2 elements: sum of p_pattern and prefix, and sub_pattern for value under the namespace key of the namespace dictionary.
for app_name , namespace_list in pattern . app_dict . items ( ) :	for every app_name and namespace_list in pattern.app_dict.items method return value,
    apps . setdefault ( app_name , [ ] ) . extend ( namespace_list )	call the method apps.setdefault with 2 arguments: app_name and an empty list, extend the resulting list with namespaces_list.
self . _callback_strs . update ( pattern . _callback_strs )	call the method self._callback_strs.update with an argument pattern._callback_strs.
else :	if not,
bits = normalize ( p_pattern )	call the function normalize with an argument p_pattern, substitute the result for bits.
lookups . appendlist ( pattern . callback , ( bits , p_pattern , pattern . default_args ) )	call the method lookups.appendlist with 2 arguments: pattern.callback and a tuple containing 3 elements: bits, p_pattern,
if pattern . name is not None :	and pattern.default_args.   if pattern.name is not None,
lookups . appendlist ( pattern . name , ( bits , p_pattern , pattern . default_args ) )	call the method lookups.appendlist with 2 arguments: pattern.name and a tuple containing 3 elements: bits, p_pattern,
self . _reverse_dict [ language_code ] = lookups	and pattern.default_args.   substitute lookups for the value under language_code key of the self._reverse_dict dictionary.
self . _namespace_dict [ language_code ] = namespaces	substitute namespaces for the value under language_code key of the self._namespace_dict dictionary.
self . _app_dict [ language_code ] = apps	substitute apps for the value under language_code key of the self._app_dict dictionary.
self . _populated = True	self._populated is boolean True.
@ property	property decorator,
def reverse_dict ( self ) :	define the method reverse_dict with an argument self.
language_code = get_language ( )	call the function get_language, substitute the result for language_code.
if language_code not in self . _reverse_dict :	if language_code is not contained in self._reverse_dict
self . _populate ( )	call the method self._populate.
return self . _reverse_dict [ language_code ]	return the value under the language_code key of the self._reverse_dict dictionary.
@ property	property decorator,
def namespace_dict ( self ) :	define the method namespace_dict with an argument self.
language_code = get_language ( )	call the method get_language, substitute the result for language_code.
if language_code not in self . _namespace_dict :	if language_code is not contained in self._namespace_dict,
self . _populate ( )	call the method self._populate.
return self . _namespace_dict [ language_code ]	return the value under the language_code key of the self._namespace_dict dictionary.
@ property	property decorator,
def app_dict ( self ) :	define the method app_dict with an argument self.
language_code = get_language ( )	call the method get_language, substitute the result for language_code.
if language_code not in self . _app_dict :	if language_code is not containsed in self._app_dict
self . _populate ( )	call the method self._populate.
return self . _app_dict [ language_code ]	return the value under the language_code key of the self._app_dict dictionary.
def resolve ( self , path ) :	define the method resolve with an argument self.
path = force_text ( path )	call the function force_text with an argument path, substitute the result for path.
tried = [ ]	tried is an empty list.
match = self . regex . search ( path )	call the function self.regex.search with an argument path, substitute the result for match.
if match :	if match is true,
new_path = path [ match . end ( ) : ]	slice the path list from the result of the match.end method as the start index to the end, substitute it for new_path.
for pattern in self . url_patterns :	for every pattern in self.url_patterns,
try :	try,
sub_match = pattern . resolve ( new_path )	call the method pattern.resolve with an argument new_path, substitute the result for sub_match.
except Resolver404 as e :	if Resolver404, renamed to e, exception is caught,
sub_tried = e . args [ 0 ] . get ( 'tried' )	call the get method with an argument string 'tried' on the first element of the e.args, substitute the result for sub_tried.
if sub_tried is not None :	if sub_tried is not None,
    tried . extend ( [ pattern ] + t for t in sub_tried )	call the method tried.extend with an argument: t added to a list containing element pattern, for every t in sub_tried.
else :	if not,
    tried . append ( [ pattern ] )	append list containing pattern to tried.
else :	if not,
if sub_match :	if sub_match is true,
    sub_match_dict = dict ( match . groupdict ( ) , ** self . default_kwargs )	sub_match_dict is a dictionary created from self.default_kwargs dictionary using mapping function match.groupdict.
sub_match_dict . update ( sub_match . kwargs )	call the method sub_match_dict.update with an argument sub_match.kwargs.
return ResolverMatch ( sub_match . func , sub_match . args , sub_match_dict , sub_match . url_name , self . app_name or sub_match . app_name , [ self . namespace ] + sub_match . namespaces )	return an instance of a class ResolverMatch created with 6 arguments: sub_match.func, sub_match.args, sub_match_dict,
tried . append ( [ pattern ] )	sub_match.url_name, self.app_name if it exists or if not sub_match.app_name and sub_match.namespaces list appended to self.name.   append pattern to tried list.
raise Resolver404 ( { 'tried' : tried , 'path' : new_path } )	raise an Resolver404 exception with an argument dictionary containing 2 entries: new_path for 'path' and tried for 'tried'.
raise Resolver404 ( { 'path' : path } )	raise an Resolver404 exception with an argument dictionary containing 1 entry: path for 'path'.
@ property	property decorator,
def urlconf_module ( self ) :	define the method urlconf_module with an argument self.
try :	try,
return self . _urlconf_module	return self._urlconf_module.
except AttributeError :	if AttributeError exception is caught.
self . _urlconf_module = import_module ( self . urlconf_name )	call the function import_module with argument self.urlconf_name, substitute the result for self._urlconf_module.
return self . _urlconf_module	return self._urlconf_module.
@ property	property decorator,
def url_patterns ( self ) :	define the method url_patterns with an argument self.
patterns = getattr ( self . urlconf_module , 'urlpatterns' , self . urlconf_module )	get attribute 'urlpatterns' form the self.urlconf_module, substitute it for patterns, if the attribute doesnt exist,
try :	substitute self.urlconf_module for self.urlconf_module.   try,
iter ( patterns )	call the function iter with an argument patterns.
except TypeError :	if TypeError exception is caught,
msg = (  'The included urlconf '{name}' does not appear to have any '  'patterns in it. If you see valid patterns in the file then '  'the issue is probably caused by a circular import.'  )	msg is a string ''The included urlconf '{name}' does not appear to have any patterns in it.
raise ImproperlyConfigured ( msg . format ( name = self . urlconf_name ) )	If you see valid patterns in the file then the issue is probably caused by a circular import.'   raise an ImproperlyConfigured exception with an argument: return value of the method msg.format, called with an argument name set to self.urlconf_name.
return patterns	return patterns.
def resolve_error_handler ( self , view_type ) :	define the method resolve_error_handler with arguments self and view_type.
callback = getattr ( self . urlconf_module , 'handler%s' % view_type , None )	replace '%s' in the string 'handler%s' with view_type, use it as an name of the attribute to get from the self.urlconf_module,
if not callback :	substitute it for callback, if the attribute doesnt exists, callback is None.   if not callback,
from django . conf import urls	from django.conf import urls into default name space,
callback = getattr ( urls , 'handler%s' % view_type )	replace '%s' in the string 'handler%s' with view_type, use it as an name of the attribute to get from the urls, substitute it for callback.
return get_callable ( callback ) , { }	call the function get_callable with an argument callback, return the result and an empty dictionary.
def reverse ( self , lookup_view , * args , ** kwargs ) :	define the method reverse with arguments self, lookup_view, unpacked list args and unpacked dictionary kwargs.
return self . _reverse_with_prefix ( lookup_view , '' , * args , ** kwargs )	call the method self._reverse_with_prefix with 4 arguments: lookup_view, an empty string, unpacked list args and unpacked dictionary kwargs.
def _reverse_with_prefix ( self , lookup_view , _prefix , * args , ** kwargs ) :	define the method _reverse_with_prefix with arguments self, lookup_view, _prefix, unpacked list args and unpacked dictionary kwargs.
if args and kwargs :	if args and kwargs are both true,
raise ValueError ( 'Don't mix *args and **kwargs in call to reverse()!' )	raise an ValueError exception with an argument string 'Don't mix *args and **kwargs in call to reverse()!'.
text_args = [ force_text ( v ) for v in args ]	call the function force_text with an argument v, for every v in args, put the results in a text_args list.
text_kwargs = dict ( ( k , force_text ( v ) ) for ( k , v ) in kwargs . items ( ) )	text_kwargs is a dictionary created from the result of the function force_text with an argument v, mapped through function k, for every k and v in return value of the kwargs.items.
if not self . _populated :	if self._populated is false,
self . _populate ( )	call the method self._populate,
original_lookup = lookup_view	substitute lookup_view for original_lookup,
try :	try,
if lookup_view in self . _callback_strs :	if lookup_view is contained in self._callback_strs,
lookup_view = get_callable ( lookup_view , True )	call the function get_callable with arguments lookup_view and boolean True, substitute the result for lookup_view.
except ( ImportError , AttributeError ) as e :	if ImportError, AttributeError, renamed to e, exceptions are caught,
raise NoReverseMatch ( 'Error importing '%s': %s.' % ( lookup_view , e ) )	raise an NoReverseMatch exception with an argument string 'Error importing '%s': %s.', where '%s' is replaced with lookup_view and e, respectively.
else :	if not,
if not callable ( original_lookup ) and callable ( lookup_view ) :	if original_lookup and lookup_view are not callable objects,
warnings . warn (  'Reversing by dotted path is deprecated (%s).' % original_lookup ,  RemovedInDjango20Warning , stacklevel = 3  )	call the function warnings.warn with 3 arguments: string 'Reversing by dotted path is deprecated (%s).', with '%s' replaced with
possibilities = self . reverse_dict . getlist ( lookup_view )	original_lookup, RemovedInDjango20Warning and stacklevel set to integer 3.   call the method self.reverse_dict.getlist with an argument lookup_view, substitute the result for possibilities.
prefix_norm , prefix_args = normalize ( urlquote ( _prefix ) ) [ 0 ]	call the function urlquote with an argument _prefix, use the result as an argument for the call to the normalize function,
for possibility , pattern , defaults in possibilities :	substitute the fitst element of the result for prefix_norm and prefix_args, respectively.   for every possibility, pattern and defaults in possibilities,
for result , params in possibility :	for every result and params in possibility,
if args :	if args is true,
if len ( args ) != len ( params ) + len ( prefix_args ) :	if length of args is not equal to the sum of the lengths of params and prefix_args,
    continue	skip this loop iteration.
candidate_subs = dict ( zip ( prefix_args + params , text_args ) )	create a list of tuples out of 2 lists: appended params list to prefix_args and text_args, covert the result into a dictionary,
else :	substitute it for candidate_subs.   if not,
if set ( kwargs . keys ( ) ) | set ( defaults . keys ( ) ) != set ( params ) | set ( defaults . keys ( ) ) | set ( prefix_args ) :	if the union of the kwargs and defaults dictionary keys converted into sets is not the same as the union of the defaults and prefix
    continue	dictionary keys converted into sets,   skip this loop iteration,
matches = True	matches is boolean True,
for k , v in defaults . items ( ) :	for every k and v in return value of the function defaults.items,
    if kwargs . get ( k , v ) != v :	if the value of the kwargs dictionary under the key k is not equal to v,
        matches = False	matches is boolean False.
break	break from this loop execution.
if not matches :	if matches is false,
    continue	skip this loop iteration,
candidate_subs = text_kwargs	substitute text_kwargs for candidate_subs.
candidate_pat = prefix_norm . replace ( '%' , '%%' ) + result	replace all the occurrences of the '%' string for '%%', append result to the previous result, substitute it for candidate_pat.
if re . search ( '^%s%s' % ( prefix_norm , pattern ) , candidate_pat % candidate_subs , re . UNICODE ) :	call the function re.search with 3 arguments: string '^%s%s', with '%s' replaced for prefix_norm and pattern, respectively,
candidate_subs = dict ( ( k , urlquote ( v ) ) for ( k , v ) in candidate_subs . items ( ) )	candidate_pat formated with candidate_subs and re.UNICODE.   candidate_subs is dictionary created from elements in return value of the function urlquote called with argument v,
return candidate_pat % candidate_subs	mapped with a function k, for every k and v in return value of the method candidate_subs.items.   format candidate_pat with candidate_subs, return the result.
m = getattr ( lookup_view , '__module__' , None )	get the attribute '__module__' from the getattr, if it exists substitute it for m, if not, m is None.
n = getattr ( lookup_view , '__name__' , None )	get the attribute '__name__' from the getattr, if it exists substitute it for m, if not, m is None.
if m is not None and n is not None :	if m and n are not None,
lookup_view_s = '%s.%s' % ( m , n )	join m and n into a string, separated by '.', substitute the result for lookup_view_s.
else :	if not,
lookup_view_s = lookup_view	substitute lookup_view for lookup_view_s.
patterns = [ pattern for ( possibility , pattern , defaults ) in possibilities ]	append pattern into a list patterns, for every possibility, pattern and defaults in possibilities.
raise NoReverseMatch ( 'Reverse for '%s' with arguments '%s' and keyword '  'arguments '%s' not found. %d pattern(s) tried: %s' %  ( lookup_view_s , args , kwargs , len ( patterns ) , patterns ) )	raise an NoReverseMatch exception with an argument string 'Reverse for '%s' with arguments '%s' and keyword ',
class LocaleRegexURLResolver ( RegexURLResolver ) :	arguments '%s' not found. %d pattern(s) tried: %s, replace '%s' with lookup_view_s, args, kwargs, length of patterns, patterns,  and respectively.   derive the class LocaleRegexURLResolver with RegexURLResolver as base class.
def __init__ ( self , urlconf_name , default_kwargs = None , app_name = None , namespace = None ) :	define the __init__ method with 5 arguments: self, urlconf_name, default_kwargs set to None, app_name set to None and  namespace set to None.
super ( LocaleRegexURLResolver , self ) . __init__ (  None , urlconf_name , default_kwargs , app_name , namespace )	call the __init__ method of the base class of the class LocaleRegexURLResolver, with arguments:  None, urlconf_name, default_kwargs, app_name and namespace.
@ property	property decorator,
def regex ( self ) :	define the method regex with an argument self.
language_code = get_language ( )	call the function get_language, substitute the result for language_code.
if language_code not in self . _regex_dict :	if language_code is not contained in self._regex_dict,
regex_compiled = re . compile ( '^%s/' % language_code , re . UNICODE )	call the function re.compile with 2 arguments, string '^%s/', where '%s' is replaced with language_code and re.UNICODE, substitute the result for regex_compiled.
self . _regex_dict [ language_code ] = regex_compiled	substitute the regex_compiled for value under the language_code key of the self._regex_dict dictionary.
return self . _regex_dict [ language_code ]	return the value under the language_code of the self._regex_dict dictionary.
def resolve ( path , urlconf = None ) :	define the function resolve with arguments path and urlconf set to None.
if urlconf is None :	if urlconf is None,
urlconf = get_urlconf ( )	call the function get_urlconf with an argument urlconf.
return get_resolver ( urlconf ) . resolve ( path )	call the function get_resolver with an argument urlconf, on the result call the method resolve with an argument path, return it.
def reverse ( viewname , urlconf = None , args = None , kwargs = None , prefix = None , current_app = None ) :	define the function reverse with 6 arguments: viewname, urlconf set to None, args set to None, kwargs set to None,
if urlconf is None :	prefix set to None, current_app set to None.   if urlconf is None,
urlconf = get_urlconf ( )	call the function get_urlconf with an argument urlconf.
resolver = get_resolver ( urlconf )	call the function get_resolver with an argument urlconf, substitute the result for resolver.
args = args or [ ]	if args in None of boolean False, substitute it for an empty list.
kwargs = kwargs or { }	if args in None of boolean False, substitute it for an empty dictionary.
if prefix is None :	if prefix is None,
prefix = get_script_prefix ( )	call the function get_script_prefix, substitute the result for prefix.
if not isinstance ( viewname , six . string_types ) :	if viewname is not an instance of the six.string_types object,
view = viewname	substitute viewname for view.
else :	if not,
parts = viewname . split ( ':' )	call the method viewname.split, with an argument ':', substitute the result for parts.
parts . reverse ( )	call the method parts.reverse.
view = parts [ 0 ]	substitute first element of parts for view.
path = parts [ 1 : ]	substitute parts, without the first element, for path.
resolved_path = [ ]	resolved_path is an empty list.
ns_pattern = ''	ns_pattern is an empty string.
while path :	while path is true,
ns = path . pop ( )	pop the element form the path as substitute the result for ns.
try :	try,
app_list = resolver . app_dict [ ns ]	get the value under the ns key of the resolver.app_dict dictionary, substitute it for app_list.
if current_app and current_app in app_list :	if current_app and is true and current_app is contained in app_list,
  ns = current_app	substitute current_app for ns.
elif ns not in app_list :	otherwise if ns is not contained in app_list,
    ns = app_list [ 0 ]	substitute first element of app_list for ns.
except KeyError :	if KeyError exception is caught,
pass	do nothing.
try :	try,
extra , resolver = resolver . namespace_dict [ ns ]	substitute the value under the ns key of the resolver.namespace_dict dictionary for extra and resolver, respectively.
resolved_path . append ( ns )	call the method resolved_path.append with an argument ns.
ns_pattern = ns_pattern + extra	add ns_pattern and extra, substitute the result for ns_pattern.
except KeyError as key :	if KeyError, renamed to key, exception is caught,
if resolved_path :	if resolved_path is true,
else :	respectively replace '%s' with key and elements of the resolved_path joined into a string, separated by ':'.   if not,
raise NoReverseMatch ( '%s is not a registered namespace' %  key )	raise an NoReverseMatch exception with an argument string '%s is not a registered namespace', with '%s' replaced with key.
if ns_pattern :	if ns_pattern is true,
resolver = get_ns_resolver ( ns_pattern , resolver )	call the function get_ns_resolver with arguments ns_pattern and resolver, substitute the result for resolver.
return iri_to_uri ( resolver . _reverse_with_prefix ( view , prefix , * args , ** kwargs ) )	call the method resolver._reverse_with_prefix with 4 arguments: view, prefix, unpacked list args, unpacked dictionary kwargs,
reverse_lazy = lazy ( reverse , str )	use the result as an argument for the call to the function iri_to_uri, return the result.   call the function lazy with arguments reverse and str, substitute the results for reverse_lazy.
def clear_url_caches ( ) :	define the function clear_url_caches.
get_callable . cache_clear ( )	call the function get_callable.cache_clear.
get_resolver . cache_clear ( )	call the function get_resolver.cache_clear.
get_ns_resolver . cache_clear ( )	call the function get_ns_resolver.cache_clear.
def set_script_prefix ( prefix ) :	define the function set_script_prefix with an argument prefix.
if not prefix . endswith ( '/' ) :	if prefix doesnt end with character '/',
prefix += '/'	append '/' to prefix.
_prefixes . value = prefix	substitute prefix for _prefixes.values.
def get_script_prefix ( ) :	define the function get_script_prefix.
return getattr ( _prefixes , 'value' , '/' )	get 'value' attribute of the _prefixes, if it exists, return it, otherwise return '/'.
def clear_script_prefix ( ) :	define the function clear_script_prefix.
try :	try,
del _prefixes . value	delete _prefixes.values.
except AttributeError :	if AttributeError exception is caught,
pass	do nothing.
def set_urlconf ( urlconf_name ) :	define the function set_urlconf with an argument urlconf_name.
if urlconf_name :	if urlconf_name is true,
_urlconfs . value = urlconf_name	substitute urlconf_name for _urlconfs.value.
else :	if not,
if hasattr ( _urlconfs , 'value' ) :	if _urlconfs has an attribute 'value',
del _urlconfs . value	delete _urlconfs.value.
def get_urlconf ( default = None ) :	define the function get_urlconf with an argument default set to None.
return getattr ( _urlconfs , 'value' , default )	get the 'value' attribute of the _urlconfs, if it exists return it, otherwise return defaults.
def is_valid_path ( path , urlconf = None ) :	define the function is_valid_path with arguments path and urlconf set to None.
try :	try,
resolve ( path , urlconf )	call the function resolve with arguments path and urlconf.
return True	return boolean True.
except Resolver404 :	if Resolver404 exception is caught,
return False	return boolean False.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import re	import module re.
from django . core . exceptions import ValidationError	from django.core.exceptions import ValidationError into default name space.
from django . utils . deconstruct import deconstructible	from django.utils.deconstruct import deconstructible into default name space.
from django . utils . translation import ugettext_lazy as _ , ungettext_lazy	from django.utils.translation import ugettext_lazy as _ and ungettext_lazy into default name space.
from django . utils . encoding import force_text	from django.utils.encoding import force_text into default name space.
from django . utils . ipv6 import is_valid_ipv6_address	from django.utils.ipv6 import is_valid_ipv6_address into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . six . moves . urllib . parse import urlsplit , urlunsplit	from django.utils.six.moves.urllib.parse import urlsplit and urlunsplit into default name space.
EMPTY_VALUES = ( None , '' , [ ] , ( ) , { } )	EMPTY_VALUES is a tuple containing 5 initial elements: None, empty string, empty list, empty tuple and an empty dictionary.
@ deconstructible	decorator deconstructible,
class RegexValidator ( object ) :	derive the class RegexValidator form the object base class.
regex = ''	regex is an empty string.
message = _ ( 'Enter a valid value.' )	call a function _ with a string 'Enter a valid value.' as an argument, substitute the result for message.
code = 'invalid'	code is a string 'invalid'
inverse_match = False	inverse_match is boolean False.
flags = 0	flags is a integer 0.
def __init__ ( self , regex = None , message = None , code = None , inverse_match = None , flags = None ) :	define the method __init__ with 6 arguments: self, regex set to None, message set to None, code set to None,
if regex is not None :	inverse_match set to None and flags set to None.   if regex is not None,
self . regex = regex	substitute regex for self.regex.
if message is not None :	if message is not None,
self . message = message	substitute message for self.message.
if code is not None :	if code is not None,
self . code = code	substitute code for self.code.
if inverse_match is not None :	if inverse_match is not None,
self . inverse_match = inverse_match	substitute inverse_match for self.inverse_match.
if flags is not None :	if flags is not None,
self . flags = flags	substitute flags for self.flags.
if self . flags and not isinstance ( self . regex , six . string_types ) :	if self.flags is true and self.regex is not an instance of a six.string_types type,
raise TypeError ( 'If the flags are set, regex must be a regular expression string.' )	raise an TypeError exception with an argument string 'If the flags are set, regex must be a regular expression string.'.
if isinstance ( self . regex , six . string_types ) :	if self.regex is not an instance of a six.string_types type,
self . regex = re . compile ( self . regex , self . flags )	call the re.compile function with self.regex and self.flags as arguments, substitute the result for self.regex.
def __call__ ( self , value ) :	define the method __call__ with arguments self and value.
if not ( self . inverse_match is not bool ( self . regex . search (  force_text ( value ) ) ) ) :	if self.inverse_match equals to return value of the self.regex.search method converted to boolean, called with argument force_text(value),
raise ValidationError ( self . message , code = self . code )	raise a ValidationError exception with arguments self.message and code set to self.code.
def __eq__ ( self , other ) :	define the method __eq__ with arguments self and other.
return (  isinstance ( other , RegexValidator ) and  self . regex . pattern == other . regex . pattern and  self . regex . flags == other . regex . flags and  ( self . message == other . message ) and  ( self . code == other . code ) and  ( self . inverse_match == other . inverse_match )  )	evaluate the logical expression, if other is an instance of RegexValidator and self.regex.pattern equals to other.regex.pattern,
def __ne__ ( self , other ) :	and self.regex.flags equals to other.regex.flags and self.message equals to other.message and self.code equals to other.code,   and self.inverse_match equals to other.inverse_match, return the result.   define the method __ne__ with arguments self and other.
return not ( self == other )	if self equals to other return boolean False, otherwise return boolean True.
@ deconstructible	decorator deconstructible,
class URLValidator ( RegexValidator ) :	derive the class URLValidator form the RegexValidator base class.
\regex = re . compile (  r'^(?:[a-z0-9\\.\\-]*)://'  r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}(?<!-)\\.?)|'  r'localhost|'  r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|'  r'\\[?[A-F0-9]*:[A-F0-9:]+\\]?)'  r'(?::\\d+)?'  r'(?:/?|[/?]\\S+)$' , re . IGNORECASE )\	\call the re.compile function with 2 arguments: raw string '^(?:[a-z0-9\\.\\-]*)://(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+',\
message = _ ( 'Enter a valid URL.' )	\(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}(?<!-)\\.?)|\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|\\[?[A-F0-9]*:[A-F0-9:]+\\]?)(?::\\d+)?(?::\\d+)?(?:/,   '?|[/?]\\S+)$' and re.IGNORECASE, substitute the result for regex.   call a function _ with a string 'Enter a valid value.' as an argument, substitute the result for message.\
schemes = [ 'http' , 'https' , 'ftp' , 'ftps' ]	schemes is a list containing 4 initial elements: 'http', 'https', 'ftp' and 'ftps'.
def __init__ ( self , schemes = None , ** kwargs ) :	define the method __init__ with 3 arguments: self, schemes set to None and unpacked dictionary kwargs.
super ( URLValidator , self ) . __init__ ( ** kwargs )	call the __init__ method of the base class of the class URLValidator, with unpacked dictionary kwargs as argument.
if schemes is not None :	if schemes is not None,
self . schemes = schemes	substitute schemes for self.schemes.
def __call__ ( self , value ) :	define the method __call__ with arguments self and value.
value = force_text ( value )	call the function force_text with an argument value, substitute the result for value.
scheme = value . split ( '://' ) [ 0 ] . lower ( )	call the value.split method with '://' as argument, convert first element of the result to lower case, substitute the result for scheme.
if scheme not in self . schemes :	if scheme is not contained in self.schemes,
raise ValidationError ( self . message , code = self . code )	raise a ValidationError exception with arguments self.message and code set to self.code.
try :	try,
super ( URLValidator , self ) . __call__ ( value )	call the __call__ method from the base class of the class URLValidator, with an argument value.
except ValidationError as e :	if ValidationError, renamed to e, is caught,
if value :	if value is true,
scheme , netloc , path , query , fragment = urlsplit ( value )	call the function urlsplit with an argument value, assign the result to scheme, netloc, path, query and fragment, respectively.
try :	try,
netloc = netloc . encode ( 'idna' ) . decode ( 'ascii' )	call the method netloc.encode with an argument string 'idna', on the return value call the decode method with string 'ascii' as argument, substitute the result for netloc.
except UnicodeError :	if UnicodeError exception is caught,
raise e	raise an exception e.
url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )	call the function urlunsplit with a tuple containing 5 elements: scheme, netloc, path, query and fragment, as an argument, substitute the result for url.
super ( URLValidator , self ) . __call__ ( url )	call the __call__ method from the base class of the URLValidator class, with an argument url.
else :	if not,
raise	raise an exception.
else :	if not,
url = value	substitute value for url.
def validate_integer ( value ) :	define the function validate_integer with an argument value.
try :	try,
int ( value )	convert value into an integer.
except ( ValueError , TypeError ) :	if ValueError or TypeError exceptions are caught,
raise ValidationError ( _ ( 'Enter a valid integer.' ) , code = 'invalid' )	raise a ValidationError exception with 2 arguments: return value of the function _ with an string argument 'Enter a valid integer.',
@ deconstructible	and code set to string 'invalid'.   decorator deconstructible,
class EmailValidator ( object ) :	derive the class EmailValidator form the object base class.
message = _ ( 'Enter a valid email address.' )	call a function _ with a string 'Enter a valid value.' as an argument, substitute the result for message.
code = 'invalid'	code is a string 'invalid'.
\user_regex = re . compile (  r'(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*$'  r'|^'([\\001-\\010\\013\\014\\016-\\037!#-\\[\\]-\\177]|\\\\[\\001-\\011\\013\\014\\016-\\177])*'$)' ,  re . IGNORECASE )\	\call the re.compile function with 2 arguments: raw string '(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*$',\
\domain_regex = re . compile (    r'(?:[A-Z0-9](?:[A-Z0-9-]{0,247}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}|[A-Z0-9-]{2,}(?<!-))$' ,  re . IGNORECASE )\	\|^([\\001-\\010\\013\\014\\016-\\037!#-\\[\\]-\\177]|\\\\[\\001-\\011\\013\\014\\016-\\177])*'$)' and re.IGNORECASE, substitute the result for user_regex.    call the re.compile function with 2 arguments: raw string '(?:[A-Z0-9](?:[A-Z0-9-]{0,247}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}|[A-Z0-9-]{2,}(?<!-))$',\
\literal_regex = re . compile (   r'\\[([A-f0-9:\\.]+)\\]$' ,  re . IGNORECASE )\	\and re.IGNORECASE, substitute the result for domain_regex.   call the re.compile function with 2 arguments: raw string '\\[([A-f0-9:\\.]+)\\]$' and re.IGNORECASE, substitute the result for literal_regex.\
domain_whitelist = [ 'localhost' ]	domain_whitelist is a list containing string 'localhost'.
def __init__ ( self , message = None , code = None , whitelist = None ) :	define the __init__ method with 4 arguments: self, message set to None, code set to None and whitelist set to None.
if message is not None :	if message is not None
self . message = message	substitute message for self.message.
if code is not None :	if code is not None
self . code = code	  substitute code for self.code.
if whitelist is not None :	if whitelist is not None
self . domain_whitelist = whitelist	  substitute whitelist for self.domain_whitelist.
def __call__ ( self , value ) :	define the method __call__ with arguments self and value.
value = force_text ( value )	call the function force_text with an argument value, substitute the result for value.
if not value or '@' not in value :	if value is false or character '@' is not contained in value,
raise ValidationError ( self . message , code = self . code )	raise a ValidationError exception with arguments self.message and code set to self.code.
user_part , domain_part = value . rsplit ( '@' , 1 )	call the method value.rsplit with arguments character '@' and integer 1, assign the result to user_part and domain_part, respectively.
if not self . user_regex . match ( user_part ) :	call the self.user_regex.match method with an argument user_part, if it evaluates to false,
raise ValidationError ( self . message , code = self . code )	raise a ValidationError exception with arguments self.message and code set to self.code.
if ( domain_part not in self . domain_whitelist and  not self . validate_domain_part ( domain_part ) ) :	if domain_part is not contained in self.domain_whitelist and method self.validate_domain_part with an argument domain_part evaluates to false,
try :	try,
domain_part = domain_part . encode ( 'idna' ) . decode ( 'ascii' )	call the method domain_part.encode with an argument string 'idna', on the return value call the decode method with string 'ascii' as argument, substitute the result for domain_part.
if self . validate_domain_part ( domain_part ) :	if method self.validate_domain_part with an argument domain_part evaluates to true,
return	return nothing.
except UnicodeError :	if UnicodeError exception is caught,
pass	do nothing.
raise ValidationError ( self . message , code = self . code )	raise a ValidationError exception with arguments self.message and code set to self.code.
def validate_domain_part ( self , domain_part ) :	define the method validate_domain_part with arguments self and domain_part.
if self . domain_regex . match ( domain_part ) :	call the self.domain_regex.match method with an argument domain_part, if it evaluates to true,
return True	return boolean True.
literal_match = self . literal_regex . match ( domain_part )	evaluate method self.literal_regex.match with an argument domain_part, substitute the result for literal_match.
if literal_match :	if literal_match is true,
ip_address = literal_match . group ( 1 )	call the method literal_match.group with an integer 1, substitute the result for ip_address.
try :	try,
validate_ipv46_address ( ip_address )	call the function validate_ipv46_address with an argument ip_address.
return True	return boolean True.
except ValidationError :	if ValidationError exception is caught,
pass	do nothing.
return False	return boolean False.
def __eq__ ( self , other ) :	define the method __eq__ with arguments self and other.
return isinstance ( other , EmailValidator ) and ( self . domain_whitelist == other . domain_whitelist ) and ( self . message == other . message ) and ( self . code == other . code )	if other is instance of EmailValidator and, self.domain_whitelist equals to other.domain_whitelist,
validate_email = EmailValidator ( )	and self.message equals to other.message, and self.code equals to other.code, return boolean True, otherwise return boolean False.   validate_email is an instance of EmailValidator class.
slug_re = re . compile ( r'^[-a-zA-Z0-9_]+$' )	call the re.compile function with an argument raw string '^[-a-zA-Z0-9_]+$', substitute the result for slug_re.
validate_slug = RegexValidator ( slug_re , _ ( 'Enter a valid 'slug' consisting of letters, numbers, underscores or hyphens.' ) , 'invalid' )	validate_slug is a instance of a RegexValidator class, created with 3 arguments: slug_re, return value of the call to the function,
\ipv4_re = re . compile ( r'^(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}$' )\	\_ with an argument string 'Enter a valid 'slug' consisting of letters, numbers, underscores or hyphens.',   and string 'invalid'.   call the re.compile function with an argument raw string '^(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}$',\
validate_ipv4_address = RegexValidator ( ipv4_re , _ ( 'Enter a valid IPv4 address.' ) , 'invalid' )	substitute the result for ipv4_re.   validate_ipv4_address is a instance of a RegexValidator class, created with 3 arguments: ipv4_re,
def validate_ipv6_address ( value ) :	return value of the call to the function _ with an argument string 'Enter a valid IPv4 address.' and string 'invalid'.   define the function validate_ipv6_address with an argument value.
if not is_valid_ipv6_address ( value ) :	call the function is_valid_ipv6_address with an argument value, if it evaluates to false,
raise ValidationError ( _ ( 'Enter a valid IPv6 address.' ) , code = 'invalid' )	raise a ValidationError exception with 2 arguments: return value of the function _ called with an argument string 'Enter a valid IPv6 address.', and code set to string 'invalid'.
def validate_ipv46_address ( value ) :	define the function validate_ipv46_address with an argument value.
try :	try,
validate_ipv4_address ( value )	call the function validate_ipv4_address with an argument value.
except ValidationError :	if ValidationError exception is caught,
try :	try,
validate_ipv6_address ( value )	call the function validate_ipv6_address with an argument value.
except ValidationError :	if ValidationError exception is caught,
raise ValidationError ( _ ( 'Enter a valid IPv4 or IPv6 address.' ) , code = 'invalid' )	raise a ValidationError exception with 2 arguments: return value of the function _ called with an argument string 'Enter a valid IPv4 or IPv6 address.', and code set to string 'invalid'.
ip_address_validator_map = {  'both' : ( [ validate_ipv46_address ] , _ ( 'Enter a valid IPv4 or IPv6 address.' ) ) ,  'ipv4' : ( [ validate_ipv4_address ] , _ ( 'Enter a valid IPv4 address.' ) ) ,  'ipv6' : ( [ validate_ipv6_address ] , _ ( 'Enter a valid IPv6 address.' ) ) ,  }	ip_address_validator_map is a dictionary containing 3 initial entries: tuple containing 2 elements: list with an element,  validate_ipv46_address and return value of the function _ with an argument string 'Enter a valid IPv4 or IPv6 address.' for 'both',
def ip_address_validators ( protocol , unpack_ipv4 ) :	tuple containing 2 elements: list with an element validate_ipv4_address and return value of the function _ with an argument string,   'Enter a valid IPv4 address.' for 'ipv4' and tuple containing 2 elements: list with an element validate_ipv6_address,   and return value of the function _ with an argument string 'Enter a valid IPv6 address.' for 'ipv6'.   define the function ip_address_validators with arguments protocol and unpack_ipv4.
if protocol != 'both' and unpack_ipv4 :	if protocol is not equal to string 'both' and unpack_ipv4 is true,
try :	try,
return ip_address_validator_map [ protocol . lower ( ) ]	convert protocol to lowercase, use it as a key to get a value from the ip_address_validator_map dictionary, return it.
except KeyError :	if KeyError exception is caught,
raise ValueError ( 'The protocol '%s' is unknown. Supported: %s'  % ( protocol , list ( ip_address_validator_map ) ) )	raise a ValueError exception with an argument 'The protocol '%s' is unknown. Supported: %s', replace '%s' with protocol,
\comma_separated_int_list_re = re . compile ( '^[\\d,]+$' )\	\and ip_address_validator_map converted to a list, respectively.   call the re.compile function with an argument raw string '^[\\d,]+$', substitute the result for comma_separated_int_list_re.\
validate_comma_separated_integer_list = RegexValidator ( comma_separated_int_list_re , _ ( 'Enter only digits separated by commas.' ) , 'invalid' )	validate_comma_separated_integer_list is a instance of a RegexValidator class, created with 3 arguments: comma_separated_int_list_re,
@ deconstructible	return value of the call to the function _ with an argument string 'Enter only digits separated by commas.' and string 'invalid'.   decorator deconstructible,
class BaseValidator ( object ) :	derive the class BaseValidator form the object base class.
compare = lambda self , a , b : a is not b	compare is a lambda function with arguments self, a and b, return value is boolean True if a is not b, otherwise it is False.
clean = lambda self , x : x	clean is a lambda function with arguments self and x, return value is x.
message = _ ( 'Ensure this value is %(limit_value)s (it is %(show_value)s).' )	call the function _ with the argument string 'Ensure this value is %(limit_value)s (it is %(show_value)s).', substitute the result for message.
code = 'limit_value'	code is a string 'limit_value'
def __init__ ( self , limit_value ) :	define the method __init__ with self and limit_value as arguments.
self . limit_value = limit_value	substitute the limit_value for self.limit_value.
def __call__ ( self , value ) :	define the method __call__ with arguments self and value.
cleaned = self . clean ( value )	call the method self.clean with value as argument, substitute the result for cleaned.
params = { 'limit_value' : self . limit_value , 'show_value' : cleaned }	params is a dictionary with 2 initial entries: self.limit_value for 'limit_value' and cleaned for 'show_value'.
if self . compare ( cleaned , self . limit_value ) :	call the self.compare method with arguments cleaned and self.limit_value, if it evaluates to true,
raise ValidationError ( self . message , code = self . code , params = params )	raise a ValidationError exception with arguments self.message, code set to self.code and params set to params.
def __eq__ ( self , other ) :	define the method __eq__ with arguments self and other.
return isinstance ( other , self . __class__ ) and ( self . limit_value == other . limit_value ) and ( self . message == other . message ) and ( self . code == other . code )	if other is an instance of self.__class__ and, self.limit_value equals to other.limit_value, and self.message equals to other.message,
@ deconstructible	and self.code equals to other.code, return boolean True, otherwise return boolean False.   decorator deconstructible,
class MaxValueValidator ( BaseValidator ) :	derive the class MaxValueValidator form the BaseValidator base class.
compare = lambda self , a , b : a > b	compare is a lambda function with arguments self, a and b, return value is boolean true if a is greater than b, otherwise is false.
message = _ ( 'Ensure this value is less than or equal to %(limit_value)s.' )	call the function _ with an argument string 'Ensure this value is less than or equal to %(limit_value)s.', substitute the result for message.
code = 'max_value'	code is a string 'max_value'
@ deconstructible	decorator deconstructible,
class MinValueValidator ( BaseValidator ) :	derive the class MinValueValidator form the BaseValidator base class.
compare = lambda self , a , b : a < b	compare is a lambda function with arguments self, a and b, return value is boolean true if a is lesser than b, otherwise is false.
message = _ ( 'Ensure this value is greater than or equal to %(limit_value)s.' )	call the function _ with an argument string 'Ensure this value is greater than or equal to %(limit_value)s.', substitute the result for message.
code = 'min_value'	code is a string 'min_value'
@ deconstructible	decorator deconstructible,
class MinLengthValidator ( BaseValidator ) :	derive the class MinLengthValidator form the BaseValidator base class.
compare = lambda self , a , b : a < b	compare is a lambda function with arguments self, a and b, return value is boolean true if a is lesser than b, otherwise is false.
clean = lambda self , x : len ( x )	clean is a lambda function with self and x as arguments, return value is length of x.
message = ungettext_lazy (  'Ensure this value has at least %(limit_value)d character (it has %(show_value)d).' ,  'Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).' ,  'limit_value' )	call the function ungettext_lazy with 3 arguments: string 'Ensure this value has at least %(limit_value)d character (it has %(show_value)d),
code = 'min_length'	string 'Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).' and string 'limit_value', substitute the result for message.   code is a string 'min_length'
@ deconstructible	decorator deconstructible,
class MaxLengthValidator ( BaseValidator ) :	derive the class MaxLengthValidator form the BaseValidator base class.
compare = lambda self , a , b : a > b	compare is a lambda function with arguments self, a and b, return value is boolean true if a is greater than b, otherwise is false.
clean = lambda self , x : len ( x )	clean is a lambda function with self and x as arguments, return value is length of x.
message = ungettext_lazy (  'Ensure this value has at most %(limit_value)d character (it has %(show_value)d).' ,  'Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).' ,  'limit_value' )	call the function ungettext_lazy with 3 arguments: string 'Ensure this value has at most %(limit_value)d character (it has %(show_value)d),
code = 'max_length'	string 'Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).' and string 'limit_value', substitute the result for message.   code is a string 'max_length'
import django	import module django.
from django . core . handlers . wsgi import WSGIHandler	from django.core.handlers.wsgi import WSGIHandler into default name space.
def get_wsgi_application ( ) :	define the function get_wsgi_application.
django . setup ( )	call the django.setup method.
return WSGIHandler ( )	return WSGIHandler object.
from django . core . exceptions import ValidationError	from django.core.exceptions import ValidationError into default name space.
from django . forms . fields import *	from django.forms.fields import everything into default name space.
from django . forms . forms import *	from django.forms.forms import everything into default name space.
from django . forms . formsets import *	from django.forms.formsets import everything into default name space.
from django . forms . models import *	from django.forms.models import everything into default name space.
from django . forms . widgets import *	from django.forms.widgets import everything into default name space.
from django . forms . extras . widgets import SelectDateWidget	from django.forms.extras.widgets import SelectDateWidget into default name space.
__all__ = [ 'SelectDateWidget' ]	__all__ is an list containing string 'SelectDateWidget'.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import datetime	import module datetime.
import re	import module re.
from django . forms . widgets import Widget , Select	from django.forms.widgets import Widget and Select into default name space.
from django . utils import datetime_safe	from django.utils import datetime_safe into default name space.
from django . utils . dates import MONTHS	from django.utils.dates import MONTHS into default name space.
from django . utils . encoding import force_str	from django.utils.encoding import force_str into default name space.
from django . utils . safestring import mark_safe	from django.utils.safestring import mark_safe into default name space.
from django . utils . formats import get_format	from django.utils.formats import get_format into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . conf import settings	from django.conf import settings into default name space.
__all__ = ( 'SelectDateWidget' , )	__all__ is an tuple containing string 'SelectDateWidget'.
\RE_DATE = re . compile ( r'(\\d{4})-(\\d\\d?)-(\\d\\d?)$' )\	\compile regex from the raw string '(\\d{4})-(\\d\\d?)-(\\d\\d?)$', substitute it for RE_DATE.\
def _parse_date_fmt ( ) :	define the function _parse_date_fmt.
fmt = get_format ( 'DATE_FORMAT' )	call the function get_format with an argument string 'DATE_FORMAT', substitute it for fmt.
escaped = False	escaped is boolean False.
for char in fmt :	for every char in fmt,
if escaped :	if escaped is true,
escaped = False	escaped is boolean False.
\elif char == '\\\\' :\	\otherwise if cahr equals a string '\\\\',\
escaped = True	escaped is boolean True.
elif char in 'Yy' :	otherwis if char is contained in string 'Yy',
yield 'year'	yield string 'year' as an return value of the generator.
elif char in 'bEFMmNn' :	otherwise if char is contained in string 'bEFMmNn',
yield 'month'	yield string 'month' as an return value of the generator.
elif char in 'dj' :	otherwise if char is contained in string 'dj',
yield 'day'	yield string 'day' as an return value of the generator.
class SelectDateWidget ( Widget ) :	derive the class SelectDateWidget for the Widget base class.
none_value = ( 0 , '---' )	none_value is a tuple containing 2 elements: integer 0 and string '---'.
month_field = '%s_month'	month_field is a string '%s_month'.
day_field = '%s_day'	day_field is a string '%s_day'.
year_field = '%s_year'	year_field is a string '%s_year'.
def __init__ ( self , attrs = None , years = None , months = None , empty_label = None ) :	define the method __init__ with 5 arguments: self, attrs set to None, years set to None, months set to None and empty_label set to None.
self . attrs = attrs or { }	if attrs is not None substitute it for self.attrs, or if not self.attrs is an empty dictionary.
if years :	if years is true,
self . years = years	substitute years for self.years.
else :	if not,
this_year = datetime . date . today ( ) . year	call the function datetime.date.today, substitute the year field of the result for this_year.
self . years = range ( this_year , this_year + 10 )	self.years is list containing 10 successive integers from this_year.
if months :	if months is true,
self . months = months	substitute months for self.months.
else :	if not,
self . months = MONTHS	substitute MONTHS for self.months.
if isinstance ( empty_label , ( list , tuple ) ) :	if empty_label is an instance of list or tuple type,
if not len ( empty_label ) == 3 :	if length of empty_label is not equal to integer 3.
raise ValueError ( 'empty_label list/tuple must have 3 elements.' )	raise an ValueError with an argument string 'empty_label list/tuple must have 3 elements.'.
self . year_none_value = ( 0 , empty_label [ 0 ] )	self.year_none_value is a tuple containing 2 elements: integer 0 and first element of empty_label.
self . month_none_value = ( 0 , empty_label [ 1 ] )	self.month_none_value is a tuple containing 2 elements: integer 0 and second element of empty_label.
self . day_none_value = ( 0 , empty_label [ 2 ] )	self.day_none_value is a tuple containing 2 elements: integer 0 and third element of empty_label.
else :	if not,
if empty_label is not None :	if empty_label is not None,
self . none_value = ( 0 , empty_label )	self.none_value is a tuple containing 2 elements: integer 0 and empty_label.
self . year_none_value = self . none_value	substitute self.none_value for self.year_none_value.
self . month_none_value = self . none_value	substitute self.none_value for self.month_none_value.
self . day_none_value = self . none_value	substitute self.none_value for self.day_none_value.
def render ( self , name , value , attrs = None ) :	define the method render with 4 arguments: self, name, value and attrs set to None.
try :	try,
year_val , month_val , day_val = value . year , value . month , value . day	substitute value.year, value.month and value.day for year_val, month_val and day_val, respectively.
except AttributeError :	if AttributeError exception is caught,
year_val = month_val = day_val = None	year_val and month_val and day_val are set to None.
if isinstance ( value , six . string_types ) :	if value is an instance of six.string_types,
if settings . USE_L10N :	if settings.USE_L10N is true,
try :	try,
    input_format = get_format ( 'DATE_INPUT_FORMATS' ) [ 0 ]	call the function get_format with an argument string 'DATE_INPUT_FORMATS', substitute the first element of the result for input_format.
v = datetime . datetime . strptime ( force_str ( value ) , input_format )	call the method datetime.datetime.strptime with 2 arguments: return value of the function force_str called with an argument value,
year_val , month_val , day_val = v . year , v . month , v . day	and input_format, substitute the result for v.   substitute v.year, v.month and v.day for year_val, month_val and day_val, respectively.
except ValueError :	if ValueError exception is caught,
    pass	do nothing.
else :	if not,
match = RE_DATE . match ( value )	call the method RE_DATE.match with an argument value, substitute the result for match.
if match :	if match is true,
    year_val , month_val , day_val = [ int ( v ) for v in match . groups ( ) ]	for v in return value of the function match.groups, convert v into an integer and append i to a list,
html = { }	assign the result for year_val, month_val and day_val, respectively.   html is an empty dictionary.
choices = [ ( i , i ) for i in self . years ]	for every i in self.years append tuple containing i and i elements into a list, substitute the resulting string for choices.
html [ 'year' ] = self . create_select ( name , self . year_field , value , year_val , choices , self . year_none_value )	call the method self.create_select with 6 arguments: name, self.year_field, value, year_val, choices and self.year_none_value,
choices = list ( six . iteritems ( self . months ) )	substitute the result for the value under the 'year' key of the html dictionary.   call the function six.iteritems with an argument self.months, convert the result to a list and substitute it for choices.
html [ 'month' ] = self . create_select ( name , self . month_field , value , month_val , choices , self . month_none_value )	call the method self.create_select with 6 arguments: name, self.month_field, value, month_val, choices and self.month_none_value,
choices = [ ( i , i ) for i in range ( 1 , 32 ) ]	substitute the result for the value under the 'month' key of the html dictionary.   for every i in successive list of integers from 1 to 30, append tuple containing i and i elements into a list,
html [ 'day' ] = self . create_select ( name , self . day_field , value , day_val , choices , self . day_none_value )	substitute the resulting string for choices.   call the method self.create_select with 6 arguments: name, self.year_field, value, day_val, choices and self.day_none_value,
output = [ ]	substitute the result for the value under the 'day' key of the html dictionary.   output is an empty list.
for field in _parse_date_fmt ( ) :	for every field in return value of the function _parse_date_fmt,
output . append ( html [ field ] )	get the value under the field key of the html dictionary, append it to output.
\return mark_safe ( '\\n' . join ( output ) )\	join output into a string, separated by newline characters, use it as an argument for the call to the mark_safe, return the result.
def id_for_label ( self , id_ ) :	define the method id_for_label with arguments self and id.
for first_select in _parse_date_fmt ( ) :	for every first_select in return value of the function _parse_date_fmt.
return '%s_%s' % ( id_ , first_select )	substitute '%s' in string '%s_%s' with id_ and first_select, return it.
else :	if not,
return '%s_month' % id_	convert if into a string append to it a string '_month', return the result.
def value_from_datadict ( self , data , files , name ) :	define the method id_for_label with arguments self, data, files and name.
y = data . get ( self . year_field % name )	format self.year_field string with name, use it as the key for the data dictionary, substitute the result for y.
m = data . get ( self . month_field % name )	format self.month_field string with name, use it as the key for the data dictionary, substitute the result for m.
d = data . get ( self . day_field % name )	format self.day_field string with name, use it as the key for the data dictionary, substitute the result for d.
if y == m == d == '0' :	if y, m and d are all equal to string '0',
return None	return None.
if y and m and d :	if y and m and d are all true,
if settings . USE_L10N :	if settings.USE_L10N is true,
input_format = get_format ( 'DATE_INPUT_FORMATS' ) [ 0 ]	call the function get_format with an argument string 'DATE_INPUT_FORMATS', substitute the first element of the result for input_format.
try :	try,
date_value = datetime . date ( int ( y ) , int ( m ) , int ( d ) )	call the function datetime.date with 3 arguments: y, m and d all converted into a integers, substitute the result for date_value.
except ValueError :	if ValueError exception is caught,
return '%s-%s-%s' % ( y , m , d )	substitute '%s' in string '%s-%s-%s' with y,m and d, return the result.
else :	if not,
date_value = datetime_safe . new_date ( date_value )	call the method datetime_safe.new_date with an argument date_value, substitute the result for date_value.
return date_value . strftime ( input_format )	call the method date_value.strftime with an argument input_format, return the result.
else :	if not,
return '%s-%s-%s' % ( y , m , d )	substitute '%s' in string '%s-%s-%s' with y, m and d, return the result.
return data . get ( name , None )	get the name key of the data dictionary, if the key exists return it, if not return None.
def create_select ( self , name , field , value , val , choices , none_value ) :	define the method id_for_label with arguments self, name, field, value, val, choices and none_value.
if 'id' in self . attrs :	if 'id' is contained in self.attrs,
id_ = self . attrs [ 'id' ]	get the value under the 'id' key of the attrs dictionary, substitute the return value field of the self object for id_.
else :	if not,
id_ = 'id_%s' % name	substitute '%s' in string 'id_%s' with name, return it.
if not self . is_required :	if self.is_required is false,
choices . insert ( 0 , none_value )	insert none_value at the beginning of the choices list.
local_attrs = self . build_attrs ( id = field % id_ )	call the method self.build_attrs with an argument id set to field modulus id_, substitute the result for local_attrs.
s = Select ( choices = choices )	s is an instance of the Select class, created with choices set to choices.
select_html = s . render ( field % name , val , local_attrs )	call the method s.render with 3 arguments: field string formated with name, val and local_attrs, substitute the result for select_html.
return select_html	return select_html.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import copy	import module copy.
import datetime	import module datetime.
import os	import module os.
import re	import module re.
import sys	import module sys.
import warnings	import module warnings.
from decimal import Decimal , DecimalException	from decimal import Decimal and DecimalException into default name space.
from io import BytesIO	from io import BytesIO into default name space.
from django . core import validators	from django.core import validators into default name space.
from django . core . exceptions import ValidationError	from django.core.exceptions import ValidationError into default name space.
from django . forms . utils import from_current_timezone , to_current_timezone	from django.forms.utils import from_current_timezone and to_current_timezone into default name space.
from django . forms . widgets import (  TextInput , NumberInput , EmailInput , URLInput , HiddenInput ,  MultipleHiddenInput , ClearableFileInput , CheckboxInput , Select ,  NullBooleanSelect , SelectMultiple , DateInput , DateTimeInput , TimeInput ,  SplitDateTimeWidget , SplitHiddenDateTimeWidget , FILE_INPUT_CONTRADICTION  )	from django.forms.widgets import TextInput, NumberInput, EmailInput, URLInput, HiddenInput, MultipleHiddenInput, ClearableFileInput,
from django . utils import formats	CheckboxInput, Select, NullBooleanSelect, SelectMultiple, DateInput, DateTimeInput, TimeInput, SplitDateTimeWidget,   SplitHiddenDateTimeWidget and FILE_INPUT_CONTRADICTION.   from django.utils import formats into default name space.
from django . utils . encoding import smart_text , force_str , force_text	from django.utils.encoding import smart_text, force_str and force_text into default name space.
from django . utils . ipv6 import clean_ipv6_address	from django.utils.ipv6 import clean_ipv6_address into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . six . moves . urllib . parse import urlsplit , urlunsplit	from django.utils.six.moves.urllib.parse import urlsplit and urlunsplit into default name space.
from django . utils . translation import ugettext_lazy as _ , ungettext_lazy	from django.utils.translation import ugettext_lazy as _ and ungettext_lazy into default name space.
from django . core . validators import EMPTY_VALUES	from django.core.validators import EMPTY_VALUES into default name space.
__all__ = (  'Field' , 'CharField' , 'IntegerField' ,  'DateField' , 'TimeField' , 'DateTimeField' ,  'RegexField' , 'EmailField' , 'FileField' , 'ImageField' , 'URLField' ,  'BooleanField' , 'NullBooleanField' , 'ChoiceField' , 'MultipleChoiceField' ,  'ComboField' , 'MultiValueField' , 'FloatField' , 'DecimalField' ,  'SplitDateTimeField' , 'IPAddressField' , 'GenericIPAddressField' , 'FilePathField' ,  'SlugField' , 'TypedChoiceField' , 'TypedMultipleChoiceField'  )	__all__ a tuple containing strings: 'Field', 'CharField', 'IntegerField', 'DateField', 'TimeField', 'DateTimeField', 'RegexField',
class Field ( object ) :	'EmailField', 'FileField', 'ImageField', 'URLField', 'BooleanField', 'NullBooleanField', 'ChoiceField', 'MultipleChoiceField',   'ComboField', 'MultiValueField', 'FloatField', 'DecimalField', 'SplitDateTimeField', 'IPAddressField', 'GenericIPAddressField',   'FilePathField', 'SlugField', 'TypedChoiceField', 'TypedMultipleChoiceField'.   derive the class Field from the base class object.
widget = TextInput	substitute substitute TextInput for widget.
hidden_widget = HiddenInput	substitute HiddenInput for hidden_widget.
default_validators = [ ]	default_validators is an empty list.
default_error_messages = {  'required' : _ ( 'This field is required.' ) ,  }	default_error_messages is an dictionary containing entry: return value of the function _ called with an string 'This field is required.' for 'required'.
empty_values = list ( validators . EMPTY_VALUES )	put elements of validators.EMPTY_VALUES to a list, substitute the result for empty_values.
creation_counter = 0	creation_counter is an integer 0.
def __init__ ( self , required = True , widget = None , label = None , initial = None ,  help_text = '' , error_messages = None , show_hidden_initial = False ,  validators = [ ] , localize = False , label_suffix = None ) :	define the function __init__ with 11 arguments: self, required set to boolean True, widget set to None, label set to None,
          self . required , self . label , self . initial = required , label , initial	initial set to None, help_text set to an empty string, error_messages set to None, show_hidden_initial set to boolean False,   validators is an empty, localize set to boolean False, label_suffix set to None.   substitute required, label and initial for self.required, self.label and self.initial.
self . show_hidden_initial = show_hidden_initial	substitute show_hidden_initial for self.show_hidden_initial.
self . help_text = help_text	substitute help_text for self.help_text.
self . label_suffix = label_suffix	substitute label_suffix for self.label_suffix.
widget = widget or self . widget	substitute self.widget if the widget is false, otherwise substitute widget for widget.
if isinstance ( widget , type ) :	if widget is an instance of type class,
widget = widget ( )	call the function widget, substitute the result for widget.
self . localize = localize	substitute localize for self.localize.
if self . localize :	if self.localize is true,
widget . is_localized = True	widget.is_localized is boolean True.
widget . is_required = self . required	substitute self.required for widget.is_required.
extra_attrs = self . widget_attrs ( widget )	call the method self.widget_attrs with an argument widget, substitute the result for extra_attrs.
if extra_attrs :	if extra_attrs is true,
widget . attrs . update ( extra_attrs )	update widget.attrs dictionary with extra_attrs.
self . widget = widget	substitute widget for self.widget.
self . creation_counter = Field . creation_counter	substitute Field.creation_counter for self.creation_counter.
Field . creation_counter += 1	increment Field.creation_counter by one.
messages = { }	messages is an empty dictionary.
for c in reversed ( self . __class__ . __mro__ ) :	for every c in reversed order of self.__class__.__mro__,
messages . update ( getattr ( c , 'default_error_messages' , { } ) )	get 'default_error_messages' from the c object, if it doesnt exists return an empty dictionary,
messages . update ( error_messages or { } )	use the result as the argument for the call to the messages.update function.   update messages dictionary with error_messages, if it exists, if not don't update it.
self . error_messages = messages	substitute messages for self.error_messages.
self . validators = self . default_validators + validators	add self.default_validators and validators, substitute the result for self.validators.
super ( Field , self ) . __init__ ( )	call the method __init__ from the base class of the Field class.
def prepare_value ( self , value ) :	define the method prepare_value with arguments: self and value.
return value	return value.
def to_python ( self , value ) :	define the method to_python with arguments self and value.
return value	return value.
def validate ( self , value ) :	define the method to_python with arguments self and value.
if value in self . empty_values and self . required :	if value is contained in self.empty_values and self.required is true,
raise ValidationError ( self . error_messages [ 'required' ] , code = 'required' )	raise an ValidationError with 2 arguments: value under the 'required' key of the self.error_messages dictionary and code set to string 'required'.
def run_validators ( self , value ) :	define the method run_validators with arguments self and value.
if value in self . empty_values :	if value is contained in self.empty_values,
return	return nothing,
errors = [ ]	errors is an empty list.
for v in self . validators :	for every v in self.validators,
try :	try
v ( value )	call the function v with an argument value.
except ValidationError as e :	if ValidationError, substituted for e, exception is caught,
if hasattr ( e , 'code' ) and e . code in self . error_messages :	if e has an attribute 'code' and e.code is contained in self.error_messages,
e . message = self . error_messages [ e . code ]	get the value under the e.code key of the self.error_messages dictionary, substitute the result for e.message.
errors . extend ( e . error_list )	extend errors list with e.error_list.
if errors :	if errors is true,
raise ValidationError ( errors )	raise an ValidationError exception with an argument errors,
def clean ( self , value ) :	define the method clean with arguments self and value.
value = self . to_python ( value )	call the method self.to_python with an argument value, substitute it for value.
self . validate ( value )	call the method self.validate with an argument value.
self . run_validators ( value )	call the method self.run_validators with an argument value.
return value	return value.
def bound_data ( self , data , initial ) :	define the method bound_data with arguments self, data and initial.
return data	return data.
def widget_attrs ( self , widget ) :	define the method widget_attrs with arguments self and widget.
return { }	return is empty dictionary.
def get_limit_choices_to ( self ) :	define the method get_limit_choices_to with arguments self.
if callable ( self . limit_choices_to ) :	if self.limit_choices_to object is callable,
return self . limit_choices_to ( )	call the method self.limit_choices_to, return the result,
return self . limit_choices_to	return self.limit_choices_to.
def _has_changed ( self , initial , data ) :	define the method _has_changed with arguments self, initial and data.
initial_value = initial if initial is not None else ''	substitute initial for initial_value, if initial is not None, if not, initial_value is an empty string.
try :	try,
data = self . to_python ( data )	call the function self.to_python with an argument data, substitute the result for data.
if hasattr ( self , '_coerce' ) :	if self has an attribute '_coerce',
data = self . _coerce ( data )	call the method self._coerce with an argument data, substitute the result for data.
except ValidationError :	if ValidationError exception is caught,
return True	return boolean True.
data_value = data if data is not None else ''	substitute data for data_value if data is not None, otherwise data_value is an empty list.
return initial_value != data_value	if initial_value is not equal to data_value, return boolean True, otherwise return boolean False.
def __deepcopy__ ( self , memo ) :	define the method __deepcopy__ with arguments self and memo.
result = copy . copy ( self )	call the method copy.copy with an argument self, substitute the result for result.
memo [ id ( self ) ] = result	substitute result for the value of the memo dictionary, with identity of the self object as an key.
result . widget = copy . deepcopy ( self . widget , memo )	call the method copy.deepcopy with arguments self.widget and memo, substitute the result for result.widget.
result . validators = self . validators [ : ]	substitute elements of self.validators list for result.validators.
return result	return result.
class CharField ( Field ) :	derive the class CharField from the base class Field class.
def __init__ ( self , max_length = None , min_length = None , * args , ** kwargs ) :	define the method __init__ with 5 arguments: self, max_length set to None, min_length set to None, unpacked list args,
self . max_length , self . min_length = max_length , min_length	and unpacked dictionary kwargs.   substitute max_length and min_length for self.max_length for self.min_length.
super ( CharField , self ) . __init__ ( * args , ** kwargs )	call the method __init__ from the base class of the class CharField, with arguments unpacked list args and unpacked dictionary kwargs.
if min_length is not None :	if min_length is not None,
self . validators . append ( validators . MinLengthValidator ( int ( min_length ) ) )	call the method validators.MinLengthValidator with min_length converted into an integer, append the result to list self.validators.
if max_length is not None :	if max_length is not None,
self . validators . append ( validators . MaxLengthValidator ( int ( max_length ) ) )	call the method validators.MaxLengthValidator with max_length converted into an integer, append the result to list self.validators.
def to_python ( self , value ) :	define the method to_python with arguments self and value.
if value in self . empty_values :	if value in self.empty_values,
return ''	return an empty string.
return smart_text ( value )	evaluate the function smart_text with an argument value, return the result.
def widget_attrs ( self , widget ) :	define the method widget_attrs with arguments self and widget.
attrs = super ( CharField , self ) . widget_attrs ( widget )	call the method widget_attrs from the base class of the class CharField, with an argument widget, substitute the result for attrs.
if self . max_length is not None :	if self.max_length is not None,
attrs . update ( { 'maxlength' : str ( self . max_length ) } )	update attrs dictionary with entry: self.max_length converted into a string for 'maxlength'.
return attrs	return attrs.
class IntegerField ( Field ) :	derive the class IntegerField from the base class Field class.
widget = NumberInput	substitute NumberInput for widget.
default_error_messages = {  'invalid' : _ ( 'Enter a whole number.' ) ,  }	default_error_messages is an dictionary with an initial entry: result of the function _ called with an argument string,
def __init__ ( self , max_value = None , min_value = None , * args , ** kwargs ) :	'Enter a whole number.' for 'invalid'.   define the method __init__ with 5 arguments: self, max_value set to None, min_value set to None, unpacked list args and unpacked dictionary kwargs.
self . max_value , self . min_value = max_value , min_value	substitute max_value and min_value for self.max_value and self.min_value.
if kwargs . get ( 'localize' ) and self . widget == NumberInput :	get the value under the 'localize' key of the kwargs dictionary, if it is true and self.widget equals to NumberInput,
kwargs . setdefault ( 'widget' , super ( IntegerField , self ) . widget )	if 'widget' key of the kwargs dictionary doesnt exists assign it widget field of the base class of the IntegerField class value.
super ( IntegerField , self ) . __init__ ( * args , ** kwargs )	call the method __init__ from the base class of the class IntegerField, with arguments unpacked list args and unpacked dictionary kwargs.
if max_value is not None :	if max_value is not None,
self . validators . append ( validators . MaxValueValidator ( max_value ) )	call the method validators.MaxValueValidator with max_value converted into an integer, append the result to list self.validators.
if min_value is not None :	if min_value is not None,
self . validators . append ( validators . MinValueValidator ( min_value ) )	call the method validators.MinValueValidator with min_value converted into an integer, append the result to list self.validators.
def to_python ( self , value ) :	define the method to_python with arguments self and value.
value = super ( IntegerField , self ) . to_python ( value )	call the method to_python with an argument value, from the base class of the IntegerField class, substitute the result for value.
if value in self . empty_values :	if value is contained in self.empty_values,
return None	return None.
if self . localize :	if self.localize is true,
value = formats . sanitize_separators ( value )	call the method formats.sanitize_separators with an argument value, substitute the result for value.
try :	try,
value = int ( str ( value ) )	convert value into an string, convert the result into an integer and substitute it for value.
except ( ValueError , TypeError ) :	if ValueError or TypeError exceptions are caught,
raise ValidationError ( self . error_messages [ 'invalid' ] , code = 'invalid' )	raise an ValidationError with 2 arguments: value under the 'invalid' key of the self.error_messages dictionary and code set to 'invalid'.
return value	return value
def widget_attrs ( self , widget ) :	define the method widget_attrs with arguments self and widget.
attrs = super ( IntegerField , self ) . widget_attrs ( widget )	call the method widget_attrs with an argument widget, from the base class of the class IntegerField, substitute it for attrs.
if isinstance ( widget , NumberInput ) :	if widget is an instance of the NumberInput,
if self . min_value is not None :	if self.min_value is not None,
attrs [ 'min' ] = self . min_value	substitute self.min_value for the value under the 'min' key of the attrs dictionary.
if self . max_value is not None :	if self.max_value is not None,
attrs [ 'max' ] = self . max_value	substitute self.max_value for the value under the 'max' key of the attrs dictionary.
return attrs	return attrs.
class FloatField ( IntegerField ) :	derive the class FloatField from the base class IntegerField class.
default_error_messages = {  'invalid' : _ ( 'Enter a number.' ) ,  }	default_error_messages is an dictionary with an initial entry: result of the function _ called with an argument string,
def to_python ( self , value ) :	'Enter a number.' for 'invalid'.   define the method to_python with arguments self and value.
value = super ( IntegerField , self ) . to_python ( value )	call the method to_python with an argument value, from the base class of the IntegerField class, substitute the result for value.
if value in self . empty_values :	if value is contained in self.empty_values,
return None	return None.
if self . localize :	if self.localize is true,
value = formats . sanitize_separators ( value )	call the method formats.sanitize_separators with an argument value, substitute the result for value.
try :	try,
value = float ( value )	convert value into an floating point number, substitute it for value.
except ( ValueError , TypeError ) :	if ValueError or TypeError exceptions are caught,
raise ValidationError ( self . error_messages [ 'invalid' ] , code = 'invalid' )	raise an ValidationError with 2 arguments: value under the 'invalid' key of the self.error_messages dictionary and code set to 'invalid'.
return value	return value.
def validate ( self , value ) :	define the method validate with arguments self and value.
super ( FloatField , self ) . validate ( value )	call the method validate with an argument value, from the base class of the FloatField class.
if value != value or value in ( Decimal ( 'Inf' ) , Decimal ( '-Inf' ) ) :	if value is Nan, or value is contained in return value of the Decimal called twice with string 'Inf' and with string '-Inf',
raise ValidationError ( self . error_messages [ 'invalid' ] , code = 'invalid' )	raise an ValidationError with 2 arguments: value under the 'invalid' key of the self.error_messages dictionary and code set to 'invalid'.
return value	return value.
def widget_attrs ( self , widget ) :	define the method widget_attrs with arguments self and widget.
attrs = super ( FloatField , self ) . widget_attrs ( widget )	call the method widget_attrs with an argument widget, from the base class of the FloatField class, substitute the result for attrs.
if isinstance ( widget , NumberInput ) and 'step' not in widget . attrs :	if widget is an instance of the NumberInput class, and string 'step' is not contained in widget.attrs,
attrs . setdefault ( 'step' , 'any' )	if 'step' attribute of attrs dictionary does not exists, set it to to string 'any'.
return attrs	return attrs.
class DecimalField ( IntegerField ) :	derive the class DecimalField from the base class IntegerField class.
default_error_messages = {  'invalid' : _ ( 'Enter a number.' ) ,  'max_digits' : ungettext_lazy (  'Ensure that there are no more than %(max)s digit in total.' ,  'Ensure that there are no more than %(max)s digits in total.' ,  'max' ) ,  'max_decimal_places' : ungettext_lazy (  'Ensure that there are no more than %(max)s decimal place.' ,  'Ensure that there are no more than %(max)s decimal places.' ,  'max' ) ,  'max_whole_digits' : ungettext_lazy (  'Ensure that there are no more than %(max)s digit before the decimal point.' ,  'Ensure that there are no more than %(max)s digits before the decimal point.' ,  'max' ) ,  }	default_error_messages is a dictionary with 4 initial entries: return value of the function _ called with string as an argument,
def __init__ ( self , max_value = None , min_value = None , max_digits = None , decimal_places = None , * args , ** kwargs ) :	'Enter a number.' for 'invalid', return value of the function ungettext_lazy called with 3 string arguments:   'Ensure that there are no more than %(max)s digit in total.', 'Ensure that there are no more than %(max)s digits in total.',   and 'max' for 'max_digits', return value of the function ungettext_lazy called with 3 string arguments:   'Ensure that there are no more than %(max)s decimal place.', 'Ensure that there are no more than %(max)s decimal places.' and 'max',   for 'max_decimal_places' and return value of the function ungettext_lazy called with 3 string arguments:   'Ensure that there are no more than %(max)s digit before the decimal point.',   'Ensure that there are no more than %(max)s digits before the decimal point.' and 'max' for 'max_whole_digits'.   define the method __init__ with 7 arguments: self, max_value set to None, min_value set to None, max_digits set to None,
self . max_digits , self . decimal_places = max_digits , decimal_places	decimal_places set to None, unpacked list args and unpacked dictionary kwargs.   substitute max_digits and decimal_places for self.max_digits and self.decimal_places.
super ( DecimalField , self ) . __init__ ( max_value , min_value , * args , ** kwargs )	call the method __init__ from the base class of the class DecimalField, with 4 arguments: max_value, min_value,
def to_python ( self , value ) :	unpacked list args and unpacked dictionary kwargs.   define the method to_python with arguments self and value.
if value in self . empty_values :	if value is contained in self.empty_values,
return None	return None.
if self . localize :	if self.localize is true,
value = formats . sanitize_separators ( value )	call the method formats.sanitize_separators with an argument value, substitute the result for value.
value = smart_text ( value ) . strip ( )	call the function smart_text with an argument value, strip the result of whitespaces from both ends and substitute it for value.
try :	try,
value = Decimal ( value )	value is an instance of a class Decimal created with value as an argument.
except DecimalException :	if DecimalException exception is caught,
raise ValidationError ( self . error_messages [ 'invalid' ] , code = 'invalid' )	raise an ValidationError with 2 arguments: value under the 'invalid' key of the self.error_messages dictionary and code set to 'invalid'.
return value	return value.
def validate ( self , value ) :	define the method validate with arguments self and value.
super ( DecimalField , self ) . validate ( value )	call the method validate with an argument value from the base class of the DecimalField class.
if value in self . empty_values :	if value is contained in self.empty_values,
return	return nothing.
if value != value or value == Decimal ( 'Inf' ) or value == Decimal ( '-Inf' ) :	if value is not equal to value or value equals return value of the call to Decimal with argument 'Inf',
raise ValidationError ( self . error_messages [ 'invalid' ] , code = 'invalid' )	or value equals return value of the call to Decimal with argument '-Inf'   raise an ValidationError with 2 arguments: value under the 'invalid' key of the self.error_messages dictionary and code set to 'invalid'.
sign , digittuple , exponent = value . as_tuple ( )	call the method value.as_tuple, assign the result to sign, digittuple and exponent, respectively.
decimals = abs ( exponent )	substitute absolute value of the exponent for decimals.
digits = len ( digittuple )	substitute length of digittuple for digits.
if decimals > digits :	if decimals is greater than digits,
digits = decimals	substitute decimals for digits.
whole_digits = digits - decimals	subtract decimals from digits, substitute the result for whole_digits.
if self . max_digits is not None and digits > self . max_digits :	if self.max_digits is not None and digits is grater than self.max_digits,
raise ValidationError (  self . error_messages [ 'max_digits' ] ,  code = 'max_digits' ,  params = { 'max' : self . max_digits } ,  )	raise an ValidationError with 3 arguments: value under the 'max_digits' key of the self.error_messages dictionary,
if self . decimal_places is not None and decimals > self . decimal_places :	code set to string 'max_digits' and params set to a dictionary with an entry: self.max_digits for 'max'.   if self.decimal_places is not None and decimals is grater than self.decimal_places:
raise ValidationError (  self . error_messages [ 'max_decimal_places' ] ,  code = 'max_decimal_places' ,  params = { 'max' : self . decimal_places } ,  )	raise an ValidationError with 3 arguments: value under the 'max_decimal_places' key of the self.error_messages dictionary,
if ( self . max_digits is not None and self . decimal_places is not None  and whole_digits > ( self . max_digits - self . decimal_places ) ) :	code set to string 'max_decimal_places' and params set to a dictionary with an entry: self.decimal_places for 'max'.    if self.max_digits is not None and self.decimal_places is not None and whole_digits is grater than the difference of,
raise ValidationError (  self . error_messages [ 'max_whole_digits' ] ,  code = 'max_whole_digits' ,  params = { 'max' : ( self . max_digits - self . decimal_places ) } ,  )	self.max_digits and self.decimal_places,   raise an ValidationError with 3 arguments: value under the 'max_whole_digits' key of the self.error_messages dictionary,
return value	code set to string 'max_whole_digits' and params set to a dictionary with an entry: difference of the self.max_digits and self.decimal_places, for 'max'.    return value.
def widget_attrs ( self , widget ) :	define the method widget_attrs with arguments self and widget.
attrs = super ( DecimalField , self ) . widget_attrs ( widget )	call the method widget_attrs with an argument widget, from the base class of the DecimalField class, substitute the result for attrs.
if isinstance ( widget , NumberInput ) and 'step' not in widget . attrs :	if widget is an instance of NumberInput and string 'step' is not contained in widget.attrs.
if self . decimal_places is not None :	if self.decimal_places is not None,
step = str ( Decimal ( '1' ) / 10 ** self . decimal_places ) . lower ( )	call the object Decimal with string '1' as an argument, divide it by 10, bring the result to the power of self.decimal_places,
else :	convert the result to a lowercase string, substitute it for step.   if not,
step = 'any'	step is an string 'any'.
attrs . setdefault ( 'step' , step )	if 'step' key of the attrs dictionary doesnt exists assign it step as an value.
return attrs	return attrs.
class BaseTemporalField ( Field ) :	derive the class BaseTemporalField from the base class Field class.
def __init__ ( self , input_formats = None , * args , ** kwargs ) :	define the method __init__ with arguments self, input_formats set to None, unpacked list args and unpacked dictionary kwargs.
super ( BaseTemporalField , self ) . __init__ ( * args , ** kwargs )	call the method __init__ from the base class of the BaseTemporalField class, with arguments: unpacked list args and unpacked dictionary kwargs.
if input_formats is not None :	if input_formats is not None,
self . input_formats = input_formats	substitute input_formats for self.input_formats.
def to_python ( self , value ) :	define the method to_python with arguments self and value.
unicode_value = force_text ( value , strings_only = True )	call the function force_text with arguments value and strings_only set to boolean True, substitute the result for unicode_value.
if isinstance ( unicode_value , six . text_type ) :	if unicode_value is an instance of six.text_type,
value = unicode_value . strip ( )	strip whitespaces from both ends of unicode_value, substitute the result for value.
if isinstance ( value , six . text_type ) :	if value is an instance of six.text_type class,
for format in self . input_formats :	for every format in self.input_formats,
try :	try,
return self . strptime ( value , format )	call the method self.strptime with arguments value and format, return the result.
except ( ValueError , TypeError ) :	if ValueError or TypeError exceptions are caught,
continue	skip this loop iteration.
raise ValidationError ( self . error_messages [ 'invalid' ] , code = 'invalid' )	raise an ValidationError with 2 arguments: value under the 'invalid' key of the self.error_messages dictionary and code set to 'invalid'.
def strptime ( self , value , format ) :	define the method strptime with arguments self, value and format.
raise NotImplementedError ( 'Subclasses must define this method.' )	raise an NotImplementedError with an argument string 'Subclasses must define this method.'.
class DateField ( BaseTemporalField ) :	derive the class DateField from the base class BaseTemporalField class.
widget = DateInput	substitute DateInput for widget.
input_formats = formats . get_format_lazy ( 'DATE_INPUT_FORMATS' )	call the method formats.get_format_lazy with an argument string 'DATE_INPUT_FORMATS', substitute the result for input_formats.
default_error_messages = {  'invalid' : _ ( 'Enter a valid date.' ) ,  }	default_error_messages is an dictionary with an entry: return value of the function _ called with an argument string 'Enter a valid date.' for 'invalid'.
def to_python ( self , value ) :	define the method to_python with arguments self and value.
if value in self . empty_values :	if value is contained in self.empty_values,
return None	return None.
if isinstance ( value , datetime . datetime ) :	if value is an instance of datetime.datetime class,
return value . date ( )	call the method value.date, return the result.
if isinstance ( value , datetime . date ) :	if value is an instance of datetime.date class,
return value	return value.
return super ( DateField , self ) . to_python ( value )	call the method to_python with an argument value from the base class of the DateField class, return the result.
def strptime ( self , value , format ) :	define the method strptime with arguments self, value and format.
return datetime . datetime . strptime ( force_str ( value ) , format ) . date ( )	call the method datetime.datetime.strptime with 2 arguments: result of the function force_str called with an argument value,
class TimeField ( BaseTemporalField ) :	and format, call the method date on the result, return the result.   derive the class TimeField from the base class BaseTemporalField class.
widget = TimeInput	substitute TimeInput for widget.
input_formats = formats . get_format_lazy ( 'TIME_INPUT_FORMATS' )	call the method formats.get_format_lazy with an argument string 'TIME_INPUT_FORMATS', substitute the result for input_formats.
default_error_messages = {  'invalid' : _ ( 'Enter a valid time.' )  }	default_error_messages is an dictionary with an entry: return value of the function _ called with an argument string 'Enter a valid time.' for 'invalid'.
def to_python ( self , value ) :	define the method to_python with arguments self and value.
if value in self . empty_values :	if value is contained in self.empty_values,
return None	return None.
if isinstance ( value , datetime . time ) :	if value is an instance of datetime.time,
return value	return value,
return super ( TimeField , self ) . to_python ( value )	call the method to_python with an argument value from the base class of the TimeField class, return the result.
def strptime ( self , value , format ) :	define the method strptime with arguments self, value and format.
return datetime . datetime . strptime ( force_str ( value ) , format ) . time ( )	call the method datetime.datetime.strptime with 2 arguments: result of the function force_str called with an argument value,
class DateTimeField ( BaseTemporalField ) :	and format, call the method time on the result, return the result.   derive the class DateTimeField from the base class BaseTemporalField class.
widget = DateTimeInput	substitute DateTimeInput for widget.
input_formats = formats . get_format_lazy ( 'DATETIME_INPUT_FORMATS' )	call the method formats.get_format_lazy with an argument string 'DATETIME_INPUT_FORMATS', substitute the result for input_formats.
default_error_messages = {  'invalid' : _ ( 'Enter a valid date/time.' ) ,  }	default_error_messages is an dictionary with an entry: return value of the function _ called with an argument string 'Enter a valid date/time.' for 'invalid'.
def prepare_value ( self , value ) :	define the method prepare_value with arguments self and value.
if isinstance ( value , datetime . datetime ) :	if value is an instance of datetime.datetime,
value = to_current_timezone ( value )	call the function to_current_timezone with an argument value, substitute the result for value.
return value	return value.
def to_python ( self , value ) :	define the method to_python with arguments self and value.
if value in self . empty_values :	if value is contained in self.empty_values,
return None	return None.
if isinstance ( value , datetime . datetime ) :	if value is an instance of datetime.datetime,
return from_current_timezone ( value )	call the function __current_timezone with an argument value, return the result.
if isinstance ( value , datetime . date ) :	if value is an instance of datetime.date,
result = datetime . datetime ( value . year , value . month , value . day )	call the function datetime.datetime with 3 arguments: value.year, value.month and value.day, substitute the result for result.
return from_current_timezone ( result )	call the function from_current_timezone with an argument result, return the result.
if isinstance ( value , list ) :	if value is an instance of list type,
warnings . warn (  'Using SplitDateTimeWidget with DateTimeField is deprecated. '  'Use SplitDateTimeField instead.' ,  RemovedInDjango19Warning , stacklevel = 2 )	call the function warnings.warn with 3 arguments: string 'Using SplitDateTimeWidget with DateTimeField is deprecated. '
if len ( value ) != 2 :	'Use SplitDateTimeField instead.', RemovedInDjango19Warning and stacklevel set to integer 2.   if length of value is not equal to integer 2,
raise ValidationError ( self . error_messages [ 'invalid' ] , code = 'invalid' )	raise an ValidationError with 2 arguments: value under the 'invalid' key of the self.error_messages dictionary and code set to 'invalid'.
if value [ 0 ] in self . empty_values and value [ 1 ] in self . empty_values :	if first and second elements of value are contained in self.empty_values,
return None	return None.
value = '%s %s' % tuple ( value )	substitute '%s' in string '%s %s' with the elements of value converted into a tuple, substitute the result for value.
result = super ( DateTimeField , self ) . to_python ( value )	call the method to_python with an argument value from the base class of the DateTimeField class, substitute the result for result.
return from_current_timezone ( result )	call the function from_current_timezone with an argument, return the result.
def strptime ( self , value , format ) :	define the method strptime with arguments self, value and format.
return datetime . datetime . strptime ( force_str ( value ) , format )	call the method datetime.datetime.strptime with 2 arguments: result of the function force_str called with an argument value,
class RegexField ( CharField ) :	and format, return the result.   derive the class RegexField from the base class CharField class.
def __init__ ( self , regex , max_length = None , min_length = None , error_message = None , * args , ** kwargs ) :	define the method __init__ with 7 arguments: self, regex, max_length set to None, min_length set to None, error_message set to None,
if error_message is not None :	if error_message is not None,
error_messages = kwargs . get ( 'error_messages' ) or { }	get the value under the 'error_messages' key of the kwargs dictionary, if it exists substitute it for error_messages, if not,
error_messages [ 'invalid' ] = error_message	error_messages is an empty dictionary.   substitute error_message for value under the 'invalid' key of the error_messages dictionary.
kwargs [ 'error_messages' ] = error_messages	substitute error_messages for value under the ''error_messages' key of the kwargs dictionary.
super ( RegexField , self ) . __init__ ( max_length , min_length , * args , ** kwargs )	call the method __init__ from the base class of the class RegexField, with 4 arguments: max_length, min_length, unpacked list args,
self . _set_regex ( regex )	unpacked dictionary kwargs.   call the method self._set_regex with an argument regex.
def _get_regex ( self ) :	define the method _get_regex an argument self.
return self . _regex	return self._regex.
def _set_regex ( self , regex ) :	define the method _set_regex with arguments self and regex.
if isinstance ( regex , six . string_types ) :	if regex is an instance of six.string_types class,
regex = re . compile ( regex , re . UNICODE )	call the function re.compile with 2 arguments regex, re.UNICODE and substitute the result for regex.
self . _regex = regex	substitute regex for self._regex.
if hasattr ( self , '_regex_validator' ) and self . _regex_validator in self . validators :	if self has an '_regex_validator' attribute and self._regex_validator is contained in self.validators,
self . validators . remove ( self . _regex_validator )	remove self._regex_validator from self.validators.
self . _regex_validator = validators . RegexValidator ( regex = regex )	call the method validators.RegexValidator with an argument regex set to regex, substitute it for self._regex_validator.
self . validators . append ( self . _regex_validator )	append self._regex_validator to self.validators.
regex = property ( _get_regex , _set_regex )	regex is an property object of this class, with _get_regex getter and _set_regex setter function.
class EmailField ( CharField ) :	derive the class EmailField from the base class CharField class.
widget = EmailInput	substitute EmailInput for widget.
default_validators = [ validators . validate_email ]	default_validators is a list with an element validators.validate_email.
def clean ( self , value ) :	define the method clean with 2 arguments self and value.
value = self . to_python ( value ) . strip ( )	call the method self.to_python with an argument value, strip the whitespaces from the both ends of the result and substitute it for value.
return super ( EmailField , self ) . clean ( value )	call the method clean with an argument value from the base class of the EmailField class.
class FileField ( Field ) :	derive the class FileField from the base class Field class.
widget = ClearableFileInput	substitute ClearableFileInput for widget.
default_error_messages = {  'invalid' : _ ( 'No file was submitted. Check the encoding type on the form.' ) ,  'missing' : _ ( 'No file was submitted.' ) ,  'empty' : _ ( 'The submitted file is empty.' ) ,  'max_length' : ungettext_lazy (  'Ensure this filename has at most %(max)d character (it has %(length)d).' ,  'Ensure this filename has at most %(max)d characters (it has %(length)d).' ,  'max' ) ,  'contradiction' : _ ( 'Please either submit a file or check the clear checkbox, not both.' )  }	default_error_messages is an dictionary with 5 initial entries: return value of the function _ called with an argument string,
def __init__ ( self , * args , ** kwargs ) :	No file was submitted. Check the encoding type on the form. for 'invalid', return value of the function _ called with an argument,   string 'No file was submitted.' for 'missing', return value of the function _ called with an argument 'The submitted file is empty.',   for 'empty', return value of the function ungettext_lazy called with 3 arguments:   string 'Ensure this filename has at most %(max)d character (it has %(length)d).',   string 'Ensure this filename has at most %(max)d characters (it has %(length)d).' and string 'max' for 'max_length',   and return value of the function _ called with an argument string,   'Please either submit a file or check the clear checkbox, not both.' for 'contradiction'.   define the method __init__ with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
self . max_length = kwargs . pop ( 'max_length' , None )	remove the value under 'max_length' key from the kwargs dictionary and if the key exists substitute it for self.max_length,
self . allow_empty_file = kwargs . pop ( 'allow_empty_file' , False )	if not self.max_length is None.   remove the value under 'allow_empty_file' key from the kwargs dictionary and if the key exists,
super ( FileField , self ) . __init__ ( * args , ** kwargs )	substitute it for self.allow_empty_file, if not self.allow_empty_file is boolean False.   call the method __init__ from the base class of the FileField class, with 2 arguments: unpacked list args and unpacked dictionary.
def to_python ( self , data ) :	define the method to_python with arguments self and data.
if data in self . empty_values :	if data in self.empty_values is true,
return None	return None.
try :	try,
file_name = data . name	substitute data.name for file_name.
file_size = data . size	substitute data.size for file_name.
except AttributeError :	if AttributeError exception is caught,
raise ValidationError ( self . error_messages [ 'invalid' ] , code = 'invalid' )	raise an ValidationError with 2 arguments: value under the 'invalid' key of the self.error_messages dictionary and code set to 'invalid'.
if self . max_length is not None and len ( file_name ) > self . max_length :	if self.max_length is not None and length of file_name is grater than self.max_length,
params = { 'max' : self . max_length , 'length' : len ( file_name ) }	params is a dictionary with 2 initial entries: self.max_length for 'max' and length of file_name for 'length'.
raise ValidationError ( self . error_messages [ 'max_length' ] , code = 'max_length' , params = params )	raise an ValidationError with 2 arguments: value under the 'max_length' key of the self.error_messages dictionary and code set to 'max_length'.
if not file_name :	if file_name is false,
raise ValidationError ( self . error_messages [ 'invalid' ] , code = 'invalid' )	raise an ValidationError with 2 arguments: value under the 'invalid' key of the self.error_messages dictionary and code set to 'invalid'.
if not self . allow_empty_file and not file_size :	if self.allow_empty_file and file_size are both false,
raise ValidationError ( self . error_messages [ 'empty' ] , code = 'empty' )	raise an ValidationError with 2 arguments: value under the 'empty' key of the self.error_messages dictionary and code set to 'empty'.
return data	return data.
def clean ( self , data , initial = None ) :	define the method clean with arguments self, data and initial set to None.
if data is FILE_INPUT_CONTRADICTION :	if data is bound to the same object as FILE_INPUT_CONTRADICTION,
raise ValidationError ( self . error_messages [ 'contradiction' ] , code = 'contradiction' )	raise an ValidationError with 2 arguments: value under the 'contradiction' key of the self.error_messages dictionary and code set to 'contradiction'.
if data is False :	if data is boolean False,
if not self . required :	if self.required is false,
return False	return boolean False.
data = None	data is None.
if not data and initial :	if data is false and initial is true,
return initial	return initial.
return super ( FileField , self ) . clean ( data )	call the method clean with an argument data from the base class of the class FileField, return the result.
def bound_data ( self , data , initial ) :	define the method bound_data with arguments self, data and initial.
if data in ( None , FILE_INPUT_CONTRADICTION ) :	if data is not None or FILE_INPUT_CONTRADICTION,
return initial	return initial.
return data	return data.
def _has_changed ( self , initial , data ) :	define the method _has_changed with arguments self, data and initial.
if data is None :	if data is None,
return False	return is boolean False.
return True	return is boolean True.
class ImageField ( FileField ) :	derive the class ImageField from the base class FileField class.
default_error_messages = {  'invalid_image' : _ ( 'Upload a valid image. The file you uploaded was either not an image or a corrupted image.' ) ,  }	default_error_messages is an dictionary with an entry: return value of the function _ called with an argument string,
f = super ( ImageField , self ) . to_python ( data )	call the method to_python with an argument data from the base class of the class ImageField, substitute the result for f.
if f is None :	if f is None,
return None	return None.
from PIL import Image	from PIL import Image into default namespace.
if hasattr ( data , 'temporary_file_path' ) :	if data has an 'temporary_file_path' attribute,
file = data . temporary_file_path ( )	substitute the result of the function data.temporary_file_path for file.
else :	if not,
if hasattr ( data , 'read' ) :	if data has an attribute 'read',
file = BytesIO ( data . read ( ) )	file is an instance of BytesIO class created with an argument: return value of the method data.read.
else :	if not,
file = BytesIO ( data [ 'content' ] )	  file is an instance of BytesIO class created with an argument: value under the 'content' key of the data dictionary.
try :	try,
Image . open ( file ) . verify ( )	call the method Image.open with an argument file, on the result call the verify method
except Exception :	if Exception exception is caught,
six . reraise ( ValidationError , ValidationError (  self . error_messages [ 'invalid_image' ] ,  code = 'invalid_image' ,  ) , sys . exc_info ( ) [ 2 ] )	call the function six.reraise with 3 arguments: ValidationError, ValidationError created with 2 arguments:
if hasattr ( f , 'seek' ) and callable ( f . seek ) :	value under the 'invalid_image' key of the self.error_messages dictionary and code set to a string 'invalid_image',   and third element of the return value of the function sys.exc_info.   if f has an attribute 'seek' and if f.seek is an callable object,
f . seek ( 0 )	call the method f.seek with an argument integer 0.
return f	return f.
class URLField ( CharField ) :	derive the class URLField from the base class CharField class.
widget = URLInput	substitute URLInput for widget.
default_error_messages = {  'invalid' : _ ( 'Enter a valid URL.' ) ,  }	default_error_messages is an dictionary with an entry: return value of the function _ called with an argument string 'Enter a valid URL.' for 'invalid'.
default_validators = [ validators . URLValidator ( ) ]	default_validators is a list with an element, return value of the validators.URLValidator method.
def to_python ( self , value ) :	define the method to_python with arguments self and data.
def split_url ( url ) :	define the function split_url with an argument url.
try :	try,
return list ( urlsplit ( url ) )	call the urlsplit with an argument url, convert the result into a list and return it.
except ValueError :	if ValueError exception is caught,
raise ValidationError ( self . error_messages [ 'invalid' ] , code = 'invalid' )	raise an ValidationError with 2 arguments: value under the 'invalid' key of the self.error_messages dictionary and code set to 'invalid'.
value = super ( URLField , self ) . to_python ( value )	call the method to_python with an argument data from the base class of the class URLField, substitute the result for value.
if value :	if value is true,
url_fields = split_url ( value )	call the function split_url with an argument value, substitute the result for url_fields.
if not url_fields [ 0 ] :	if first element of the url_fields is false,
url_fields [ 0 ] = 'http'	first element of url_fields is string 'http'.
if not url_fields [ 1 ] :	if second element of url_fields is false,
url_fields [ 1 ] = url_fields [ 2 ]	substitute third element of url_fields for second element of url_fields.
url_fields [ 2 ] = ''	third element of url_fields is an empty string.
url_fields = split_url ( urlunsplit ( url_fields ) )	call the function urlunsplit with an argument url_fields, use the result as an argument for the call to the function split_url,
value = urlunsplit ( url_fields )	substitute the result for url_fields.   call the function urlunsplit with an argument url_fields, substitute the result for value.
return value	return value.
def clean ( self , value ) :	define the method clean with arguments self and value.
value = self . to_python ( value ) . strip ( )	call the method self.to_python with an argument value, strip the whitespaces from the result, substitute it for value.
return super ( URLField , self ) . clean ( value )	call the method clean with an argument data from the base class of the class URLField, return the result.
class BooleanField ( Field ) :	derive the class BooleanField from the base class Field class.
widget = CheckboxInput	substitute CheckboxInput for widget.
def to_python ( self , value ) :	define the method to_python with arguments self and value.
if isinstance ( value , six . string_types ) and value . lower ( ) in ( 'false' , '0' ) :	if value is an instance of six.string_types and value converted to lowercase is not equal to strings 'false' or '0',
value = False	value is boolean False.
else :	if not,
value = bool ( value )	convert value into boolean and substitute it for value.
return super ( BooleanField , self ) . to_python ( value )	call the method to_python with an argument data from the base class of the class BooleanField, return the result.
def validate ( self , value ) :	define the method validate with arguments self and value.
if not value and self . required :	if value is false and self.required is true,
raise ValidationError ( self . error_messages [ 'required' ] , code = 'required' )	raise an ValidationError with 2 arguments: value under the 'required' key of the self.error_messages dictionary and code set to 'required'.
def _has_changed ( self , initial , data ) :	define the method _has_changed with arguments self, initial and data.
if initial == 'False' :	  if initial equals a string 'False',
initial = False	initial is boolean False.
return bool ( initial ) != bool ( data )	convert initial and data into boolean, if they are not equal return boolean True, if they are return boolean False.
class NullBooleanField ( BooleanField ) :	derive the class NullBooleanField from the base class BooleanField class.
widget = NullBooleanSelect	substitute NullBooleanSelect for widget.
def to_python ( self , value ) :	define the method to_python with arguments self and value.
if value in ( True , 'True' , '1' ) :	if value is boolean True, string 'True' or string '1',
return True	return boolean True.
elif value in ( False , 'False' , '0' ) :	otherwise if value is boolean False, string 'False' or string '0'
return False	return boolean False,
else :	if not,
return None	return None.
def validate ( self , value ) :	define the method validate with arguments self and value.
pass	do nothing.
def _has_changed ( self , initial , data ) :	define the method _has_changed with arguments self, initial and data.
if initial is not None :	if initial is not None,
initial = bool ( initial )	convert initial into boolean and substitute it for initial.
if data is not None :	if data is not None,
data = bool ( data )	convert data into boolean and substitute it for data.
return initial != data	if initial is not equal to data, return boolean True, if it is return boolean False.
class ChoiceField ( Field ) :	derive the class ChoiceField from the base class Field class.
widget = Select	substitute Select for widget.
default_error_messages = {  'invalid_choice' : _ ( 'Select a valid choice. %(value)s is not one of the available choices.' ) ,  }	default_error_messages is an dictionary with an entry: return value of the function _ called with an argument string,
def __init__ ( self , choices = ( ) , required = True , widget = None , label = None ,  initial = None , help_text = '' , * args , ** kwargs ) :	'Select a valid choice. %(value)s is not one of the available choices.' for 'invalid_choice'.   define the method __init__ with 9 arguments: self, choices set to an empty tuple, required set to boolean True, widget set to None,
super ( ChoiceField , self ) . __init__ ( required = required , widget = widget , label = label ,  initial = initial , help_text = help_text , * args , ** kwargs )	label set to None, initial set to None, help_text set to an empty string, unpacked list args and unpacked dictionary kwargs.   call the __init__ method of the base class of the class ChoiceField, called with 7 arguments: required set to required,
self . choices = choices	widget set to widget, label set to label, initial set to initial, help_text set to help_text, unpacked list args,   and unpacked dictionary kwargs.   substitute choices for self.choices.
def __deepcopy__ ( self , memo ) :	define the method __deepcopy__ with arguments self and memo.
result = super ( ChoiceField , self ) . __deepcopy__ ( memo )	call the method __deepcopy__ with an argument memo from the base class of the class ChoiceField, substitute the result for result.
result . _choices = copy . deepcopy ( self . _choices , memo )	call the method copy.deepcopy with arguments self._choices and memo, substitute the result for result._choices.
return result	return result.
def _get_choices ( self ) :	define the method _get_choices with an argument self.
return self . _choices	return self._choices.
def _set_choices ( self , value ) :	define the method _set_choices with arguments self and value.
self . _choices = self . widget . choices = list ( value )	self._choices and self.widget.choices are assigned value converted into a list.
choices = property ( _get_choices , _set_choices )	choices is an property object of this class where _get_choices is a getter and _set_choices is a setter function.
def to_python ( self , value ) :	define the method to_python with arguments self and value.
if value in self . empty_values :	if value is contained in self.empty_values,
return ''	return an empty string.
return smart_text ( value )	call the function smart_text with an argument value, return the result.
def validate ( self , value ) :	define the method validate with arguments self and value.
super ( ChoiceField , self ) . validate ( value )	call the method validate with an argument value from the base class of the class ChoiceField.
if value and not self . valid_value ( value ) :	if value is true and method self.valid_value called with an argument value evaluates to false,
raise ValidationError (  self . error_messages [ 'invalid_choice' ] ,  code = 'invalid_choice' ,  params = { 'value' : value } ,  )	raise an ValidationError with 3 arguments: value under the 'invalid_choice' key of the self.error_messages dictionary,
def valid_value ( self , value ) :	code set to an string 'invalid_choice' and dictionary params with an entry: value for 'value'.   define the method valid_value with arguments self and value.
text_value = force_text ( value )	call the function force_text with an argument value, substitute the result for text_value.
for k , v in self . choices :	for every k and v in self.choices,
if isinstance ( v , ( list , tuple ) ) :	if v is an instance of list or tuple type,
for k2 , v2 in v :	for every k2 and v2 in v,
if value == k2 or text_value == force_text ( k2 ) :	if value equals k2 or text_value equals return value of the function force_text called with argument k2,
    return True	return boolean True.
else :	if not,
if value == k or text_value == force_text ( k ) :	if value equals k or text_value equals return value of the function force_text called with argument k,
return True	return boolean True.
return False	return boolean False.
class TypedChoiceField ( ChoiceField ) :	derive the class TypedChoiceField from the base class ChoiceField class.
def __init__ ( self , * args , ** kwargs ) :	define the method __init__ with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
self . coerce = kwargs . pop ( 'coerce' , lambda val : val )	if 'coerce' key of the kwargs dictionary exists remove it and substitute its value for self.coerce,
self . empty_value = kwargs . pop ( 'empty_value' , '' )	if not, self.coerce is an identity lambda function with an argument val.   if 'empty_value' key of the kwargs dictionary exists remove it and substitute its value for self.empty_value,
super ( TypedChoiceField , self ) . __init__ ( * args , ** kwargs )	if not, sself.empty_value is an empty string.   call the method __init__ with 2 arguments: unpacked list args and unpacked dictionary kwargs,
def _coerce ( self , value ) :	from the base class of the class TypedChoiceField.   define the method _coerce with arguments self and value.
if value == self . empty_value or value in self . empty_values :	if value equals self.empty_value or value is contained in self.empty_values,
return self . empty_value	return self.empty_value.
try :	try,
value = self . coerce ( value )	call the function self.coerce with an argument value, substitute it for value.
except ( ValueError , TypeError , ValidationError ) :	if ValueError, TypeError or ValidationError exception is caught,
raise ValidationError (  self . error_messages [ 'invalid_choice' ] ,  code = 'invalid_choice' ,  params = { 'value' : value } ,  )	raise an ValidationError with 3 arguments: value under the 'invalid_choice' key of the self.error_messages dictionary,
return value	code set to an string 'invalid_choice' and dictionary params with an entry: value for 'value'.   return value.
def clean ( self , value ) :	define the method clean with arguments self and value.
value = super ( TypedChoiceField , self ) . clean ( value )	call the method clean with an argument value from the base class of the class TypedChoiceField, substitute the result for value.
return self . _coerce ( value )	call the method self._coerce with an argument value, return the result.
class MultipleChoiceField ( ChoiceField ) :	derive the class MultipleChoiceField from the base class ChoiceField class.
hidden_widget = MultipleHiddenInput	substitute MultipleHiddenInput for hidden_widget.
widget = SelectMultiple	substitute SelectMultiple for widget.
default_error_messages = {  'invalid_choice' : _ ( 'Select a valid choice. %(value)s is not one of the available choices.' ) ,  'invalid_list' : _ ( 'Enter a list of values.' ) ,  }	default_error_messages is an dictionary with an entry: return value of the function _ called with an argument string,
def to_python ( self , value ) :	'Select a valid choice. %(value)s is not one of the available choices.' for 'invalid_choice',   and return value of the function _ called with an argument string 'Enter a list of values.' for 'invalid_list'.   define the method to_python with arguments self and value.
if not value :	if value is false,
return [ ]	return an empty list.
elif not isinstance ( value , ( list , tuple ) ) :	otherwise if value is not an instance of list ot tuple type,
raise ValidationError ( self . error_messages [ 'invalid_list' ] , code = 'invalid_list' )	raise an ValidationError with 2 arguments: value under the 'invalid_list' key of the self.error_messages dictionary and code set to 'invalid_list'.
return [ smart_text ( val ) for val in value ]	for every val in value call the function smart_text with an argument val, return the results in a lit.
def validate ( self , value ) :	define the method validate with arguments self and value.
if self . required and not value :	if self.required is true and value is false,
raise ValidationError ( self . error_messages [ 'required' ] , code = 'required' )	raise an ValidationError with 3 arguments: value under the 'required' key of the self.error_messages dictionary,
for val in value :	and code set to an string 'required'.   for every val in value,
if not self . valid_value ( val ) :	call the method self.valid_value with an argument val, if it evaluates to false,
raise ValidationError (  self . error_messages [ 'invalid_choice' ] ,  code = 'invalid_choice' ,  params = { 'value' : val } ,  )	raise an ValidationError with 3 arguments: value under the 'invalid_choice' key of the self.error_messages dictionary,
def _has_changed ( self , initial , data ) :	code set to an string 'invalid_choice' and dictionary params with an entry: val for 'value'.   define the method _has_changed with arguments self, initial and data.
if initial is None :	if initial is None,
initial = [ ]	initial is an empty list.
if data is None :	if data is None,
data = [ ]	data is an empty list.
if len ( initial ) != len ( data ) :	if lengths of initial and data are not the same,
return True	return boolean True.
initial_set = set ( force_text ( value ) for value in initial )	for every value in initial call the function force_text with an argument value, add the results into a set, substitute the resulting set for initial_set.
data_set = set ( force_text ( value ) for value in data )	for every value in data call the function force_text with an argument value, add the results into a set, substitute the resulting set for data_set.
return data_set != initial_set	if data_set is not equal to initial_set, return boolean True, otherwise return boolean False.
class TypedMultipleChoiceField ( MultipleChoiceField ) :	derive the class TypedMultipleChoiceField from the base class MultipleChoiceField class.
def __init__ ( self , * args , ** kwargs ) :	define the method __init__ with 3 arguments: self unpacked list args and unpacked dictionary kwargs.
self . coerce = kwargs . pop ( 'coerce' , lambda val : val )	if 'coerce' key of the kwargs dictionary exists remove it and substitute its value for self.coerce,
self . empty_value = kwargs . pop ( 'empty_value' , [ ] )	if not, self.coerce is an identity lambda function with an argument val.   if 'empty_value' key of the kwargs dictionary exists remove it and substitute its value for self.empty_value,
super ( TypedMultipleChoiceField , self ) . __init__ ( * args , ** kwargs )	if not, self.empty_value is an empty list.   call the method __init__ with 2 arguments: unpacked list args and unpacked dictionary kwargs,
def _coerce ( self , value ) :	from the base class of the class TypedMultipleChoiceField.   define the method _coerce with arguments self and value.
if value == self . empty_value or value in self . empty_values :	if value equals self.empty_value or value is contained in self.empty_values,
return self . empty_value	return self.empty_value.
new_value = [ ]	new_value is an empty list.
for choice in value :	for every choice in value,
try :	try,
new_value . append ( self . coerce ( choice ) )	call the method self.coerce with an argument choice, append the result to new_value.
except ( ValueError , TypeError , ValidationError ) :	if ValueError, TypeError or ValidationError exception is caught,
raise ValidationError (  self . error_messages [ 'invalid_choice' ] ,  code = 'invalid_choice' ,  params = { 'value' : choice } ,  )	raise an ValidationError with 3 arguments: value under the 'invalid_choice' key of the self.error_messages dictionary,
return new_value	code set to an string 'invalid_choice' and dictionary params with an entry: choice for 'value'.   return new_value.
def clean ( self , value ) :	define the method clean with arguments self and value.
value = super ( TypedMultipleChoiceField , self ) . clean ( value )	call the method clean with an argument value from the base class of the class TypedMultipleChoiceField, substitute the result for value.
return self . _coerce ( value )	call the method self._coerce with an argument value, return the result.
def validate ( self , value ) :	define the method validate with arguments self and value.
if value != self . empty_value :	if value is not equal self.empty_value,
super ( TypedMultipleChoiceField , self ) . validate ( value )	call the method validate with an argument value from the base class of the class TypedMultipleChoiceField.
elif self . required :	otherwise if self.required is true,
raise ValidationError ( self . error_messages [ 'required' ] , code = 'required' )	raise an ValidationError with 2 arguments: value under the 'required' key of the self.error_messages dictionary and code set to 'required'.
class ComboField ( Field ) :	derive the class ComboField from the base class Field class.
def __init__ ( self , fields = ( ) , * args , ** kwargs ) :	define the method __init__ with arguments: self, fields set to an empty tuple, unpacked list args and unpacked dictionary kwargs.
super ( ComboField , self ) . __init__ ( * args , ** kwargs )	call the method __init__ with 2 arguments: unpacked list args and unpacked dictionary kwargs, from the base class of the class ComboField.
for f in fields :	for every f in fields,
f . required = False	f.required is boolean False.
self . fields = fields	substitute fields for self.fields.
def clean ( self , value ) :	define the method clean with arguments self and value.
super ( ComboField , self ) . clean ( value )	call the method clean with an argument value from the base class of the class ComboField.
for field in self . fields :	for every field in self.fields,
value = field . clean ( value )	call the method field.clean with an argument value, substitute the result for value.
return value	return value.
class MultiValueField ( Field ) :	derive the class MultiValueField from the base class Field class.
default_error_messages = {  'invalid' : _ ( 'Enter a list of values.' ) ,  'incomplete' : _ ( 'Enter a complete value.' ) ,  }	default_error_messages is an dictionary with 2 entries: return value of the function _ called with an argument string,
def __init__ ( self , fields = ( ) , * args , ** kwargs ) :	'Enter a list of values.' for 'invalid' and return value of the function _ called with an argument string,   'Enter a complete value.' for 'incomplete'.   define the method __init__ with arguments self, fields set to an empty ilst, unpacked list args and unpacked dictionary kwargs.
self . require_all_fields = kwargs . pop ( 'require_all_fields' , True )	if 'require_all_fields' key of the kwargs dictionary exists remove it and substitute its value for self.require_all_fields,
super ( MultiValueField , self ) . __init__ ( * args , ** kwargs )	if not, self.require_all_fields is boolean True.   call the method __init__ with 2 arguments: unpacked list args and unpacked dictionary kwargs, from the base class of the class MultiValueField.
for f in fields :	for every f in fields,
f . error_messages . setdefault ( 'incomplete' ,  self . error_messages [ 'incomplete' ] )	if 'incomplete' key of the f.error_messages doesnt exists, assign it the value under the 'incomplete' key of the self.error_messages dictionary.
if self . require_all_fields :	if self.require_all_fields is true,
f . required = False	f.required is boolean False.
self . fields = fields	substitute fields for self.fields.
def __deepcopy__ ( self , memo ) :	define the method __deepcopy__ with arguments self and memo.
result = super ( MultiValueField , self ) . __deepcopy__ ( memo )	call the method __deepcopy__ with an argument memo, from the base class of the class MultiValueField, substitute the result for result.
result . fields = tuple ( [ x . __deepcopy__ ( memo ) for x in self . fields ] )	for every x in self.fields call the method x.__deepcopy__ with an argument memo, put the result into a tuple, substitute it for result.fields.
return result	return result.
def validate ( self , value ) :	define the method validate with arguments self and value.
pass	do nothing.
def clean ( self , value ) :	define the method clean with arguments self and value.
clean_data = [ ]	clean_data is an empty list.
errors = [ ]	errors is an empty list.
if not value or isinstance ( value , ( list , tuple ) ) :	if value is false or value is not an instance of list or tuple types,
if not value or not [ v for v in value if v not in self . empty_values ] :	if value is false or for every v in value every v is contained in self.empty_values,
if self . required :	if self.required is true,
raise ValidationError ( self . error_messages [ 'required' ] , code = 'required' )	raise an ValidationError with 2 arguments: value under the 'required' key of the self.error_messages dictionary and code set to 'required'.
else :	if not,
return self . compress ( [ ] )	call the function self.compress with empty list as an argument, return the result.
else :	if not,
raise ValidationError ( self . error_messages [ 'invalid' ] , code = 'invalid' )	raise an ValidationError with 2 arguments: value under the 'invalid' key of the self.error_messages dictionary and code set to 'invalid'.
for i , field in enumerate ( self . fields ) :	for every i and field in enumerated iterable self.fields,
try :	try,
field_value = value [ i ]	substitute i-th element of value for field_value.
except IndexError :	if IndexError exception is caught,
field_value = None	field_value is None.
if field_value in self . empty_values :	if field_value is cotained in self.empty_values,
if self . require_all_fields :	if self.require_all_fields is boolean true,
  if self . required :	if self.required is boolean true,
    raise ValidationError ( self . error_messages [ 'required' ] , code = 'required' )	raise an ValidationError with 2 arguments: value under the 'required' key of the self.error_messages dictionary and code set to 'required'.
elif field . required :	otherwise if field.required is true,
    if field . error_messages [ 'incomplete' ] not in errors :	get the value under the 'incomplete' key of the field.error_messages dictionary, if it is not contained in errors,
    errors . append ( field . error_messages [ 'incomplete' ] )	get the value under the 'incomplete' key of the field.error_messages dictionary, append it to errors.
continue	skip this loop iteration,
try :	try,
clean_data . append ( field . clean ( field_value ) )	call the method field.clean with an argument field_value, append the result to clean_data.
except ValidationError as e :	if ValidationError, renamed to e, is caught,
errors . extend ( m for m in e . error_list if m not in errors )	extend errors list with m for every m in e.error_list, only if m is not in errors.
if errors :	if errors is true,
raise ValidationError ( errors )	raise an ValidationError with an argument errors.
out = self . compress ( clean_data )	call the method self.compress with an argument clean_data, substitute the result for out.
self . validate ( out )	call the method self.validate with an argument out.
self . run_validators ( out )	call the method self.run_validators with an argument out.
return out	return out.
def compress ( self , data_list ) :	define the method compress with arguments self and data_list.
raise NotImplementedError ( 'Subclasses must implement this method.' )	raise an NotImplementedError with an argument string 'Subclasses must implement this method.'.
def _has_changed ( self , initial , data ) :	define the method has_changed with arguments self, initial and data.
if initial is None :	if initial is None,
initial = [ '' for x in range ( 0 , len ( data ) ) ]	for every x in sequence of integer from integer 0 to length of data, append an empty string to a list, substitute the resulting list for initial.
else :	if not,
if not isinstance ( initial , list ) :	if initial is not an instance of the list type,
initial = self . widget . decompress ( initial )	call the method self.widget.decompress with an argument initial, substitute the result for initial.
for field , initial , data in zip ( self . fields , initial , data ) :	for every field, initial and data in list of tuples tuple containing elements of self.fields, initial and data, respectively,
if field . _has_changed ( field . to_python ( initial ) , data ) :	call the method field._has_changed with 2 arguments: return value of the function field.to_python called with an argument initial,
return True	and data, if it evaluates to true,    return boolean  True.
return False	return boolean False.
class FilePathField ( ChoiceField ) :	derive the class FilePathField from the base class ChoiceField class.
def __init__ ( self , path , match = None , recursive = False , allow_files = True ,  allow_folders = False , required = True , widget = None , label = None ,  initial = None , help_text = '' , * args , ** kwargs ) :	define the method __init__ with 13 arguments: self, path, match set to None, recursive set to boolean False,
self . path , self . match , self . recursive = path , match , recursive	allow_files set to boolean True, allow_folders set to boolean False, required set to boolean True, widget set to None,   label set to None, initial set to None, help_text set to an empty string, unpacked list args, unpacked dictionary kwargs.   substitute path, match and recursive for self.path, self.match and self.recursive.
self . allow_files , self . allow_folders = allow_files , allow_folders	substitute allow_files and allow_folders for self.allow_files and self.allow_folders.
super ( FilePathField , self ) . __init__ ( choices = ( ) , required = required ,  widget = widget , label = label , initial = initial , help_text = help_text ,  * args , ** kwargs )	call the __init__ method of the base class of the class FilePathField, with arguments: choices set to an empty tuple,4
if self . required :	required set to required, widget set to widget, label set to label, initial st to initial, help_text set to help_text,   unpacked list args, unpacked dictionary kwargs.   if self.required is true,
self . choices = [ ]	self.choices is an empty list.
else :	if not,
self . choices = [ ( '' , '---------' ) ]	self.choices is an list containing an tuple with 2 elements: an empty string and string '---------'.
if self . match is not None :	if self.match is not None,
self . match_re = re . compile ( self . match )	compile self.match regular expression, substitute it for self.match_re.
if recursive :	if recursive is true,
for root , dirs , files in sorted ( os . walk ( self . path ) ) :	for root, dirs and files in sorted list of the directory tree starting from the directory self.path,
if self . allow_files :	if self.allow_files is true,
for f in files :	for every f in files,
    if self . match is None or self . match_re . search ( f ) :	if self.match is None or call to the method self.match_re.search with an argument f, evaluated to true,
        f = os . path . join ( root , f )	join root and f into a file, substitute it for f.
self . choices . append ( ( f , f . replace ( path , '' , 1 ) ) )	append a tuple with 2 elements: f and f with first occurrence of the path replaced with an empty string, to self.choices.
if self . allow_folders :	if self.allow_folders is true,
for f in dirs :	for every f in files,
    if f == '__pycache__' :	if f equals to string '__pycache__',
        continue	skip this loop execution.
if self . match is None or self . match_re . search ( f ) :	if self.match is None or call to the method self.match_re.search with an argument f, evaluated to true,
        f = os . path . join ( root , f )	join root and f in path, substitute the result for f.
self . choices . append ( ( f , f . replace ( path , '' , 1 ) ) )	append a tuple with 2 elements: f and f with first occurrence of the path replaced with an empty string, to self.choices.
else :	if not,
try :	try,
for f in sorted ( os . listdir ( self . path ) ) :	for f in sorted list of the files in the self.path directory,
if f == '__pycache__' :	if f equals to string '__pycache__',
    continue	skip this loop execution.
full_file = os . path . join ( self . path , f )	join self.path and f in path, substitute the result for full_file.
if ( ( ( self . allow_files and os . path . isfile ( full_file ) ) or  ( self . allow_folders and os . path . isdir ( full_file ) ) ) and  ( self . match is None or self . match_re . search ( f ) ) ) :	if self.allow_files is true and full_file is a file, or if self.allow_folders is true and full_file is an directory,
    self . choices . append ( ( full_file , f ) )	and only if self.match is None or return value of the method self.match_re.search called with an argument f is true.   append a tuple containing 2 elements: full_file and f to self.choices list.
except OSError :	if OSError exception is caught,
pass	do nothing.
self . widget . choices = self . choices	substitute self.choices for self.widgetchoices.
class SplitDateTimeField ( MultiValueField ) :	derive the class SplitDateTimeField from the base class MultiValueField class.
widget = SplitDateTimeWidget	substitute SplitDateTimeWidget for widget.
hidden_widget = SplitHiddenDateTimeWidget	substitute SplitHiddenDateTimeWidget for hidden_widget.
default_error_messages = {  'invalid_date' : _ ( 'Enter a valid date.' ) ,  'invalid_time' : _ ( 'Enter a valid time.' ) ,  }	default_error_messages is an dictionary with 2 entries: return value of the function _ called with an string 'Enter a valid date.',
def __init__ ( self , input_date_formats = None , input_time_formats = None , * args , ** kwargs ) :	for 'invalid_date' and return value of the function _ called with an string 'Enter a valid time.', for 'invalid_time.   define the method __init__ with 3 arguments: self, input_date_formats set to None, input_time_formats set to None,
errors = self . default_error_messages . copy ( )	and errors set to the result of self.default_error_messages.copy.
if 'error_messages' in kwargs :	if 'error_messages' is contained in kwargs,
errors . update ( kwargs [ 'error_messages' ] )	get the value under the 'error_messages' key of the kwargs dictionary, update errors dictionary with it.
localize = kwargs . get ( 'localize' , False )	get the value under the 'localize' key of the kwargs dictionary, substitute it for localize, if the key doesnt exists, substitute the result for localize.
fields = (  DateField ( input_formats = input_date_formats ,  error_messages = { 'invalid' : errors [ 'invalid_date' ] } ,  localize = localize ) ,  TimeField ( input_formats = input_time_formats ,  error_messages = { 'invalid' : errors [ 'invalid_time' ] } ,  localize = localize ) ,  )	fields is an tuple containing instances of the class DateField, created with 3 arguments: input_formats set to input_date_formats,
super ( SplitDateTimeField , self ) . __init__ ( fields , * args , ** kwargs )	error_messages as an dictionary with an entry: value under the 'invalid_date' of errors dictionary for 'invalid',   localize set to localize, and an instance of the class TimeField created with 3 arguments: input_formats set to input_time_formats,   error_messages as an dictionary with an entry: value under the 'invalid_time' of errors dictionary for 'invalid',   localize set to localize   call the __init__ method with fields, unpacked list args and unpacked dictionary kwargs from the base class of the SplitDateTimeField class.
def compress ( self , data_list ) :	define the method compress with arguments self and data_list.
if data_list :	if data_list is true,
if data_list [ 0 ] in self . empty_values :	if first element of data_list is contained in self.empty_values,
raise ValidationError ( self . error_messages [ 'invalid_date' ] , code = 'invalid_date' )	raise an ValidationError with 2 arguments: value under the 'invalid_date' key of the self.error_messages dictionary and code set to string 'invalid_date'.
if data_list [ 1 ] in self . empty_values :	if second element of data_list is contained in self.empty_values,
raise ValidationError ( self . error_messages [ 'invalid_time' ] , code = 'invalid_time' )	raise an ValidationError with 2 arguments: value under the 'invalid_time' key of the self.error_messages dictionary and code set to string 'invalid_time'.
result = datetime . datetime . combine ( * data_list )	call the method datetime.datetime.combine with unpacked list data_list, substitute the result for result.
return from_current_timezone ( result )	call the method from_current_timezone with an argument result, return the result.
return None	return None.
class IPAddressField ( CharField ) :	derive the class IPAddressField from the base class CharField class.
default_validators = [ validators . validate_ipv4_address ]	default_validators is an list containing validators.validate_ipv4_address.
def __init__ ( self , * args , ** kwargs ) :	define the method __init__ with 3 arguments: self,unpacked list args and unpacked dictionary kwargs.
warnings . warn ( 'IPAddressField has been deprecated. Use GenericIPAddressField instead.' ,  RemovedInDjango19Warning )	call the function warnings.warn with 2 arguments string 'IPAddressField has been deprecated. Use GenericIPAddressField instead.',
super ( IPAddressField , self ) . __init__ ( * args , ** kwargs )	and RemovedInDjango19Warning.   call the __init__ method with unpacked list args and unpacked dictionary kwargs from the base class of the IPAddressField class.
def to_python ( self , value ) :	define the method to_python with arguments self and value.
if value in self . empty_values :	if value is contained in self.empty_values,
return ''	return an empty string.
return value . strip ( )	strip whitespaces from both sides of the value, return the result.
class GenericIPAddressField ( CharField ) :	derive the class GenericIPAddressField from the base class CharField class.
def __init__ ( self , protocol = 'both' , unpack_ipv4 = False , * args , ** kwargs ) :	define the method __init__ with 5 arguments: self, protocol set to string 'both', unpack_ipv4 set to boolean False,
self . unpack_ipv4 = unpack_ipv4	unpacked list args, unpacked dictionary kwargs.   substitute unpack_ipv4 for self.unpack_ipv4.
self . default_validators = validators . ip_address_validators ( protocol , unpack_ipv4 ) [ 0 ]	call the method validators.ip_address_validators with arguments protocol, unpack_ipv4, substitute first element of the result for self.default_validators.
super ( GenericIPAddressField , self ) . __init__ ( * args , ** kwargs )	call the __init__ method with unpacked list args and unpacked dictionary kwargs from the base class of the GenericIPAddressField class.
def to_python ( self , value ) :	define the method to_python with arguments self and value.
if value in self . empty_values :	if value is contained in self.empty_values,
return ''	return an empty string.
value = value . strip ( )	strip whitespaces from both sides of the value, substitute it for value.
if value and ':' in value :	if value is true and character ':' is contained in value,
return clean_ipv6_address ( value , self . unpack_ipv4 )	call the function clean_ipv6_address with arguments value and self.unpack_ipv4, return the result.
return value	return value.
class SlugField ( CharField ) :	derive the class SlugField from the base class CharField class.
default_validators = [ validators . validate_slug ]	default_validators is an list containing validators.validate_slug.
def clean ( self , value ) :	define the method clean with arguments self and value.
value = self . to_python ( value ) . strip ( )	call the self.to_python method with an argument value, strip the result of the whitespaces from the sides, substitute the result for value.
return super ( SlugField , self ) . clean ( value )	call the clean method wiht value argument from the base class of the SlugField class, return the result.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from collections import OrderedDict	from collections import OrderedDict into default name space.
import copy	import module copy.
import datetime	import module datetime.
import warnings	import module warnings.
from django . core . exceptions import ValidationError , NON_FIELD_ERRORS	from django.core.exceptions import ValidationError and NON_FIELD_ERRORS into default name space.
from django . forms . fields import Field , FileField	from django.forms.fields import Field and FileField into default name space.
from django . forms . utils import flatatt , ErrorDict , ErrorList	from django.forms.utils import flatatt,  ErrorDict and ErrorList into default name space.
from django . forms . widgets import Media , MediaDefiningClass , TextInput , Textarea	from django.forms.widgets import Media,  MediaDefiningClass,  TextInput and Textarea into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
from django . utils . encoding import smart_text , force_text , python_2_unicode_compatible	from django.utils.encoding import smart_text,  force_text and python_2_unicode_compatible into default name space.
from django . utils . html import conditional_escape , format_html	from django.utils.html import conditional_escape and format_html into default name space.
from django . utils . safestring import mark_safe	from django.utils.safestring import mark_safe into default name space.
from django . utils . translation import ugettext as _	from django.utils.translation import ugettext as _ into default name space.
from django . utils import six	from django.utils import six into default name space.
__all__ = ( 'BaseForm' , 'Form' )	__all__is an tuple with 2 elements: strings 'BaseForm' and 'Form'.
def pretty_name ( name ) :	define the function pretty_name with an argument name.
if not name :	if name is false,
return ''	return an empty string.
return name . replace ( '_' , ' ' ) . capitalize ( )	replace all the occurrences of character '_' in name with a whitespace, capitalize the first letter and return the result.
def get_declared_fields ( bases , attrs , with_base_fields = True ) :	define the function get_declared_fields with 3 arguments: bases, attrs and with_base_fields set to boolean True.
warnings . warn (  'get_declared_fields is deprecated and will be removed in Django 1.9.' ,  RemovedInDjango19Warning ,  stacklevel = 2 ,  )	call the function warnings.warn with 3 arguments: string 'get_declared_fields is deprecated and will be removed in Django 1.9.',
fields = [ ( field_name , attrs . pop ( field_name ) ) for field_name , obj in list ( six . iteritems ( attrs ) ) if isinstance ( obj , Field ) ]	RemovedInDjango19Warning, stacklevel set to integer 2.   for field_name every obj in list created from the elements of the return value of the function six.iteritems with an argument attrs.
fields . sort ( key = lambda x : x [ 1 ] . creation_counter )	if obj is an instance of Field, append to a list a tuple with 2 elements: field_name,   and poped value under the field_name key of the attrs dictionary, substitute the resulting list for fields.   sort fields elements with key being a lambda function with argument x and return value creation_counter filed of first element of x.
if with_base_fields :	if with_base_fields is true,
for base in bases [ : : - 1 ] :	for every base in reversed order of bases,
if hasattr ( base , 'base_fields' ) :	if base has an attribute 'base_fields'.
fields = list ( six . iteritems ( base . base_fields ) ) + fields	call the method six.iteritems with an argument base.base_fields, convert it to a list and append fields to it, substitute the result for fields.
else :	if not,
for base in bases [ : : - 1 ] :	for every base in reversed order of bases,
if hasattr ( base , 'declared_fields' ) :	if base has an 'declared_fields' attribute,
fields = list ( six . iteritems ( base . declared_fields ) ) + fields	call the method six.iteritems with an argument base.declared_fields, convert it to a list and append fields to it, substitute the result for fields.
return OrderedDict ( fields )	return an instance of OrderedDict class, created with an argument fields.
class DeclarativeFieldsMetaclass ( MediaDefiningClass ) :	derive the class DeclarativeFieldsMetaclass from the base class MediaDefiningClass.
def __new__ ( mcs , name , bases , attrs ) :	define the method __new__ with 4 arguments: mcs, name, bases and attrs.
current_fields = [ ]	current_fields is an empty list.
for key , value in list ( attrs . items ( ) ) :	for every key and value in list created out of the elements of the result of the call to the method attrs.items,
if isinstance ( value , Field ) :	if value is an instance of Field class,
current_fields . append ( ( key , value ) )	append a tuple with elements key and value to current_fields.
attrs . pop ( key )	remove entry at the key key of the attrs dictionary.
current_fields . sort ( key = lambda x : x [ 1 ] . creation_counter )	sort current_fields elements with key being a lambda function with argument x and return value creation_counter filed of first element of x.
attrs [ 'declared_fields' ] = OrderedDict ( current_fields )	value under the 'declared_fields' key of the attrs dictionary is an instance of OrderedDict class, created with an argument current_fields.
new_class = ( super ( DeclarativeFieldsMetaclass , mcs )  . __new__ ( mcs , name , bases , attrs ) )	call the method __new__ from the base class of the class DeclarativeFieldsMetaclass, with 4 arguments: mcs, name, bases and attrs.
declared_fields = OrderedDict ( )	declared_fields is an instance of OrderedDict class.
for base in reversed ( new_class . __mro__ ) :	for every base in new_class.__mro__ in reversed order,
if hasattr ( base , 'declared_fields' ) :	if base has an attribute 'declared_fields',
declared_fields . update ( base . declared_fields )	update declared_fields dictionary with entry base.declared_fields.
for attr , value in base . __dict__ . items ( ) :	call the method base.__dict__.items, for every attr and value in the result,
if value is None and attr in declared_fields :	if value is None and attr is contained in declared_fields,
declared_fields . pop ( attr )	remove entry at the attr key of the declared_fields dictionary.
new_class . base_fields = declared_fields	substitute declared_fields for new_class.base_fields.
new_class . declared_fields = declared_fields	substitute declared_fields for new_class.declared_fields.
return new_class	return new_class.
@ python_2_unicode_compatible	python_2_unicode_compatible decorator,
class BaseForm ( object ) :	derive the class BaseForm from the base class object.
def __init__ ( self , data = None , files = None , auto_id = 'id_%s' , prefix = None ,  initial = None , error_class = ErrorList , label_suffix = None ,  empty_permitted = False ) :	define the method __init__ with 4 arguments: self, data set to None, files set to None, auto_id is an string 'id_%s', prefix is None,
self . is_bound = data is not None or files is not None	initial set to None, error_class set to ErrorList, label_suffix set to None, empty_permitted set to boolean False.   if data is not None or files is not None, self.is_bound is boolean True, otherwise it is boolean False.
self . data = data or { }	if data is true, substitute it for self.data, if not self.data is an empty dictionary.
self . files = files or { }	if files is true, substitute it for self.files, if not self.files is an empty dictionary.
self . auto_id = auto_id	substitute auto_id for self.auto_id.
self . prefix = prefix	substitute prefix for self.prefix.
self . initial = initial or { }	if initial is true, substitute it for self.initial, if not self.files is an empty dictionary.
self . error_class = error_class	substitute .error_class for self.error_class.
self . label_suffix = label_suffix if label_suffix is not None else _ ( ':' )	if label_suffix is not None substitute label_suffix for self.label_suffix,
self . empty_permitted = empty_permitted	otherwise substitute return value of the function _ called with an argument ':' for self.label_suffix.   substitute empty_permitted for self.empty_permitted.
self . _errors = None	self._errors is None.
self . _changed_data = None	self._changed_data is None.
self . fields = copy . deepcopy ( self . base_fields )	call the function copy.deepcopy with an argument self.base_fields, substitute the result for self.fields.
def __str__ ( self ) :	define the method __str__ with an argument self.
return self . as_table ( )	call the method self.as_table, return the result.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
for name in self . fields :	for every name in self.fields,
yield self [ name ]	get the value under the name key of the self dictionary, yield it as the return value of the generator.
def __getitem__ ( self , name ) :	define the method __getitem__ with 2 arguments: self and name.
try :	try,
field = self . fields [ name ]	get the value under the name key of the self.fields dictionary, substitute it for field.
except KeyError :	if KeyError exception is caught,
return BoundField ( self , field , name )	return an instance of BoundField class, created with arguments self, field and name.
@ property	property decorator,
def errors ( self ) :	define the method errors with an argument self.
if self . _errors is None :	if self._errors is None,
self . full_clean ( )	call the method self.full_clean.
return self . _errors	return self._errors.
def is_valid ( self ) :	define the method is_valid with an argument self.
return self . is_bound and not self . errors	if self.is_bound is true and self.errors is false, return boolean True, otherwise return boolean False.
def add_prefix ( self , field_name ) :	define the method add_prefix with 2 arguments: self and field_name.
return '%s-%s' % ( self . prefix , field_name ) if self . prefix else field_name	substitute '%s' in string '%s-%s' with self.prefix and field_name and return it, if self.prefix is true, if not return field_name.
def add_initial_prefix ( self , field_name ) :	define the method add_initial_prefix with 2 arguments: self and field_name.
return 'initial-%s' % self . add_prefix ( field_name )	return string 'initial-%s' where '%s' is replaced with return value of the self.add_prefix method called with an argument field_name.
def _html_output ( self , normal_row , error_row , row_ender , help_text_html , errors_on_separate_row ) :	define the method _html_output with 6 arguments: self, normal_row, error_row, row_ender, help_text_html and errors_on_separate_row.
top_errors = self . non_field_errors ( )	call the method self.non_field_errors, substitute the result for top_errors.
output , hidden_fields = [ ] , [ ]	output and hidden_fields are both empty lists.
for name , field in self . fields . items ( ) :	call the method self.fields.items, for every name and field in return value,
html_class_attr = ''	html_class_attr is an empty string.
bf = self [ name ]	substitute value under the name key for bf.
bf_errors = self . error_class ( [ conditional_escape ( error ) for error in bf . errors ] )	call the method self.error_class with an argument list containing results of the function conditional_escape,
if bf . is_hidden :	called with an argument error, for every error in bf.errors, substitute the result for bf_errors.   if bf.is_hidden is true,
if bf_errors :	if bf_errors is true,
top_errors . extend (  [ _ ( '(Hidden field %(name)s) %(error)s' ) % { 'name' : name , 'error' : force_text ( e ) }  for e in bf_errors ] )	call the function _ with an argument string '(Hidden field %(name)s) %(error)s', where '%(name)s' is replaced with name,
hidden_fields . append ( six . text_type ( bf ) )	and '%(error)s' is replaced with return value of the force_text function called with an argument e,   extend the top_errors with the result.   call the function six.text_type with an argument bf, append the result to hidden_fields.
else :	if not,
css_classes = bf . css_classes ( )	call the method bf.css_classes, substitute the result for css_classes.
if css_classes :	if css_classes is true,
if errors_on_separate_row and bf_errors :	if errors_on_separate_row and bf_errors are both true,
output . append ( error_row % force_text ( bf_errors ) )	call the function force_text with an argument bf_errors, format the error_row string with the result, append it to the output.
if bf . label :	if bf.label is true,
label = conditional_escape ( force_text ( bf . label ) )	call the function force_text with an argument bf.label, use the result as an argument for the call to the function conditional_escape, substitute the result label.
label = bf . label_tag ( label ) or ''	call the function bf.label_tag with an argument label, if the result is true substitute it for label, otherwise label is an empty string.
else :	if not,
label = ''	label is an empty string.
if field . help_text :	if field.help_text is true,
help_text = help_text_html % force_text ( field . help_text )	call the function force_text with an argument field.help_text, format help_text_html with it, substitute the result for help_text.
else :	if not,
help_text = ''	label is an empty string.
output . append ( normal_row % {  'errors' : force_text ( bf_errors ) ,  'label' : force_text ( label ) ,  'field' : six . text_type ( bf ) ,  'help_text' : help_text ,  'html_class_attr' : html_class_attr ,  'field_name' : bf . html_name ,  } )	format string normal_row with an dictionary containing 6 entries: return value of the function force_text with an argument bf_errors,
if top_errors :	for 'errors', return value of the function force_text with an argument label for 'label', return value of the function six.text_type,   with an argument bf, for 'field', help_text for help_text, html_class_attr for 'html_class_attr' and bf.html_name for 'field_name'.    if top_errors is true,
output . insert ( 0 , error_row % force_text ( top_errors ) )	call the function force_text with an argument top_errors, format error_row with it, insert it at the beginning of output.
if hidden_fields :	if hidden_fields is true,
str_hidden = '' . join ( hidden_fields )	join hidden_fields elements into a string, without separation, substitute the result for str_hidden.
if output :	if output is true,
last_row = output [ - 1 ]	substitute last element of output for last_row.
if not last_row . endswith ( row_ender ) :	if last_row doesnt ends with row_ender,
    last_row = ( normal_row % { 'errors' : '' , 'label' : '' ,  'field' : '' , 'help_text' : '' ,  'html_class_attr' : html_class_attr } )	format string normal_row with an dictionary containing 5 entries: an empty string for 'errors', empty string for 'label',
output . append ( last_row )	empty string for 'field', empty string for 'help_text' and html_class_attr for html_class_attr.   append last_row to output.
output [ - 1 ] = last_row [ : - len ( row_ender ) ] + str_hidden + row_ender	create list out of last_row elements from the start to the last length of row_ender element, append str_hidden and row_ender to it,
else :	substitute the result for last element of output.   if not,
output . append ( str_hidden )	append str_hidden to output.
\return mark_safe ( '\\n' . join ( output ) )\	join elements of output into a string with newline as separator, use it as an argument for the call to the function mark_safe, return it.
def as_table ( self ) :	define the method as_table with an argument self.
return self . _html_output (  normal_row = '<tr%(html_class_attr)s><th>%(label)s</th><td>%(errors)s%(field)s%(help_text)s</td></tr>' ,  error_row = '<tr><td colspan='2'>%s</td></tr>' ,  row_ender = '</td></tr>' ,  help_text_html = '<br /><span class='helptext'>%s</span>' ,  errors_on_separate_row = False )	return the result of the method self._html_output, called with 5 arguments: normal_row to a string,
def as_ul ( self ) :	'<tr%(html_class_attr)s><th>%(label)s</th><td>%(errors)s%(field)s%(help_text)s</td></tr>', error_row set to a a string,   '<tr><td colspan='2'>%s</td></tr>', row_ender set to a string '</td></tr>', help_text_html set to a string,   '<br /><span class='helptext'>%s</span>' and errors_on_separate_row set to boolean False.   define the method as_ul with an argument self.
return self . _html_output (  normal_row = '<li%(html_class_attr)s>%(errors)s%(label)s %(field)s%(help_text)s</li>' ,  error_row = '<li>%s</li>' ,  row_ender = '</li>' ,  help_text_html = ' <span class='helptext'>%s</span>' ,  errors_on_separate_row = False )	return the result of the method self._html_output, called with 5 arguments: normal_row to a string,
def as_p ( self ) :	'<li%(html_class_attr)s>%(errors)s%(label)s %(field)s%(help_text)s</li>', error_row set to a a string '<li>%s</li>',   row_ender set to a string '</li>', help_text_html set to a string, ' <span class='helptext'>%s</span>',   and errors_on_separate_row set to boolean False.   define the method as_p with an argument self.
return self . _html_output (  normal_row = '<p%(html_class_attr)s>%(label)s %(field)s%(help_text)s</p>' ,  error_row = '%s' ,  row_ender = '</p>' ,  help_text_html = ' <span class='helptext'>%s</span>' ,  errors_on_separate_row = True )	return the result of the method self._html_output, called with 5 arguments: normal_row to a string,
def non_field_errors ( self ) :	'<p%(html_class_attr)s>%(label)s %(field)s%(help_text)s</p>', error_row set to a a string '%s', row_ender set to a string '</p>',   help_text_html set to a string, <span class='helptext'>%s</span>' and errors_on_separate_row set to boolean True.   define the method non_field_errors with an argument self.
return self . errors . get ( NON_FIELD_ERRORS , self . error_class ( error_class = 'nonfield' ) )	return the result of the method self.errors.get called with 2 arguments: NON_FIELD_ERRORS and return value of the method,
def _raw_value ( self , fieldname ) :	self.error_class called with an argument error_class set to string 'nonfield'.   define the method _raw_value with 2 arguments: self and fieldname.
field = self . fields [ fieldname ]	substitute the value under the fieldname key of the self.fields dictionary for field.
prefix = self . add_prefix ( fieldname )	call the method self.add_prefix with an argument fieldname, substitute it for prefix.
return field . widget . value_from_datadict ( self . data , self . files , prefix )	return the result of the method field.widget.value_from_datadict called with 3 arguments: self.data, self.files and prefix.
def add_error ( self , field , error ) :	define the method add_error with 3 arguments: self, field and errors.
if not isinstance ( error , ValidationError ) :	if error is not an instance of ValidationError,
error = ValidationError ( error )	error is an instance of ValidationError created with an argument error.
if hasattr ( error , 'error_dict' ) :	if error has an attribute 'error_dict',
if field is not None :	if field is not None,
raise TypeError (  'The argument `field` must be `None` when the `error` '  'argument contains errors for multiple fields.'  )	raise an TypeError with an argument string 'The argument `field` must be `None` when the `error`argument contains errors for multiple fields.'.
else :	if not,
error = error . error_dict	substitute error.error_dict for error.
else :	if not,
error = { field or NON_FIELD_ERRORS : error . error_list }	error is an dictionary with an initial entry error.error_list for filed if true, or NON_FIELD_ERRORS if not.
for field , error_list in error . items ( ) :	call the method error.items, for every field and error_list in the result,
if field not in self . errors :	if field is not contained in self.errors,
if field != NON_FIELD_ERRORS and field not in self . fields :	if field is not equal to NON_FIELD_ERRORS and field is not contained in self.fields,
if field == NON_FIELD_ERRORS :	if field equals NON_FIELD_ERRORS,
self . _errors [ field ] = self . error_class ( error_class = 'nonfield' )	call the method self.error_class with an argument error_class as an string 'nonfield',
else :	substitute the result for value under the field key of the self._errors dictionary.   if not,
self . _errors [ field ] = self . error_class ( )	call the method self.error_class, substitute the result for value under the field key of the self._errors dictionary.
self . _errors [ field ] . extend ( error_list )	extend the value under the field key of the self._errors dictionary with error_list.
if field in self . cleaned_data :	if field is contained in self.cleaned_data,
del self . cleaned_data [ field ]	delete the entry of self.cleaned_data dictionary under the key field.
def has_error ( self , field , code = None ) :	define the method has_error with 3 arguments: self, field and code set to None.
if code is None :	if code is None,
return field in self . errors	if field is contained in self.errors return boolean True, if not, return boolean False.
if field in self . errors :	if field is contained in self.errors,
for error in self . errors . as_data ( ) [ field ] :	call the method self.errors.as_data, for every error for value under the filed key of the returned dictionary,
if error . code == code :	if error.code equals code,
return True	return boolean True.
return False	return boolean False.
def full_clean ( self ) :	define the method full_clean with an argument self.
self . _errors = ErrorDict ( )	self._errors is an instance of ErrorDict.
if not self . is_bound :	if self.is_bound is false,
return	return nothing.
self . cleaned_data = { }	self.cleaned_data is an empty dictionary.
if self . empty_permitted and not self . has_changed ( ) :	if self.empty_permitted is true and call to the method self.has_changed evaluates to false,
return	return nothing.
self . _clean_fields ( )	call the method self._clean_fields.
self . _clean_form ( )	call the method self._clean_form.
self . _post_clean ( )	call the method self._post_clean.
def _clean_fields ( self ) :	define the method _clean_fields with an argument self.
for name , field in self . fields . items ( ) :	call the method self.fields.items, for every name and field in result,
value = field . widget . value_from_datadict ( self . data , self . files , self . add_prefix ( name ) )	call the method field.widget.value_from_datadict with 3 arguments: self.data, self.files and return value of the method,
try :	self.add_prefix called with an argument name, substitute the result for value.   try,
if isinstance ( field , FileField ) :	if field is an instance of FileField,
initial = self . initial . get ( name , field . initial )	get the value under the name key of the self.initial dictionary, if it exists substitute it for initial,
value = field . clean ( value , initial )	if not substitute field.initial for initial.   call the method filed.clean with arguments value and initial, substitute the result for value.
else :	if not,
value = field . clean ( value )	call the method field.clean with an argument value, substitute the result for value.
self . cleaned_data [ name ] = value	substitute value for the value under the name key of the self.cleaned_data dictionary.
if hasattr ( self , 'clean_%s' % name ) :	if self has an attribute 'clean_%s', where '%s' is replaced with name,
value = getattr ( self , 'clean_%s' % name ) ( )	get 'clean_%s', where '%s' is replaced with name' attribute of the self object, call the result as an function,
self . cleaned_data [ name ] = value	substitute the result for value.   substitute value for the value under the name key of the self.cleaned_data dictionary.
except ValidationError as e :	if ValidationError renamed to e, exception is caught,
self . add_error ( name , e )	call the method self.add_error with 2 arguments name and e.
def _clean_form ( self ) :	define the method _clean_form with an argument self.
try :	try,
cleaned_data = self . clean ( )	call the method self.clean, substitute the result for cleaned_data.
except ValidationError as e :	if ValidationError renamed to e, exception is caught,
self . add_error ( None , e )	call the method self.add_error with 2 arguments None and e.
else :	if not,
if cleaned_data is not None :	if cleaned_data is not None,
self . cleaned_data = cleaned_data	substitute cleaned_data for self.cleaned_data.
def _post_clean ( self ) :	define the method _post_clean with an argument self.
pass	do nothing.
def clean ( self ) :	define the method clean with an argument self.
return self . cleaned_data	return self.cleaned_data.
def has_changed ( self ) :	define the method has_changed with an argument self.
return bool ( self . changed_data )	convert self.changed_data into boolean, return it.
@ property	property decorator,
def changed_data ( self ) :	define the method changed_data with an argument self.
if self . _changed_data is None :	if self._changed_data is None,
self . _changed_data = [ ]	self._changed_data is an empty list.
for name , field in self . fields . items ( ) :	call the method self.fields.items, for every name and field in the result,
prefixed_name = self . add_prefix ( name )	call the method self.add_prefix with an argument name, substitute the result for prefixed_name.
data_value = field . widget . value_from_datadict ( self . data , self . files , prefixed_name )	call the method field.widget.value_from_datadict with 3 arguments: self.data, self.files, prefixed_name, substitute the result for data_value.
if not field . show_hidden_initial :	if field.show_hidden_initial is false,
initial_value = self . initial . get ( name , field . initial )	get the value under the name key of the self.initial dictionary, if it exists substitute it for initial_value,
if callable ( initial_value ) :	if not substitute field.initial for initial_value.   if initial_value is an callable object,
    initial_value = initial_value ( )	call the function initial_value, substitute the result for initial_value.
else :	if not,
initial_prefixed_name = self . add_initial_prefix ( name )	call the method self.add_initial_prefix with an argument name, substitute the result for initial_prefixed_name.
hidden_widget = field . hidden_widget ( )	call the method field.hidden_widget, substitute the result for field.hidden_widget.
try :	try,
    initial_value = field . to_python ( hidden_widget . value_from_datadict (  self . data , self . files , initial_prefixed_name ) )	call the method (hidden_widget.value_from_datadict with 3 arguments: self.data, self.files and initial_prefixed_name,
except ValidationError :	use the result as an argument for the call to the field.to_python method, substitute the result for initial_value.   if ValidationError exception is caught,
      self . _changed_data . append ( name )	append name to self._changed_data.
continue	skip this loop iteration.
if field . _has_changed ( initial_value , data_value ) :	call the method field._has_changed with 2 arguments: initial_value and data_value, if it evaluates to true,
self . _changed_data . append ( name )	append name to self._changed_data list.
return self . _changed_data	return self._changed_data.
@ property	property decorator,
def media ( self ) :	define the method media with an argument self.
media = Media ( )	media is an instance of Media class.
for field in self . fields . values ( ) :	call the method self.fields.values, for every field in result,
media = media + field . widget . media	append field.widget.media to media, substitute the result for media.
return media	return media.
def is_multipart ( self ) :	define the method is_multipart with an argument self.
for field in self . fields . values ( ) :	call the method self.fields.values, for every field in result,
if field . widget . needs_multipart_form :	  if field.widget.needs_multipart_form is true,
return True	return boolean True.
return False	return boolean False.
def hidden_fields ( self ) :	define the method hidden_fields with an argument self.
return [ field for field in self if field . is_hidden ]	for field in self if field.is_hidden is true, append field to a list, return the resulting list.
def visible_fields ( self ) :	define the method visible_fields with an argument self.
return [ field for field in self if not field . is_hidden ]	for field in self if field.is_hidden is false, append field to a list, return the resulting list.
class Form ( six . with_metaclass ( DeclarativeFieldsMetaclass , BaseForm ) ) :	derive the class Form from the base classes DeclarativeFieldsMetaclass and BaseForm.
@ python_2_unicode_compatible	decorator python_2_unicode_compatible,
class BoundField ( object ) :	derive the class BoundField from the base class object.
def __init__ ( self , form , field , name ) :	define the method __init__ with 4 arguments: self, form, field and name.
self . form = form	substitute form for self.form.
self . field = field	substitute field for self.field.
self . name = name	substitute name for self.name.
self . html_name = form . add_prefix ( name )	call the method form.add_prefix with an argument self, substitute the result for self.html_name.
self . html_initial_name = form . add_initial_prefix ( name )	call the method form.add_initial_prefix with an argument name, substitute the result for self.html_initial_name.
self . html_initial_id = form . add_initial_prefix ( self . auto_id )	call the method form.add_initial_prefix with an argument self.auto_id, substitute the result for self.html_initial_id.
if self . field . label is None :	if self.field.label is None,
self . label = pretty_name ( name )	call the method pretty_name with an argument name, substitute the result for self.label.
else :	if not,
self . label = self . field . label	substitute self.field.label for self.label.
self . help_text = field . help_text or ''	if field.help_text is true, substitute field.help_text for self.help_text, if not self.help_text is an empty string.
def __str__ ( self ) :	define the method __str__ with an argument self.
if self . field . show_hidden_initial :	if self.field.show_hidden_initial is true,
return self . as_widget ( ) + self . as_hidden ( only_initial = True )	call the method self.as_hidden with an argument only_initial set to boolean True,
return self . as_widget ( )	append the result to the result of the method, self.as_widget, return the resulting string.   call the method self.as_widget, return the result.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
id_ = self . field . widget . attrs . get ( 'id' ) or self . auto_id	get the value under the 'id' key of the self.field.widget.attrs dictionary, if the key exists substitute it for id_,
attrs = { 'id' : id_ } if id_ else { }	if not, substitute self.auto_id for id_.   if if_is true attrs is an dictionary with initial entry: id_ for 'id', if not, attrs is an empty dictionary.
for subwidget in self . field . widget . subwidgets ( self . html_name , self . value ( ) , attrs ) :	call the method self.field.widget.subwidgets with 3 arguments: self.html_name, return value of the method self.value and attrs,
yield subwidget	for every subwidget in the result,   yield subwidget, as the result of the generator.
def __len__ ( self ) :	define the method __len__ with an argument self.
return len ( list ( self . __iter__ ( ) ) )	convert result of the method self.__iter__ into a list, return its length.
def __getitem__ ( self , idx ) :	define the method __getitem__ with 2 arguments: self and idx.
return list ( self . __iter__ ( ) ) [ idx ]	convert result of the method self.__iter__ into a list, return element at the idx index.
@ property	property decorator,
def errors ( self ) :	define the method errors with an argument self.
return self . form . errors . get ( self . name , self . form . error_class ( ) )	get the value under the self.name key of the self.form.errors dictionary, if the key exists, return it,
def as_widget ( self , widget = None , attrs = None , only_initial = False ) :	if not evaluate the method self.form.error_class and return the result.   define the method as_widget with 4 arguments: self, widget set to None, attrs set to None, only_initial set to boolean False.
if not widget :	if widget is false,
widget = self . field . widget	substitute self.field.widget for widget.
if self . field . localize :	if self.field.localize is true,
widget . is_localized = True	widget.is_localized is boolean True.
attrs = attrs or { }	if attrs is false, make it an empty dictionary.
auto_id = self . auto_id	substitute self.auto_id for auto_id.
if auto_id and 'id' not in attrs and 'id' not in widget . attrs :	if auto_id is true and 'id' is not contained in attrs and 'id' is not contained in widget.attrs,
if not only_initial :	if only_initial is false,
attrs [ 'id' ] = auto_id	substitute auto_id for value under the 'id' key of the attrs dictionary.
else :	if not,
attrs [ 'id' ] = self . html_initial_id	substitute self.html_initial_id for value under the 'id' key of the attrs dictionary.
if not only_initial :	if only_initial is false,
name = self . html_name	substitute self.html_name for name.
else :	if not,
name = self . html_initial_name	substitute self.html_initial_name for name.
return force_text ( widget . render ( name , self . value ( ) , attrs = attrs ) )	call the method widget.render with 3 arguments: name, return value of the method self.value, attrs set to attrs,
def as_text ( self , attrs = None , ** kwargs ) :	use it as an argument for the call to the function force_text, return the result.   define the method as_text with 3 arguments: self, attrs set to None and unpacked dictionary kwargs.
return self . as_widget ( TextInput ( ) , attrs , ** kwargs )	call the method self.as_widget with 3 arguments: instance of a class TextInput, attrs and unpacked dictionary kwargs, return the result.
def as_textarea ( self , attrs = None , ** kwargs ) :	define the method as_textarea with 3 arguments: self, attrs set to None and unpacked dictionary kwargs.
return self . as_widget ( Textarea ( ) , attrs , ** kwargs )	call the method self.as_widget with 3 arguments: instance of a class Textarea, attrs and unpacked dictionary kwargs, return the result.
def as_hidden ( self , attrs = None , ** kwargs ) :	define the method as_hidden with 3 arguments: self, attrs set to None and unpacked dictionary kwargs.
return self . as_widget ( self . field . hidden_widget ( ) , attrs , ** kwargs )	call the method self.as_widget with 3 arguments: return value of the method self.field.hidden_widget, attrs,
@ property	and unpacked dictionary kwargs, return the result.   property decorator,
def data ( self ) :	define the method data with an argument self.
return self . field . widget . value_from_datadict ( self . form . data , self . form . files , self . html_name )	call the method self.field.widget.value_from_datadict with 3 arguments: self.form.data, self.form.files, self.html_name, return the result.
def value ( self ) :	define the method value with an argument self.
if not self . form . is_bound :	if self.form.is_bound is false,
data = self . form . initial . get ( self . name , self . field . initial )	get the value under the self.name key of the self.form.initial dictionary, if it exists, substitute it for data,
if callable ( data ) :	if not, substitute self.field.initial for data.   if data is an callable object,
data = data ( )	call the method data, substitute the result for data.
if ( isinstance ( data , ( datetime . datetime , datetime . time ) ) and  not getattr ( self . field . widget , 'supports_microseconds' , True ) ) :	if data is an instance of datetime.datetime or datetime.time classes, and supports_microseconds field of self.field.widget is false,
data = data . replace ( microsecond = 0 )	call the method data.replace with an argument microsecond set to integer 0, substitute the result for data.
else :	if not,
data = self . field . bound_data (  self . data , self . form . initial . get ( self . name , self . field . initial )  )	call the method self.field.bound_data with 2 arguments: self.data and value under the self.name key of the dictionary,
return self . field . prepare_value ( data )	self.form.initial, if it exists, or self.field.initial if not, substitute the result for data.   call the method self.field.prepare_value with an argument data, return the result.
def label_tag ( self , contents = None , attrs = None , label_suffix = None ) :	define the method label_tag with 4 arguments: self, contents set to None, attrs set to None and label_suffix set to None.
contents = contents or self . label	if contents is false, substitute self.label for contents.
if label_suffix is None :	if label_suffix is None,
label_suffix = ( self . field . label_suffix if self . field . label_suffix is not None  else self . form . label_suffix )	if self.field.label_suffix is not None, substitute self.field.label_suffix for label_suffix,
if label_suffix and contents and contents [ - 1 ] not in _ ( ':?.!' ) :	otherwise substitute self.form.label_suffix for label_suffix.   if label_suffix and contents are both true and last element of contents is not contained in the result of the function _,
contents = format_html ( '{0}{1}' , contents , label_suffix )	called with an argument string ':?.!'.   call the method format_html with 3 arguments: string '{0}{1}', contents and label_suffix, substitute the result for contents.
widget = self . field . widget	substitute self.field.widget for widget.
id_ = widget . attrs . get ( 'id' ) or self . auto_id	get the value under the 'id' key of the widget.attrs dictionary, if the key exists substitute it for id_,
if id_ :	if not, substitute self.auto_id for id_.   if id_ is true,
id_for_label = widget . id_for_label ( id_ )	call the method widget.id_for_label with an argument id_, substitute the result for id_for_label.
if id_for_label :	if id_for_label is true,
attrs = dict ( attrs or { } , ** { 'for' : id_for_label } )	unpack a dictionary with an entry id_for_label for 'for', map it through attrs mapping if attrs is true,
if self . field . required and hasattr ( self . form , 'required_css_class' ) :	and convert it again to the dictionary, if attrs is false, leave it alone, substitute the result for attrs.   if self.field.required is true and self.form has an attribute 'required_css_class',
attrs = attrs or { }	if attrs is false, make attrs an empty dictionary.
if 'class' in attrs :	if 'class' is contained in attrs,
attrs [ 'class' ] += ' ' + self . form . required_css_class	append self.form.required_css_class to a whitespace character, append it to the value under the 'class' key of the attrs dictionary.
else :	if not,
attrs [ 'class' ] = self . form . required_css_class	substitute self.form.required_css_class for the value under the 'class' key of the attrs dictionary.
attrs = flatatt ( attrs ) if attrs else ''	if attrs is true, call the function flatatt with an argument attrs, substitute the result for attrs, if not attrs is an empty string.
contents = format_html ( '<label{0}>{1}</label>' , attrs , contents )	call the function format_html with 3 arguments string '<label{0}>{1}</label>', attrs and contents, substitute the result for contents.
else :	if not,
contents = conditional_escape ( contents )	call the function conditional_escape with an argument contents, substitute the result for contents.
return mark_safe ( contents )	call the function mark_safe with an argument contents, return the result.
def css_classes ( self , extra_classes = None ) :	define the method css_classes with 2 arguments: self and extra_classes set to None.
if hasattr ( extra_classes , 'split' ) :	if extra_classes has an attribute 'split',
extra_classes = extra_classes . split ( )	split extra_classes into words, by whitespaces, substitute the result for extra_classes.
extra_classes = set ( extra_classes or [ ] )	if extra_classes is not empty put its elements into a set, substitute it for extra_classes, if not extra_classes is an empty set.
if self . errors and hasattr ( self . form , 'error_css_class' ) :	if self.errors is true and self.form has an attribute 'error_css_class',
extra_classes . add ( self . form . error_css_class )	add self.form.error_css_class to extra_classes set.
if self . field . required and hasattr ( self . form , 'required_css_class' ) :	if self.field.required is true and self.form has an attribute 'required_css_class' ,
extra_classes . add ( self . form . required_css_class )	add self.form.required_css_class to extra_classes set.
return ' ' . join ( extra_classes )	join elements of extra_classes into a string separated by whitespaces, return it.
@ property	property decorator,
def is_hidden ( self ) :	define the method is_hidden with an argument self.
return self . field . widget . is_hidden	return self.field.widget.is_hidden,
@ property	property decorator,
def auto_id ( self ) :	define the method auto_id with an argument self.
auto_id = self . form . auto_id	substitute self.form.auto_id for auto_id.
if auto_id and '%s' in smart_text ( auto_id ) :	if auto_id is true and '%s' is contained in result of the call to the function smart_text with an argument auto_id,
return smart_text ( auto_id ) % self . html_name	call the function smart_text with an argument auto_id, format the result with self.html_name, return it.
elif auto_id :	otherwise if auto_id is true,
return self . html_name	return self.html_name.
return ''	return an empty string.
@ property	property decorator,
def id_for_label ( self ) :	define the method id_for_label with an argument self.
widget = self . field . widget	substitute self.field.widget for widget.
id_ = widget . attrs . get ( 'id' ) or self . auto_id	get the value under the 'id' key of the widget.attrs dictionary, if the key exists substitute it for id_,
return widget . id_for_label ( id_ )	if not, substitute self.auto_id for id_.   call the method widget.id_for_label with an argument id_, return the result.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . core . exceptions import ValidationError	from django.core.exceptions import ValidationError into default name space.
from django . forms import Form	from django.forms import Form into default name space.
from django . forms . fields import IntegerField , BooleanField	from django.forms.fields import IntegerField and BooleanField into default name space.
from django . forms . utils import ErrorList	from django.forms.utils import ErrorList into default name space.
from django . forms . widgets import HiddenInput	from django.forms.widgets import HiddenInput into default name space.
from django . utils . encoding import python_2_unicode_compatible	from django.utils.encoding import python_2_unicode_compatible into default name space.
from django . utils . functional import cached_property	from django.utils.functional import cached_property into default name space.
from django . utils . safestring import mark_safe	from django.utils.safestring import mark_safe into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . six . moves import xrange	from django.utils.six.moves import xrange into default name space.
from django . utils . translation import ungettext , ugettext as _	from django.utils.translation import ungettext and ugettext as _ into default name space.
__all__ = ( 'BaseFormSet' , 'formset_factory' , 'all_valid' )	__all__ is a tuple containing strings 'BaseFormSet', 'formset_factory' and 'all_valid'.
TOTAL_FORM_COUNT = 'TOTAL_FORMS'	TOTAL_FORM_COUNT is a string 'TOTAL_FORMS'.
INITIAL_FORM_COUNT = 'INITIAL_FORMS'	INITIAL_FORM_COUNT is a string 'INITIAL_FORMS'.
MIN_NUM_FORM_COUNT = 'MIN_NUM_FORMS'	MIN_NUM_FORM_COUNT is a string 'MIN_NUM_FORMS'.
MAX_NUM_FORM_COUNT = 'MAX_NUM_FORMS'	MAX_NUM_FORM_COUNT is a string 'MAX_NUM_FORMS'.
ORDERING_FIELD_NAME = 'ORDER'	ORDERING_FIELD_NAME is a string 'ORDER'.
DELETION_FIELD_NAME = 'DELETE'	DELETION_FIELD_NAME is a string 'DELETE'.
DEFAULT_MIN_NUM = 0	DEFAULT_MIN_NUM is an integer 0.
DEFAULT_MAX_NUM = 1000	DEFAULT_MAX_NUM is an integer 1000.
class ManagementForm ( Form ) :	derive the class ManagementForm from the Form base class.
def __init__ ( self , * args , ** kwargs ) :	define the method __init__ with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
self . base_fields [ TOTAL_FORM_COUNT ] = IntegerField ( widget = HiddenInput )	value under the TOTAL_FORM_COUNT of the self.base_fields dictionary is an instance of IntegerField class,
self . base_fields [ INITIAL_FORM_COUNT ] = IntegerField ( widget = HiddenInput )	created with an argument widget set to HiddenInput.   value under the INITIAL_FORM_COUNT of the self.base_fields dictionary is an instance of IntegerField class,
self . base_fields [ MIN_NUM_FORM_COUNT ] = IntegerField ( required = False , widget = HiddenInput )	created with an argument widget set to HiddenInput.   value under the MIN_NUM_FORM_COUNT of the self.base_fields dictionary is an instance of IntegerField class,
self . base_fields [ MAX_NUM_FORM_COUNT ] = IntegerField ( required = False , widget = HiddenInput )	created with 2 arguments: required as boolean False and widget set to HiddenInput.   value under the MAX_NUM_FORM_COUNT of the self.base_fields dictionary is an instance of IntegerField class,
super ( ManagementForm , self ) . __init__ ( * args , ** kwargs )	created with 2 arguments: required as boolean False and widget set to HiddenInput.   call the method __init__ from the base class of the class ManagementForm, called with 2 arguments: unpacked list args,
@ python_2_unicode_compatible	and unpacked dictionary kwargs.   python_2_unicode_compatible decorator,
class BaseFormSet ( object ) :	derive the class BaseFormSet from the object base class.
def __init__ ( self , data = None , files = None , auto_id = 'id_%s' , prefix = None ,  initial = None , error_class = ErrorList ) :	define the method __init__ with 7 arguments: self, data set to None, files set to None, auto_id set to an string 'id_%s',
self . is_bound = data is not None or files is not None	if data is not None or files is not None, self.is_bound is boolean True, otherwise it is boolean False.
self . prefix = prefix or self . get_default_prefix ( )	if prefix is true, substitute it for self.prefix, otherwise call the method self.get_default_prefix,
self . auto_id = auto_id	and substitute the result for self.prefix.   substitute auto_id for self.auto_id.
self . data = data or { }	if data is true, substitute it for self.data, otherwise self.data is an empty dictionary.
self . files = files or { }	if data is true, substitute it for self.files, otherwise self.files is an empty dictionary.
self . initial = initial	substitute initial_id for self.auto_id.
self . error_class = error_class	substitute error_class for self.error_class.
self . _errors = None	self._errors is None.
self . _non_form_errors = None	self._non_form_errors is None.
def __str__ ( self ) :	define the method __str__ with an argument self.
return self . as_table ( )	call the method self.as_table, return the result.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
return iter ( self . forms )	convert self.forms into an iterable, return it.
def __getitem__ ( self , index ) :	define the method __getitem__ with an argument self.
return self . forms [ index ]	return self.forms element at the index index.
def __len__ ( self ) :	define the method __len__ with an argument self.
return len ( self . forms )	return the length of self.forms.
def __bool__ ( self ) :	define the method __bool__ with an argument self.
return True	return boolean True.
def __nonzero__ ( self ) :	define the method __nonzero__ with an argument self.
return type ( self ) . __bool__ ( self )	get the type of self object, call the __bool__ method on the result with an argument self, return the result.
@ property	property decorator,
def management_form ( self ) :	define the method management_form with an argument self.
if self . is_bound :	if self.is_bound is true,
form = ManagementForm ( self . data , auto_id = self . auto_id , prefix = self . prefix )	form is an instance of ManagementForm class, created with 3 arguments: self.data, auto_id as self.auto_id and prefix as self.prefix.
if not form . is_valid ( ) :	call the form.is_valid method, if it evaluates to false,
raise ValidationError (  _ ( 'ManagementForm data is missing or has been tampered with' ) ,  code = 'missing_management_form' ,  )	raise ValidationError with 2 arguments: return value of the function _ called with an argument string,
else :	'ManagementForm data is missing or has been tampered with' and code as a string 'missing_management_form'.   if not,
form = ManagementForm ( auto_id = self . auto_id , prefix = self . prefix , initial = {  TOTAL_FORM_COUNT : self . total_form_count ( ) ,  INITIAL_FORM_COUNT : self . initial_form_count ( ) ,  MIN_NUM_FORM_COUNT : self . min_num ,  MAX_NUM_FORM_COUNT : self . max_num  } )	form is an instance of ManagementForm class, created with 3 arguments: auto_id as self.auto_id, prefix as self.prefix,
return form	and initial as a dictionary with 4 entries: result of self.total_form_count method for TOTAL_FORM_COUNT,   result of self.initial_form_count method for INITIAL_FORM_COUNT, self.min_num for MIN_NUM_FORM_COUNT and self.max_num for MAX_NUM_FORM_COUNT.   return form.
def total_form_count ( self ) :	define the method total_form_count with an argument self.
if self . is_bound :	if self.is_bound is true,
return min ( self . management_form . cleaned_data [ TOTAL_FORM_COUNT ] , self . absolute_max )	get the element with minimal value between the value under the TOTAL_FORM_COUNT key of self.management_form.cleaned_data dictionary,
else :	and self.absolute_max, return the result.   if not,
initial_forms = self . initial_form_count ( )	call the method self.initial_form_count, return the result initial_forms.
total_forms = max ( initial_forms , self . min_num ) + self . extra	get the element with maximal value between initial_forms and self.min_num, add self.extra to it, substitute the result for total_forms.
if initial_forms > self . max_num >= 0 :	if initial_forms is grater than self.max_num is grater or equal to integer 0,
total_forms = initial_forms	substitute initial_forms for total_forms.
elif total_forms > self . max_num >= 0 :	otherwise if total_forms is grater than self.max_num is grater or equal to integer 0,
total_forms = self . max_num	substitute self.max_num for total_forms.
return total_forms	return total_forms.
def initial_form_count ( self ) :	define the method initial_form_count with an argument self.
if self . is_bound :	if self.is_bound is true,
return self . management_form . cleaned_data [ INITIAL_FORM_COUNT ]	return the value under the INITIAL_FORM_COUNT key of the self.management_form.cleaned_data dictionary.
else :	if not,
initial_forms = len ( self . initial ) if self . initial else 0	if self.initial is true, substitute the length of self.initial for initial_forms, if not, initial_forms is integer 0.
return initial_forms	return initial_forms.
@ cached_property	cached_property decorator,
def forms ( self ) :	define the method forms with an argument self.
forms = [ self . _construct_form ( i ) for i in xrange ( self . total_form_count ( ) ) ]	for every i in sequence of integers from 0 to result of the method self.total_form_count, call the method self._construct_form,
return forms	with an argument i, append the result to a list, substitute the resulting list for forms.   return forms.
def _construct_form ( self , i , ** kwargs ) :	define the method _construct_form with 3 arguments: self, i and unpacked dictionary kwargs.
defaults = {  'auto_id' : self . auto_id ,  'prefix' : self . add_prefix ( i ) ,  'error_class' : self . error_class ,  }	defaults is an dictionary with 3 initial entries: self.auto_id for 'auto_id', result of the call to the method self.add_prefix,
if self . is_bound :	with an argument i, for 'prefix' and self.error_class for 'error_class'.   if self.is_bound is true,
defaults [ 'data' ] = self . data	substitute self.data for value under the 'data' key of the defaults dictionary.
defaults [ 'files' ] = self . files	substitute self.files for value under the 'files' key of the defaults dictionary.
if self . initial and 'initial' not in kwargs :	  if self.initial is true and 'initial' key is not contained in kwargs,
try :	try,
defaults [ 'initial' ] = self . initial [ i ]	substitute i-th element of self.initial for value under the 'initial' key of the defaults dictionary.
except IndexError :	if IndexError exception is caught,
pass	do nothing.
if i >= self . initial_form_count ( ) and i >= self . min_num :	if i is greater than, or equal to the result of the call to the method self.initial_form_count,
defaults [ 'empty_permitted' ] = True	and i is greater than or equal to self.min_num,   value under the 'empty_permitted' key of the defaults dictionary is boolean True.
defaults . update ( kwargs )	update defaults dictionary with kwargs.
form = self . form ( ** defaults )	call the method self.form with unpacked dictionary defaults as an argument, substitute it for form.
self . add_fields ( form , i )	call the method self.add_fields with arguments form and i).
return form	return form.
@ property	property decorator,
def initial_forms ( self ) :	define the method initial_forms with an argument self.
return self . forms [ : self . initial_form_count ( ) ]	call the self.initial_form_count method, return the sublist of self.forms from the beginning to the previous result as the end index.
@ property	property decorator,
def extra_forms ( self ) :	define the method extra_forms with an argument self.
return self . forms [ self . initial_form_count ( ) : ]	call the self.initial_form_count method, return the sublist of self.forms, using previous result as start index to the end.
@ property	property decorator,
def empty_form ( self ) :	define the method empty_form with an argument self.
form = self . form (  auto_id = self . auto_id ,  prefix = self . add_prefix ( '__prefix__' ) ,  empty_permitted = True ,  )	call the function empty_form with 3 arguments: auto_id as self.auto_id, prefix set to the return value of the self.add_prefix method,
self . add_fields ( form , None )	called with string '__prefix__' as an argument and empty_permitted as boolean True, substitute the result for form.   call the method self.add_fields with arguments form and None.
return form	return form.
@ property	property decorator,
def cleaned_data ( self ) :	define the method cleaned_data with an argument self.
if not self . is_valid ( ) :	call the method self.is_valid, if it evaluates to false,
return [ form . cleaned_data for form in self . forms ]	where '%s' is replaced with self.__class__.__name__.   for form in self.forms append form.cleaned_data to a list, return the resulting list.
@ property	property decorator,
def deleted_forms ( self ) :	define the method deleted_forms with an argument self.
if not self . is_valid ( ) or not self . can_delete :	if call to the method self.is_valid, evaluates to false or self.can_delete is boolean false,
return [ ]	return an empty list.
if not hasattr ( self , '_deleted_form_indexes' ) :	if self doesnt have an '_deleted_form_indexes' attribute,
self . _deleted_form_indexes = [ ]	self._deleted_form_indexes is an empty list.
for i in range ( 0 , self . total_form_count ( ) ) :	call the method self.total_form_count, for every i in sequence of integers, from 0 to the previous result,
form = self . forms [ i ]	substitute i-th element of self.forms for form.
if i >= self . initial_form_count ( ) and not form . has_changed ( ) :	if i is greater than or equal to the result of the method self.initial_form_count,
continue	and call to the method form.has_changed evaluates to false,   skip this loop iteration,
if self . _should_delete_form ( form ) :	call the method self._should_delete_form with an argument form, if it evaluates to true,
self . _deleted_form_indexes . append ( i )	call the method self._deleted_form_indexes.append with an argument i.
return [ self . forms [ i ] for i in self . _deleted_form_indexes ]	for i in self._deleted_form_indexes append i-th element of self.forms into a list, return the resulting list.
@ property	property decorator,
def ordered_forms ( self ) :	define the method ordered_forms with an argument self.
if not self . is_valid ( ) or not self . can_order :	if call to the self.is_valid method evaluates to false or self.can_order is false,
if not hasattr ( self , '_ordering' ) :	where '%s' is replaced with self.__class__.__name__.   if self doesnt have an '_ordering' attribute,
self . _ordering = [ ]	self._ordering is an empty list.
for i in range ( 0 , self . total_form_count ( ) ) :	for every i in sequence of integers, from 0 to the result of the method self.total_form_count,
form = self . forms [ i ]	substitute i-th element of self.forms for form.
if i >= self . initial_form_count ( ) and not form . has_changed ( ) :	if i is greater than or equal to the result of the method self.initial_form_count,
continue	and call to the method form.has_changed evaluates to false,   skip this loop iteration,
if self . can_delete and self . _should_delete_form ( form ) :	if self.can_delete is true and call to the method self._should_delete_form with an argument form, evaluates to true,
continue	skip this loop iteration,
self . _ordering . append ( ( i , form . cleaned_data [ ORDERING_FIELD_NAME ] ) )	append tuple with 2 elements: i and value under the ORDERING_FIELD_NAME key of form.cleaned_data dictionary to self._ordering.
def compare_ordering_key ( k ) :	define the function compare_ordering_key with an argument k.
if k [ 1 ] is None :	if second element of k is None,
return ( 1 , 0 )	return a tuple with 2 elements: integers 1 and 0.
return ( 0 , k [ 1 ] )	return a tuple with 2 elements: integer 0 and second element of k.
self . _ordering . sort ( key = compare_ordering_key )	call the method self._ordering.sort with an argument key as compare_ordering_key.
return [ self . forms [ i [ 0 ] ] for i in self . _ordering ]	for i in self._ordering append to a list value under the first element of i key of the self.forms dictionary, return resulting list.
@ classmethod	classmethod decorator,
def get_default_prefix ( cls ) :	define the method get_default_prefix with an argument cls.
return 'form'	return string 'form'.
def non_form_errors ( self ) :	define the method non_form_errors with an argument self.
if self . _non_form_errors is None :	if self._non_form_errors is None,
self . full_clean ( )	call the method self.full_clean.
return self . _non_form_errors	return self._non_form_errors.
@ property	property decorator,
def errors ( self ) :	define the method errors with an argument self.
if self . _errors is None :	if self._errors is None,
self . full_clean ( )	call the method self.full_clean.
return self . _errors	return self._errors.
def total_error_count ( self ) :	define the method total_error_count with an argument self.
return len ( self . non_form_errors ( ) ) + sum ( len ( form_errors ) for form_errors in self . errors )	for every form_errors in self.errors sum length of return value of the method self.non_form_errors and length of form_errors, return the result.
def _should_delete_form ( self , form ) :	define the method _should_delete_form with an argument self.
return form . cleaned_data . get ( DELETION_FIELD_NAME , False )	get the value under the DELETION_FIELD_NAME key of the form.cleaned_data dictionary, if it exists return it, if not, return boolean False.
def is_valid ( self ) :	define the method is_valid with an argument self.
if not self . is_bound :	if self.is_bound is false,
return False	return boolean False.
forms_valid = True	forms_valid is True.
self . errors	call self.errors.
for i in range ( 0 , self . total_form_count ( ) ) :	for every i in sequence of integers, from 0 to the result of the method self.total_form_count,
form = self . forms [ i ]	substitute i-th element of self.forms for form.
if self . can_delete :	if self.can_delete is true,
if self . _should_delete_form ( form ) :	call the method self._should_delete_form with an argument, if it evaluates to true,
  continue	skip this loop iteration,
forms_valid &= form . is_valid ( )	call the method form.is_valid, perform bitwise and with the result and forms_valid as operands, substitute the result for forms_valid.
return forms_valid and not self . non_form_errors ( )	if forms_valid is true and call to the method self.non_form_errors, evaluates to false, return boolean True, otherwise return False.
def full_clean ( self ) :	define the method full_clean with an argument self.
self . _errors = [ ]	self._errors is an empty list.
self . _non_form_errors = self . error_class ( )	call the method self.error_class, substitute the result for self._non_form_errors.
if not self . is_bound :	if self.is_bound is false,
return	return nothing.
for i in range ( 0 , self . total_form_count ( ) ) :	for every i in sequence of integers, from 0 to the result of the method self.total_form_count,
form = self . forms [ i ]	substitute i-th element of self.forms for form.
self . _errors . append ( form . errors )	append form.errors to self._errors.
try :	try,
if ( self . validate_max and  self . total_form_count ( ) - len ( self . deleted_forms ) > self . max_num ) or self . management_form . cleaned_data [ TOTAL_FORM_COUNT ] > self . absolute_max :	if self.validate_max is true, and length of self.deleted_forms subtracted from the return value of the method self.total_form_count,
raise ValidationError ( ungettext (  'Please submit %d or fewer forms.' ,  'Please submit %d or fewer forms.' , self . max_num ) % self . max_num ,  code = 'too_many_forms' ,  )	is greater than self.max_num, or if value under the TOTAL_FORM_COUNT key of the self.management_form.cleaned_data dictionary,   is grater than self.absolute_max,   raise an ValidationError with 2 arguments: return value of the function ungettext with 3 arguments:
if ( self . validate_min and  self . total_form_count ( ) - len ( self . deleted_forms ) < self . min_num ) :	strings 'Please submit %d or fewer forms.', 'Please submit %d or fewer forms.' and self.max_num,   where '%d' is replaced with self.max_num, and code as a string 'too_many_forms'.   if self.validate_min is true, and length of self.deleted_forms subtracted from the return value of the method self.total_form_count,
raise ValidationError ( ungettext (  'Please submit %d or more forms.' ,  'Please submit %d or more forms.' , self . min_num ) % self . min_num ,  code = 'too_few_forms' )	is smaller than self.min_num,   raise an ValidationError with 2 arguments: return value of the function ungettext with 3 arguments:
self . clean ( )	strings 'Please submit %d or more forms.', 'Please submit %d or more forms.' and self.min_num,   where '%d' is replaced with self.min_num, and code as a string 'too_few_forms'.   call the method self.clean.
except ValidationError as e :	if ValidationError, renamed to e, exception is caught,
self . _non_form_errors = self . error_class ( e . error_list )	call the method self.error_class with an argument e.error_list, substitute the result for self._non_form_errors.
def clean ( self ) :	define the method clean with an argument self.
pass	do nothing.
def has_changed ( self ) :	define the method has_changed with an argument self.
return any ( form . has_changed ( ) for form in self )	for every form in self call the method form.has_changed if any of the results evaluates to true, return boolean True,
def add_fields ( self , form , index ) :	if not return boolean False.   define the method add_fields with 3 arguments: self, form and index.
if self . can_order :	if self.can_order is true,
if index is not None and index < self . initial_form_count ( ) :	if index is not None and index is smaller than return value of the method self.initial_form_count,
form . fields [ ORDERING_FIELD_NAME ] = IntegerField ( label = _ ( 'Order' ) , initial = index + 1 , required = False )	value under the ORDERING_FIELD_NAME key of the form.fields is an instance of IntegerField class, created with 3 arguments:
else :	label set to return value of the function _ called with an string 'Order', initial set to index incremented by 1,   and required as boolean False.   if not,
form . fields [ ORDERING_FIELD_NAME ] = IntegerField ( label = _ ( 'Order' ) , required = False )	value under the ORDERING_FIELD_NAME key of the form.fields is an instance of IntegerField class, created with 2 arguments:
if self . can_delete :	label set to return value of the function _ called with an string 'Order' and required as boolean False.   if self.can_delete is true,
form . fields [ DELETION_FIELD_NAME ] = BooleanField ( label = _ ( 'Delete' ) , required = False )	value under the DELETION_FIELD_NAME key of the form.fields is an instance of BooleanField class, created with 2 arguments:
def add_prefix ( self , index ) :	label set to return value of the function _ called with an string 'Delete' and required as boolean False.   define the method add_prefix with an argument self.
return '%s-%s' % ( self . prefix , index )	replace '%s' in sting '%s-%s' with self.prefix and index, return the result.
def is_multipart ( self ) :	define the method is_multipart with an argument self.
if self . forms :	if self.forms is true,
return self . forms [ 0 ] . is_multipart ( )	call the method is_multipart on the first element of self.forms, return it.
else :	if not,
return self . empty_form . is_multipart ( )	call the method self.empty_form.is_multipart, return the result
@ property	property decorator,
def media ( self ) :	define the method media with an argument self.
if self . forms :	if self.forms is true,
return self . forms [ 0 ] . media	return the media field of the first element of self.forms.
else :	if not,
return self . empty_form . media	return self.empty_form.media.
def as_table ( self ) :	define the method as_table with an argument self.
forms = ' ' . join ( form . as_table ( ) for form in self )	for every form in self call the form.as_table method, join the results in a string, separated by an empty string.
\return mark_safe ( '\\n' . join ( [ six . text_type ( self . management_form ) , forms ] ) )\	join return value of the function six.text_type called with an argument self.management_form and forms into a string,
def as_p ( self ) :	separated by newline, use it as an argument for the call to the function mark_safe, return the result.   define the method as_p with an argument self.
forms = ' ' . join ( form . as_p ( ) for form in self )	for every form in self call the form.as_p method, join the results in a string, separated by an empty string.
\return mark_safe ( '\\n' . join ( [ six . text_type ( self . management_form ) , forms ] ) )\	join return value of the function six.text_type called with an argument self.management_form and forms into a string,
def as_ul ( self ) :	separated by newline, use it as an argument for the call to the function mark_safe, return the result.   define the method as_ul with an argument self.
forms = ' ' . join ( form . as_ul ( ) for form in self )	for every form in self call the form.as_ul method, join the results in a string, separated by an empty string.
\return mark_safe ( '\\n' . join ( [ six . text_type ( self . management_form ) , forms ] ) )\	join return value of the function six.text_type called with an argument self.management_form and forms into a string,
def formset_factory ( form , formset = BaseFormSet , extra = 1 , can_order = False ,  can_delete = False , max_num = None , validate_max = False ,  min_num = None , validate_min = False ) :	separated by newline, use it as an argument for the call to the function mark_safe, return the result.   define the function formset_factory with 9 arguments: form, formset set to BaseFormSet, extra set to integer 1,
if min_num is None :	if min_num is None,
min_num = DEFAULT_MIN_NUM	substitute DEFAULT_MIN_NUM for min_num,
if max_num is None :	if max_num is None,
max_num = DEFAULT_MAX_NUM	substitute DEFAULT_MAX_NUM for max_num,
absolute_max = max_num + DEFAULT_MAX_NUM	sum max_num and DEFAULT_MAX_NUM, substitute the result for absolute_max.
attrs = { 'form' : form , 'extra' : extra ,  'can_order' : can_order , 'can_delete' : can_delete ,  'min_num' : min_num , 'max_num' : max_num ,  'absolute_max' : absolute_max , 'validate_min' : validate_min ,  'validate_max' : validate_max }	attrs is an dictionary with 9 initial entries: form for 'form', extra for 'extra', can_order for 'can_order',
return type ( form . __name__ + str ( 'FormSet' ) , ( formset , ) , attrs )	can_delete for 'can_delete', min_num for 'min_num', max_num for 'max_num', absolute_max for 'absolute_max',   validate_min for 'validate_min' for validate_max for 'validate_max'.   create a class class which name is generated by converting 'FormSet' into a string and appending it to form.__name__,
def all_valid ( formsets ) :	is derived from the formset base class and with fields contained in attrs, return an instance of the obtained class.   define the function all_valid with an argument formsets.
valid = True	valid is boolean True.
for formset in formsets :	for every formset in formsets,
if not formset . is_valid ( ) :	call the function formset.is_valid, if it evaluates to false,
valid = False	valid is boolean False.
return valid	return valid.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from collections import OrderedDict	from collections import OrderedDict into default name space.
import warnings	import module warnings.
from django . core . exceptions import (  ImproperlyConfigured , ValidationError , NON_FIELD_ERRORS , FieldError )	django.core.exceptions import ImproperlyConfigured, ValidationError, NON_FIELD_ERRORS and FieldError into default namespace.
from django . forms . fields import Field , ChoiceField	from django.forms.fields import Field and ChoiceField into default name space.
from django . forms . forms import DeclarativeFieldsMetaclass , BaseForm	from django.forms.forms import DeclarativeFieldsMetaclass and BaseForm into default name space.
from django . forms . formsets import BaseFormSet , formset_factory	from django.forms.formsets import BaseFormSet and formset_factory into default name space.
from django . forms . utils import ErrorList	from django.forms.utils import ErrorList into default name space.
from django . forms . widgets import ( SelectMultiple , HiddenInput ,  MultipleHiddenInput )	from django.forms.widgets import SelectMultiple, HiddenInput, MultipleHiddenInput into default namespace.
from django . utils import six	from django.utils import six into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
from django . utils . encoding import smart_text , force_text	from django.utils.encoding import smart_text and force_text into default name space.
from django . utils . text import get_text_list , capfirst	from django.utils.text import get_text_list and capfirst into default name space.
from django . utils . translation import ugettext_lazy as _ , ugettext	from django.utils.translation import ugettext_lazy as _ and ugettext into default name space.
__all__ = (  'ModelForm' , 'BaseModelForm' , 'model_to_dict' , 'fields_for_model' ,  'save_instance' , 'ModelChoiceField' , 'ModelMultipleChoiceField' ,  'ALL_FIELDS' , 'BaseModelFormSet' , 'modelformset_factory' ,  'BaseInlineFormSet' , 'inlineformset_factory' ,  )	__all__ is a tuple containing strings: 'ModelForm', 'BaseModelForm', 'model_to_dict', 'fields_for_model', 'save_instance',
ALL_FIELDS = '__all__'	'ModelChoiceField', 'ModelMultipleChoiceField', 'ALL_FIELDS', 'BaseModelFormSet', 'modelformset_factory', 'BaseInlineFormSet',   and 'inlineformset_factory'.   ALL_FIELDS is a string '__all__'.
def construct_instance ( form , instance , fields = None , exclude = None ) :	define the function construct_instance with 4 arguments: form, instance, fields set to None and exclude set to None.
from django . db import models	from django.db import models into default namespace.
opts = instance . _meta	substitute instance._meta for opts.
cleaned_data = form . cleaned_data	substitute form.cleaned_data for cleaned_data.
file_field_list = [ ]	file_field_list is an empty list.
for f in opts . fields :	for every f in opts.fields,
if not f . editable or isinstance ( f , models . AutoField ) or f . name not in cleaned_data :	if f.editable is true and f is an instance of models.AutoField, or f.name is not contained in cleaned_data,
continue	skip this loop iteration.
if fields is not None and f . name not in fields :	if fields is not None and f.name is not contained in fields,
continue	skip this loop iteration.
if exclude and f . name in exclude :	if exclude is true and f.name is contained in exclude,
continue	skip this loop iteration.
if isinstance ( f , models . FileField ) :	if f is an instance of models.FileField,
file_field_list . append ( f )	append f to file_field_list.
else :	if not,
f . save_form_data ( instance , cleaned_data [ f . name ] )	call the method f.save_form_data with 2 arguments: instance and value under the f.name key of cleaned_data dictionary.
for f in file_field_list :	for every f in file_field_list,
f . save_form_data ( instance , cleaned_data [ f . name ] )	call the method f.save_form_data with 2 arguments: instance and value under the f.name key of cleaned_data dictionary.
return instance	return instance.
def save_instance ( form , instance , fields = None , fail_message = 'saved' ,  commit = True , exclude = None , construct = True ) :	define the function save_instance with 7 arguments: form, instance, fields set to None, fail_message as string 'saved',
if construct :	if construct is true,
instance = construct_instance ( form , instance , fields , exclude )	call the function construct_instance with 4 arguments form, instance, fields, exclude and substitute the result for instance.
opts = instance . _meta	substitute instance._meta for opts.
if form . errors :	if form.errors is true,
raise ValueError ( 'The %s could not be %s because the data didn't'  ' validate.' % ( opts . object_name , fail_message ) )	raise an ValueError with an argument string 'The %s could not be %s because the data didn't validate.',
def save_m2m ( ) :	where '%s' is replaced with opts.object_name and fail_message, respectively.   define the function save_m2m.
cleaned_data = form . cleaned_data	substitute form.cleaned_data for cleaned_data.
for f in opts . many_to_many + opts . virtual_fields :	append opts.virtual_fields to opts.many_to_many, for every f in the result,
if not hasattr ( f , 'save_form_data' ) :	if f doesnt has an 'save_form_data' attribute,
continue	skip this loop iteration.
if fields and f . name not in fields :	if fields is true and f.name is not contained in fields,
continue	skip this loop iteration.
if exclude and f . name in exclude :	if exclude is true and f.name is contained in exclude,
continue	skip this loop iteration.
if f . name in cleaned_data :	if f.name is contained in cleaned_data,
f . save_form_data ( instance , cleaned_data [ f . name ] )	call the method f.save_form_data with 2 arguments: instance and value under the f.name key of cleaned_data dictionary.
if commit :	if commit is true,
instance . save ( )	call the method instance.save.
save_m2m ( )	call the function save_m2m.
else :	if not,
form . save_m2m = save_m2m	substitute save_m2m for form.save_m2m.
return instance	return instance.
def model_to_dict ( instance , fields = None , exclude = None ) :	define the function model_to_dict with 3 arguments: instance, fields set to None and exclude set None.
from django . db . models . fields . related import ManyToManyField	from django.db.models.fields.related import ManyToManyField.
opts = instance . _meta	substitute instance._meta for opts.
data = { }	data is an empty dictionary.
for f in opts . concrete_fields + opts . virtual_fields + opts . many_to_many :	concatenate opts.concrete_fields, opts.virtual_fields and opts.many_to_many, for every f in the result,
if not getattr ( f , 'editable' , False ) :	get 'editable' attribute from object f, if it doesnt exists or its true,
continue	skip this loop iteration.
if fields and f . name not in fields :	if fields is true and f.name is not contained in fields,
continue	skip this loop iteration.
if exclude and f . name in exclude :	if exclude is true and f.name is contained in exclude,
continue	skip this loop iteration.
if isinstance ( f , ManyToManyField ) :	if f is an instance of ManyToManyField,
if instance . pk is None :	if instance.pk is None,
data [ f . name ] = [ ]	value under f.name key of the dta dictionary is an empty list.
else :	if not,
qs = f . value_from_object ( instance )	call the method f.value_from_object with an argument instance, substitute the result for qs.
if qs . _result_cache is not None :	if qs._result_cache is not None,
data [ f . name ] = [ item . pk for item in qs ]	for every item in qu append item.pk to a list, substitute resulting list for value under f.name key of the data dictionary.
else :	if not,
data [ f . name ] = list ( qs . values_list ( 'pk' , flat = True ) )	call the method qs.values_list with 2 arguments: string 'pk' and flat set to boolean True, put the results in a list,
else :	substitute the result for value under the f.name key of data dictionary.   if not,
data [ f . name ] = f . value_from_object ( instance )	call the method f.value_from_object with an argument instance, substitute the result for value under the f.name key of the data dictionary.
return data	return data.
def fields_for_model ( model , fields = None , exclude = None , widgets = None ,  formfield_callback = None , localized_fields = None ,  labels = None , help_texts = None , error_messages = None ) :	define the function fields_for_model with 9 arguments: model, fields set to None, exclude set to None, widgets set to None,
field_list = [ ]	field_list is an empty list.
ignored = [ ]	ignored  is an empty list.
opts = model . _meta	substitute model._meta for opts.
from django . db . models . fields import Field as ModelField	from django.db.models.fields import Field as ModelField.
sortable_virtual_fields = [ f for f in opts . virtual_fields  if isinstance ( f , ModelField ) ]	if f is an instance of ModelFiled, for every f in opts.virtual_fields, append f to a list, substitute the resulting list for sortable_virtual_fields.
for f in sorted ( opts . concrete_fields + sortable_virtual_fields + opts . many_to_many ) :	concatenate opts.concrete_fields, sortable_virtual_fields and opts.many_to_many, for every f in sorted result,
if not getattr ( f , 'editable' , False ) :	get 'editable' attribute from object f, if it doesnt exists or its true,
continue	skip this loop iteration.
if fields is not None and f . name not in fields :	if fields is not None and f.name is not contained in fields,
continue	skip this loop iteration.
if exclude and f . name in exclude :	if exclude is true and f.name is contained in exclude,
continue	skip this loop iteration.
kwargs = { }	kwargs is an empty dictionary,
if widgets and f . name in widgets :	if widgets is true and f.name is contained in widgets,
kwargs [ 'widget' ] = widgets [ f . name ]	substitute value under the f.name key of the widgets dictionary for value under the 'widget' key of kwargs dictionary.
if localized_fields == ALL_FIELDS or ( localized_fields and f . name in localized_fields ) :	if localized_fields equals ALL_FIELDS, or if localized_fields is true and f.name is contained in localized_fields,
kwargs [ 'localize' ] = True	value under 'localize' key of kwargs dictionary is boolean True.
if labels and f . name in labels :	if labels is true and f.name is contained in labels,
kwargs [ 'label' ] = labels [ f . name ]	substitute value under the f.name key of the labels dictionary for value under the 'label' key of kwargs dictionary.
if help_texts and f . name in help_texts :	if help_texts is true and f.name is contained in help_texts,
kwargs [ 'help_text' ] = help_texts [ f . name ]	substitute value under the f.name key of the help_texts dictionary for value under the 'help_text' key of kwargs dictionary.
if error_messages and f . name in error_messages :	if error_messages is true and f.name is contained in error_messages,
kwargs [ 'error_messages' ] = error_messages [ f . name ]	substitute value under the f.name key of the error_messages dictionary for value under the 'error_messages' key of kwargs dictionary.
if formfield_callback is None :	if formfield_callback is None,
formfield = f . formfield ( ** kwargs )	call the method f.formfield with an argument, unpacked dictionary kwargs, substitute the result for formfield.
elif not callable ( formfield_callback ) :	otherwise if formfield_callback is not callable object,
raise TypeError ( 'formfield_callback must be a function or callable' )	raise an TypeError with an string 'formfield_callback must be a function or callable'.
else :	if not,
formfield = formfield_callback ( f , ** kwargs )	call the method formfield_callback with 2 arguments: f and unpacked dictionary kwargs, substitute the result for formfield.
if formfield :	if formfield is true,
field_list . append ( ( f . name , formfield ) )	append a tuple with 2 elements: f.name and formfield to field_list.
else :	if not,
ignored . append ( f . name )	append f.name to ignored list.
field_dict = OrderedDict ( field_list )	field_dict is an instance of OrderedDict class, created with an argument field_list.
if fields :	if fields is true,
field_dict = OrderedDict (  [ ( f , field_dict . get ( f ) ) for f in fields  if ( ( not exclude ) or ( exclude and f not in exclude ) ) and ( f not in ignored ) ]  )	for every f in fields, if exclude is false, or if exclude is true and f is not contained in exclude, and only if f is not in ignored,
return field_dict	append to list, a tuple with 2 elements: f and value under the f key of field_dict dictionary, use the resulting list as an argument,   for the creation of the instance of OrderedDict class, substitute it for field_dict.   return field_dict.
class ModelFormOptions ( object ) :	derive the class ModelFormOptions from object base class.
def __init__ ( self , options = None ) :	define the method __init__ with arguments: self and options set to None.
self . model = getattr ( options , 'model' , None )	get 'model' attribute from the options object, if it exists substitute it for self.model, if not self.model is None.
self . fields = getattr ( options , 'fields' , None )	get 'fields' attribute from the options object, if it exists substitute it for self.fields, if not self.fields is None.
self . exclude = getattr ( options , 'exclude' , None )	get 'exclude' attribute from the options object, if it exists substitute it for self.exclude, if not self.exclude is None.
self . widgets = getattr ( options , 'widgets' , None )	get 'widgets' attribute from the options object, if it exists substitute it for self.widgets, if not self.widgets is None.
self . localized_fields = getattr ( options , 'localized_fields' , None )	get 'localized_fields' attribute from the options object, if it exists substitute it for self.localized_fields,
self . labels = getattr ( options , 'labels' , None )	if not self.localized_fields is None.   get 'labels' attribute from the options object, if it exists substitute it for self.labels, if not self.labels is None.
self . help_texts = getattr ( options , 'help_texts' , None )	get 'help_texts' attribute from the options object, if it exists substitute it for self.help_texts, if not self.help_texts is None.
self . error_messages = getattr ( options , 'error_messages' , None )	get 'error_messages' attribute from the options object, if it exists substitute it for self.error_messages,
class ModelFormMetaclass ( DeclarativeFieldsMetaclass ) :	if not self.error_messages is None.   derive the class ModelFormMetaclass from the DeclarativeFieldsMetaclass base class.
def __new__ ( mcs , name , bases , attrs ) :	define the method __new__ with 4 arguments: mcs, name, bases and attrs.
formfield_callback = attrs . pop ( 'formfield_callback' , None )	remove entry under the 'formfield_callback' key of the attrs dictionary, if it exists substitute if for formfield_callback,
new_class = super ( ModelFormMetaclass , mcs ) . __new__ ( mcs , name , bases , attrs )	if not formfield_callback is None.   call the method __new__ from the base class of the class ModelFormMetaclass, with 4 arguments: mcs, name, bases and attrs,
if bases == ( BaseModelForm , ) :	substitute the result for new_class.   if bases equals a tuple with an element: class BaseModelForm.
return new_class	return new_class.
opts = new_class . _meta = ModelFormOptions ( getattr ( new_class , 'Meta' , None ) )	instantiate class ModelFormOptions with argument: attribute 'Meta' of the new_class object. if it exists or None, if not,
for opt in [ 'fields' , 'exclude' , 'localized_fields' ] :	assign the result to opts and new_class._meta.   for every opt in list containing 3 elements: strings 'fields', 'exclude' and 'localized_fields',
value = getattr ( opts , opt )	get opt attribute of the opts object, substitute it for value.
if isinstance ( value , six . string_types ) and value != ALL_FIELDS :	if value is an instance of six.string_types and value is not equal to ALL_FIELDS,
msg = ( '%(model)s.Meta.%(opt)s cannot be a string. '  'Did you mean to type: ('%(value)s',)?' % {  'model' : new_class . __name__ ,  'opt' : opt ,  'value' : value ,  } )	msg is a string '%(model)s.Meta.%(opt)s cannot be a string. Did you mean to type: ('%(value)s',)?', where '%(model)s' is replaced,
raise TypeError ( msg )	with new_class.__name__, '%(opt)s' is replaced with opt and '%(value)s' is replaced with value.   raise an TypeError exception with an argument msg.
if opts . model :	if opts.model is true,
if opts . fields is None and opts . exclude is None :	if opts.fields is None and opts.exclude is None,
raise ImproperlyConfigured (  'Creating a ModelForm without either the 'fields' attribute '  'or the 'exclude' attribute is prohibited; form %s '  'needs updating.' % name  )	raise an ImproperlyConfigured exception with an argument string 'Creating a ModelForm without either the 'fields' attribute,
if opts . fields == ALL_FIELDS :	or the 'exclude' attribute is prohibited; form %s needs updating., where '%s' is replaced with name.   if opts.fields equals ALL_FIELDS,
opts . fields = None	opts.fields is None.
fields = fields_for_model ( opts . model , opts . fields , opts . exclude ,  opts . widgets , formfield_callback ,  opts . localized_fields , opts . labels ,  opts . help_texts , opts . error_messages )	call the function fields_for_model with 9 arguments: opts.model, opts.fields, opts.exclude, opts.widgets, formfield_callback,
none_model_fields = [ k for k , v in six . iteritems ( fields ) if not v ]	opts.localized_fields, opts.labels, opts.help_texts and opts.error_messages, substitute the result for fields.   for every k and v in return value of the function six.iteritems called with an argument fields, if n is false, append it to a list,
missing_fields = ( set ( none_model_fields ) -  set ( new_class . declared_fields . keys ( ) ) )	substitute the resulting list for none_model_fields.   missing_fields is difference between set containing none_model_fields and set containing result of the method,
if missing_fields :	new_class.declared_fields.keys.   if missing_fields is true,
message = 'Unknown field(s) (%s) specified for %s'	message is an string 'Unknown field(s) (%s) specified for %s'.
message = message % ( ', ' . join ( missing_fields ) ,  opts . model . __name__ )	join missing_fields into a string separated by string ', ', use it and opts.model.__name__ to format message, substitute the result for message.
raise FieldError ( message )	raise an FieldError exception with an argument message.
fields . update ( new_class . declared_fields )	update fields dictionary with new_class.declared_fields.
else :	if not,
fields = new_class . declared_fields	substitute new_class.declared_fields for fields.
new_class . base_fields = fields	substitute fields for new_class.base_fields.
return new_class	return new_class.
class BaseModelForm ( BaseForm ) :	derive the class BaseModelForm from the BaseForm base class.
def __init__ ( self , data = None , files = None , auto_id = 'id_%s' , prefix = None ,  initial = None , error_class = ErrorList , label_suffix = None ,  empty_permitted = False , instance = None ) :	define the method __init__ with 10 arguments: self, data set to None, files set to None, auto_id set to string 'id_%s',
opts = self . _meta	prefix set to None, initial set to None, error_class set to ErrorList, label_suffix set to None,   empty_permitted set to boolean False, instance set to None.   substitute self._meta for opts.
if opts . model is None :	if opts.model is None.
raise ValueError ( 'ModelForm has no model class specified.' )	raise an ValueError with an argument string 'ModelForm has no model class specified.'.
if instance is None :	if instance is None,
self . instance = opts . model ( )	call the method opts.model, substitute the result for self.instance.
object_data = { }	object_data is an empty dictionary.
else :	if not,
self . instance = instance	substitute instance for self.instance.
object_data = model_to_dict ( instance , opts . fields , opts . exclude )	call the method model_to_dict with 3 arguments: instance, opts.fields, opts.exclude and substitute the result for object_data.
if initial is not None :	if initial is not None,
object_data . update ( initial )	update object_data dictionary with initial.
self . _validate_unique = False	self._validate_unique is boolean False.
super ( BaseModelForm , self ) . __init__ ( data , files , auto_id , prefix , object_data ,  error_class , label_suffix , empty_permitted )	call the method __init__ from the base class of the class BaseModelForm, with 8 arguments: data, files, auto_id, prefix, object_data,
for field_name in self . fields :	error_class, label_suffix and empty_permitted.   for every field_name in self.fields,
formfield = self . fields [ field_name ]	substitute value under the field_name key of the self.fields dictionary for formfield.
if hasattr ( formfield , 'queryset' ) :	if formfield has an attribute 'queryset',
limit_choices_to = formfield . limit_choices_to	substitute formfield.limit_choices_to for limit_choices_to.
if limit_choices_to is not None :	if limit_choices_to is not None,
if callable ( limit_choices_to ) :	if limit_choices_to is callable object,
    limit_choices_to = limit_choices_to ( )	call the function limit_choices_to, substitute the result for limit_choices_to.
formfield . queryset = formfield . queryset . complex_filter ( limit_choices_to )	call the method formfield.queryset.complex_filter with an argument limit_choices_to, substitute the result for formfield.queryset.
def _get_validation_exclusions ( self ) :	define the method _get_validation_exclusions with an argument self.
exclude = [ ]	exclude is an empty list.
for f in self . instance . _meta . fields :	for every f in self.instance._meta.fields,
field = f . name	substitute f.name for field.
if field not in self . fields :	if field is not contained in self.fields,
exclude . append ( f . name )	append f.name to exclude.
elif self . _meta . fields and field not in self . _meta . fields :	otherwise if self._meta.fields is true and field is not contained in self._meta.fields,
exclude . append ( f . name )	append f.name to exclude.
elif self . _meta . exclude and field in self . _meta . exclude :	otherwise if self._meta.exclude is true and field is not contained in self._meta.exclude,
exclude . append ( f . name )	append f.name to exclude.
elif field in self . _errors . keys ( ) :	otherwise if field is contained in the result of the call to the method self._errors.keys,
exclude . append ( f . name )	append f.name to exclude.
else :	if not,
form_field = self . fields [ field ]	substitute value under the field key of the self.fields dictionary for form_field.
field_value = self . cleaned_data . get ( field , None )	get the value under the field key of the self.cleaned_data dictionary, if it exists substitute it for field_value,
if not f . blank and not form_field . required and field_value in form_field . empty_values :	if not field_value is None.   if f.blank is false and form_field.required is false and field_value is contained in form_field.empty_values,
exclude . append ( f . name )	append f.name to exclude.
return exclude	return exclude.
def clean ( self ) :	define the method clean with an argument self.
self . _validate_unique = True	self._validate_unique is boolean True.
return self . cleaned_data	return self.cleaned_data.
def _update_errors ( self , errors ) :	define the method _update_errors with 2 arguments: self and errors.
opts = self . _meta	substitute self._meta for opts.
for field , messages in errors . error_dict . items ( ) :	call the function errors.error_dict.items, for every field and messages in the result,
if ( field == NON_FIELD_ERRORS and opts . error_messages and  NON_FIELD_ERRORS in opts . error_messages ) :	if field equals NON_FIELD_ERRORS and opts.error_messages is true and NON_FIELD_ERRORS is contained in opts.error_messages,
error_messages = opts . error_messages [ NON_FIELD_ERRORS ]	substitute value under the NON_FIELD_ERRORS key of opts.error_messages dictionary for error_messages.
elif field in self . fields :	otherwise if field is contained in self.fields,
error_messages = self . fields [ field ] . error_messages	get the value under the field key of self.fields dictionary, substitute error_messages field of the result for error_messages.
else :	if not,
continue	skip this loop iteration.
for message in messages :	for every message in messages,
if ( isinstance ( message , ValidationError ) and  message . code in error_messages ) :	if message is an instance of ValidationError class and message.code is contained in error_messages,
message . message = error_messages [ message . code ]	substitute error_messages under the message.code key of error_messages dictionary for message.message.
self . add_error ( None , errors )	call the method self.add_error with 2 arguments: None and errors.
def _post_clean ( self ) :	define the method _post_clean with an argument self.
opts = self . _meta	substitute self._meta for opts.
exclude = self . _get_validation_exclusions ( )	call the method self._get_validation_exclusions, substitute the result for exclude.
construct_instance_exclude = list ( exclude )	convert exclude elements to list, substitute it for construct_instance_exclude.
for name , field in self . fields . items ( ) :	call the method self.fields.items, for every name and field in result,
if isinstance ( field , InlineForeignKeyField ) :	if field is an instance of InlineForeignKeyField class,
if self . cleaned_data . get ( name ) is not None and self . cleaned_data [ name ] . _state . adding :	if value under the name key of self.cleaned_data dictionary is not None,
construct_instance_exclude . append ( name )	  and field _state.adding of value under the name key of self.cleaned_data dictionary is true,   append name to construct_instance_exclude list.
exclude . append ( name )	append name to exclude.
self . instance = construct_instance ( self , self . instance , opts . fields , construct_instance_exclude )	call the function construct_instance with 4 arguments: self, self.instance, opts.fields and construct_instance_exclude,
try :	substitute the result for self.instance.   try,
self . instance . full_clean ( exclude = exclude , validate_unique = False )	call the method self.instance.full_clean with 2 arguments: exclude set to exclude and validate_unique set to boolean False.
except ValidationError as e :	if ValidationError, renamed to e, exception is caught,
self . _update_errors ( e )	call the method self._update_errors with an argument e.
if self . _validate_unique :	if self._validate_unique is true,
self . validate_unique ( )	call the method self.validate_unique.
def validate_unique ( self ) :	define the method validate_unique with an argument self.
exclude = self . _get_validation_exclusions ( )	call the method self._get_validation_exclusions, substitute the result for exclude.
try :	try,
self . instance . validate_unique ( exclude = exclude )	call the method self.instance.validate_unique with an argument exclude set to exclude.
except ValidationError as e :	if ValidationError, renamed to e, exception is caught,
self . _update_errors ( e )	call the method self._update_errors with an argument e.
def save ( self , commit = True ) :	define the method save with 2 arguments: self and commit set to boolean True.
if self . instance . pk is None :	if self.instance.pk is None,
fail_message = 'created'	fail_message is a string 'created'.
else :	if not,
fail_message = 'changed'	fail_message is a string changed'.
return save_instance ( self , self . instance , self . _meta . fields ,  fail_message , commit , self . _meta . exclude ,  construct = False )	call the function with 7 arguments: self, self.instance, self._meta.fields, fail_message, commit, self._meta.exclude,
save . alters_data = True	and construct as boolean False, return the result.   save.alters_data is boolean True.
class ModelForm ( six . with_metaclass ( ModelFormMetaclass , BaseModelForm ) ) :	derive the class ModelForm from the base class in the return value of the method six.with_metaclass, called with 2 arguments:
pass	ModelFormMetaclass and BaseModelForm.   do nothing.
def modelform_factory ( model , form = ModelForm , fields = None , exclude = None ,  formfield_callback = None , widgets = None , localized_fields = None ,  labels = None , help_texts = None , error_messages = None ) :	define the function modelform_factory with 10 arguments: model, form set to ModelForm, fields set to None, exclude set to None,
attrs = { 'model' : model }	attrs is a dictionary with model for 'model'.
if fields is not None :	if fields is not None,
attrs [ 'fields' ] = fields	substitute fields for value under the 'fields' key of attrs dictionary.
if exclude is not None :	if exclude is not None,
attrs [ 'exclude' ] = exclude	substitute exclude for value under the 'exclude' key of attrs dictionary.
if widgets is not None :	if widgets is not None,
attrs [ 'widgets' ] = widgets	substitute widgets for value under the 'widgets' key of attrs dictionary.
if localized_fields is not None :	if localized_fields is not None,
attrs [ 'localized_fields' ] = localized_fields	substitute localized_fields for value under the 'localized_fields' key of attrs dictionary.
if labels is not None :	if labels is not None,
attrs [ 'labels' ] = labels	substitute labels for value under the 'labels' key of attrs dictionary.
if help_texts is not None :	if help_texts is not None,
attrs [ 'help_texts' ] = help_texts	substitute help_texts for value under the 'help_texts' key of attrs dictionary.
if error_messages is not None :	if error_messages is not None,
attrs [ 'error_messages' ] = error_messages	substitute error_messages for value under the 'error_messages' key of attrs dictionary.
parent = ( object , )	parent is a tuple with 1 element, object.
if hasattr ( form , 'Meta' ) :	if form has an attribute 'Meta',
parent = ( form . Meta , object )	parent is a tuple with 2 arguments: form.Meta and object.
Meta = type ( str ( 'Meta' ) , parent , attrs )	Meta is an instance of class with name 'Meta', parent base class and fields attrs.
class_name = model . __name__ + str ( 'Form' )	append string 'Form' to model.__name__, substitute the result for class_name.
form_class_attrs = {  'Meta' : Meta ,  'formfield_callback' : formfield_callback  }	form_class_attrs is a dictionary with 2 entries: Meta for 'Meta' and formfield_callback for 'formfield_callback'.
if ( getattr ( Meta , 'fields' , None ) is None and  getattr ( Meta , 'exclude' , None ) is None ) :	if 'fields' attribute of Meta object is None and 'exclude' attribute of Meta object is None,
return type ( form ) ( class_name , ( form , ) , form_class_attrs )	get the type of form object, return an instance of resulting class created with 3 arguments: class_name, tuple with an element form,
class BaseModelFormSet ( BaseFormSet ) :	and form_class_attrs.   derive the class BaseModelFormSet from the BaseFormSet base class.
model = None	model is None.
def __init__ ( self , data = None , files = None , auto_id = 'id_%s' , prefix = None ,  queryset = None , ** kwargs ) :	define the method __init__ with 7 arguments: self, data set to None, files set to None, auto_id set to string 'id_%s',
self . queryset = queryset	prefix set to None, queryset set to None and unpacked dictionary kwargs.   substitute queryset for self.queryset.
self . initial_extra = kwargs . pop ( 'initial' , None )	remove entry under 'initial' key of the kwargs dictionary, substitute it for self.initial_extra if it exists,
defaults = { 'data' : data , 'files' : files , 'auto_id' : auto_id , 'prefix' : prefix }	if not self.initial_extra is None.   defaults is a dictionary with 4 entries: data for 'data', files for 'files', auto_id for 'auto_id' and prefix for 'prefix'.
defaults . update ( kwargs )	update defaults dictionary with kwargs.
super ( BaseModelFormSet , self ) . __init__ ( ** defaults )	call the method __init__ from the base class of the class BaseModelFormSet, with an argument unpacked dictionary defaults.
def initial_form_count ( self ) :	define the method initial_form_count with an argument self.
if not ( self . data or self . files ) :	if self.data and self.files are both False,
return len ( self . get_queryset ( ) )	call the method self.get_queryset, return the length of the result.
return super ( BaseModelFormSet , self ) . initial_form_count ( )	call the method initial_form_count from the base class of the class BaseModelFormSet, return the result.
def _existing_object ( self , pk ) :	define the method _existing_object with 2 arguments: self and pk.
if not hasattr ( self , '_object_dict' ) :	if self has an attribute '_object_dict',
self . _object_dict = dict ( ( o . pk , o ) for o in self . get_queryset ( ) )	call the function dict with an argument tuple with 2 elements: o.pk and o, for every o in result of the method self.get_queryset,
return self . _object_dict . get ( pk )	substitute the result for self._object_dict.   return the value under the pk key of self._object_dict dictionary.
def _get_to_python ( self , field ) :	define the method _get_to_python with 2 arguments: self and field.
while field . rel is not None :	while field.rel is not None,
field = field . rel . get_related_field ( )	call the method field.rel.get_related_field, substitute the result for field.
return field . to_python	return field.to_python.
def _construct_form ( self , i , ** kwargs ) :	define the method _construct_form with 3 arguments: self, i and unpacked dictionary kwargs.
if self . is_bound and i < self . initial_form_count ( ) :	if self.is_bound is true and i is smaller than self.initial_form_count,
pk_key = '%s-%s' % ( self . add_prefix ( i ) , self . model . _meta . pk . name )	pk_key is a string '%s-%s', where '%s' is replaced with: result of the method self.add_prefix called with an argument i,
pk = self . data [ pk_key ]	and self.model._meta.pk.name.   substitute the value under the pk_key key of the self.data dictionary for pk.
pk_field = self . model . _meta . pk	substitute self.model._meta.pk for pk_field.
to_python = self . _get_to_python ( pk_field )	call the method self._get_to_python with an argument pk_field, substitute the result for to_python.
pk = to_python ( pk )	call the function to_python with an argument pk, substitute the result for pk.
kwargs [ 'instance' ] = self . _existing_object ( pk )	call the method self._existing_object with an argument pk, substitute the result for value under the 'instance' key of kwargs.
if i < self . initial_form_count ( ) and 'instance' not in kwargs :	if i is smaller than result of the method self.initial_form_count and key 'instance' is not contained in kwargs,
kwargs [ 'instance' ] = self . get_queryset ( ) [ i ]	call the method self.get_queryset, substitute i-th element of the result for value under the 'instance' key of kwargs dictionary.
if i >= self . initial_form_count ( ) and self . initial_extra :	  if i is greater or equal to the result of the method self.initial_form_count and self.initial_extra is true,
try :	try,
kwargs [ 'initial' ] = self . initial_extra [ i - self . initial_form_count ( ) ]	subtract result of the method self.initial_form_count from i, use the result as an index to get the element from self.initial_extra,
except IndexError :	substitute it for value under the 'initial' key of kwargs dictionary.   if IndexError exception is caught,
pass	do nothing.
return super ( BaseModelFormSet , self ) . _construct_form ( i , ** kwargs )	call the method _construct_form from the base class of the class BaseModelFormSet, with 2 arguments: i and unpacked dictionary kwargs.
def get_queryset ( self ) :	define the method get_queryset with an argument self.
if not hasattr ( self , '_queryset' ) :	if self doesnt have '_queryset' attribute,
if self . queryset is not None :	if self.queryset is not None,
qs = self . queryset	substitute self.queryset for qs.
else :	if not,
qs = self . model . _default_manager . get_queryset ( )	call the method self.model._default_manager.get_queryset with an argument qs.
if not qs . ordered :	if qs.ordered is false,
qs = qs . order_by ( self . model . _meta . pk . name )	call the method qs.order_by with argument self.model._meta.pk.name, substitute the result for qs.
self . _queryset = qs	substitute qs for self._queryset.
return self . _queryset	return self._queryset.
def save_new ( self , form , commit = True ) :	define the method save_new with 3 arguments: self, form and commit set to boolean True.
return form . save ( commit = commit )	call the method form.save with an argument commit as commit, return the result.
def save_existing ( self , form , instance , commit = True ) :	define the method save_existing with 4 arguments: self, form, instance and commit set to boolean True.
return form . save ( commit = commit )	call the method form.save with an argument commit as commit, return the result.
def save ( self , commit = True ) :	define the method save with 2 arguments: self and commit set to boolean True.
if not commit :	if commit is true,
self . saved_forms = [ ]	self.saved_forms is an empty list.
def save_m2m ( ) :	define the function save_m2m.
for form in self . saved_forms :	for every form in self.saved_forms,
form . save_m2m ( )	call the function form.save_m2m.
self . save_m2m = save_m2m	substitute save_m2m for self.save_m2m.
return self . save_existing_objects ( commit ) + self . save_new_objects ( commit )	sum results of method self.save_existing_objects called with an argument commit and of method self.save_new_objects,
save . alters_data = True	called with an argument commit, return the result.   save.alters_data is boolean True.
def clean ( self ) :	define the method clean with an argument self.
self . validate_unique ( )	call the method self.validate_unique.
def validate_unique ( self ) :	define the method validate_unique with an argument self.
all_unique_checks = set ( )	all_unique_checks is an empty set.
all_date_checks = set ( )	all_date_checks is an empty set.
forms_to_delete = self . deleted_forms	substitute self.deleted_forms for forms_to_delete.
valid_forms = [ form for form in self . forms if form . is_valid ( ) and form not in forms_to_delete ]	for every form in self.forms append form to a list, if function form.is_valid evaluates to true,
for form in valid_forms :	and form is not contained in forms_to_delete, substitute the resulting list for valid_forms.   for every form in valid_forms,
exclude = form . _get_validation_exclusions ( )	call the method form._get_validation_exclusions, substitute the result for exclude.
unique_checks , date_checks = form . instance . _get_unique_checks ( exclude = exclude )	call the method form.instance._get_unique_checks with an argument exclude as exclude, substitute the result for unique_checks,  and date_checks, respectively.
all_unique_checks = all_unique_checks . union ( set ( unique_checks ) )	all_unique_checks is union of all_unique_checks set and unique_checks set.
all_date_checks = all_date_checks . union ( set ( date_checks ) )	all_date_checks is union of all_date_checks set and date_checks set.
errors = [ ]	errors is an empty list.
for uclass , unique_check in all_unique_checks :	for every uclass, unique_check in all_unique_checks,
seen_data = set ( )	seen_data is an empty set.
for form in valid_forms :	for every form in valid_forms,
row_data = ( form . cleaned_data [ field ]  for field in unique_check if field in form . cleaned_data )	row_data is an generator object that returns value under the field key of form.cleaned_data dictionary,
row_data = tuple ( d . _get_pk_val ( ) if hasattr ( d , '_get_pk_val' ) else d  for d in row_data )	for every field in unique_check, if field is contained in form.cleaned_data.   create a generator that for every d in row_data, if d has an '_get_pk_val' attribute,
if row_data and None not in row_data :	returns the result of the call the method d._get_pk_val, if not return d, put all the generator items into a tuple row_data.   if row_data is true and None is not contained in row_data,
  if row_data in seen_data :	if row_data is contained in seen_data,
      errors . append ( self . get_unique_error_message ( unique_check ) )	call the method self.get_unique_error_message with an argument unique_check, append the result to errors.
form . _errors [ NON_FIELD_ERRORS ] = self . error_class ( [ self . get_form_error ( ) ] )	call the method self.error_class with an argument list with a element: result of the method self.get_form_error,
for field in unique_check :	substitute the result for value under the NON_FIELD_ERRORS key of the form._errors dictionary.   for every field in unique_check,
        if field in form . cleaned_data :	if field is contained in form.cleaned_data,
            del form . cleaned_data [ field ]	delete the form.cleaned_data dictionary entry under the field key.
seen_data . add ( row_data )	add row_data to seen_data set.
for date_check in all_date_checks :	for every date_check in all_date_checks,
seen_data = set ( )	seen_data is an empty set.
uclass , lookup , field , unique_for = date_check	substitute date_check elements to uclass, lookup, field and unique_for, respectively.
for form in valid_forms :	for every form in valid_forms,
if ( form . cleaned_data and form . cleaned_data [ field ] is not None  and form . cleaned_data [ unique_for ] is not None ) :	if form.cleaned_data is true and value under the field key of form.cleaned_data dictionary is not None,
  if lookup == 'date' :	and value under the unique_for key of form.cleaned_data dictionary is not None,   if lookup equals a string 'date',
    date = form . cleaned_data [ unique_for ]	substitute value under the unique_for key of form.cleaned_data dictionary for date.
date_data = ( date . year , date . month , date . day )	date_data is a tuple with 3 elements: date.year, date.month and date.day.
else :	if not,
    date_data = ( getattr ( form . cleaned_data [ unique_for ] , lookup ) , )	date_data is a tuple with an entry: attribute lookup from the value under the unique_for key of the form.cleaned_data dictionary.
data = ( form . cleaned_data [ field ] , ) + date_data	create a tuple out of elements under the key field of the form.cleaned_data dictionary, add elements of date_data to it,
if data in seen_data :	substitute it for data.   if data is contained in seen_data,
      errors . append ( self . get_date_error_message ( date_check ) )	call the method self.get_date_error_message with an argument date_check, append the result to errors.
form . _errors [ NON_FIELD_ERRORS ] = self . error_class ( [ self . get_form_error ( ) ] )	call the method self.error_class with an argument list with one element, return value of the method self.get_form_error,
del form . cleaned_data [ field ]	substitute the result for the value under the NON_FIELD_ERRORS key of form._errors dictionary.   delete entry from form.cleaned_data dictionary under the field key.
seen_data . add ( data )	add data to seen_data set.
if errors :	if errors is true,
raise ValidationError ( errors )	raise an ValidationError exception with an argument errors.
def get_unique_error_message ( self , unique_check ) :	define the method get_unique_error_message with 2 arguments: self and unique_check.
if len ( unique_check ) == 1 :	if length of unique_check equals integer 1,
return ugettext ( 'Please correct the duplicate data for %(field)s.' ) % {  'field' : unique_check [ 0 ] ,  }	call the function ugettext with an argument string 'Please correct the duplicate data for %(field)s.',
else :	where '%(field)s' is replaced with first element of unique_check, return the result.   if not,
return ugettext ( 'Please correct the duplicate data for %(field)s, '  'which must be unique.' ) % {  'field' : get_text_list ( unique_check , six . text_type ( _ ( 'and' ) ) ) ,  }	call the function ugettext with an argument string 'Please correct the duplicate data for %(field)s, which must be unique.',
def get_date_error_message ( self , date_check ) :	where '%(field)s' is replaced with return value of the get_text_list function called with 2 arguments:   unique_check and return value of the function six.text_type called with return value of the function _ with an argument string 'and',   return the result.   define the method get_date_error_message with 2 arguments: self and date_check.
return ugettext ( 'Please correct the duplicate data for %(field_name)s '  'which must be unique for the %(lookup)s in %(date_field)s.' ) % {  'field_name' : date_check [ 2 ] ,  'date_field' : date_check [ 3 ] ,  'lookup' : six . text_type ( date_check [ 1 ] ) ,  }	call the function ugettext with an argument string 'Please correct the duplicate data for %(field_name)s which must be unique for,
def get_form_error ( self ) :	the %(lookup)s in %(date_field)s.', where '%(field_name)s' is replaced with third element of data_check,   '%(date_field)s' is replaced with fourth element of date_check and '%(lookup)s' is replaced with result of the function,   six.text_type called with second element of date_check as an argument, return the result.   define the method get_form_error with an argument self.
return ugettext ( 'Please correct the duplicate values below.' )	call the function ugettext with an argument string 'Please correct the duplicate values below.', return the result.
def save_existing_objects ( self , commit = True ) :	define the method save_existing_objects with 2 arguments: self and commit set to boolean True.
self . changed_objects = [ ]	self.changed_objects is an empty list.
self . deleted_objects = [ ]	self.deleted_objects is an empty list.
if not self . initial_forms :	if self.initial_forms is false,
return [ ]	return an empty list.
saved_instances = [ ]	saved_instances is an empty list.
forms_to_delete = self . deleted_forms	substitute self.deleted_forms for forms_to_delete.
for form in self . initial_forms :	for every form in self.initial_forms,
obj = form . instance	substitute form.instance for obj.
if form in forms_to_delete :	if form is contained in forms_to_delete,
if obj . pk is None :	if obj.pk is None,
continue	skip this loop iteration.
self . deleted_objects . append ( obj )	append obj to self.deleted_objects list.
if commit :	if commit is true,
obj . delete ( )	call the method obj.delete.
elif form . has_changed ( ) :	otherwise if form.has_changed method evaluates to true,
self . changed_objects . append ( ( obj , form . changed_data ) )	append a tuple with 2 elements: obj and form.changed_data to self.changed_objects.
saved_instances . append ( self . save_existing ( form , obj , commit = commit ) )	call the method self.save_existing with 3 arguments: form, obj and commit as commit, append the result to saved_instances.
if not commit :	if commit is false,
self . saved_forms . append ( form )	append form to self.saved_forms.
return saved_instances	return saved_instances.
def save_new_objects ( self , commit = True ) :	define the method save_new_objects with 2 arguments: self and commit set to boolean True.
self . new_objects = [ ]	self.new_objects is an empty list.
for form in self . extra_forms :	for every form in self.extra_forms,
if not form . has_changed ( ) :	if function form.has_changed evaluates to false,
continue	skip this loop iteration.
if self . can_delete and self . _should_delete_form ( form ) :	if self.can_delete is true and call to the function self._should_delete_form with an argument form evaluates to true,
continue	skip this loop iteration.
self . new_objects . append ( self . save_new ( form , commit = commit ) )	call the method self.save_new with 2 arguments: form and commit as commit, append the result to self.new_objects.
if not commit :	if commit is false,
self . saved_forms . append ( form )	append form to self.saved_forms.
return self . new_objects	return self.new_objects.
def add_fields ( self , form , index ) :	define the method add_fields with 2 arguments: self, form and index.
from django . db . models import AutoField , OneToOneField , ForeignKey	from django.db.models import AutoField, OneToOneField and ForeignKey.
self . _pk_field = pk = self . model . _meta . pk	assign self.model._meta.pk to self._pk_field and pk.
def pk_is_not_editable ( pk ) :	define the method pk_is_not_editable with an argument pk.
return ( ( not pk . editable ) or ( pk . auto_created or isinstance ( pk , AutoField ) )  or ( pk . rel and pk . rel . parent_link and pk_is_not_editable ( pk . rel . to . _meta . pk ) ) )	if pk.editable is true, or pk.auto_created is true or pk is an instance of AutoField class, or if pk.rel is true,
if pk_is_not_editable ( pk ) or pk . name not in form . fields :	and pk.rel.parent_link is true and function pk_is_not_editable called with an argument pk.rel.to._meta.pk evaluates to true,   if function pk_is_not_editable called with an argument pk evaluates to true, or pk.name is not contained in form.fields,
if form . is_bound :	if form.is_bound is true,
pk_value = form . instance . pk	substitute form.instance.pk for pk_value.
else :	if not,
try :	try,
if index is not None :	if index is not None,
    pk_value = self . get_queryset ( ) [ index ] . pk	call the method self.get_queryset, substitute field pk under the result at the index index for pk_value.
else :	if not,
    pk_value = None	pk_value is None.
except IndexError :	if IndexError exception is caught,
pk_value = None	pk_value is None.
if isinstance ( pk , OneToOneField ) or isinstance ( pk , ForeignKey ) :	if pk is an instance of OneToOneField or ForeignKey classes,
qs = pk . rel . to . _default_manager . get_queryset ( )	call the method pk.rel.to._default_manager.get_queryset, substitute the result for qs.
else :	if not,
qs = self . model . _default_manager . get_queryset ( )	call the method self.model._default_manager.get_queryset with an argument qs.
qs = qs . using ( form . instance . _state . db )	call the method qs.using with an argument form.instance._state.db, substitute the result for qs.
if form . _meta . widgets :	if form._meta.widgets is true,
widget = form . _meta . widgets . get ( self . _pk_field . name , HiddenInput )	get the value under self._pk_field.name key of form._meta.widgets dictionary, if it exists substitute it for widget, if not,
else :	widget is an instance of HiddenInput class.   if not,
widget = HiddenInput	widget is an instance of HiddenInput class
form . fields [ self . _pk_field . name ] = ModelChoiceField ( qs , initial = pk_value , required = False , widget = widget )	value under the self._pk_field.name key of form.fields dictionary is an instance of ModelChoiceField class,
super ( BaseModelFormSet , self ) . add_fields ( form , index )	created with 4 arguments: qs, initial as pk_value, required as boolean False and widget as widget.   call the method add_fields from the base class of the class BaseModelFormSet, with 2 arguments: form and index.
def modelformset_factory ( model , form = ModelForm , formfield_callback = None ,  formset = BaseModelFormSet , extra = 1 , can_delete = False ,  can_order = False , max_num = None , fields = None , exclude = None ,  widgets = None , validate_max = False , localized_fields = None ,  labels = None , help_texts = None , error_messages = None ,  min_num = None , validate_min = False ) :	define the function modelformset_factory with 18 arguments: model, form set to ModelForm, formfield_callback set to None,
meta = getattr ( form , 'Meta' , None )	get 'Meta' attribute from form object, if it exists substitute it for meta, if not meta is None.
if meta is None :	if meta is None,
meta = type ( str ( 'Meta' ) , ( object , ) , { } )	meta is an instance of a class named 'Meta', derived from the object base class, without any fields.
if ( getattr ( meta , 'fields' , fields ) is None and  getattr ( meta , 'exclude' , exclude ) is None ) :	if 'fields' attribute of meta is None, or if it doesnt exists if fields is None and if 'exclude' attribute of meta is None,
form = modelform_factory ( model , form = form , fields = fields , exclude = exclude ,  formfield_callback = formfield_callback ,  widgets = widgets , localized_fields = localized_fields ,  labels = labels , help_texts = help_texts , error_messages = error_messages )	explicitly is prohibited.'   call the function modelform_factory with 10 arguments: model, form as form, fields as fields, exclude as exclude,
FormSet = formset_factory ( form , formset , extra = extra , min_num = min_num , max_num = max_num ,  can_order = can_order , can_delete = can_delete ,  validate_min = validate_min , validate_max = validate_max )	formfield_callback as formfield_callback, widgets as widgets, localized_fields as localized_fields, labels as labels,   help_texts as help_texts and error_messages as error_messages, substitute the result for form.   call the function formset_factory with 10 arguments: form, formset, extra as extra, min_num as min_num, max_num as max_num,
FormSet . model = model	can_order as can_order, can_delete as can_delete, validate_min as validate_min, validate_max as validate_max,   substitute the result for form.   substitute model for FormSet.model.
return FormSet	return FormSet.
class BaseInlineFormSet ( BaseModelFormSet ) :	derive the class BaseInlineFormSet from the BaseModelFormSet base class.
def __init__ ( self , data = None , files = None , instance = None ,  save_as_new = False , prefix = None , queryset = None , ** kwargs ) :	define the method __init__ with 8 arguments: self, data set to None, files set to None, instance set to None,
if instance is None :	save_as_new set to boolean False, prefix set to None, queryset set to None and unpacked dictionary kwargs.   if instance is None,
self . instance = self . fk . rel . to ( )	call the method self.fk.rel.to, substitute the result for self.instance.
else :	if not,
self . instance = instance	substitute instance for self.instance.
self . save_as_new = save_as_new	substitute save_as_new for self.save_as_new.
if queryset is None :	if queryset is None,
queryset = self . model . _default_manager	substitute self.model._default_manager for queryset.
if self . instance . pk is not None :	if self.instance.pk is not None,
qs = queryset . filter ( ** { self . fk . name : self . instance } )	call the method queryset.filter with an argument unpacked dictionary containing self.instance for self.fk.name, substitute the result for qs.
else :	if not,
qs = queryset . none ( )	call the method queryset.none, substitute it for qs.
super ( BaseInlineFormSet , self ) . __init__ ( data , files , prefix = prefix ,  queryset = qs , ** kwargs )	call the method __init__ from the base class of the class BaseInlineFormSet, with 5 arguments: data, files, prefix set to prefix,
def initial_form_count ( self ) :	queryset set to qs and unpacked dictionary kwargs.   define the method initial_form_count with an argument self.
if self . save_as_new :	if self.save_as_new is true,
return 0	return integer 0.
return super ( BaseInlineFormSet , self ) . initial_form_count ( )	call the method initial_form_count from the base class of the class BaseInlineFormSet, return the result.
def _construct_form ( self , i , ** kwargs ) :	define the method _construct_form with 3 arguments: self, i and unpacked dictionary kwargs.
form = super ( BaseInlineFormSet , self ) . _construct_form ( i , ** kwargs )	call the method _construct_form from the base class of the class BaseInlineFormSet, with 2 arguments: i,
if self . save_as_new :	and unpacked dictionary kwargs, substitute the result for form.   if self.save_as_new is true,
form . data [ form . add_prefix ( self . _pk_field . name ) ] = None	call the method form.add_prefix with an argument self._pk_field.name,
form . data [ form . add_prefix ( self . fk . name ) ] = None	use the result as an key to get the value of the form.data dictionary, assign it value None.   call the method form.add_prefix with an argument self.fk.name,
setattr ( form . instance , self . fk . get_attname ( ) , self . instance . pk )	use the result as an key to get the value of the form.data dictionary, assign it value None.   use return value of the self.fk.get_attname as the name of the attribute of form.instance object to set, set it to self.instance.pk.
return form	return form.
@ classmethod	classmethod decorator,
def get_default_prefix ( cls ) :	define the method get_default_prefix with an argument cls.
from django . db . models . fields . related import RelatedObject	from django.db.models.fields.related import RelatedObject into default namespace.
return RelatedObject ( cls . fk . rel . to , cls . model , cls . fk ) . get_accessor_name ( ) . replace ( '+' , '' )	instantiate RelatedObject class with 3 arguments: cls.fk.rel.to, cls.model and cls.fk,
def save_new ( self , form , commit = True ) :	call the method get_accessor_name on the result, substitute all occurrences of '+' in the result with an empty string, return it.   define the method save_new with 3 arguments: self, form and commit set to boolean True.
obj = form . save ( commit = False )	call the method form.save, with an argument commit set to boolean False, substitute the result for obj.
pk_value = getattr ( self . instance , self . fk . rel . field_name )	get self.instance
setattr ( obj , self . fk . get_attname ( ) , getattr ( pk_value , 'pk' , pk_value ) )	get attribute 'pk' of the pk_value object, if it doesnt exists use pk_value, set to it self.fk.get_attname return value attribute,
if commit :	of the obj object.   if commit is true,
obj . save ( )	call the method obj.save.
if commit and hasattr ( form , 'save_m2m' ) :	if commit is true and form has an attribute 'save_m2m',
form . save_m2m ( )	call the method form.save_m2m.
return obj	return obj.
def add_fields ( self , form , index ) :	define the method add_fields with 3 arguments: self, form and index.
super ( BaseInlineFormSet , self ) . add_fields ( form , index )	call the method add_fields from the base class of the class BaseInlineFormSet, with 2 arguments: form and index.
if self . _pk_field == self . fk :	if self._pk_field equals self.fk,
name = self . _pk_field . name	substitute self._pk_field.name for name.
kwargs = { 'pk_field' : True }	kwargs is a dictionary with boolean True for 'pk_field'.
else :	if not,
name = self . fk . name	substitute self.fk.name for name.
kwargs = {  'label' : getattr ( form . fields . get ( name ) , 'label' , capfirst ( self . fk . verbose_name ) )  }	kwargs is a dictionary with an entry: attribute 'label' of the object under the name key of the form.fields dictionary for 'label',
if self . fk . rel . field_name != self . fk . rel . to . _meta . pk . name :	if it doesnt exists return value of the function capfirst with an argument self.fk.verbose_name for 'label'.   if self.fk.rel.field_name is not equal to self.fk.rel.to._meta.pk.name,
kwargs [ 'to_field' ] = self . fk . rel . field_name	substitute self.fk.rel.field_name for value under the 'to_field' key of the kwargs dictionary.
form . fields [ name ] = InlineForeignKeyField ( self . instance , ** kwargs )	value under the name key of the form.fields dictionary is an instance of InlineForeignKeyField created with 2 arguments:
if form . _meta . fields :	self.instance and unpacked dictionary kwargs.   if form._meta.fields is true,
if isinstance ( form . _meta . fields , tuple ) :	if form._meta.fields is an instance of tuple type,
form . _meta . fields = list ( form . _meta . fields )	form._meta.fields is a list created out of form._meta.fields elements.
form . _meta . fields . append ( self . fk . name )	append self.fk.name to form._meta.fields.
def get_unique_error_message ( self , unique_check ) :	define the method get_unique_error_message with 2 arguments: self and unique_check.
unique_check = [ field for field in unique_check if field != self . fk . name ]	unique_check is a list with elements field, for every field in unique_check if field is not equal to self.fk.name.
return super ( BaseInlineFormSet , self ) . get_unique_error_message ( unique_check )	call the method get_unique_error_message from the base class of the class BaseInlineFormSet, with an argument unique_check, return the result.
def _get_foreign_key ( parent_model , model , fk_name = None , can_fail = False ) :	define the function _get_foreign_key with 4 arguments: parent_model, model, fk_name set to None and can_fail set to boolean False.
from django . db . models import ForeignKey	from django.db.models import ForeignKey.
opts = model . _meta	substitute model._meta for opts.
if fk_name :	if fk_name is true,
fks_to_parent = [ f for f in opts . fields if f . name == fk_name ]	fks_to_parent is a list containing f, for every f in opts.fields if f.name equals fk_name.
if len ( fks_to_parent ) == 1 :	if length of fks_to_parent equals integer 1.
fk = fks_to_parent [ 0 ]	substitute first element of fks_to_parent for fk.
if not isinstance ( fk , ForeignKey ) or ( fk . rel . to != parent_model and  fk . rel . to not in parent_model . _meta . get_parent_list ( ) ) :	if fk is not an instance of ForeignKey class, or fk.rel.to is not equal to parent_model,
raise ValueError (  'fk_name '%s' is not a ForeignKey to '%s.%'.'  % ( fk_name , parent_model . _meta . app_label , parent_model . _meta . object_name ) )	and fk.rel.to is not contained in result of the call to the method parent_model._meta.get_parent_list.   raise an ValueError with an argument string 'fk_name '%s' is not a ForeignKey to '%s.%'.', where '%s' is replaced with,
elif len ( fks_to_parent ) == 0 :	fk_name, parent_model._meta.app_label and parent_model._meta.object_name, respectively.   otherwise if length of fks_to_parent is zero,
else :	model._meta.app_label, model._meta.object_name, fk_name, respectively.   if not,
fks_to_parent = [  f for f in opts . fields  if isinstance ( f , ForeignKey )  and ( f . rel . to == parent_model  or f . rel . to in parent_model . _meta . get_parent_list ( ) )  ]	fks_to_parent is a list containing f for every f in opts.fields, only if f is an instance of ForeignKey,
if len ( fks_to_parent ) == 1 :	and, if f.rel.toequals parent_model or f.rel.to is contained in result of the call to the method parent_model._meta.get_parent_list.   if length of fks_to_parent is integer 1,
fk = fks_to_parent [ 0 ]	substitute first element of fks_to_parent for fk.
elif len ( fks_to_parent ) == 0 :	otherwise if length of fks_to_parent is zero,
if can_fail :	if can_fail is true,
return	return nothing.
else :	model._meta.app_label, model._meta.object_name, parent_model._meta.app_label, parent_model._meta.object_name, respectively.   if not,
return fk	model._meta.app_label, model._meta.object_name, parent_model._meta.app_label, parent_model._meta.object_name, respectively.   return fk.
def inlineformset_factory ( parent_model , model , form = ModelForm ,  formset = BaseInlineFormSet , fk_name = None ,  fields = None , exclude = None , extra = 3 , can_order = False ,  can_delete = True , max_num = None , formfield_callback = None ,  widgets = None , validate_max = False , localized_fields = None ,  labels = None , help_texts = None , error_messages = None ,  min_num = None , validate_min = False ) :	define the function inlineformset_factory with 20 arguments: parent_model, model, form set to ModelForm,
fk = _get_foreign_key ( parent_model , model , fk_name = fk_name )	call the function _get_foreign_key with 3 arguments: parent_model, model and fk_name=fk_name, substitute the result for fk.
if fk . unique :	if fk.unique is boolean true,
max_num = 1	max_num is integer 1.
kwargs = {  'form' : form ,  'formfield_callback' : formfield_callback ,  'formset' : formset ,  'extra' : extra ,  'can_delete' : can_delete ,  'can_order' : can_order ,  'fields' : fields ,  'exclude' : exclude ,  'min_num' : min_num ,  'max_num' : max_num ,  'widgets' : widgets ,  'validate_min' : validate_min ,  'validate_max' : validate_max ,  'localized_fields' : localized_fields ,  'labels' : labels ,  'help_texts' : help_texts ,  'error_messages' : error_messages ,  }	kwargs is a dictionary with 17 entries: form for 'form', formfield_callback for 'formfield_callback', formset for 'formset',
FormSet = modelformset_factory ( model , ** kwargs )	extra for 'extra', can_delete for 'can_delete', can_order for 'can_order', fields for 'fields', exclude for 'exclude',   min_num for 'min_num', max_num for 'max_num', widgets for 'widgets', validate_min for 'validate_min',   validate_max for 'validate_max', localized_fields for 'localized_fields', labels for 'labels', help_texts for 'help_texts',   and error_messages for 'error_messages'.   call the function modelformset_factory with 2 arguments: model and unpacked dictionary kwargs, substitute the result for FormSet.
FormSet . fk = fk	substitute fk for FormSet.fk.
return FormSet	return FormSet.
class InlineForeignKeyField ( Field ) :	derive the class InlineForeignKeyField from the Field base class.
widget = HiddenInput	substitute HiddenInput for widget.
default_error_messages = {  'invalid_choice' : _ ( 'The inline foreign key did not match the parent instance primary key.' ) ,  }	default_error_messages is an dictionary with an entry: return value of the function _ called with an argument,
def __init__ ( self , parent_instance , * args , ** kwargs ) :	string 'The inline foreign key did not match the parent instance primary key.' for 'invalid_choice'.   define the method __init__ with 4 arguments: self, parent_instance, unpacked list args and unpacked dictionary kwargs.
self . parent_instance = parent_instance	substitute parent_instance for self.parent_instance.
self . pk_field = kwargs . pop ( 'pk_field' , False )	remove element from kwargs dictionary under the key 'pk_field', substitute it for self.pk_field if it exists,
self . to_field = kwargs . pop ( 'to_field' , None )	if not self.pk_field is boolean False.   remove element from kwargs dictionary under the key 'to_field', substitute it for self.to_field if it exists,
if self . parent_instance is not None :	if not self.to_field is None.   if self.parent_instance is not None,
if self . to_field :	if self.to_field is true,
kwargs [ 'initial' ] = getattr ( self . parent_instance , self . to_field )	get self.to_field attribute of self.parent_instance object, substitute it for value under the 'initial' key of the kwargs dictionary.
else :	if not,
kwargs [ 'initial' ] = self . parent_instance . pk	substitute self.parent_instance.pk for value under the 'initial' key of the kwargs dictionary.
kwargs [ 'required' ] = False	value under the 'required' key of the kwargs dictionary is boolean False.
super ( InlineForeignKeyField , self ) . __init__ ( * args , ** kwargs )	call the method __init__ from the base class of the class InlineForeignKeyField, with 2 arguments unpacked list args,
def clean ( self , value ) :	and unpacked dictionary kwargs.   define the method clean with 2 arguments: self and value.
if value in self . empty_values :	if value is contained in self.empty_values,
if self . pk_field :	if self.pk_field,
return None	return None.
return self . parent_instance	return self.parent_instance.
if self . to_field :	if self.to_field is true,
orig = getattr ( self . parent_instance , self . to_field )	get self.to_field attribute of self.parent_instance, substitute it for orig.
else :	if not,
orig = self . parent_instance . pk	substitute self.parent_instance.pk for orig.
if force_text ( value ) != force_text ( orig ) :	if return values of the function force_text called two times with 1 argument, with value, and with orig, are equal,
raise ValidationError ( self . error_messages [ 'invalid_choice' ] , code = 'invalid_choice' )	raise an ValidationError with 2 arguments: self.error_messages dictionary value under the 'invalid_choice' key,
return self . parent_instance	and code set to a string 'invalid_choice'.   return self.parent_instance.
def _has_changed ( self , initial , data ) :	define the method _has_changed with 3 arguments: self, initial and data.
return False	return boolean False.
class ModelChoiceIterator ( object ) :	derive the class ModelChoiceIterator from object base class.
def __init__ ( self , field ) :	define the method __init__ with 2 arguments: self and field.
self . field = field	substitute field for self.field.
self . queryset = field . queryset	substitute field.queryset for self.queryset.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
if self . field . empty_label is not None :	if self.field.empty_label is not None,
yield ( '' , self . field . empty_label )	yield a tuple with 2 elements: an empty string and self.field.empty_label.
if self . field . cache_choices :	if self.field.cache_choices is true,
if self . field . choice_cache is None :	if self.field.choice_cache is None,
self . field . choice_cache = [  self . choice ( obj ) for obj in self . queryset . all ( )  ]	self.field.choice_cache is a list containing results of the method self.choice called with an argument obj,
for choice in self . field . choice_cache :	for every obj in result of the method self.queryset.all.   for every choice in self.field.choice_cache,
yield choice	yield choice.
else :	if not,
for obj in self . queryset . all ( ) :	for every obj in result of the call to the method self.queryset.all,
yield self . choice ( obj )	call the method self.choice with an argument obj, yield the result.
def __len__ ( self ) :	define the method __len__ with an argument self.
return ( len ( self . queryset ) +  ( 1 if self . field . empty_label is not None else 0 ) )	sum length of self.quertset and integer 1 if self.field.empty_label is not None, or integer 0 if not, return the result.
def choice ( self , obj ) :	define the method choice with 2 arguments: self and obj.
return ( self . field . prepare_value ( obj ) , self . field . label_from_instance ( obj ) )	return a tuple with 2 elements: result of the method self.field.prepare_value called with an argument obj,
class ModelChoiceField ( ChoiceField ) :	and result of the method self.field.label_from_instance, called with an argument obj.   derive the class ModelChoiceField from the ChoiceField base class.
default_error_messages = {  'invalid_choice' : _ ( 'Select a valid choice. That choice is not one of'  ' the available choices.' ) ,  }	default_error_messages is a dictionary with an entry, result of the call to the function _ with an argument,
def __init__ ( self , queryset , empty_label = '---------' , cache_choices = None ,  required = True , widget = None , label = None , initial = None ,  help_text = '' , to_field_name = None , limit_choices_to = None ,  * args , ** kwargs ) :	string 'Select a valid choice. That choice is not one of the available choices.' for 'invalid_choice'.   define the method __init__ with 13 arguments: self, queryset, empty_label set to a string  '---------', cache_choices set to None,
if required and ( initial is not None ) :	required set to boolean True, widget set to None, label set to None, initial set to None, help_text set to an empty string,   to_field_name set to None, limit_choices_to set to None, unpacked list args and unpacked dictionary kwargs.   if required is true and initial is not None,
self . empty_label = None	self.empty_label is None.
else :	if not,
self . empty_label = empty_label	substitute empty_label for self.empty_label.
if cache_choices is not None :	if cache_choices is not None,
warnings . warn ( 'cache_choices has been deprecated and will be '  'removed in Django 1.9.' ,  RemovedInDjango19Warning , stacklevel = 2 )	call the function warnings.warn with 3 arguments: string 'cache_choices has been deprecated and will be removed in Django 1.9.',
else :	RemovedInDjango19Warning and stacklevel set to integer 2.   if not,
cache_choices = False	substitute boolean False for cache_choices.
self . cache_choices = cache_choices	substitute cache_choices for self.cache_choices.
Field . __init__ ( self , required , widget , label , initial , help_text ,  * args , ** kwargs )	call the method Field.__init__ with 8 arguments: self, required, widget, label, initial, help_text, unpacked list args,
self . queryset = queryset	and unpacked dictionary kwargs.   substitute queryset for self.queryset.
self . limit_choices_to = limit_choices_to	substitute limit_choices_to for self.limit_choices_to.
self . choice_cache = None	self.choice_cache is None.
self . to_field_name = to_field_name	substitute to_field_name for self.to_field_name
def __deepcopy__ ( self , memo ) :	define the method __deepcopy__ with 2 arguments: self and memo.
result = super ( ChoiceField , self ) . __deepcopy__ ( memo )	call the method __deepcopy__ from the base class of the class ChoiceField, with an argument memo, substitute the result for result.
result . queryset = result . queryset	substitute result.queryset for result.queryset.
return result	return result.
def _get_queryset ( self ) :	define the method _get_queryset with an argument self.
return self . _queryset	return self._queryset.
def _set_queryset ( self , queryset ) :	define the method _set_queryset with 2 arguments: self and queryset.
self . _queryset = queryset	substitute queryset for self._queryset.
self . widget . choices = self . choices	substitute self.choices for self.widget.choices.
queryset = property ( _get_queryset , _set_queryset )	queryset is an property object of this class, with _get_queryset getter and _set_queryset setter functions.
def label_from_instance ( self , obj ) :	define the method label_from_instance with 2 arguments: self and obj.
return smart_text ( obj )	call the function smart_text with an argument obj, return the result.
def _get_choices ( self ) :	define the method _get_choices with an argument self.
if hasattr ( self , '_choices' ) :	if self has an attribute '_choices',
return self . _choices	return self._choices.
return ModelChoiceIterator ( self )	return an instance of ModelChoiceIterator class, created with an argument self.
choices = property ( _get_choices , ChoiceField . _set_choices )	choices is an property property object of this class, with _get_choices getter and ChoiceField._set_choices setter functions.
def prepare_value ( self , value ) :	define the method prepare_value with 2 arguments: self and value.
if hasattr ( value , '_meta' ) :	if value has an attribute '_meta',
if self . to_field_name :	if self.to_field_name is true,
return value . serializable_value ( self . to_field_name )	call the method value.serializable_value with an argument self.to_field_name, return the result.
else :	if not,
return value . pk	return value.pk.
return super ( ModelChoiceField , self ) . prepare_value ( value )	call the method prepare_value from the base class of the class ModelChoiceField, with an argument value, return the result.
def to_python ( self , value ) :	define the method to_python with 2 arguments: self and value.
if value in self . empty_values :	if value is contained in self.empty_values,
return None	return None.
try :	try,
key = self . to_field_name or 'pk'	substitute self.to_field_name, if exists, for key, if not substitute string 'pk' for key.
value = self . queryset . get ( ** { key : value } )	call the method self.queryset.get with an argument, unpacked dictionary with an element: value for key, substitute the result for value.
except ( ValueError , self . queryset . model . DoesNotExist ) :	if ValueError or self.queryset.model.DoesNotExist exception is caught,
raise ValidationError ( self . error_messages [ 'invalid_choice' ] , code = 'invalid_choice' )	raise an ValidationError exception with 2 arguments: value under the 'invalid_choice' key of the self.error_messages dictionary,
return value	code set to a string 'invalid_choice'.   return value.
def validate ( self , value ) :	define the method validate with 2 arguments: self and value.
return Field . validate ( self , value )	call the method Field.validate with 2 arguments: self and value, return the result.
def _has_changed ( self , initial , data ) :	define the method _has_changed with 3 arguments: self, initial and data.
initial_value = initial if initial is not None else ''	if initial is not None, substitute initial for initial_value, otherwise initial_value is an empty string.
data_value = data if data is not None else ''	if data is not None, substitute data for initial_value, otherwise data_value is an empty string.
return force_text ( self . prepare_value ( initial_value ) ) != force_text ( data_value )	call the method self.prepare_value with an argument initial_value, use it as the argument for the call to the function force_text,
class ModelMultipleChoiceField ( ModelChoiceField ) :	if the result is equal to the result of the call to the function force_text with data_value as an argument, return boolean True,   otherwise return boolean False.   derive the class ModelMultipleChoiceField from the ModelChoiceField base class.
widget = SelectMultiple	substitute SelectMultiple for widget.
hidden_widget = MultipleHiddenInput	substitute MultipleHiddenInput for hidden_widget.
super ( ModelMultipleChoiceField , self ) . __init__ ( queryset , None ,  cache_choices , required , widget , label , initial , help_text ,  * args , ** kwargs )	widget set to None, label set to None, initial set to None, help_text set to an empty strign,   unpacked list args and unpacked dictionary kwargs.   call the method __init__ from the base class of the class ModelMultipleChoiceField, with 10 arguments: queryset, None,
def to_python ( self , value ) :	cache_choices, required, widget, label, initial, help_text, unpacked list args and unpacked dictionary kwargs.   define the method to_python with 2 arguments: self and value.
if not value :	if value is false,
return [ ]	return an empty list.
to_py = super ( ModelMultipleChoiceField , self ) . to_python	instantiate base class of the class ModelMultipleChoiceField, substitute filed to_python of the  result for to_py.
return [ to_py ( val ) for val in value ]	return a list containing return values of the function to_py called with an argument val, for every val in value.
def clean ( self , value ) :	define the method clean with 2 arguments: self and value.
if self . required and not value :	if self.required is true and value is false,
raise ValidationError ( self . error_messages [ 'required' ] , code = 'required' )	raise an ValidationError with 2 arguments: dictionary self.error_messages value under the key 'required',
elif not self . required and not value :	and code set to string 'required.   otherwise if self.required is false and value is false,
return self . queryset . none ( )	call the method self.queryset.none, return the result.
if not isinstance ( value , ( list , tuple ) ) :	if value is not an instance of list or tuple types,
raise ValidationError ( self . error_messages [ 'list' ] , code = 'list' )	raise an ValidationError with 2 arguments: dictionary self.error_messages value under the key 'list',
key = self . to_field_name or 'pk'	and code set to string 'list.   substitute self.to_field_name, if true, for key, or if not, substitute string 'pk' for key.
for pk in value :	for every pk in value,
try :	try,
self . queryset . filter ( ** { key : pk } )	call the method self.queryset.filter with an argument, unpacked dictionary with an entry: pk for key.
except ValueError :	if ValueError exception is caught,
raise ValidationError (  self . error_messages [ 'invalid_pk_value' ] ,  code = 'invalid_pk_value' ,  params = { 'pk' : pk } ,  )	raise an ValidationError with 3 arguments: dictionary self.error_messages value under the key 'invalid_pk_value',
qs = self . queryset . filter ( ** { '%s__in' % key : value } )	code set to string 'invalid_pk_value and params with an entry: pk for 'pk'.   call the method self.queryset.filter with an argument, unpacked dictionary with an entry: value for string '__in' appended to key,
pks = set ( force_text ( getattr ( o , key ) ) for o in qs )	substitute the result for qs.   pks is a set containing results of the call to the function force_text with an argument, key attribute of the o object,
for val in value :	for every o in opts.   for every val in value,
if force_text ( val ) not in pks :	call the function force_text with an argument val, if the result is not contained in pks,
raise ValidationError (  self . error_messages [ 'invalid_choice' ] ,  code = 'invalid_choice' ,  params = { 'value' : val } ,  )	raise an ValidationError with 3 arguments: dictionary self.error_messages value under the key 'invalid_choice',
self . run_validators ( value )	code set to string 'invalid_choice' and params as a dictionary with an entry, val for 'value'.   call the method self.run_validators with an argument value.
return qs	return qs.
def prepare_value ( self , value ) :	define the method prepare_value with 2 arguments: self and value.
if ( hasattr ( value , '__iter__' ) and  not isinstance ( value , six . text_type ) and  not hasattr ( value , '_meta' ) ) :	if value has an attribute '__iter__' and value is not an instance of six.text_type and value doesnt have an attribute '_meta',
return [ super ( ModelMultipleChoiceField , self ) . prepare_value ( v ) for v in value ]	call the method prepare_value from the base class of the class ModelMultipleChoiceField, with an argument v,
return super ( ModelMultipleChoiceField , self ) . prepare_value ( value )	for every v in value, return the list of results.   call the method prepare_value the base class of the class ModelMultipleChoiceField, with an argument value, return the result.
def _has_changed ( self , initial , data ) :	define the method _has_changed with 3 arguments: self, initial and data.
if initial is None :	if initial is None,
initial = [ ]	initial is an empty list.
if data is None :	if data is None,
data = [ ]	data is an empty list.
if len ( initial ) != len ( data ) :	if lengths of initial and data are equal,
return True	return boolean True.
initial_set = set ( force_text ( value ) for value in self . prepare_value ( initial ) )	initial_set is set created out of return values of the function force_text called with an argument value,
data_set = set ( force_text ( value ) for value in data )	for every value in result of the method self.prepare_value called with an argument initial.   data_set is set created out of return values of the function force_text called with an argument value,
return data_set != initial_set	for every value in data.   if data_set is not equal to initial_set return boolean True, otherwise return boolean False.
def modelform_defines_fields ( form_class ) :	define the function modelform_defines_fields with an argument form_class.
return ( form_class is not None and (  hasattr ( form_class , '_meta' ) and  ( form_class . _meta . fields is not None or  form_class . _meta . exclude is not None )  ) )	only if form_class is not None, and if form_class has an attribute '_meta' and form_class._meta.fields is not None,
import warnings	import module warnings.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
warnings . warn (  'The django.forms.util module has been renamed. '  'Use django.forms.utils instead.' , RemovedInDjango19Warning , stacklevel = 2 )	call the function warnings.warn with 3 arguments: string 'The django.forms.util module has been renamed. '
from django . forms . utils import *	Use django.forms.utils instead., RemovedInDjango19Warning and stacklevel set to an integer 2.   from django.forms.utils import everything into default name space.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import json	import module json.
import sys	import module sys.
try :	try,
from collections import UserList	from collections import UserList into default namespace.
except ImportError :	if ImportError exception is caught.
from UserList import UserList	from UserList import UserList into default namespace.
from django . conf import settings	from django.conf import settings into default name space.
from django . utils . encoding import force_text , python_2_unicode_compatible	from django.utils.encoding import force_text and python_2_unicode_compatible into default name space.
from django . utils . html import format_html , format_html_join , escape	from django.utils.html import format_html, format_html_join and escape into default name space.
from django . utils import timezone	from django.utils import timezone into default name space.
from django . utils . translation import ugettext_lazy as _	from django.utils.translation import ugettext_lazy as _ into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . core . exceptions import ValidationError	from django.core.exceptions import ValidationError into default name space.
def flatatt ( attrs ) :	define the function flatatt with an argument attrs.
boolean_attrs = [ ]	boolean_attrs is an empty list.
for attr , value in list ( attrs . items ( ) ) :	convert items of attrs dictionary to list of tuples, for every attr and value in it,
if value is True :	if value is boolean True,
boolean_attrs . append ( ( attr , ) )	append tuple containing element attr to boolean_attrs.
del attrs [ attr ]	delete entry under the attr key of the attrs dictionary.
elif value is False :	otherwise if value is boolean False,
del attrs [ attr ]	delete entry under the attr key of the attrs dictionary.
@ python_2_unicode_compatible	and sorted return value of the items of the attrs dictionary, and second time with 3 arguments: an empty string, string ' {0}',   and sorted list of boolean_attrs elements, concatenate the results and return the resulting list.   python_2_unicode_compatible decorator,
class ErrorDict ( dict ) :	derive the class ErrorDict from the dict base class.
def as_data ( self ) :	define the method as_data with an argument self.
return { f : e . as_data ( ) for f , e in self . items ( ) }	return a dictionary generated with an expression, return value of the method e.as_data for f,
def as_json ( self , escape_html = False ) :	for every f and e in list of tuples of self dictionary key, pair entries.   define the method as_json with 2 argumens self and escape_html set to boolean False.
return json . dumps ( { f : e . get_json_data ( escape_html ) for f , e in self . items ( ) } )	call the method json.dumps with a dictionary generate with an expression as an argument, return value of the function e.get_json_data,
def as_ul ( self ) :	with an argument escape_html for f, for every f and e in list of tuples of self dictionary key, pair entries, return the result.   define the method as_ul with an argument self.
if not self :	if self is false,
return ''	return an empty string.
return format_html (  '<ul class='errorlist'>{0}</ul>' ,  format_html_join ( '' , '<li>{0}{1}</li>' , ( ( k , force_text ( v ) ) for k , v in self . items ( ) ) )  )	call the function format_html with 2 arguments: string '<ul class='errorlist'>{0}</ul>', and return value of the function,
def as_text ( self ) :	format_html_join, called with 3 arguments: empty string, string '<li>{0}{1}</li>', tuple containing tuples with 2 elements:   k and result of the function force_text with an argument v, for every k and v in items of the dictionary self, return the result.   define the method as_text with an argument self.
output = [ ]	output is an empty list.
for field , errors in self . items ( ) :	call the method self.items, for every field and errors in the result.
output . append ( '* %s' % field )	convert field into a string and concatenate it to a string '* ', append the result to output.
\output . append ( '\\n' . join ( '  * %s' % e for e in errors ) )\	for every e in errors convert e into a string and append it to a string '  * ',
\return '\\n' . join ( output )\	join all the results into a string separated by newlines, append the result to output.   join elements of output into a string, separated by newline characters, return the result.
def __str__ ( self ) :	define the method __str__ with an argument self.
return self . as_ul ( )	call the method self.as_ul, return the result.
@ python_2_unicode_compatible	python_2_unicode_compatible decorator,
class ErrorList ( UserList , list ) :	derive the class ErrorList from the UserList and list base classes.
def __init__ ( self , initlist = None , error_class = None ) :	define the method __init__ with 3 arguments: self, initlist set to None and error_class set to None.
super ( ErrorList , self ) . __init__ ( initlist )	call the method __init__ with an argument initlist from the base class of the class ErrorList.
if error_class is None :	if error_class is None,
self . error_class = 'errorlist'	self.error_class is a string 'errorlist'.
else :	if not,
self . error_class = 'errorlist {}' . format ( error_class )	append error_class converted into a string to string 'errorlist ', substitute the result for self.error_class.
def as_data ( self ) :	define the method as_text with an argument self.
return ValidationError ( self . data ) . error_list	instantiate ValidationError class with an argument self.data, return its field error_list.
def get_json_data ( self , escape_html = False ) :	define the method get_json_data with 2 arguments self and escape_html set to boolean False.
errors = [ ]	errors is an empty list.
for error in self . as_data ( ) :	call the method self.as_data, for every error in the result.
message = list ( error ) [ 0 ]	convert elements of error into a list, substitute the first element for message.
errors . append ( {  'message' : escape ( message ) if escape_html else message ,  'code' : error . code or '' ,  } )	append to errors list a dictionary created with 2 etries, if escape_html is true, return value of the function escape
return errors	with an argument message for 'message', or if not message for 'message' and error.code for 'code' in error.code is true,   if not, an empty string for 'code'.   return errors.
def as_json ( self , escape_html = False ) :	define the method as_json with 2 arguments self and escape_html set to boolean False.
return json . dumps ( self . get_json_data ( escape_html ) )	call the method self.get_json_data with an argument escape_html,
def as_ul ( self ) :	use the result as an argument for the call to the json.dumps function, return the result.   define the method as_text with an argument self.
if not self . data :	if self.data is false,
return ''	return an empty string.
return format_html (  '<ul class='{0}'>{1}</ul>' ,  self . error_class ,  format_html_join ( '' , '<li>{0}</li>' , ( ( force_text ( e ) , ) for e in self ) )  )	call the function format_html with 3 arguments: string '<ul class='{0}'>{1}</ul>', self.error_class and return value of the function,
def as_text ( self ) :	format_html_join, called with 3 arguments: empty string, string '<li>{0}</li>', tuple containing results of the function,   force_text with an argument e, for every e in self, return the result.   define the method as_text with an argument self.
\return '\\n' . join ( '* %s' % e for e in self )\	for every e in self, append convert e to an string and append it to string '* ',
def __str__ ( self ) :	join all of the results into a string separated by newline character, return the result.   define the method __str__ with an argument self.
return self . as_ul ( )	call the method self.as_ul, return the result.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return repr ( list ( self ) )	convert elements of self into a list, return the its printable representation.
def __contains__ ( self , item ) :	define the method __contains__ with an argument self.
return item in list ( self )	if item is contained in the list of the elements of self, return boolean True, otherwise return boolean False.
def __eq__ ( self , other ) :	define the method __eq__ with an argument self.
return list ( self ) == other	if other equals list containing elements of self, return boolean True, otherwise return boolean False.
def __ne__ ( self , other ) :	define the method __ne__ with an argument self.
return list ( self ) != other	if other is not equal to list containing elements of self, return boolean True, otherwise return boolean False.
def __getitem__ ( self , i ) :	define the method __getitem__ with an argument self.
error = self . data [ i ]	substitute i-th element of self.data for error.
if isinstance ( error , ValidationError ) :	if error is an instance of ValidationError,
return list ( error ) [ 0 ]	return first element of the list containing elements of error.
return force_text ( error )	call the function force_text with an argument error, return the result.
def from_current_timezone ( value ) :	define the function from_current_timezone with an argument value.
if settings . USE_TZ and value is not None and timezone . is_naive ( value ) :	if settings.USE_TZ is true and value is not None and call to the function timezone.is_naive with an argument value, evaluates to true,
current_timezone = timezone . get_current_timezone ( )	call the method timezone.get_current_timezone, substitute the result for current_timezone.
try :	try,
return timezone . make_aware ( value , current_timezone )	call the function timezone.make_aware with arguments value and current_timezone, return the result.
except Exception :	if Exception exception is caught,
\message = _ (  '%(datetime)s couldn\\'t be interpreted '  'in time zone %(current_timezone)s; it '  'may be ambiguous or it may not exist.'  )\	\call the function _ with an argument string '%(datetime)s couldn\\'t be interpreted in time zone %(current_timezone)s; it '\
params = { 'datetime' : value , 'current_timezone' : current_timezone }	'may be ambiguous or it may not exist.', substitute the result for message.   params is an dictionary containing 2 initial entries: value for 'datetime' and current_timezone for 'current_timezone'.
six . reraise ( ValidationError , ValidationError (  message ,  code = 'ambiguous_timezone' ,  params = params ,  ) , sys . exc_info ( ) [ 2 ] )	call the function six.reraise with 3 arguments: class ValidationError, class ValidationError, created with 3 arguments:
return value	message, code as a string 'ambiguous_timezone' and params as params,   and third element of the return value of the function sys.exc_info.   return value.
def to_current_timezone ( value ) :	define the function to_current_timezone with an argument value.
if settings . USE_TZ and value is not None and timezone . is_aware ( value ) :	if settings.USE_TZ is true and value is not None and call to the function timezone.is_aware with an argument value, evaluates to true,
current_timezone = timezone . get_current_timezone ( )	call the function timezone.get_current_timezone, substitute the result for current_timezone.
return timezone . make_naive ( value , current_timezone )	call the function timezone.make_naive with 2 arguments value, current_timezone, return the result.
return value	return value.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import copy	import module copy.
from itertools import chain	from itertools import chain into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . forms . utils import flatatt , to_current_timezone	from django.forms.utils import flatatt and to_current_timezone into default name space.
from django . utils . datastructures import MultiValueDict , MergeDict	from django.utils.datastructures import MultiValueDict and MergeDict into default name space.
from django . utils . encoding import force_text , python_2_unicode_compatible	from django.utils.encoding import force_text and python_2_unicode_compatible into default name space.
from django . utils . html import conditional_escape , format_html	from django.utils.html import conditional_escape and format_html into default name space.
from django . utils . translation import ugettext_lazy	from django.utils.translation import ugettext_lazy into default name space.
from django . utils . safestring import mark_safe	from django.utils.safestring import mark_safe into default name space.
from django . utils import formats , six	from django.utils import formats and six into default name space.
from django . utils . six . moves . urllib . parse import urljoin	from django.utils.six.moves.urllib.parse import urljoin into default name space.
__all__ = (  'Media' , 'MediaDefiningClass' , 'Widget' , 'TextInput' ,  'EmailInput' , 'URLInput' , 'NumberInput' , 'PasswordInput' ,  'HiddenInput' , 'MultipleHiddenInput' , 'ClearableFileInput' ,  'FileInput' , 'DateInput' , 'DateTimeInput' , 'TimeInput' , 'Textarea' , 'CheckboxInput' ,  'Select' , 'NullBooleanSelect' , 'SelectMultiple' , 'RadioSelect' ,  'CheckboxSelectMultiple' , 'MultiWidget' ,  'SplitDateTimeWidget' , 'SplitHiddenDateTimeWidget' ,  )	__all__ is a tuple of strings: 'Media', 'MediaDefiningClass', 'Widget', 'TextInput', 'EmailInput', 'URLInput', 'NumberInput',
MEDIA_TYPES = ( 'css' , 'js' )	'PasswordInput', 'HiddenInput', 'MultipleHiddenInput', 'ClearableFileInput', 'FileInput', 'DateInput', 'DateTimeInput', 'TimeInput',   'Textarea', 'CheckboxInput', 'Select', 'NullBooleanSelect', 'SelectMultiple', 'RadioSelect','CheckboxSelectMultiple', 'MultiWidget',   'SplitDateTimeWidget' and 'SplitHiddenDateTimeWidget'.   MEDIA_TYPES is a tuple with 2 strings: 'css' and 'js'.
@ python_2_unicode_compatible	python_2_unicode_compatible decorator,
class Media ( object ) :	derive the class Media from the object base class.
def __init__ ( self , media = None , ** kwargs ) :	define the method __init__ with 3 arguments: self, media set to None and unpacked dictionary kwargs.
if media :	if media is true,
media_attrs = media . __dict__	substitute media.__dict__ for media_attrs.
else :	if not,
media_attrs = kwargs	substitute kwargs for media_attrs.
self . _css = { }	self._css is an empty dictionary.
self . _js = [ ]	self._js is an empty list.
for name in MEDIA_TYPES :	for every name in MEDIA_TYPES,
getattr ( self , 'add_' + name ) ( media_attrs . get ( name , None ) )	append name to string 'add_' use it as the name of the attribute to get from object self, call the result as an function,
def __str__ ( self ) :	with an argument: value under the name key of the media_attrs dictionary, if it exists, if not use None as an argument.   define the method __str__ with an argument self.
return self . render ( )	call the method self.render, return the result.
def render ( self ) :	define the method render with an argument self.
\return mark_safe ( '\\n' . join ( chain ( * [ getattr ( self , 'render_' + name ) ( ) for name in MEDIA_TYPES ] ) ) )\	call the function chain with an argument unpacked list, append name to string 'render_',
def render_js ( self ) :	and use it as the name of the attribute to get from the self object,   call the result and append it to a list for every name in MEDIA_TYPES, join all the results into a string with newline separator,   use the result as an argument for the call to the function mark_safe, return the result.   define the method render_js with an argument self.
return [ format_html ( '<script type='text/javascript' src='{0}'></script>' , self . absolute_path ( path ) ) for path in self . _js ]	return a list containing results of the function format_html called with 2 arguments:
def render_css ( self ) :	string '<script type='text/javascript' src='{0}'></script>' and absolute file path of the path, for every path is self._js.   define the method render_css with an argument self.
media = sorted ( self . _css . keys ( ) )	call the method self._css.keys, sort the result and substitute it for media.
return chain ( * [  [ format_html ( '<link href='{0}' type='text/css' media='{1}' rel='stylesheet' />' , self . absolute_path ( path ) , medium )  for path in self . _css [ medium ] ]  for medium in media ] )	return the result of the call to the function chain, with an argument unpacked list, containing the result of the function,
def absolute_path ( self , path , prefix = None ) :	format_html called with 3 arguments: string '<link href='{0}' type='text/css' media='{1}' rel='stylesheet' />',   return value of the function self.absolute_path called with an argument path and medium,   for every medium in media and for every path in value under the medium key of the self._css dictionary.   define the method absolute_path with 3 arguments self, path and prefix set to None.
if path . startswith ( ( 'http://' , 'https://' , '/' ) ) :	if path starts with string 'http://' or string 'https://' or with string '/',
return path	return path,
if prefix is None :	if prefix is None,
if settings . STATIC_URL is None :	if settings.STATIC_URL is None,
prefix = settings . MEDIA_URL	substitute settings.MEDIA_URL for prefix.
else :	if not,
prefix = settings . STATIC_URL	substitute settings.STATIC_URL for prefix.
return urljoin ( prefix , path )	join prefix and path into an url, return it.
def __getitem__ ( self , name ) :	define the method __getitem__ with arguments self and name.
if name in MEDIA_TYPES :	if name is contained in MEDIA_TYPES,
return Media ( ** { str ( name ) : getattr ( self , '_' + name ) } )	return an instance of the class Media, called with an unpacked dictionary with an entry: name appended to string '_',
def add_js ( self , data ) :	define the method __getitem__ with arguments self and name.
if data :	if data is true,
for path in data :	for every path in data,
if path not in self . _js :	if path is not contained in self._js,
self . _js . append ( path )	append path to self._js.
def add_css ( self , data ) :	define the method add_css with arguments self and data.
if data :	if data is true,
for medium , paths in data . items ( ) :	call the method data.items, for every medium and paths in the result.
for path in paths :	for every path in paths,
if not self . _css . get ( medium ) or path not in self . _css [ medium ] :	if call to the method self._css.get with an argument medium evaluates to false,
    self . _css . setdefault ( medium , [ ] ) . append ( path )	or path is not contained in the value under the medium key of self._css dictionary.   call the method self._css.setdefault with 2 arguments medium and an empty string, append path to the result.
def __add__ ( self , other ) :	define the method __add__ with arguments self and other.
combined = Media ( )	combined is an instance of Media class.
for name in MEDIA_TYPES :	for every name in MEDIA_TYPES,
getattr ( combined , 'add_' + name ) ( getattr ( self , '_' + name , None ) )	append name to 'add_' use it as the name of the attribute to get from combined object , call the result with an argument:
getattr ( combined , 'add_' + name ) ( getattr ( other , '_' + name , None ) )	name appended to string '_', as the name of the attribute to get from self object, or if the previous doesnt exist, None.   append name to 'add_' use it as the name of the attribute to get from combined object , call the result with an argument:
return combined	name appended to string '_', as the name of the attribute to get from other object, or if the previous doesnt exist, None.   return combined.
def media_property ( cls ) :	define the function media_property with an argument cls.
def _media ( self ) :	define the method _media with an argument self.
sup_cls = super ( cls , self )	sup_cls is base class of the class cls.
try :	try,
base = sup_cls . media	substitute sup_cls.media for base.
except AttributeError :	if AttributeError exception is caught,
base = Media ( )	base is an instance of Media class.
definition = getattr ( cls , 'Media' , None )	get the attribute 'Media' of the cls object, if it exists substitute it for definition, if not definition is None.
if definition :	if definition is true,
extend = getattr ( definition , 'extend' , True )	get the attribute 'extend' of the cls object, if it exists substitute it for extend, if not extend is boolean True.
if extend :	if extend is true,
if extend is True :	if extend is boolean True,
m = base	substitute base for m.
else :	if not,
m = Media ( )	m is an instance of Media class.
for medium in extend :	for every medium in extend,
    m = m + base [ medium ]	sum m and value under the medium key of the base dictionary, substitute it for m.
return m + Media ( definition )	sum m and class Media created with definition, return the result.
else :	if not,
return Media ( definition )	return an instance of Media class, created with definition as an argument.
else :	if not,
return base	return base.
return property ( _media )	return property object with _media as getter function.
class MediaDefiningClass ( type ) :	derive the class MediaDefiningClass from the type base class.
def __new__ ( mcs , name , bases , attrs ) :	define the method __new__ with 4 arguments mcs, name, bases and attrs.
new_class = ( super ( MediaDefiningClass , mcs )  . __new__ ( mcs , name , bases , attrs ) )	call the method __new__ from the base class of the class MediaDefiningClass, called with 4 arguments: mcs, name, bases and attrs.
if 'media' not in attrs :	if 'media' is not contained in attrs,
new_class . media = media_property ( new_class )	call the method media_property with an argument new_class, substitute the result for new_class.media.
return new_class	return new_class.
@ python_2_unicode_compatible	python_2_unicode_compatible decorator
class SubWidget ( object ) :	derive the class SubWidget from the object base class.
def __init__ ( self , parent_widget , name , value , attrs , choices ) :	define the method __init__ with 6 arguments self, parent_widget, name, value, attrs and choices.
self . parent_widget = parent_widget	substitute parent_widget for self.parent_widget.
self . name , self . value = name , value	substitute name and value for self.name and self.value.
self . attrs , self . choices = attrs , choices	substitute attrs and choices for self.attrs and self.choices
def __str__ ( self ) :	define the method __str__ with an argument self.
args = [ self . name , self . value , self . attrs ]	args is an list with 3 initial elements self.name, self.value and self.attrs.
if self . choices :	if self.choices is true,
args . append ( self . choices )	append self.choices to args.
return self . parent_widget . render ( * args )	call the method self.parent_widget.render with unpacked list args as an argument, return the result.
class Widget ( six . with_metaclass ( MediaDefiningClass ) ) :	derive the class Widget from the base class in the return value of the six.with_metaclass called with an argument MediaDefiningClass.
needs_multipart_form = False	needs_multipart_form is boolean False.
is_localized = False	is_localized is boolean False.
is_required = False	is_required is boolean False.
def __init__ ( self , attrs = None ) :	define the method __init__ with arguments self and attrs set to None.
if attrs is not None :	if attrs is not None,
self . attrs = attrs . copy ( )	call the method attrs.copy, substitute the result for self.attrs.
else :	if not,
self . attrs = { }	self.attrs is an empty dictionary.
def __deepcopy__ ( self , memo ) :	define the method __deepcopy__ with arguments self and memo.
obj = copy . copy ( self )	call the method copy.copy, substitute the result for obj.
obj . attrs = self . attrs . copy ( )	call the method self.attrs.copy, substitute the result for obj.attrs.
memo [ id ( self ) ] = obj	substitute obj for the value of the memo dictionary at the identity of the self object key.
return obj	return obj.
@ property	property decorator,
def is_hidden ( self ) :	define the method is_hidden with an argument self.
return self . input_type == 'hidden' if hasattr ( self , 'input_type' ) else False	if self.input_type equals string 'hidden' and self has an attribute 'input_type', return boolean True, otherwise return boolean False.
def subwidgets ( self , name , value , attrs = None , choices = ( ) ) :	define the method subwidgets with 5 arguments: self, name, value, attrs set to None and choices set to an empty tuple.
yield SubWidget ( self , name , value , attrs , choices )	yield an instance of SubWidget class created with 5 arguments: self, name, value, attrs and choices.
def render ( self , name , value , attrs = None ) :	define the method render with 4 arguments: self, name, value and attrs set to None.
raise NotImplementedError ( 'subclasses of Widget must provide a render() method' )	raise an NotImplementedError with an argument string 'subclasses of Widget must provide a render() method'.
def build_attrs ( self , extra_attrs = None , ** kwargs ) :	define the method build_attrs with 3 arguments: self, extra_attrs set to None and unpacked dictionary kwargs.
attrs = dict ( self . attrs , ** kwargs )	unpack dictionary kwargs, map it through self.attrs and convert to dictionary, substitute the result for attrs.
if extra_attrs :	if extra_attrs is true,
attrs . update ( extra_attrs )	update attrs dictionary with extra_attrs entry.
return attrs	return attrs.
def value_from_datadict ( self , data , files , name ) :	define the method render with 4 arguments: self, name, value and attrs set to None.
return data . get ( name , None )	get the value under the name key of the data dictionary, return it, if the previous doesnt exists, return None.
def id_for_label ( self , id_ ) :	define the method id_for_label with 2 arguments: self and id.
return id_	return id_.
class Input ( Widget ) :	derive the class Input from the Widget base class.
input_type = None	input_type is None.
def _format_value ( self , value ) :	define the method _format_value with 2 arguments: self and value.
if self . is_localized :	if self.is_localized is true,
return formats . localize_input ( value )	call the method formats.localize_input with an argument value, return the result.
return value	return value.
def render ( self , name , value , attrs = None ) :	define the method render with 4 arguments: self, name, value and attrs set to None.
if value is None :	if value is None,
value = ''	value is an empty string.
final_attrs = self . build_attrs ( attrs , type = self . input_type , name = name )	call the method self.build_attrs with 3 arguments: attrs, type as self.input_type, name as name, substitute the result for final_attrs.
if value != '' :	if value is not equal to an empty string,
final_attrs [ 'value' ] = force_text ( self . _format_value ( value ) )	call the method self._format_value with an argument value, use the result as an argument for the call to the function force_text,
return format_html ( '<input{0} />' , flatatt ( final_attrs ) )	substitute the result for final_attrs dictionary value under the 'value' key.   call the function format_html with 2 arguments: string '<input{0} />',
class TextInput ( Input ) :	result of the function flatatt called with an argument final_attrs, return the result.   derive the class TextInput from the Input base class.
input_type = 'text'	input_type is a string 'text'.
def __init__ ( self , attrs = None ) :	define the method __init__ with 2 arguments: self and attrs set to None.
if attrs is not None :	if attrs is not None,
self . input_type = attrs . pop ( 'type' , self . input_type )	remover the entry under the 'type' key of the attrs dictionary, substitute it for self.input_type, if the key doesnt exists,
super ( TextInput , self ) . __init__ ( attrs )	substitute self.input_type for self.input_type.   call the method __init__ from the base class of the class TextInput, called with an argument attrs.
class NumberInput ( TextInput ) :	derive the class NumberInput from the TextInput base class.
input_type = 'number'	input_type is a string 'number'.
class EmailInput ( TextInput ) :	derive the class EmailInput from the TextInput base class.
input_type = 'email'	input_type is a string 'email'.
class URLInput ( TextInput ) :	derive the class URLInput from the TextInput base class.
input_type = 'url'	input_type is a string 'url'.
class PasswordInput ( TextInput ) :	derive the class PasswordInput from the TextInput base class.
input_type = 'password'	input_type is a string 'password'.
def __init__ ( self , attrs = None , render_value = False ) :	define the method __init__ with 3 arguments: self, attrs set to None and render_value set to boolean False.
super ( PasswordInput , self ) . __init__ ( attrs )	call the method __init__ from the base class of the class PasswordInput, called with an argument attrs.
self . render_value = render_value	substitute render_value for self.render_value.
def render ( self , name , value , attrs = None ) :	define the method render with 4 arguments: self, name, value and attrs set to None.
if not self . render_value :	if self.render_value is false,
value = None	value is None.
return super ( PasswordInput , self ) . render ( name , value , attrs )	call the method render from the base class of the class PasswordInput, called with 3 arguments: name, value and attrs,
class HiddenInput ( Input ) :	return the result.   derive the class HiddenInput from the Input base class.
input_type = 'hidden'	input_type is a string 'hidden'.
class MultipleHiddenInput ( HiddenInput ) :	derive the class MultipleHiddenInput from the HiddenInput base class.
def __init__ ( self , attrs = None , choices = ( ) ) :	define the method __init__ with 3 arguments: self, attrs set to None and choices set to an empty tuple.
super ( MultipleHiddenInput , self ) . __init__ ( attrs )	call the method __init__ from the base class of the class MultipleHiddenInput, called with an argument attrs.
self . choices = choices	substitute choices for self.choices.
def render ( self , name , value , attrs = None , choices = ( ) ) :	define the method render with 5 arguments: self, name, value, attrs set to None and choices set to an empty tuple.
if value is None :	if value is None,
value = [ ]	value is an empty list.
final_attrs = self . build_attrs ( attrs , type = self . input_type , name = name )	call the method self.build_attrs with 3 arguments: attrs, type set to self.input_type, name set to name,
id_ = final_attrs . get ( 'id' , None )	substitute the result for final_attrs.   get the value under the 'id' key of final_attrs dictionary, substitute if for id_ if the key doesnt exists, id_ is None.
inputs = [ ]	inputs is an empty list.
for i , v in enumerate ( value ) :	for every i and v in enumerated iterable value,
input_attrs = dict ( value = force_text ( v ) , ** final_attrs )	unpack dictionary final_attrs, map the values through force_text function with an argument v and convert it to a dictionary, again,
if id_ :	substitute the result input_attrs.   if id_,
input_attrs [ 'id' ] = '%s_%s' % ( id_ , i )	replace '%s' in string '%s_%s' with id_ and i, substitute the result for input_attrs dictionary value under the 'id' key.
inputs . append ( format_html ( '<input{0} />' , flatatt ( input_attrs ) ) )	call the function format_html with 2 arguments: string '<input{0} />', return value of the function flatatt, called with an argument,
\return mark_safe ( '\\n' . join ( inputs ) )\	input_attrs, append the result to inputs list.   join inputs elements into a string, separated with newline character, use it as an argument for the call to the function mark_safe,
def value_from_datadict ( self , data , files , name ) :	return the result.   define the method value_from_datadict with 4 arguments: self, data, files and name.
if isinstance ( data , ( MultiValueDict , MergeDict ) ) :	if data is an instance of MultiValueDict or MergeDict class,
return data . getlist ( name )	call the method data.getlist with an argument name, return the result.
return data . get ( name , None )	return value under the name key of the data dictionary, if it doesnt exists, return None.
class FileInput ( Input ) :	derive the class FileInput from the Input base class.
input_type = 'file'	input_type is a string 'file'.
needs_multipart_form = True	needs_multipart_form is boolean True.
def render ( self , name , value , attrs = None ) :	define the method render with 4 arguments: self, name, value and attrs set to None.
return super ( FileInput , self ) . render ( name , None , attrs = attrs )	call the method render from the base class of the class FileInput, called with 3 arguments: name, None and attrs as attrs.
def value_from_datadict ( self , data , files , name ) :	define the method value_from_datadict with 4 arguments: self, data, files and name.
return files . get ( name , None )	return value under the name key of the files dictionary, if it doesnt exists, return None.
FILE_INPUT_CONTRADICTION = object ( )	FILE_INPUT_CONTRADICTION is an instance of object class.
class ClearableFileInput ( FileInput ) :	derive the class ClearableFileInput from the FileInput base class.
initial_text = ugettext_lazy ( 'Currently' )	call the function ugettext_lazy with an argument string 'Currently', substitute the result for initial_text.
input_text = ugettext_lazy ( 'Change' )	call the function ugettext_lazy with an argument string 'Change', substitute the result for input_text.
clear_checkbox_label = ugettext_lazy ( 'Clear' )	call the function ugettext_lazy with an argument string 'Clear', substitute the result for clear_checkbox_label.
template_with_initial = '%(initial_text)s: %(initial)s %(clear_template)s<br />%(input_text)s: %(input)s'	template_with_initial is a string '%(initial_text)s: %(initial)s %(clear_template)s<br />%(input_text)s: %(input)s'.
template_with_clear = '%(clear)s <label for='%(clear_checkbox_id)s'>%(clear_checkbox_label)s</label>'	template_with_clear is a string '%(clear)s <label for='%(clear_checkbox_id)s'>%(clear_checkbox_label)s</label>'.
url_markup_template = '<a href='{0}'>{1}</a>'	url_markup_template is a string '<a href='{0}'>{1}</a>'.
def clear_checkbox_name ( self , name ) :	define the method clear_checkbox_name with 2 arguments: self and name.
return name + '-clear'	concatenate name and string '-clear', return it.
def clear_checkbox_id ( self , name ) :	define the method clear_checkbox_id with 2 arguments: self and name.
return name + '_id'	concatenate name and string '_id', return it.
def render ( self , name , value , attrs = None ) :	define the method render with 4 arguments: self, name, value and attrs set to None.
substitutions = {  'initial_text' : self . initial_text ,  'input_text' : self . input_text ,  'clear_template' : '' ,  'clear_checkbox_label' : self . clear_checkbox_label ,  }	substitutions is a dictionary with 4 initial entries: self.initial_text for 'initial_text', self.input_text for 'input_text',
template = '%(input)s'	an empty string for 'clear_template' and self.clear_checkbox_label for 'clear_checkbox_label'.   template is a string '%(input)s'.
substitutions [ 'input' ] = super ( ClearableFileInput , self ) . render ( name , value , attrs )	call the method render from the base class of the class ClearableFileInput, called with 3 arguments: name, value and attrs,
if value and hasattr ( value , 'url' ) :	substitute the result for value under the 'input' key of the substitutions dictionary.   if value is true and value has an attribute 'url',
template = self . template_with_initial	substitute self.template_with_initial for template.
substitutions [ 'initial' ] = format_html ( self . url_markup_template ,  value . url ,  force_text ( value ) )	call the function format_html with 3 arguments: self.url_markup_template, value.url and return value of the function force_text,
if not self . is_required :	called with an argument value, substitute the result for value under the 'initial' key of the substitutions dictionary.   if self.is_required is false,
checkbox_name = self . clear_checkbox_name ( name )	call the method self.clear_checkbox_name with an argument name, substitute the result for checkbox_name.
checkbox_id = self . clear_checkbox_id ( checkbox_name )	call the method self.clear_checkbox_id with an argument checkbox_name, substitute the result for checkbox_id.
substitutions [ 'clear_checkbox_name' ] = conditional_escape ( checkbox_name )	call the function conditional_escape with an argument checkbox_name,
substitutions [ 'clear_checkbox_id' ] = conditional_escape ( checkbox_id )	substitute the result for value under the 'clear_checkbox_name' key of the substitutions dictionary.   call the function conditional_escape with an argument checkbox_id,
substitutions [ 'clear' ] = CheckboxInput ( ) . render ( checkbox_name , False , attrs = { 'id' : checkbox_id } )	substitute the result for value under the 'clear_checkbox_id' key of the substitutions dictionary.   call the method render from the instance of CheckboxInput class, with 3 arguments: checkbox_name, boolean False,
substitutions [ 'clear_template' ] = self . template_with_clear % substitutions	attrs as a dictionary with an entry: checkbox_id for 'id',   substitute the result for value under the 'clear' key of the substitutions dictionary.   format self.template_with_clear with substitutions, substitute the result for value under the 'clear_template' key of,
return mark_safe ( template % substitutions )	substitutions dictionary.   call the function mark_safe with an argument template, formated with substitutions, return the result.
def value_from_datadict ( self , data , files , name ) :	define the method value_from_datadict with 4 arguments: self, data, files and name.
upload = super ( ClearableFileInput , self ) . value_from_datadict ( data , files , name )	call the method value_from_datadict from the base class of the class ClearableFileInput,
if not self . is_required and CheckboxInput ( ) . value_from_datadict (  data , files , self . clear_checkbox_name ( name ) ) :	called with 3 arguments: data, files and name, substitute the result for upload.   if self.is_required is boolean false and call to the method value_from_datadict from the instance of CheckboxInput class,
if upload :	with 3 arguments: data, files and return value of the function self.clear_checkbox_name called with an argument name,   evaluates to true,   if upload is true,
return FILE_INPUT_CONTRADICTION	return FILE_INPUT_CONTRADICTION.
return False	return boolean False.
return upload	return boolean upload.
class Textarea ( Widget ) :	derive the class Textarea from the Widget base class.
def __init__ ( self , attrs = None ) :	define the method __init__ with 2 arguments: self and attrs set to None.
default_attrs = { 'cols' : '40' , 'rows' : '10' }	default_attrs is an dictionary with 2 initial entries: string '40' for 'cols' and string '10' for 'rows'.
if attrs :	if attrs is true,
default_attrs . update ( attrs )	update default_attrs dictionary with attrs entry.
super ( Textarea , self ) . __init__ ( default_attrs )	call the method __init__ from the base class of the class Textarea, with an argument default_attrs.
def render ( self , name , value , attrs = None ) :	define the method render with 4 arguments: self, name, value and attrs set to None.
if value is None :	if value is None,
value = ''	value is an empty string.
final_attrs = self . build_attrs ( attrs , name = name )	call the method self.build_attrs with 2 arguments: attrs and name set to name, substitute the result for final_attrs.
\return format_html ( '<textarea{0}>\\r\\n{1}</textarea>' ,  flatatt ( final_attrs ) ,  force_text ( value ) )\	\call the function format_html with 3 arguments: string ('<textarea{0}>\\r\\n{1}</textarea>', return value of the function flatatt,\
class DateTimeBaseInput ( TextInput ) :	called with an argument final_attrs and return value of the function force_text called with an argument value, return the result.   derive the class DateTimeBaseInput from the TextInput base class.
format_key = ''	format key is an empty string.
supports_microseconds = False	supports_microseconds is boolean False.
def __init__ ( self , attrs = None , format = None ) :	define the method __init__ with 3 arguments: self, attrs set to None and format is None.
super ( DateTimeBaseInput , self ) . __init__ ( attrs )	call the method __init__ from the base class of the class DateTimeBaseInput, with an argument attrs.
self . format = format if format else None	substitute format for self.format if format is true, if not self.format is None.
def _format_value ( self , value ) :	define the method _format_value with 2 arguments: self and value.
return formats . localize_input ( value ,  self . format or formats . get_format ( self . format_key ) [ 0 ] )	call the function formats.localize_input with 2 arguments: value and self.format if true, if not,
class DateInput ( DateTimeBaseInput ) :	then the first element of the result of the function formats.get_format called with an argument self.format_key, return the result.   derive the class DateInput from the DateTimeBaseInput base class.
format_key = 'DATE_INPUT_FORMATS'	format_key is a string 'DATE_INPUT_FORMATS'.
class DateTimeInput ( DateTimeBaseInput ) :	derive the class DateTimeInput from the DateTimeBaseInput base class.
format_key = 'DATETIME_INPUT_FORMATS'	format_key is a string 'DATETIME_INPUT_FORMATS'.
class TimeInput ( DateTimeBaseInput ) :	derive the class TimeInput from the DateTimeBaseInput base class.
format_key = 'TIME_INPUT_FORMATS'	format_key is a string 'TIME_INPUT_FORMATS'.
def boolean_check ( v ) :	define the function boolean_check with an argument v.
return not ( v is False or v is None or v == '' )	if v is boolean False or v is None or v is an empty string, return boolean False, otherwise return boolean True.
class CheckboxInput ( Widget ) :	derive the class CheckboxInput from the Widget base class.
def __init__ ( self , attrs = None , check_test = None ) :	define the method __init__ with 3 arguments: self, attrs set to None and check_test set to None.
super ( CheckboxInput , self ) . __init__ ( attrs )	call the method __init__ from the base class of the class CheckboxInput, with an argument attrs.
self . check_test = boolean_check if check_test is None else check_test	substitute boolean_check for self.check_test if check_test is None, otherwise substitute check_test for self.check_test.
def render ( self , name , value , attrs = None ) :	define the method render with 4 arguments: self, name, value and attrs set to None.
final_attrs = self . build_attrs ( attrs , type = 'checkbox' , name = name )	call the method self.build_attrs with 3 arguments: attrs, type as a string 'checkbox', name as name, substitute the result for final_attrs.
if self . check_test ( value ) :	call the method self.check_test with an argument value, if it evaluates to true,
final_attrs [ 'checked' ] = 'checked'	substitute string 'checked' for value under the 'checked' key of final_attrs dictionary.
if not ( value is True or value is False or value is None or value == '' ) :	if value is boolean False or boolean True or value is None or value is an empty string, do not perform the following,
final_attrs [ 'value' ] = force_text ( value )	call the function force_text with an argument value, substitute the result for value under the 'value' key of the final_attrs.
return format_html ( '<input{0} />' , flatatt ( final_attrs ) )	return the result of the function format_html called with 2 arguments: string '<input{0} />',
def value_from_datadict ( self , data , files , name ) :	and result of the function flatatt, called with an argument final_attrs.   define the method value_from_datadict with 4 arguments: self, data, files and name.
if name not in data :	if name is not contained in data,
return False	return boolean False.
value = data . get ( name )	get the name key of the data dictionary, substitute it for value.
values = { 'true' : True , 'false' : False }	values is an dictionary with 2 arguments: boolean False for 'false' and boolean True for 'true'.
if isinstance ( value , six . string_types ) :	if value is an instance of six.string_types class,
value = values . get ( value . lower ( ) , value )	get the value of the values dictionary under the value converted to lowercase key, substitute it for value, if the key doesnt exists,
return bool ( value )	substitute value for value.   return value converted into a boolean.
class Select ( Widget ) :	derive the class Select from the Widget base class.
allow_multiple_selected = False	allow_multiple_selected is boolean False.
def __init__ ( self , attrs = None , choices = ( ) ) :	define the method __init__ with 3 arguments: self, attrs set to None and choices set to an empty tuple.
super ( Select , self ) . __init__ ( attrs )	call the method __init__ from the base class of the class Select, with an argument attrs.
self . choices = list ( choices )	convert elements of choices into a list, substitute it for self.choices.
def render ( self , name , value , attrs = None , choices = ( ) ) :	define the method render with 5 arguments: self, name, value, attrs set to None and choices set to an empty tuple.
if value is None :	if value is None,
value = ''	value is an empty string.
final_attrs = self . build_attrs ( attrs , name = name )	call the method self.build_attrs with arguments attrs, name as name, substitute the result for final_attrs.
output = [ format_html ( '<select{0}>' , flatatt ( final_attrs ) ) ]	output is a list containing an element: result of the function format_html called with 2 arguments: string '<select{0}>',
options = self . render_options ( choices , [ value ] )	and return value of the function flatatt called with an argument final_attrs, substitute the result for output.   call the method self.render_options with 2 arguments: choices and list with an entry, value, substitute the result for options.
if options :	if options is true,
output . append ( options )	append options to output.
output . append ( '</select>' )	append string '</select>' to output.
\return mark_safe ( '\\n' . join ( output ) )\	join elements of output into a string, separated by newline characters, use it as the argument for the call the function mark_safe,
def render_option ( self , selected_choices , option_value , option_label ) :	return the result.   define the method render_option with 4 arguments: self, selected_choices, option_value and option_label.
if option_value is None :	if option_value is None,
option_value = ''	option_value is an empty string.
option_value = force_text ( option_value )	call the function force_text with an argument option_value, substitute the result for option_value.
if option_value in selected_choices :	if option_value is contained in selected_choices,
if not self . allow_multiple_selected :	if self.allow_multiple_selected is false,
selected_choices . remove ( option_value )	call the method selected_choices.remove with an argument option_value.
else :	if not,
selected_html = ''	selected_html is an empty string.
return format_html ( '<option value='{0}'{1}>{2}</option>' ,  option_value ,  selected_html ,  force_text ( option_label ) )	call the function format_html with 4 arguments: string '<option value='{0}'{1}>{2}</option>', option_value, selected_html,
def render_options ( self , choices , selected_choices ) :	result of the function force_text with an argument option_label, return the result.   define the method render_options with 3 arguments: self, choices and selected_choices.
selected_choices = set ( force_text ( v ) for v in selected_choices )	call the function force_text with an argument v, for every v in selected_choices, add results to a set,
output = [ ]	substitute the resulting set for selected_choices.   output is an empty list.
for option_value , option_label in chain ( self . choices , choices ) :	call the function chain with arguments self.choices and choices, for every option_value and option_label in the result,
if isinstance ( option_label , ( list , tuple ) ) :	if option_label is an instance of list or tuple,
output . append ( format_html ( '<optgroup label='{0}'>' , force_text ( option_value ) ) )	call the function format_html with 2 arguments: string '<optgroup label='{0}'>' and return value of the function force_text,
for option in option_label :	called with an argument option_value, append the result to output.   for every option in option_label,
output . append ( self . render_option ( selected_choices , * option ) )	call the method self.render_option with 2 arguments: selected_choices and unpacked list option, append the result to output.
output . append ( '</optgroup>' )	append string '</optgroup>' to output.
else :	if not,
output . append ( self . render_option ( selected_choices , option_value , option_label ) )	call the method self.render_option with 3 arguments: selected_choices, option_value and option_label, append the result to output.
\return '\\n' . join ( output )\	join elements of output in a string, separated by newlines, return it.
class NullBooleanSelect ( Select ) :	derive the class NullBooleanSelect from the Select base class.
def __init__ ( self , attrs = None ) :	define the method __init__ with 2 arguments: self and attrs set to None.
choices = ( ( '1' , ugettext_lazy ( 'Unknown' ) ) ,  ( '2' , ugettext_lazy ( 'Yes' ) ) ,  ( '3' , ugettext_lazy ( 'No' ) ) )	choices is a tuple with 3 elements: tuple with 2 elements: string '1' and return value of the function ugettext_lazy,
super ( NullBooleanSelect , self ) . __init__ ( attrs , choices )	called with an argument string 'Unknown', tuple with 2 elements: string '2' and return value of the function ugettext_lazy,   called with an argument string 'Yes' and tuple with 2 elements: string '3' and return value of the function ugettext_lazy,   called with an argument string 'No'.   call the method __init__ from the base class of the class NullBooleanSelect, with arguments attrs and choices.
def render ( self , name , value , attrs = None , choices = ( ) ) :	define the method render with 5 arguments: self, name, value, attrs set to None and choices set to an empty tuple.
try :	try,
value = { True : '2' , False : '3' , '2' : '2' , '3' : '3' } [ value ]	get the value under value key of a dictionary with 4 entries: '2' for boolean True, '3' for boolean False, '2' for '2',
except KeyError :	and '3' for '3', substitute it for value.   if KeyError exception is caught,
value = '1'	value is an string '1'.
return super ( NullBooleanSelect , self ) . render ( name , value , attrs , choices )	call the method render from the base class of the class NullBooleanSelect, with 4 arguments: name, value, attrs and choices,
def value_from_datadict ( self , data , files , name ) :	return the result.   define the method value_from_datadict with 4 arguments: self, data, files and name.
value = data . get ( name , None )	get the value under the name key of the data dictionary, if it exists substitute it for value, if not, value is None.
return { '2' : True ,  True : True ,  'True' : True ,  '3' : False ,  'False' : False ,  False : False } . get ( value , None )	get the value under the value key of a dictionary with 6 entries: boolean True for '2', boolean True for boolean True,
class SelectMultiple ( Select ) :	boolean True for 'True', boolean False for '3', boolean False for 'False' and boolean False for boolean False,   return it if the key exists, if not return None.   derive the class SelectMultiple from the Select base class.
allow_multiple_selected = True	allow_multiple_selected is boolean True.
def render ( self , name , value , attrs = None , choices = ( ) ) :	define the method render with 5 arguments: self, name, value, attrs set to None and choices set to an empty tuple.
if value is None :	if value is None,
value = [ ]	value is an empty list.
final_attrs = self . build_attrs ( attrs , name = name )	call the method self.build_attrs with 2 arguments: attrs and name set to name, substitute the result for final_attrs.
output = [ format_html ( '<select multiple='multiple'{0}>' , flatatt ( final_attrs ) ) ]	output is a list containing an entry: result of the function format_html called with 2 arguments:
options = self . render_options ( choices , value )	string '<select multiple='multiple'{0}>' and result of the function flatatt called with an argument final_attrs.   call the method self.render_options with 2 arguments: choices and value, substitute the result for options.
if options :	if options is true,
output . append ( options )	append options to output.
output . append ( '</select>' )	append string '</select>' to output.
\return mark_safe ( '\\n' . join ( output ) )\	join elements of output into a string, separated with newline character,
def value_from_datadict ( self , data , files , name ) :	use it as an argument for the call to the mark_safe function, return the result.   define the method value_from_datadict with 4 arguments: self, data, files and name.
if isinstance ( data , ( MultiValueDict , MergeDict ) ) :	if data is an instance of MultiValueDict or MergeDict,
return data . getlist ( name )	call the method data.getlist with an argument name, return the result.
return data . get ( name , None )	get the value under the name key of the data dictionary, if it exists return it, if not return None.
@ python_2_unicode_compatible	python_2_unicode_compatible decorator,
class ChoiceInput ( SubWidget ) :	derive the class ChoiceInput from the SubWidget base class.
input_type = None	input_type is None.
def __init__ ( self , name , value , attrs , choice , index ) :	define the method __init__ with 6 arguments: self, name, value, attrs, choice and index.
self . name = name	substitute name for self.name.
self . value = value	substitute value for self.value.
self . attrs = attrs	substitute attrs for self.attrs.
self . choice_value = force_text ( choice [ 0 ] )	call the function force_text with first element of choice as an argument, substitute the result for self.choice_value.
self . choice_label = force_text ( choice [ 1 ] )	call the function force_text with second element of choice as an argument, substitute the result for self.choice_label.
self . index = index	substitute index for self.index.
if 'id' in self . attrs :	if string 'id' is contained in self.attrs,
self . attrs [ 'id' ] += '_%d' % self . index	convert self.index into a string and append it to '_' string, substitute it for value under the 'id' key of self.attrs dictionary.
def __str__ ( self ) :	define the method __str__ with an argument self.
return self . render ( )	call the method self.render, return the result.
def render ( self , name = None , value = None , attrs = None , choices = ( ) ) :	define the method render with 5 arguments: self, name set to None, value set to None, attrs set to None and choices set to an empty tuple.
if self . id_for_label :	self.id_for_label is true,
else :	if not,
label_for = ''	label_for is an empty string.
return format_html ( '<label{0}>{1} {2}</label>' , label_for , self . tag ( ) , self . choice_label )	call the function format_html with 4 arguments: string '<label{0}>{1} {2}</label>', label_for, result of the method self.tag,
def is_checked ( self ) :	and self.choice_label, return the result.   define the method is_checked with an argument self.
return self . value == self . choice_value	if self.value equals self.choice_value, return boolean True, if not, return boolean False.
def tag ( self ) :	define the method tag with an argument self.
final_attrs = dict ( self . attrs , type = self . input_type , name = self . name , value = self . choice_value )	call the method dict with 4: self.attrs, type as self.input_type, name as self.name, value as self.choice_value,
if self . is_checked ( ) :	substitute the result for final_attrs.   call the method self.is_checked, if it evaluates to true,
final_attrs [ 'checked' ] = 'checked'	substitute string 'checked' for value under the 'checked' key of final_attrs dictionary.
return format_html ( '<input{0} />' , flatatt ( final_attrs ) )	call the function format_html with 2 arguments: string '<input{0} />' and result of the function flatatt,
@ property	called with an argument final_attrs, return the result.   property decorator,
def id_for_label ( self ) :	define the method id_for_label with an argument self.
return self . attrs . get ( 'id' , '' )	get the value under the 'id' key of the self.attrs dictionary, return it, if the key doesnt exists return an empty string.
class RadioChoiceInput ( ChoiceInput ) :	derive the class RadioChoiceInput from the ChoiceInput base class.
input_type = 'radio'	input_type is a string 'radio'.
def __init__ ( self , * args , ** kwargs ) :	define the method __init__ with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
super ( RadioChoiceInput , self ) . __init__ ( * args , ** kwargs )	call the method __init__ from the base class of the class RadioChoiceInput, with 2 arguments: unpacked list args,
self . value = force_text ( self . value )	and unpacked dictionary kwargs.   call the function force_text with an argument self.value, substitute the result for self.value.
class CheckboxChoiceInput ( ChoiceInput ) :	derive the class CheckboxChoiceInput from the ChoiceInput base class.
input_type = 'checkbox'	input_type is a string 'checkbox'.
def __init__ ( self , * args , ** kwargs ) :	define the method __init__ with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
super ( CheckboxChoiceInput , self ) . __init__ ( * args , ** kwargs )	call the method __init__ from the base class of the class CheckboxChoiceInput, with 2 arguments: unpacked list args,
self . value = set ( force_text ( v ) for v in self . value )	and unpacked dictionary kwargs.   for every v in self.value call the function force_text with an argument v, add the result to a set,
def is_checked ( self ) :	substitute set of the results for self.value.   define the method is_checked with an argument self.
return self . choice_value in self . value	if self.choice_value is contained in self.value return boolean True, otherwise return boolean False.
@ python_2_unicode_compatible	python_2_unicode_compatible decorator,
class ChoiceFieldRenderer ( object ) :	derive the class ChoiceFieldRenderer from the object base class.
choice_input_class = None	choice_input_class is None.
outer_html = '<ul{id_attr}>{content}</ul>'	outer_html is a string '<ul{id_attr}>{content}</ul>'.
inner_html = '<li>{choice_value}{sub_widgets}</li>'	inner_html is a string '<li>{choice_value}{sub_widgets}</li>'.
def __init__ ( self , name , value , attrs , choices ) :	define the method __init__ with 5 arguments: self, name, value, attrs and choices.
self . name = name	substitute name for self.name.
self . value = value	substitute value for self.value.
self . attrs = attrs	substitute attrs for self.attrs.
self . choices = choices	substitute choices for self.choices.
def __getitem__ ( self , idx ) :	define the method __getitem__ with 2 arguments: self and idx.
choice = self . choices [ idx ]	substitute idx-th element of self.choices for choice.
return self . choice_input_class ( self . name , self . value , self . attrs . copy ( ) , choice , idx )	call the method self.choice_input_class with 5 arguments: self.name, self.value, result of the method self.attrs.copy,
def __str__ ( self ) :	choice and idx, return the result.   define the method __str__ with an argument self.
return self . render ( )	call the method self.render, return the result.
def render ( self ) :	define the method render with an argument self.
id_ = self . attrs . get ( 'id' , None )	get the value under the 'id' key of the self.attrs dictionary, substitute it for id_ if the key exists, if not id_ is None.
output = [ ]	output is an empty list.
for i , choice in enumerate ( self . choices ) :	for every i and choice in enumerated iterable self.choices,
choice_value , choice_label = choice	substitute choice for choice_value and choice_label, respectively.
if isinstance ( choice_label , ( tuple , list ) ) :	if choice_label is an instance of tuple or list,
attrs_plus = self . attrs . copy ( )	call the method self.attrs.copy, substitute the result for attrs_plus.
if id_ :	if id_ is true,
attrs_plus [ 'id' ] += '_{0}' . format ( i )	prepend string '_' to i converted to an string, append the result to the value under the 'id' key of the attrs_plus.
sub_ul_renderer = ChoiceFieldRenderer ( name = self . name ,  value = self . value ,  attrs = attrs_plus ,  choices = choice_label )	sub_ul_renderer is an instance of ChoiceFieldRenderer class, created with 4 arguments: name as self.name, value as self.value,
sub_ul_renderer . choice_input_class = self . choice_input_class	attrs as attrs_plus and choices as choice_label.   substitute self.choice_input_class for sub_ul_renderer.choice_input_class.
output . append ( format_html ( self . inner_html , choice_value = choice_value ,  sub_widgets = sub_ul_renderer . render ( ) ) )	call the function format_html with 3 arguments: self.inner_html, choice_value set to choice_value,
else :	and sub_widgets set to return value of the function sub_ul_renderer.render, append the result to output.   if not,
w = self . choice_input_class ( self . name , self . value ,  self . attrs . copy ( ) , choice , i )	call the method self.choice_input_class with 5 arguments: self.name, self.value, return value of the method self.attrs.copy,
output . append ( format_html ( self . inner_html ,  choice_value = force_text ( w ) , sub_widgets = '' ) )	choice and i, substitute the result for w.   call the function format_html with 3 arguments: self.inner_html, choice_value set to result of the function force_text,
class RadioFieldRenderer ( ChoiceFieldRenderer ) :	\if id_ is true id_attr set to return value of the function format_html, if not id_attr set to an empty string,   content set to result of the function mark_safe with an argument: string created by joining elements of outputs, with '\\n' separator,   return the result.   derive the class RadioFieldRenderer from the ChoiceFieldRenderer base class.\
choice_input_class = RadioChoiceInput	substitute RadioChoiceInput for choice_input_class.
class CheckboxFieldRenderer ( ChoiceFieldRenderer ) :	derive the class CheckboxFieldRenderer from the ChoiceFieldRenderer base class.
choice_input_class = CheckboxChoiceInput	substitute CheckboxChoiceInput for choice_input_class.
class RendererMixin ( object ) :	derive the class RendererMixin from the object base class.
renderer = None	renderer is None.
_empty_value = None	_empty_value is None.
def __init__ ( self , * args , ** kwargs ) :	define the method __init__ with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
renderer = kwargs . pop ( 'renderer' , None )	remove entry under 'render' key of the kwargs dictionary and substitute it for renderer, if the key doesnt exists, renderer is None.
if renderer :	if renderer is true,
self . renderer = renderer	substitute renderer for self.renderer.
super ( RendererMixin , self ) . __init__ ( * args , ** kwargs )	call the method __init__ from the base class of the class RendererMixin, with 2 arguments: unpacked list args,
def subwidgets ( self , name , value , attrs = None , choices = ( ) ) :	and unpacked dictionary kwargs.   define the method subwidgets with 5 arguments: self, name, value, attrs set to None and choices set to an empty tuple.
for widget in self . get_renderer ( name , value , attrs , choices ) :	call the method self.get_renderer with 4 arguments: name, value, attrs and choices, for every widget in result,
yield widget	yield widget.
def get_renderer ( self , name , value , attrs = None , choices = ( ) ) :	define the method get_renderer with 5 arguments: self, name, value, attrs set to None and choices set to an empty tuple.
if value is None :	if value is None,
value = self . _empty_value	substitute self._empty_value for value.
final_attrs = self . build_attrs ( attrs )	call the method self.build_attrs with an argument attrs, substitute the result for final_attrs.
choices = list ( chain ( self . choices , choices ) )	call the function chain with 2 arguments: self.choices and choices, convert the result into a list and substitute it for choices.
return self . renderer ( name , value , final_attrs , choices )	call the method self.renderer with 4 arguments: name, value, final_attrs and choices, return the result.
def render ( self , name , value , attrs = None , choices = ( ) ) :	define the method render with 5 arguments: self, name, value, attrs set to None and choices set to an empty tuple.
return self . get_renderer ( name , value , attrs , choices ) . render ( )	call the method self.get_renderer with 4 arguments: name, value, attrs and choices, call the render method on the result, return the result.
def id_for_label ( self , id_ ) :	define the method id_for_label with 2 arguments: self and id_.
if id_ :	if id_ is true,
id_ += '_0'	append string '_0' to id_.
return id_	return id_.
class RadioSelect ( RendererMixin , Select ) :	derive the class RadioSelect from the RendererMixin and Select base classes.
renderer = RadioFieldRenderer	substitute RadioFieldRenderer for renderer.
_empty_value = ''	_empty_value is an empty string.
class CheckboxSelectMultiple ( RendererMixin , SelectMultiple ) :	derive the class CheckboxSelectMultiple from the RendererMixin and SelectMultiple base classes.
renderer = CheckboxFieldRenderer	substitute CheckboxFieldRenderer for renderer.
_empty_value = [ ]	_empty_value is an empty list.
class MultiWidget ( Widget ) :	derive the class MultiWidget from the Widget base class.
def __init__ ( self , widgets , attrs = None ) :	define the method __init__ with 3 arguments: self, widgets and attrs set to None.
self . widgets = [ w ( ) if isinstance ( w , type ) else w for w in widgets ]	for every w in widgets, call the function w and append the result to a list, if w is an instance of type class,
super ( MultiWidget , self ) . __init__ ( attrs )	if not append w to the list, substitute the resulting list for self.widgets.   call the method __init__ from the base class of the class MultiWidget, with an argument attrs.
@ property	property decorator,
def is_hidden ( self ) :	define the method is_hidden with an argument self.
return all ( w . is_hidden for w in self . widgets )	for every w in self.widgets, if all elements w.is_hidden are true, return boolean True, otherwise return boolean False.
def render ( self , name , value , attrs = None ) :	define the method render with 4 arguments: self, name, value and attrs set to None.
if self . is_localized :	if self.is_localized is true,
for widget in self . widgets :	for every bwidget in self.widgets,
widget . is_localized = self . is_localized	substitute self.is_localized for widget.is_localized.
if not isinstance ( value , list ) :	if value is not an instance of list type,
value = self . decompress ( value )	call the method self.decompress with an argument value, substitute the result for value.
output = [ ]	output is an empty list.
final_attrs = self . build_attrs ( attrs )	call the method self.build_attrs with an argument attrs, substitute the result for final_attrs.
id_ = final_attrs . get ( 'id' , None )	get the value under the 'id' key of the final_attrs dictionary, substitute it for id_, if it doesnt exists, id_ is None.
for i , widget in enumerate ( self . widgets ) :	for every i and widget in enumerated iterable self.widgets,
try :	try,
widget_value = value [ i ]	substitute i-th element of value for widget_value.
except IndexError :	if IndexError exception is caught,
widget_value = None	widget_value is None.
if id_ :	if id_ is true,
final_attrs = dict ( final_attrs , id = '%s_%s' % ( id_ , i ) )	call the dict function with 2 arguments: final_attrs and id set to string '%s_%s', where '%s' is replaced with id_ and i,
output . append ( widget . render ( name + '_%s' % i , widget_value , final_attrs ) )	substitute the result for final_attrs.   call the method widget.render with 3 arguments: string created by concatenation from: name, string '_' and i, widget_value,
return mark_safe ( self . format_output ( output ) )	and final_attrs, append the result to output.   call the method self.format_output with an argument output, use the result as an argument for the call to the function mark_safe,
def id_for_label ( self , id_ ) :	return the result.   define the method id_for_label with 2 arguments: self and id_.
if id_ :	if id_ is true,
id_ += '_0'	append string '_0' to id_.
return id_	return id_.
def value_from_datadict ( self , data , files , name ) :	define the method value_from_datadict with 2 arguments: self, data, files and name.
return [ widget . value_from_datadict ( data , files , name + '_%s' % i ) for i , widget in enumerate ( self . widgets ) ]	for every i and widget in enumerated iterable self.widgets, call the function widget.value_from_datadict with 3 arguments: data,
def format_output ( self , rendered_widgets ) :	files and string created with concatenation of: name, string '_' and i converted into a string, return the results in a list.   define the method format_output with 2 arguments: self and rendered_widgets.
return '' . join ( rendered_widgets )	join rendered_widgets into a string, return it.
def decompress ( self , value ) :	define the method decompress with 2 arguments: self and value.
raise NotImplementedError ( 'Subclasses must implement this method.' )	raise NotImplementedError exception with an argument string 'Subclasses must implement this method.'.
def _get_media ( self ) :	define the method _get_media with an argument self.
media = Media ( )	media is an instance of Media class.
for w in self . widgets :	for every w in self.widgets,
media = media + w . media	sum media and w.media, substitute the result for media.
return media	return media.
media = property ( _get_media )	media is a property object of the current class, with _get_media as getter function.
def __deepcopy__ ( self , memo ) :	define the method __deepcopy__ with 2 arguments: self and memo.
obj = super ( MultiWidget , self ) . __deepcopy__ ( memo )	call the method __deepcopy__ from the base class of the class MultiWidget, with an argument memo, substitute the result for obj.
obj . widgets = copy . deepcopy ( self . widgets )	call the method copy.deepcopy with an argument self.widgets, substitute the result for obj.widgets.
return obj	return obj.
@ property	property decorator,
def needs_multipart_form ( self ) :	define the method needs_multipart_form with an argument self.
return any ( w . needs_multipart_form for w in self . widgets )	if any w.needs_multipart_form for every w in self.widgets is true, return boolean True, if not return boolean False.
class SplitDateTimeWidget ( MultiWidget ) :	derive the class SplitDateTimeWidget from the MultiWidget base class.
supports_microseconds = False	supports_microseconds is boolean False.
def __init__ ( self , attrs = None , date_format = None , time_format = None ) :	define the method __init__ with 4 arguments: self, attrs set to None, date_format set to None and time_format set to None.
widgets = ( DateInput ( attrs = attrs , format = date_format ) ,  TimeInput ( attrs = attrs , format = time_format ) )	widgets is a tuple with 2 elements: instance of DateInput class, created with 2 arguments: attrs as attrs and format as date_format,
super ( SplitDateTimeWidget , self ) . __init__ ( widgets , attrs )	and instance of TimeInput class, created with 2 arguments: attrs set to attrs and format set to date_format.   call the method __init__ from the base class of the class SplitDateTimeWidget, with 2 arguments: widgets and attrs.
def decompress ( self , value ) :	define the method decompress with 2 arguments: self and value.
if value :	if value is true,
value = to_current_timezone ( value )	call the function to_current_timezone with an argument, substitute the result for value.
return [ value . date ( ) , value . time ( ) . replace ( microsecond = 0 ) ]	return a list containing 2 elements: return value of the value.date method and return value of the replace method,
return [ None , None ]	called with the argument microseconds set to integer 0, on the result of the method value.time.   return list containing 2 elements: None and None.
class SplitHiddenDateTimeWidget ( SplitDateTimeWidget ) :	derive the class SplitHiddenDateTimeWidget from the SplitDateTimeWidget base class.
def __init__ ( self , attrs = None , date_format = None , time_format = None ) :	define the method render with 4 arguments: self, attrs set to None, date_format set to None and time_format set to None.
super ( SplitHiddenDateTimeWidget , self ) . __init__ ( attrs , date_format , time_format )	call the method __init__ from the base class of the class SplitHiddenDateTimeWidget, with 3 arguments: attrs, date_format,  and time_format.
for widget in self . widgets :	for every widget in self.widgets:,
widget . input_type = 'hidden'	widget.input_type is a string 'hidden'.
from django . http . cookie import SimpleCookie , parse_cookie	from django.http.cookie import SimpleCookie and parse_cookie into default name space.
from django . http . request import ( HttpRequest , QueryDict ,  RawPostDataException , UnreadablePostError , build_request_repr )	from django.http.request import HttpRequest, QueryDict, RawPostDataException, UnreadablePostError and build_request_repr into default name space.
from django . http . response import ( HttpResponse , StreamingHttpResponse ,  HttpResponseRedirect , HttpResponsePermanentRedirect ,  HttpResponseNotModified , HttpResponseBadRequest , HttpResponseForbidden ,  HttpResponseNotFound , HttpResponseNotAllowed , HttpResponseGone ,  HttpResponseServerError , Http404 , BadHeaderError , JsonResponse )	from django.http.response import HttpResponse, StreamingHttpResponse, HttpResponseRedirect, HttpResponsePermanentRedirect,
from django . http . utils import fix_location_header , conditional_content_removal	HttpResponseNotModified, HttpResponseBadRequest, HttpResponseForbidden, HttpResponseNotFound, HttpResponseNotAllowed, HttpResponseGone,   HttpResponseServerError, Http404, BadHeaderError, JsonResponse into default name space.   from django.http.utils import fix_location_header and conditional_content_removal into default name space.
__all__ = [  'SimpleCookie' , 'parse_cookie' , 'HttpRequest' , 'QueryDict' ,  'RawPostDataException' , 'UnreadablePostError' , 'build_request_repr' ,  'HttpResponse' , 'StreamingHttpResponse' , 'HttpResponseRedirect' ,  'HttpResponsePermanentRedirect' , 'HttpResponseNotModified' ,  'HttpResponseBadRequest' , 'HttpResponseForbidden' , 'HttpResponseNotFound' ,  'HttpResponseNotAllowed' , 'HttpResponseGone' , 'HttpResponseServerError' ,  'Http404' , 'BadHeaderError' , 'fix_location_header' , 'JsonResponse' ,  'conditional_content_removal' ,  ]	__all__ is a list of strings, 'SimpleCookie', 'parse_cookie', 'HttpRequest', 'QueryDict', 'RawPostDataException',
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . utils . encoding import force_str	from django.utils.encoding import force_st into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . six . moves import http_cookies	from django.utils.six.moves import http_cookies into default name space.
try :	try,
_tc . load ( str ( 'foo:bar=1' ) )	call the _tc.load method with the 'foo:bar=1' converted to string as an argument.
_cookie_allows_colon_in_names = True	  _cookie_allows_colon_in_names is a boolean True.
except http_cookies . CookieError :	if http_cookies.CookieError exception is caught,
_cookie_allows_colon_in_names = False	_cookie_allows_colon_in_names is boolean False.
if _cookie_encodes_correctly and _cookie_allows_colon_in_names :	if _cookie_encodes_correctly and _cookie_allows_colon_in_names are boolean True,
SimpleCookie = http_cookies . SimpleCookie	substitute http_cookies.SimpleCookie for SimpleCookie.
else :	if not,
Morsel = http_cookies . Morsel	substitute http_cookies.Morsel for Morsel.
class SimpleCookie ( http_cookies . SimpleCookie ) :	derive class SimpleCookie from the base class http_cookies.SimpleCookie.
if not _cookie_encodes_correctly :	if _cookie_encodes_correctly is boolean False,
def value_encode ( self , val ) :	define method value_encode with self class instance and val as arguments.
          val , encoded = super ( SimpleCookie , self ) . value_encode ( val )	from the base class of the class SimpleCookie call the value_encode method with val as the argument, store the result in the val and encoded, respectively.
\encoded = encoded . replace ( ';' , '\\\\073' ) . replace ( ',' , '\\\\054' )\	\in encoded, replace all the occurrences of unicode character '\\\\054' with ',' character and '\\\\073' with ';' characters.\
return val , encoded	return val and encoded as a tuple.
if not _cookie_allows_colon_in_names :	if _cookie_allows_colon_in_names is False,
def load ( self , rawdata ) :	define the method load with self class instance and rawdata as arguments.
self . bad_cookies = set ( )	self.bad_cookies is an empty set.
if six . PY2 and isinstance ( rawdata , six . text_type ) :	if six.PY2 is true and rawdata is an instance of the type six.text_type.
rawdata = force_str ( rawdata )	call the function force_str with raw data as an argument and substitute it for rawdata.
super ( SimpleCookie , self ) . load ( rawdata )	from the base class of the SimpleCookie class call the method load with rawdata as argument.
for key in self . bad_cookies :	for every key is self.bad_cookies,
del self [ key ]	delete self entry under the key key.
def _BaseCookie__set ( self , key , real_value , coded_value ) :	define protected method _BaseCookie__set with self class instance, key, real_value and coded_value as arguments.
key = force_str ( key )	evaluate the function force_str with key as the argument, substitute it for key.
try :	try,
M = self . get ( key , Morsel ( ) )	get the value under the key of the dictionary self, if key does not exists return evaluated result of the function Morsel, substitute it for M.
M . set ( key , real_value , coded_value )	call the M.set method with the key, real_value, coded_value as the arguments.
dict . __setitem__ ( self , key , M )	call the private dict.__setitem__ method with self class instance, key and M as arguments.
except http_cookies . CookieError :	if http_cookies.CookieError exception is raised.
if not hasattr ( self , 'bad_cookies' ) :	if self does not have 'bad_cookies' attribute,
    self . bad_cookies = set ( )	self.bad_cookies is an empty set.
self . bad_cookies . add ( key )	add key to the self.bad_cookies set.
dict . __setitem__ ( self , key , http_cookies . Morsel ( ) )	call the private dict.__setitem__ method with self class instance, key and result of the function http_cookies.Morsel() as arguments.
def parse_cookie ( cookie ) :	define the function parse_cookie with cookie as the argument.
if cookie == '' :	if cookie is an empty string,
return { }	return an empty dictionary.
if not isinstance ( cookie , http_cookies . BaseCookie ) :	if cookie is not an instance of http_cookies.BaseCookie,
try :	try,
c = SimpleCookie ( )	c is an instance of the class SimpleCookie.
c . load ( cookie )	call the load method on the c class instance, with the cookie argument.
except http_cookies . CookieError :	if http_cookies.CookieError exception is raised,
return { }	return an empty dictionary.
else :	if not,
c = cookie	substitute cookie for c.
cookiedict = { }	cookiedict is an empty dictionary.
for key in c . keys ( ) :	for every key in return value of the method c.keys call,
cookiedict [ key ] = c . get ( key ) . value	get the value filed from the return value of the call to the c.key with the argument key, add the value to the cookiedict under the key key.
return cookiedict	return cookiedict.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import base64	import module base64.
import binascii	import module binascii.
import cgi	import module cgi.
import sys	import module sys.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . exceptions import SuspiciousMultipartForm	from django.core.exceptions import SuspiciousMultipartF into default name space.
from django . utils . datastructures import MultiValueDict	from django.utils.datastructures import MultiValueDict into default name space.
from django . utils . encoding import force_text	from django.utils.encoding import force_text into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . text import unescape_entities	from django.utils.text import unescape_entities into default name space.
from django . core . files . uploadhandler import StopUpload , SkipFile , StopFutureHandlers	from django.core.files.uploadhandler import StopUpload,  SkipFile and StopFutureHandlers into default name space.
__all__ = ( 'MultiPartParser' , 'MultiPartParserError' , 'InputStreamExhausted' )	__all__ is an tuple with 3 elements: strings 'MultiPartParser', 'MultiPartParserError' and 'InputStreamExhausted'.
class MultiPartParserError ( Exception ) :	derive the class MultiPartParserError from the Exception base class.
pass	do nothing.
class InputStreamExhausted ( Exception ) :	derive the class InputStreamExhausted from the Exception base class.
pass	do nothing.
RAW = 'raw'	RAW is a string 'raw'.
FILE = 'file'	FILE is a file'.
FIELD = 'field'	FIELD is a field'.
_BASE64_DECODE_ERROR = TypeError if six . PY2 else binascii . Error	if six.PY2 is true, _BASE64_DECODE_ERROR is TypeError, if not, _BASE64_DECODE_ERROR is binascii.Error.
class MultiPartParser ( object ) :	derive the class MultiPartParser from the object base class.
def __init__ ( self , META , input_data , upload_handlers , encoding = None ) :	define the method __init__ wiht 5 arguments: self, META, input_data, upload_handlers and encoding set to None.
content_type = META . get ( 'HTTP_CONTENT_TYPE' , META . get ( 'CONTENT_TYPE' , '' ) )	get the value from META dictionary, under the 'HTTP_CONTENT_TYPE' key, if the key doesnt exist,
if not content_type . startswith ( 'multipart/' ) :	return the value under the 'CONTENT_TYPE' of the META dictionary, if it doesnt exist return an empty string,   substitute the result for content_type.   if content_type doesnt start with string 'multipart/',
raise MultiPartParserError ( 'Invalid Content-Type: %s' % content_type )	raise an MultiPartParserError with an argument string 'Invalid Content-Type: %s', where '%s' is replaced with content_type.
ctypes , opts = parse_header ( content_type . encode ( 'ascii' ) )	call the method boundary with an argument string 'ascii', use the result to call to the parse_header function,
boundary = opts . get ( 'boundary' )	assign the result to ctypes and opts.   get the value under the 'boundary' key of the opts dictionary, substitute it for boundary.
if not boundary or not cgi . valid_boundary ( boundary ) :	if boundary is false or return value of the method cgi.valid_boundary called with an argument boundary evaluates to false,
raise MultiPartParserError ( 'Invalid boundary in multipart: %s' % boundary )	raise an MultiPartParserError with an argument string 'Invalid boundary in multipart: %s' is replaced with boundary.
try :	try,
content_length = int ( META . get ( 'HTTP_CONTENT_LENGTH' , META . get ( 'CONTENT_LENGTH' , 0 ) ) )	convert value under the 'HTTP_CONTENT_LENGTH' key of the META dictionary to an integer of base of value under the 'CONTENT_LENGTH' key of META dictionary, if the key doesnt exists use 0 as the base, substitute the result for content_length.
except ( ValueError , TypeError ) :	if ValueError or TypeError are caught,
content_length = 0	content_length is integer 0.
if content_length < 0 :	if content_length is lesser than integer 0,
raise MultiPartParserError ( 'Invalid content length: %r' % content_length )	raise an MultiPartParserError with an argument string 'Invalid content length: %r', where '%r' is replaced with content_length.
if isinstance ( boundary , six . text_type ) :	if boundary is an instance of six.text_type class,
boundary = boundary . encode ( 'ascii' )	call the method boundary.encode with an argument string 'ascii', substitute the result for boundary.
self . _boundary = boundary	substitute boundary for self._boundary.
self . _input_data = input_data	substitute input_data for self._input_data.
possible_sizes = [ x . chunk_size for x in upload_handlers if x . chunk_size ]	for every x in upload_handlers if x.chunk_size is true, append x.chunk_size to a list, substitute the result for possible_sizes.
self . _chunk_size = min ( [ 2 ** 31 - 4 ] + possible_sizes )	bring integer 2 to the power of 31, subtract the result by 4, put the result into a list, append possible_sizes to it,
self . _meta = META	substitute minimal element of the resulting list for self._chunk_size.   substitute META for self._meta.
self . _encoding = encoding or settings . DEFAULT_CHARSET	if encoding is true, substitute it for self._encoding, if not substitute settings.DEFAULT_CHARSET for self._encoding.
self . _content_length = content_length	substitute content_length for self._content_length.
self . _upload_handlers = upload_handlers	substitute _upload_handlers for self.__upload_handlers.
def parse ( self ) :	define the method parse with an argument self.
from django . http import QueryDict	from django.http import QueryDict into default namespace.
encoding = self . _encoding	substitute self._encoding for encoding.
handlers = self . _upload_handlers	substitute self._upload_handlers for handlers.
if self . _content_length == 0 :	if self._content_length equals integer 0,
return QueryDict ( '' , encoding = self . _encoding ) , MultiValueDict ( )	instantiate QueryDict class with 2 arguments: an empty string and encoding set to self._encoding, instantiate a class MultiValueDict, return them.
for handler in handlers :	for every handler in handlers,
result = handler . handle_raw_input ( self . _input_data ,  self . _meta ,  self . _content_length ,  self . _boundary ,  encoding )	call the method handler.handle_raw_input with 5 arguments: self._input_data, self._meta, self._content_length, self._boundary,
if result is not None :	and encoding, substitute the result for result.   if result is not None,
return result [ 0 ] , result [ 1 ]	return first and second element of result.
self . _post = QueryDict ( '' , mutable = True )	self._post is an instance of QueryDict class, created with an empty string and mutable set to boolean True.
self . _files = MultiValueDict ( )	self._files is an instance of MultiValueDict class.
stream = LazyStream ( ChunkIter ( self . _input_data , self . _chunk_size ) )	instantiate class ChunkIter with 2 arguments: self._input_data and self._chunk_size, use it to instantiate LazyStream class,
old_field_name = None	assign the handle to stream.   old_field_name is None.
counters = [ 0 ] * len ( handlers )	counters is a list containing length of handlers number of zeros.
try :	try,
for item_type , meta_data , field_stream in Parser ( stream , self . _boundary ) :	call the Parser object with stream and self._boundary, for every item_type, meta_data and field_stream in return value,
if old_field_name :	if old_field_name is true,
    self . handle_file_complete ( old_field_name , counters )	call the method self.handle_file_complete with arguments old_field_name, counters.
old_field_name = None	old_field_name is None.
try :	try,
disposition = meta_data [ 'content-disposition' ] [ 1 ]	get the value under the 'content-disposition' key of the meta_data dictionary, substitute second element of it for disposition.
field_name = disposition [ 'name' ] . strip ( )	get the value under the 'name' key of the disposition dictionary, strip it of whitespaces, substitute the result for field_name.
except ( KeyError , IndexError , AttributeError ) :	if KeyError, IndexError and AttributeError exception is caught,
continue	skip this loop iteration,
transfer_encoding = meta_data . get ( 'content-transfer-encoding' )	get the value under the 'content-transfer-encoding' key of the disposition meta_data, substitute it for transfer_encoding.
if transfer_encoding is not None :	if transfer_encoding is not None,
transfer_encoding = transfer_encoding [ 0 ] . strip ( )	strip of the whitespaces first element of transfer_encoding, substitute the result for transfer_encoding.
field_name = force_text ( field_name , encoding , errors = 'replace' )	call the function force_text with 3 arguments: field_name, encoding and errors as a string 'replace', substitute the result for field_name.
if item_type == FIELD :	if item_type equals FIELD,
  if transfer_encoding == 'base64' :	if transfer_encoding equals a string 'base64',
    raw_data = field_stream . read ( )	call the method field_stream.read, substitute the result for raw_data.
try :	try,
        data = base64 . b64decode ( raw_data )	call the function base64.b64decode with an argument raw_data, substitute the result for data.
except _BASE64_DECODE_ERROR :	if _BASE64_DECODE_ERROR exception is caught,
        data = raw_data	substitute raw_data for data.
else :	if not,
    data = field_stream . read ( )	call the method field_stream.read, substitute the result for data.
self . _post . appendlist ( field_name ,  force_text ( data , encoding , errors = 'replace' ) )	call the method self._post.appendlist with 2 arguments: field_name and result of the function force_text called with 3 arguments:
elif item_type == FILE :	data, encoding and errors as a string 'replace'.   otherwise if item_type equals FILE,
  file_name = disposition . get ( 'filename' )	get the value under the 'filename' key of the disposition dictionary, substitute it for file_name.
if not file_name :	if file_name is false,
    continue	skip this loop execution.
file_name = force_text ( file_name , encoding , errors = 'replace' )	call the function force_text with 3 arguments: file_name, encoding and errors set to string 'replace',
file_name = self . IE_sanitize ( unescape_entities ( file_name ) )	substitute the result for file_name.   call the function unescape_entities with an argument file_name, use the result as an argument for the call to the self.IE_sanitize,
content_type , content_type_extra = meta_data . get ( 'content-type' , ( '' , { } ) )	method, substitute the result for file_name.   get the value under the 'content-type' of the meta_data dictionary, if it exists assign it to content_type, content_type_extra,
content_type = content_type . strip ( )	if not, content_type is an empty string and content_type_extra is an empty dictionary.   strip the content_type of the whitespaces, substitute it for content_type.
charset = content_type_extra . get ( 'charset' )	get the value under the 'charset' key of the content_type_extra dictionary, substitute it for charset.
try :	try,
    content_length = int ( meta_data . get ( 'content-length' ) [ 0 ] )	convert to an integer first element of the value under the 'content-length' key of the meta_data dictionary, substitute it for content_length.
except ( IndexError , TypeError , ValueError ) :	if IndexError, TypeError or ValueError exception is caught,
    content_length = None	content_length is None.
counters = [ 0 ] * len ( handlers )	counters is a list containing length of handlers number of zeros.
try :	try,
    for handler in handlers :	for every handler in handlers,
        try :	try,
            handler . new_file ( field_name , file_name ,  content_type , content_length ,  charset , content_type_extra )	call the method handler.new_file with 6 arguments: field_name, file_name, content_type, content_length, charset and  content_type_extra.
except StopFutureHandlers :	if StopFutureHandlers exception is caught.
            break	break the loop execution.
for chunk in field_stream :	for every chunk in field_stream,
        if transfer_encoding == 'base64' :	if transfer_encoding equals string 'base64',
              over_bytes = len ( chunk ) % 4	calculate length of chunk modulo integer 4, substitute the result for over_bytes.
if over_bytes :	if over_bytes is true,
                over_chunk = field_stream . read ( 4 - over_bytes )	call the method field_stream.read with an argument: over_bytes subtracted from integer 4, substitute the result for over_chunk.
chunk += over_chunk	increment chunk by over_chunk.
try :	try,
                chunk = base64 . b64decode ( chunk )	call the method base64.b64decode with an argument chunk, substitute the result for chunk.
except Exception as e :	if Exception, renamed to e, exception is caught,
                  msg = 'Could not decode base64 data: %r' % e	msg is a string 'Could not decode base64 data: %r', where '%r' is replace with e.
six . reraise ( MultiPartParserError , MultiPartParserError ( msg ) , sys . exc_info ( ) [ 2 ] )	call the method six.reraise with 3 arguments: MultiPartParserError, MultiPartParserError created with msg,
for i , handler in enumerate ( handlers ) :	and third element of the result of the function sys.exc_info.   for every i and handler in enumerated iterable handlers,
            chunk_length = len ( chunk )	substitute length of chunk for chunk_length.
chunk = handler . receive_data_chunk ( chunk ,  counters [ i ] )	call the method handler.receive_data_chunk with 2 arguments: chunk and i-th element of counters, substitute the result for chunk.
counters [ i ] += chunk_length	increment i-th element of counters by chunk_length.
if chunk is None :	if chunk is None,
                  break	break the loop execution.
except SkipFile :	if SkipFile exception is caught,
    self . _close_files ( )	call the method self._close_files.
exhaust ( field_stream )	call the function exhaust with an argument field_stream.
else :	if not,
      old_field_name = field_name	substitute field_name for old_field_name.
else :	if not,
  exhaust ( stream )	call the function exhaust with an argument stream.
except StopUpload as e :	if StopUpload, renamed to e, exception is caught,
self . _close_files ( )	call the method self._close_files.
if not e . connection_reset :	if e.connection_reset is false,
exhaust ( self . _input_data )	call the function exhaust with an argument self._input_data.
else :	if not,
exhaust ( self . _input_data )	call the function exhaust with an argument self._input_data.
for handler in handlers :	for every handler in handlers,
retval = handler . upload_complete ( )	call the method handler.upload_complete, substitute the result for retval.
if retval :	if retval is true,
break	break the loop execution.
return self . _post , self . _files	return self._post and self._files.
def handle_file_complete ( self , old_field_name , counters ) :	define the method handle_file_complete with 3 arguments: self, old_field_name and counters.
for i , handler in enumerate ( self . _upload_handlers ) :	for every i and handler in enumerated iterator self._upload_handlers,
file_obj = handler . file_complete ( counters [ i ] )	call the method handler.file_complete with i-th element of counters as an argument, substitute the result for file_obj.
if file_obj :	if file_obj is true,
self . _files . appendlist (  force_text ( old_field_name , self . _encoding , errors = 'replace' ) ,  file_obj )	call the function force_text with 3 arguments: old_field_name, self._encoding and errors as a string 'replace',
break	use the result and file_obj as arguments for the call to the method self._files.appendlist.   break the loop execution.
def IE_sanitize ( self , filename ) :	define the method IE_sanitize with arguments self and filename.
\return filename and filename [ filename . rfind ( '\\\\' ) + 1 : ] . strip ( )\	\call the method filename.rfind with an argument string '\\\\', increment the result by one,\
def _close_files ( self ) :	slice the filename from the previous result as start index to the end, strip it of white spaces from both ends,   if the result is not an empty string and filename is not an empty string, return boolean True, otherwise return boolean False.   define the method _close_files with an argument self.
for handler in self . _upload_handlers :	for every handler in self._upload_handlers,
if hasattr ( handler , 'file' ) :	if handler has an attribute 'file',
handler . file . close ( )	call the method handler.file.close.
class LazyStream ( six . Iterator ) :	derive the class LazyStream from the six.Iterator base class.
def __init__ ( self , producer , length = None ) :	define the method __init__ with 3 arguments: self, producer and length set to None.
self . _producer = producer	substitute producer for self._producer.
self . _empty = False	self._empty is boolean False.
self . _leftover = b''	self._leftover is an empty string.
self . length = length	substitute length for self._length.
self . position = 0	self.position is an integer 0.
self . _remaining = length	substitute length for self._remaining.
self . _unget_history = [ ]	self._unget_history is an empty list.
def tell ( self ) :	define the method tell with an argument self.
return self . position	  return self.position.
def read ( self , size = None ) :	define the method read with arguments self and size set to None.
def parts ( ) :	define the function parts.
remaining = self . _remaining if size is None else size	if size is None substitute self._remaining for remaining, if not, substitute size for remaining.
if remaining is None :	if remaining is None,
yield b'' . join ( self )	join self into a bytes string, yield the result as the return value of the generator.
return	return nothing.
while remaining != 0 :	while remaining is not equal to integer 0,
assert remaining > 0 , 'remaining bytes to read should never go negative'	if remaining is not greater than 0, assert an error with the message string 'remaining bytes to read should never go negative'.
chunk = next ( self )	get the next element of iterable self, substitute it for chunk.
emitting = chunk [ : remaining ]	create list of first remaining elements of chunk, substitute it for emitting.
self . unget ( chunk [ remaining : ] )	call the method self.unget with list containing first remaining elements of chunk as an argument.
remaining -= len ( emitting )	decrement remaining by length of emitting.
yield emitting	yield emitting as result of the generator.
out = b'' . join ( parts ( ) )	join result of the parts function into a bytes string, substitute it for out.
return out	return out.
def __next__ ( self ) :	define the method __next__ with an argument self.
if self . _leftover :	if self._leftover is true,
output = self . _leftover	substitute self._leftover for output.
self . _leftover = b''	self._leftover is an empty string.
else :	if not,
output = next ( self . _producer )	get the next element of the self._producer iterable, substitute it for output.
self . _unget_history = [ ]	self._unget_history is an empty list.
self . position += len ( output )	increment self.position by length of output.
return output	return output.
def close ( self ) :	define the method close with an argument self.
self . _producer = [ ]	self._producer is an empty list.
def __iter__ ( self ) :	define the method _iter with an argument self.
return self	return self.
def unget ( self , bytes ) :	define the method unget with arguments self and bytes.
if not bytes :	if bytes is false,
return	return nothing.
self . _update_unget_history ( len ( bytes ) )	call the method self._update_unget_history with length of bytes as an argument.
self . position -= len ( bytes )	decrement self.position by length of bytes.
self . _leftover = b'' . join ( [ bytes , self . _leftover ] )	join bytes and self._leftover into a bytes string, substitute it for self._leftover.
def _update_unget_history ( self , num_bytes ) :	define the method _update_unget_history with arguments self and num_bytes.
self . _unget_history = [ num_bytes ] + self . _unget_history [ : 49 ]	append first 49 elements of self._unget_history to list containing num_bytes, substitute the result for self._unget_history.
number_equal = len ( [ current_number for current_number in self . _unget_history  if current_number == num_bytes ] )	append current_number to a list for current_number in self._unget_history, if current_number is equal to num_bytes,
if number_equal > 40 :	substitute the length of the resulting list for number_equal.   if number_equal is greater than integer 40,
raise SuspiciousMultipartForm (  'The multipart parser got stuck, which shouldn't happen with'  ' normal uploaded files. Check for malicious upload activity;'  ' if there is none, report this to the Django developers.'  )	raise SuspiciousMultipartForm exception with an argument string, 'The multipart parser got stuck, which shouldn't happen with'
class ChunkIter ( six . Iterator ) :	 normal uploaded files. Check for malicious upload activity; if there is none, report this to the Django developers..   derive the class ChunkIter from the six.Iterator base class.
def __init__ ( self , flo , chunk_size = 64 * 1024 ) :	define the method __init__ with arguments self, flo and chunk_size set to integer 64 multiplied by integer 1024.
self . flo = flo	substitute flo for self.flo.
self . chunk_size = chunk_size	substitute chunk_size for self.chunk_size.
def __next__ ( self ) :	define the method __next__ with an argument self.
try :	try,
data = self . flo . read ( self . chunk_size )	call the method self.flo.read with an argument self.chunk_size, substitute the result for data.
except InputStreamExhausted :	if InputStreamExhausted exception is caught,
raise StopIteration ( )	raise an StopIteration exception.
if data :	if data is true,
return data	return data.
else :	if not,
raise StopIteration ( )	raise an StopIteration exception.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
return self	return self.
class InterBoundaryIter ( six . Iterator ) :	derive the class InterBoundaryIter from the six.Iterator base class.
def __init__ ( self , stream , boundary ) :	define the method __init__ with arguments self, stream and boundary.
self . _stream = stream	substitute stream for self._stream.
self . _boundary = boundary	substitute boundary for self.boundary.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
return self	return self.
def __next__ ( self ) :	define the method __next__ with an argument self.
try :	try,
return LazyStream ( BoundaryIter ( self . _stream , self . _boundary ) )	instantiate class BoundaryIter with 2 arguments: self._stream and self._boundary, use it to instantiate LazyStream class, return it.
except InputStreamExhausted :	if InputStreamExhausted exception is caught,
raise StopIteration ( )	raise an StopIteration.
class BoundaryIter ( six . Iterator ) :	derive the class BoundaryIter from the six.Iterator base class.
def __init__ ( self , stream , boundary ) :	define the method __init__ with arguments self, stream and boundary.
self . _stream = stream	substitute stream for self._stream.
self . _boundary = boundary	substitute boundary for self._boundary.
self . _done = False	self._done is boolean False.
self . _rollback = len ( boundary ) + 6	increment length of boundary by integer 6, substitute the result for self._rollback.
unused_char = self . _stream . read ( 1 )	call the method self._stream.read with an argument integer 1, substitute the result for unused_char.
if not unused_char :	if unused_char is false,
raise InputStreamExhausted ( )	raise an InputStreamExhausted exception,
self . _stream . unget ( unused_char )	call the method self._stream.unget with an argument unused_char.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
return self	return self.
def __next__ ( self ) :	define the method __next__ with an argument self.
if self . _done :	if self._done is true,
raise StopIteration ( )	raise an StopIteration exception,
stream = self . _stream	substitute self._stream for stream.
rollback = self . _rollback	substitute self._rollback for rollback.
bytes_read = 0	bytes_read is integer 0.
chunks = [ ]	chunks is an empty list.
for bytes in stream :	for every bytes in stream,
bytes_read += len ( bytes )	increment bytes_read by length of bytes.
chunks . append ( bytes )	append bytes to chunks.
if bytes_read > rollback :	if bytes_read is greater than rollback,
break	break the loop execution.
if not bytes :	if bytes is false,
break	break the loop execution.
else :	if not,
self . _done = True	self._done is boolean True.
if not chunks :	if chunks is false,
raise StopIteration ( )	raise an StopIteration exception.
chunk = b'' . join ( chunks )	join chunks into bytes string, substitute it for chunk.
boundary = self . _find_boundary ( chunk , len ( chunk ) < self . _rollback )	call the method self._find_boundary with 2 arguments: chunk and boolean if length of chunks is lesser than self._rollback,
if boundary :	or boolean False if not, substitute the result for boundary.   if boundary is true,
end , next = boundary	substitute elements of tuple boundary to end and next, respectively.
stream . unget ( chunk [ next : ] )	call the method stream.unget with elements of list chunk from the index next to the end.
self . _done = True	self._done is boolean True.
return chunk [ : end ]	return first end elements of list chunk.
else :	if not,
if not chunk [ : - rollback ] :	slice chunk list to get the last rollback elements, if the new list is not empty,
self . _done = True	self._done is boolean True.
return chunk	return chunk.
else :	if not,
stream . unget ( chunk [ - rollback : ] )	call the method stream.unget with last rollback elements of chunk as an argument.
return chunk [ : - rollback ]	return last rollback elements of chunk.
def _find_boundary ( self , data , eof = False ) :	define the method _find_boundary with an arguments self, data and eof set to boolean False.
index = data . find ( self . _boundary )	call the method data.find with an argument self._boundary, substitute the result for index.
if index < 0 :	if index is lesser than integer 0,
return None	return None.
else :	if not,
end = index	substitute index for end.
next = index + len ( self . _boundary )	sum index and length of self._boundary, substitute the result for next.
last = max ( 0 , end - 1 )	substitute greater element between integer 0 and end decremented by one for last.
\if data [ last : last + 1 ] == b'\\n' :\	element of data at the index last equals to newline bytes character.
end -= 1	decrement end by one.
last = max ( 0 , end - 1 )	substitute greater element between integer 0 and end decremented by one for last.
\if data [ last : last + 1 ] == b'\\r' :\	element of data at the index last equals to carriage return bytes character.
end -= 1	decrement end by one.
return end , next	return end ans next.
def exhaust ( stream_or_iterable ) :	define the function exhaust with an argument stream_or_iterable.
iterator = None	iterator is None.
try :	try,
iterator = iter ( stream_or_iterable )	iterator is iterator created out of stream_or_iterable.
except TypeError :	if TypeError exception is caught,
iterator = ChunkIter ( stream_or_iterable , 16384 )	iterator is an instance of ChunkIter class, created with arguments: stream_or_iterable and integer 16384.
if iterator is None :	if iterator is None,
raise MultiPartParserError ( 'multipartparser.exhaust() was passed a non-iterable or stream parameter' )	raise an MultiPartParserError with an argument string 'multipartparser.exhaust() was passed a non-iterable or stream parameter'.
for __ in iterator :	for every __ in iterator,
pass	do nothing.
def parse_boundary_stream ( stream , max_header_size ) :	define the function parse_boundary_stream with arguments stream and max_header_size.
chunk = stream . read ( max_header_size )	call the method stream.read with an argument max_header_size, substitute the result for chunk.
\header_end = chunk . find ( b'\\r\\n\\r\\n' )\	\call the method chunk.find with an argument bytes string '\\r\\n\\r\\n', substitute the result for header_end.\
def _parse_header ( line ) :	define the method _parse_header with an argument line.
main_value_pair , params = parse_header ( line )	call the function parse_header with an argument line, substitute the result for main_value_pair and params, respectively.
try :	try,
name , value = main_value_pair . split ( ':' , 1 )	split into two parts string main_value_pair at character ':', substitute the parts for name and value, respectively.
except ValueError :	if ValueError exception is caught,
raise ValueError ( 'Invalid header: %r' % line )	raise an ValueError with an argument string 'Invalid header: %r', where '%s' is replaced with line.
return name , ( value , params )	return name and tuple containing 2 elements value and params.
if header_end == - 1 :	if header_end equals integer negative 1,
stream . unget ( chunk )	call the method stream.unget with an argument chunk.
return ( RAW , { } , stream )	return tuple containing 3 elements: RAW, an empty dictionary and stream.
header = chunk [ : header_end ]	substitute first header_end elements of chunk list for header.
stream . unget ( chunk [ header_end + 4 : ] )	call the method stream.unget with list containing elements of chunk list from the header_end incremented by integer 4 as a start index to the end as argument.
TYPE = RAW	substitute RAW for TYPE.
outdict = { }	outdict is an empty dictionary.
\for line in header . split ( b'\\r\\n' ) :\	\split header string at string '\\r\\n', for every line in result,\
try :	try,
name , ( value , params ) = _parse_header ( line )	call the method _parse_header with an argument line, assign the result to name and tuple with 2 elements: value and params, respectively.
except ValueError :	if ValueError exception is caught,
continue	skip this loop iteration.
if name == 'content-disposition' :	if name equals a string 'content-disposition',
TYPE = FIELD	substitute FIELD for TYPE,
if params . get ( 'filename' ) :	get the value under the 'filename' key of the params dictionary, if it is true,
TYPE = FILE	substitute FILE for TYPE.
outdict [ name ] = value , params	assign value and params to the value under the name key of the outdict dictionary.
if TYPE == RAW :	if TYPE equals to RAW,
stream . unget ( chunk )	call the method stream.unget with an argument chunk.
return ( TYPE , outdict , stream )	return a tuple with 3 elements: TYPE, outdict and stream.
class Parser ( object ) :	derive the class Parser from the base class object.
def __init__ ( self , stream , boundary ) :	define the method __init__ with arguments self, stream and boundary.
self . _stream = stream	substitute stream for self._stream.
self . _separator = b'--' + boundary	append boundary to bytes string '--', substitute the result for self._separator.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
boundarystream = InterBoundaryIter ( self . _stream , self . _separator )	boundarystream is an instance of InterBoundaryIter class, created with self._stream and self._separator as arguments.
for sub_stream in boundarystream :	for every sub_stream in boundarystream,
yield parse_boundary_stream ( sub_stream , 1024 )	call the function parse_boundary_stream with 2 arguments: sub_stream and integer 1024, yield the result as the return value of the generator.
def parse_header ( line ) :	define the function parse_header with an argument line.
plist = _parse_header_params ( b';' + line )	append line to bytes string ';', use it as an argument for the call to the function _parse_header_params, substitute the result for plist.
key = plist . pop ( 0 ) . lower ( ) . decode ( 'ascii' )	pop the first element from plist, convert it to lowercase, call the method decode on it, with string 'ascii' as an argument,
pdict = { }	substitute the result for key.   pdict is an empty dictionary.
for p in plist :	for every p in plist,
i = p . find ( b'=' )	call the method p.find with bytes string '=' as an argument, substitute the result for i.
if i >= 0 :	if i is greater or equal to integer 0,
name = p [ : i ] . strip ( ) . lower ( ) . decode ( 'ascii' )	take the first i elements of string p, strip the whitespaces from the both sides, convert it to lowercase and apply on it the method,
value = p [ i + 1 : ] . strip ( )	decode with an argument string 'ascii', substitute the result for name.   take elements of p from index i incremented by 1 to the end, strip the result of the whitespaces, substitute it for value.
value = value [ 1 : - 1 ]	strip value of the first and last element.
pdict [ name ] = value	substitute value for the vale under the name key of the pdict dictionary.
return key , pdict	return key and pdict.
def _parse_header_params ( s ) :	define the function _parse_header_params with an argument s.
plist = [ ]	plist is an empty list.
while s [ : 1 ] == b';' :	while first element of s is equal to bytes string ';',
s = s [ 1 : ]	substitute s without the first element for s.
end = s . find ( b';' )	call the method s.find with an argument bytes string ';', substitute the result for end.
end = s . find ( b';' , end + 1 )	is an even number,   call the method s.find with 2 arguments: bytes string ';' and end incremented by one, substitute the result for end.
if end < 0 :	if end is lesser than integer 0,
end = len ( s )	substitute length of s for end.
f = s [ : end ]	substitute first end elements of s for f.
plist . append ( f . strip ( ) )	strip f of whitespaces and append it to plist.
s = s [ end : ]	substitute elements of s from the end index to end for s.
return plist	return plist.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import copy	import module copy.
import os	import module os.
import re	import module re.
import sys	import module sys.
from io import BytesIO	from io import BytesIO into default name space.
from itertools import chain	from itertools import chain into default name space.
from pprint import pformat	from pprint import pformat into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . core import signing	from django.core import signing into default name space.
from django . core . exceptions import DisallowedHost , ImproperlyConfigured	from django.core.exceptions import DisallowedHost and ImproperlyConfigured into default name space.
from django . core . files import uploadhandler	from django.core.files import uploadhandler into default name space.
from django . http . multipartparser import MultiPartParser , MultiPartParserError	from django.http.multipartparser import MultiPartParser and MultiPartParserError into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . datastructures import MultiValueDict , ImmutableList	from django.utils.datastructures import MultiValueDict and ImmutableList into default name space.
from django . utils . encoding import force_bytes , force_text , force_str , iri_to_uri	from django.utils.encoding import force_bytes,  force_text,  force_str and iri_to_uri into default name space.
from django . utils . six . moves . urllib . parse import parse_qsl , urlencode , quote , urljoin , urlsplit	from django.utils.six.moves.urllib.parse import parse_qsl,  urlencode,  quote,  urljoin and urlsplit into default name space.
RAISE_ERROR = object ( )	RAISE_ERROR is an instance of object class.
absolute_http_url_re = re . compile ( r'^https?://' , re . I )	compile the regex '^https?://' with an argument re.I, substitute it for absolute_http_url_re.
\host_validation_re = re . compile ( r'^([a-z0-9.-]+|\\[[a-f0-9]*:[a-f0-9:]+\\])(:\\d+)?$' )\	\compile the regex '^([a-z0-9.-]+|\\[[a-f0-9]*:[a-f0-9:]+\\])(:\\d+)?$', substitute it for host_validation_re.\
class UnreadablePostError ( IOError ) :	derive the class UnreadablePostError from the base class IOError.
pass	do nothing.
class RawPostDataException ( Exception ) :	derive the class RawPostDataException from the base class Exception.
pass	do nothing.
class HttpRequest ( object ) :	derive the class HttpRequest from the object base class.
_encoding = None	_encoding is None.
_upload_handlers = [ ]	_upload_handlers is an empty list.
def __init__ ( self ) :	define the method __init__ with an argument self.
self . GET = QueryDict ( mutable = True )	self.GET is an instance of QueryDict class created with an argument mutable set to boolean True.
self . POST = QueryDict ( mutable = True )	self.POST is an instance of QueryDict class created with an argument mutable set to boolean True.
self . COOKIES = { }	self.COOKIES is an empty dictionary.
self . META = { }	self.META is an empty dictionary.
self . FILES = MultiValueDict ( )	self.FILES is an instance of MultiValueDict class.
self . path = ''	self.path is an empty string.
self . path_info = ''	self.path_info is an empty string.
self . method = None	self.method is None.
self . resolver_match = None	self.resolver_match is None.
self . _post_parse_error = False	self._post_parse_error is boolen False.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return build_request_repr ( self )	call the method build_request_repr with an argument self, return the result.
def get_host ( self ) :	define the method get_host with an argument self.
if settings . USE_X_FORWARDED_HOST and (  'HTTP_X_FORWARDED_HOST' in self . META ) :	if settings.USE_X_FORWARDED_HOST is true and 'HTTP_X_FORWARDED_HOST' is contained in self.META.
host = self . META [ 'HTTP_X_FORWARDED_HOST' ]	get the value under the 'HTTP_X_FORWARDED_HOST' key of the self.META dictionary, substitute the result for host.
elif 'HTTP_HOST' in self . META :	if 'HTTP_HOST' is contained in self.META,
host = self . META [ 'HTTP_HOST' ]	substitute the value under the 'HTTP_HOST' key of the self.META dictionary, substitute it for host.
else :	if not,
host = self . META [ 'SERVER_NAME' ]	substitute the value under the 'SERVER_NAME' key of the self.META dictionary, substitute it for host.
server_port = str ( self . META [ 'SERVER_PORT' ] )	convert the value under the 'SERVER_NAME' key of the self.META dictionary to a string, substitute result for server_port.
if server_port != ( '443' if self . is_secure ( ) else '80' ) :	if return value of the self.is_secure method is true and server_port is not equal to string '443',
host = '%s:%s' % ( host , server_port )	if return value of the self.is_secure is false and server port is not equal to string '80',   join host and server_port into a string, separated with ':', substitute the result for host.
if settings . DEBUG :	if settings.DEBUG is true,
return host	return host.
domain , port = split_domain_port ( host )	call the function split_domain_port with an argument host, assign the result to domain and port, respectively.
if domain and validate_host ( domain , settings . ALLOWED_HOSTS ) :	if domain is true and return value of the function validate_host called with 2 arguments: domain and settings.ALLOWED_HOSTS, evaluates to true,
return host	return host.
else :	if not,
msg = 'Invalid HTTP_HOST header: %r.' % host	msg is a string 'Invalid HTTP_HOST header: %r.', replace '%r' with host.
if domain :	if domain is true,
msg += ' You may need to add %r to ALLOWED_HOSTS.' % domain	append string ' You may need to add %r to ALLOWED_HOSTS.' to msg, where '%s' is replaced with domain.
else :	if not,
msg += ' The domain name provided is not valid according to RFC 1034/1035.'	append string ' The domain name provided is not valid according to RFC 1034/1035.' to msg.
raise DisallowedHost ( msg )	raise an DisallowedHost exception with an argument msg.
def get_full_path ( self ) :	define the method get_full_path with an argument self.
return '%s%s' % ( self . path , ( '?' + iri_to_uri ( self . META . get ( 'QUERY_STRING' , '' ) ) ) if self . META . get ( 'QUERY_STRING' , '' ) else '' )	if the value under the 'QUERY_STRING' key of the self.META dictionary is true, call the function iri_to_uri,
def get_signed_cookie ( self , key , default = RAISE_ERROR , salt = '' , max_age = None ) :	called with value under the 'QUERY_STRING' key of the self.META dictionary and append it to string '?',   append the result th the self.path converted into a string and return it,   if the value under the 'QUERY_STRING' key of the self.META dictionary is false, return self.path converted into a string.   def the method get_signed_cookie with 5 arguments: self, key, default set to RAISE_ERROR, salt as an empty string,
try :	try,
cookie_value = self . COOKIES [ key ]	substitute value under the key key of the self.COOKIES dictionary, substitute it for cookie_value.
except KeyError :	if KeyError exception is caught,
if default is not RAISE_ERROR :	if default is true and RAISE_ERROR is false,
return default	return default.
else :	if not,
raise	raise an exception.
try :	try,
value = signing . get_cookie_signer ( salt = key + salt ) . unsign (  cookie_value , max_age = max_age )	call the method signing.get_cookie_signer with an argument salt set to sum of key and salt, call the method unsign on the result,
except signing . BadSignature :	with arguments cookie_value and max_age set to max_age.   if signing.BadSignature exception is caught,
if default is not RAISE_ERROR :	if default is true and RAISE_ERROR is false,
return default	return default.
else :	if not,
raise	raise an exception.
return value	return value.
def build_absolute_uri ( self , location = None ) :	define the method build_absolute_uri with an arguments self and location set to None.
if location is None :	if location is None,
location = '//%s' % self . get_full_path ( )	call the method self.get_full_path, append the result to string '//', substitute it for location.
bits = urlsplit ( location )	call the function urlsplit with an argument location, substitute the result for bits.
if not ( bits . scheme and bits . netloc ) :	do not perform the following only if bits.scheme and bits.netloc are both true,
current_uri = '{scheme}://{host}{path}' . format ( scheme = self . scheme ,  host = self . get_host ( ) ,  path = self . path )	format the string '{scheme}://{host}{path}' by replacing scheme with self.scheme, host with return value of the self.get_host method,
location = urljoin ( current_uri , location )	and path with self.path, substitute the result for current_uri.   call the function urljoin with arguments current_uri and location, substitute the result for location.
return iri_to_uri ( location )	call the function iri_to_uri with an argument location, return the result.
def _get_scheme ( self ) :	define the method _get_scheme with an argument self.
return 'https' if os . environ . get ( 'HTTPS' ) == 'on' else 'http'	return string 'https' if value under the 'HTTPS' key of the os.environ dictionary equals string 'on', if not return 'http'.
@ property	property decorator.
def scheme ( self ) :	define the method scheme with an argument self.
if settings . SECURE_PROXY_SSL_HEADER :	if settings.SECURE_PROXY_SSL_HEADER is true,
try :	try,
header , value = settings . SECURE_PROXY_SSL_HEADER	assign the settings.SECURE_PROXY_SSL_HEADER to header and value, respectively.
except ValueError :	if ValueError exception is caught,
raise ImproperlyConfigured ( 'The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values.' )	raise an ImproperlyConfigured exception with an argument string 'The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values.'.
if self . META . get ( header , None ) == value :	if value under the header key of the self.META dictionary is equal to value,
return 'https'	return string 'https'.
return self . _get_scheme ( )	call the method self._get_scheme, return the result.
def is_secure ( self ) :	define the method is_secure with an argument self.
return self . scheme == 'https'	if self.scheme equals to string 'https', return boolean True, otherwise return boolean False.
def is_ajax ( self ) :	define the method is_ajax with an argument self.
return self . META . get ( 'HTTP_X_REQUESTED_WITH' ) == 'XMLHttpRequest'	get the value under the 'HTTP_X_REQUESTED_WITH' key of the self.META dictionary, if it equals string 'XMLHttpRequest',
@ property	return boolean True, otherwise return boolean False.   property decorator.
def encoding ( self ) :	define the method encoding with an argument self.
return self . _encoding	return self._encoding.
@ encoding . setter	encoding.setter decorator,
def encoding ( self , val ) :	define the method encoding with arguments self and val.
self . _encoding = val	substitute val for self._encoding.
if hasattr ( self , '_get' ) :	if self has an '_get' attribute,
del self . _get	delete self._get.
if hasattr ( self , '_post' ) :	if self has an '_post' attribute,
del self . _post	del self._post
def _initialize_handlers ( self ) :	define the method _initialize_handlers with an argument self.
self . _upload_handlers = [ uploadhandler . load_handler ( handler , self )  for handler in settings . FILE_UPLOAD_HANDLERS ]	for every handler in settings.FILE_UPLOAD_HANDLERS,
@ property	add to a list result of the method uploadhandler.load_handler called with arguments handler and self,   substitute resulting list for self._upload_handlers.   property decorator,
def upload_handlers ( self ) :	define the method upload_handlers with an argument self.
if not self . _upload_handlers :	if self._upload_handlers is false,
self . _initialize_handlers ( )	call the method self._initialize_handlers,
return self . _upload_handlers	return self._upload_handlers.
@ upload_handlers . setter	upload_handlers.setter decorator.
def upload_handlers ( self , upload_handlers ) :	define the method upload_handlers with arguments: self and upload_handlers.
if hasattr ( self , '_files' ) :	if self has an '_files' attribute.
raise AttributeError ( 'You cannot set the upload handlers after the upload has been processed.' )	raise an AttributeError exception with an argument string 'You cannot set the upload handlers after the upload has been processed.'.
self . _upload_handlers = upload_handlers	substitute upload_handlers for self._upload_handlers.
def parse_file_upload ( self , META , post_data ) :	define the method parse_file_upload with 3 arguments: self, META and post_data.
self . upload_handlers = ImmutableList (  self . upload_handlers ,  warning = 'You cannot alter upload handlers after the upload has been processed.'  )	self.upload_handlers is an instance of ImmutableList, created with 2 arguments: self.upload_handlers,
parser = MultiPartParser ( META , post_data , self . upload_handlers , self . encoding )	and warning as a string 'You cannot alter upload handlers after the upload has been processed.'.   parser is an instance of MultiPartParser class, created with 4 arguments: META, post_data, self.upload_handlers and self.encoding.
return parser . parse ( )	call the method parser.parse, return the result.
@ property	property decorator,
def body ( self ) :	define the method body with an argument self.
if not hasattr ( self , '_body' ) :	if self doesnt have an '_body' attribute,
if self . _read_started :	if self._read_started is true,
raise RawPostDataException ( 'You cannot access body after reading from request's data stream' )	raise an RawPostDataException exception with an argument string 'You cannot access body after reading from request's data stream'.
try :	try,
self . _body = self . read ( )	call the method self.read, substitute the result or self._body.
except IOError as e :	if IOError, renamed to e, exception is caught,
six . reraise ( UnreadablePostError , UnreadablePostError ( * e . args ) , sys . exc_info ( ) [ 2 ] )	call the function six.reraise with 3 arguments: UnreadablePostError, UnreadablePostError instantiated with unpacked list e.args,
self . _stream = BytesIO ( self . _body )	third element of the result of the function sys.exc_info.   self._stream is an instance of BytesIO class created with an argument self._body.
return self . _body	return self._body.
def _mark_post_parse_error ( self ) :	define the method_mark_post_parse_error with an argument self.
self . _post = QueryDict ( '' )	self._post is an instance of QueryDict class created with an empty string as argument.
self . _files = MultiValueDict ( )	self._files is an instance of MultiValueDict class.
self . _post_parse_error = True	self._post_parse_error is boolean True.
def _load_post_and_files ( self ) :	define the method _load_post_and_files with an argument self.
if self . method != 'POST' :	if self.method is not equal to string 'POST',
self . _post , self . _files = QueryDict ( '' , encoding = self . _encoding ) , MultiValueDict ( )	self._post is an instance of QueryDict created with arguments: an empty string and encoding set to self._encoding,
return	self._files is an instance of class MultiValueDict.   return nothing.
if self . _read_started and not hasattr ( self , '_body' ) :	if self._read_started is true and self doesnt have an '_body' attribute.
self . _mark_post_parse_error ( )	call the method self._mark_post_parse_error.
return	return nothing.
if self . META . get ( 'CONTENT_TYPE' , '' ) . startswith ( 'multipart/form-data' ) :	get the value under the 'CONTENT_TYPE' key of the self.META dictionary, if it starts with a string 'multipart/form-data',
if hasattr ( self , '_body' ) :	if self has an attribute '_body',
data = BytesIO ( self . _body )	data is an instance of BytesIO class, created with an argument: self._body.
else :	if not,
data = self	substitute self for data.
try :	try,
self . _post , self . _files = self . parse_file_upload ( self . META , data )	call the method self.parse_file_upload with arguments self.META and data, assign the result to self._post and self._files.
except MultiPartParserError :	if MultiPartParserError exception is caught,
    self . _mark_post_parse_error ( )	call the method self._mark_post_parse_error.
raise	raise an exception.
elif self . META . get ( 'CONTENT_TYPE' , '' ) . startswith ( 'application/x-www-form-urlencoded' ) :	otherwise if value under the 'CONTENT_TYPE' key of hte self.META dictionary starts with 'application/x-www-form-urlencoded',
self . _post , self . _files = QueryDict ( self . body , encoding = self . _encoding ) , MultiValueDict ( )	self._post is an instance of QueryDict created with arguments: self.body and encoding set to self._encoding,
else :	self._files is an instance of class MultiValueDict.   if not,
self . _post , self . _files = QueryDict ( '' , encoding = self . _encoding ) , MultiValueDict ( )	self._post is an instance of QueryDict created with arguments: an empty string and encoding set to self._encoding,
def close ( self ) :	self._files is an instance of class MultiValueDict.   define the method close with an argument self.
if hasattr ( self , '_files' ) :	if self has an attribute '_files',
for f in chain . from_iterable ( l [ 1 ] for l in self . _files . lists ( ) ) :	for every f in return value of the return value of the method chain.from_iterable called with argument:
f . close ( )	second element of l for every l in return value of the self._files.lists   call the method f.close.
def read ( self , * args , ** kwargs ) :	define the method read with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
self . _read_started = True	self._read_started is True.
try :	try,
return self . _stream . read ( * args , ** kwargs )	call the method self._stream.read with 2 arguments: unpacked list args and unpacked dictionary kwargs.
except IOError as e :	if IOError, renamed to e, exception is caught,
six . reraise ( UnreadablePostError , UnreadablePostError ( * e . args ) , sys . exc_info ( ) [ 2 ] )	call the function six.reraise with 3 arguments: UnreadablePostError, UnreadablePostError instantiated with unpacked list e.args,
def readline ( self , * args , ** kwargs ) :	third element of the result of the function sys.exc_info.   define the method readline with 3 arguments: self, unpacked list args and unpacked list kwargs.
self . _read_started = True	self._read_started is boolean True.
try :	try,
return self . _stream . readline ( * args , ** kwargs )	call the method self._stream.readline with 2 arguments: unpacked list args, unpacked dictionary kwargs.
except IOError as e :	if IOError, substituted to e, exception is caught,
six . reraise ( UnreadablePostError , UnreadablePostError ( * e . args ) , sys . exc_info ( ) [ 2 ] )	call the function six.reraise with 3 arguments: UnreadablePostError, UnreadablePostError instantiated with unpacked list e.args,
def xreadlines ( self ) :	third element of the result of the function sys.exc_info.   define the method __init__ with an argument self.
while True :	endless loop,
buf = self . readline ( )	read one line from self file stream, substitute the result for buf.
if not buf :	if buf is false,
break	break the loop execution.
yield buf	yield buf as return value of the generator.
__iter__ = xreadlines	substitute xreadlines for __iter__.
def readlines ( self ) :	define the method __init__ with an argument self.
return list ( iter ( self ) )	append to a list elements of the iterator self, return the resulting list.
class QueryDict ( MultiValueDict ) :	derive the class QueryDict from the base class MultiValueDict.
_mutable = True	  _mutable is boolean True.
_encoding = None	_encoding is None.
def __init__ ( self , query_string = None , mutable = False , encoding = None ) :	define the method __init__ with 4 arguments: self, query_string is None, mutable is boolean False and encoding set to None.
super ( QueryDict , self ) . __init__ ( )	call the __init__ method of the base class of the QueryDict class.
if not encoding :	if encoding is false.
encoding = settings . DEFAULT_CHARSET	substitute settings.DEFAULT_CHARSET for encoding.
self . encoding = encoding	substitute encoding for self.encoding.
if six . PY3 :	if six.PY3 is true,
if isinstance ( query_string , bytes ) :	if query_string is an instance of bytes,
query_string = query_string . decode ( )	call the method query_string.decode, substitute the result for query_string.
for key , value in parse_qsl ( query_string or '' ,  keep_blank_values = True ,  encoding = encoding ) :	for every key and value in return value of the parse_qsl with 3 arguments: query_string is it exists or an empty string if not,
self . appendlist ( key , value )	keep_blank_values set to boolean True, encoding set to encoding.   call the method appendlist with 2 arguments: key and value.
else :	if not,
for key , value in parse_qsl ( query_string or '' ,  keep_blank_values = True ) :	for every key and value in parse_gsl with query_string is it exists or an empty string if not and keep_blank_values set to boolean True.
self . appendlist ( force_text ( key , encoding , errors = 'replace' ) ,  force_text ( value , encoding , errors = 'replace' ) )	call the method self.appendlist with 2 arguments: return value of the function force_text with 3 arguments:
self . _mutable = mutable	key, encoding and errors set to string 'replace', and return value of the function force_text with 3 arguments:   value, encoding and errors set to string 'replace'.   call the method mutable substitute for self._mutable.
@ property	property decorator,
def encoding ( self ) :	define the method encoding with an argument self.
if self . _encoding is None :	if self._encoding is None,
self . _encoding = settings . DEFAULT_CHARSET	substitute settings.DEFAULT_CHARSET for self._encoding.
return self . _encoding	return self._encoding.
@ encoding . setter	encoding.setter decorator,
def encoding ( self , value ) :	define the method encoding with arguments self and value.
self . _encoding = value	substitute value for self._encoding.
def _assert_mutable ( self ) :	define the method _assert_mutable with an argument self.
if not self . _mutable :	if not self._mutable,
raise AttributeError ( 'This QueryDict instance is immutable' )	raise an AttributeError with an argument string 'This QueryDict instance is immutable'.
def __setitem__ ( self , key , value ) :	define the method __setitem__ with 3 arguments: self, key and value.
self . _assert_mutable ( )	call the method self._assert_mutable.
key = bytes_to_text ( key , self . encoding )	call the method bytes_to_text with 2 arguments: key and self.encoding, substitute the result for key.
value = bytes_to_text ( value , self . encoding )	call the method bytes_to_text with 2 arguments: key and self.encoding, substitute the result for value.
super ( QueryDict , self ) . __setitem__ ( key , value )	call the method __setitem__ from the base class of the QueryDict class, with arguments key and value.
def __delitem__ ( self , key ) :	define the method __delitem__ with 3 arguments: self and key.
self . _assert_mutable ( )	call the method self._assert_mutable.
super ( QueryDict , self ) . __delitem__ ( key )	call the method __delitem__ from the base class of the QueryDict class, with an argument key.
def __copy__ ( self ) :	define the method __copy__ with an argument self.
result = self . __class__ ( '' , mutable = True , encoding = self . encoding )	call the method self.__class__ with 3 arguments: an empty string, mutable is boolean True, encoding is self.encoding, substitute the result for result.
for key , value in six . iterlists ( self ) :	for key and value in return value of the six.iterlists function called with an argument self,
result . setlist ( key , value )	call the method result.setlist with the arguments: key and value.
return result	return result.
def __deepcopy__ ( self , memo ) :	define the method __deepcopy__ with 3 arguments: self and memo.
result = self . __class__ ( '' , mutable = True , encoding = self . encoding )	call the method self.__class__ with 3 arguments: an empty string, mutable is boolean True, encoding is self.encoding, substitute the result for result.
memo [ id ( self ) ] = result	get the identity of the self object, use it as a key to get the value of the memo dictionary, substitute result for it.
for key , value in six . iterlists ( self ) :	for key and value in result of the function six.iterlists called with an argument,
result . setlist ( copy . deepcopy ( key , memo ) , copy . deepcopy ( value , memo ) )	call the method result.setlist with 2 arguments: return value of the function copy.deepcopy called with 2 arguments: key and memo,
return result	and return value of the function copy.deepcopy called with 2 arguments: value and memo.   return result.
def setlist ( self , key , list_ ) :	define the method setlist with 3 arguments: self, key and list_.
self . _assert_mutable ( )	call the method self._assert_mutable.
key = bytes_to_text ( key , self . encoding )	call the method bytes_to_text with an arguments key and self.encoding, substitute the result for key.
list_ = [ bytes_to_text ( elt , self . encoding ) for elt in list_ ]	for every elt in list_ call the method bytes_to_text with 2 argument: elt and self.encoding, append the result into a list,
super ( QueryDict , self ) . setlist ( key , list_ )	substitute the resulting list for list_.   call the method setlist from the base class of the QueryDict class, with arguments key and list_.
def setlistdefault ( self , key , default_list = None ) :	define the method setlistdefault with 3 arguments: self, key and default_list set to None.
self . _assert_mutable ( )	call the method self._assert_mutable.
return super ( QueryDict , self ) . setlistdefault ( key , default_list )	call the method setlistdefault from the base class of the class QueryDict, with arguments key and default_list, return the result.
def appendlist ( self , key , value ) :	define the method appendlist with 3 arguments: self, key and value.
self . _assert_mutable ( )	call the method self._assert_mutable.
key = bytes_to_text ( key , self . encoding )	call the method bytes_to_text with 2 arguments: key and self.encoding, substitute the result for key.
value = bytes_to_text ( value , self . encoding )	call the method bytes_to_text with 2 arguments: value and self.encoding, substitute the result for value.
super ( QueryDict , self ) . appendlist ( key , value )	call the method appendlist from the base class of the QueryDict class, with arguments key and value.
def pop ( self , key , * args ) :	define the method pop with 3 arguments: self, key and unpacked list args.
self . _assert_mutable ( )	call the method self._assert_mutable.
return super ( QueryDict , self ) . pop ( key , * args )	call the method pop from the base class of the class QueryDict, with arguments key and unpacked list args, return the result.
def popitem ( self ) :	define the method popitem with an argument self.
self . _assert_mutable ( )	call the method self._assert_mutable.
return super ( QueryDict , self ) . popitem ( )	call the method popitem from the base class of the class QueryDict, return the result.
def clear ( self ) :	define the method clear with an argument self.
self . _assert_mutable ( )	call the method self._assert_mutable.
super ( QueryDict , self ) . clear ( )	call the method clear from the base class of the class QueryDict, return the result.
def setdefault ( self , key , default = None ) :	define the method setdefault with 3 arguments: self, key and default set to None.
self . _assert_mutable ( )	call the method self._assert_mutable.
key = bytes_to_text ( key , self . encoding )	call the method bytes_to_text with 2 arguments: key and self.encoding, substitute the result for key.
default = bytes_to_text ( default , self . encoding )	call the method bytes_to_text with 2 arguments: default and self.encoding, substitute the result for default.
return super ( QueryDict , self ) . setdefault ( key , default )	call the method setlistdefault from the base class of the class QueryDict, with arguments key and default_list, return the result.
def copy ( self ) :	define the method copy with an argument self.
return self . __deepcopy__ ( { } )	call the method self.__deepcopy__ with an empty dictionary as an argument.
def urlencode ( self , safe = None ) :	define the method urlencode with 3 arguments: self and safe set to None.
output = [ ]	output is an empty list.
if safe :	if safe is true,
safe = force_bytes ( safe , self . encoding )	call the function force_bytes with 2 arguments: safe and self.encoding, substitute it for safe.
encode = lambda k , v : '%s=%s' % ( ( quote ( k , safe ) , quote ( v , safe ) ) )	encode is an lambda function with arguments k and v, return value is string '%s=%s', where '%s' is replaced with:
else :	return value of the function quote called with arguments k and safe, and with return value of the function quote called with arguments v and safe.   if not,
encode = lambda k , v : urlencode ( { k : v } )	encode is an lambda function with 2 arguments k and v, return value is the result of the function urlencode, called with an argument:
for k , list_ in self . lists ( ) :	dictionary containing element v for k.   for every k and list_ in return value of the method self.lists,
k = force_bytes ( k , self . encoding )	call the function force_bytes with arguments k and self.encoding, substitute the result for k.
output . extend ( [ encode ( k , force_bytes ( v , self . encoding ) )  for v in list_ ] )	for every v in list_ append to a list result of the function encode, called with arguments: k and result of the function force_bytes,
return '&' . join ( output )	called with arguments v and self.encoding, extend the output with the result.   join elements of the output into a string, separated with '&', return the result.
def build_request_repr ( request , path_override = None , GET_override = None ,  POST_override = None , COOKIES_override = None ,  META_override = None ) :	define the function build_request_repr with arguments: request, path_override set to None, GET_override set to None,
try :	try,
get = ( pformat ( GET_override )  if GET_override is not None  else pformat ( request . GET ) )	get is a tuple containing elements generated by the call to the function pformat with an argument GET_override,
except Exception :	if GET_override is not None, or otherwise generated with the call to the function pformat with an argument request.GET.   if Exception exception is caught,
get = '<could not parse>'	get is a string '<could not parse>'.
if request . _post_parse_error :	if request._post_parse_error is true,
post = '<could not parse>'	post is a string '<could not parse>'.
else :	if not,
try :	try,
post = ( pformat ( POST_override )  if POST_override is not None  else pformat ( request . POST ) )	get is a tuple containing elements generated by the call to the function pformat with an argument POST_override,
except Exception :	if POST_override is not None, or otherwise generated with the call to the function pformat with an argument request.POST.   if Exception exception is caught,
post = '<could not parse>'	post is a string '<could not parse>'.
try :	try,
cookies = ( pformat ( COOKIES_override )  if COOKIES_override is not None  else pformat ( request . COOKIES ) )	get is a tuple containing elements generated by the call to the function pformat with an argument COOKIES_override,
except Exception :	if COOKIES_override is not None, or otherwise generated with the call to the function pformat with an argument request.COOKIES.   if Exception exception is caught,
cookies = '<could not parse>'	cookies is a string '<could not parse>'.
try :	try,
meta = ( pformat ( META_override )  if META_override is not None  else pformat ( request . META ) )	get is a tuple containing elements generated by the call to the function pformat with an argument META_override,
except Exception :	if META_override is not None, or otherwise generated with the call to the function pformat with an argument request.META.   if Exception exception is caught,
meta = '<could not parse>'	meta is a string '<could not parse>'.
path = path_override if path_override is not None else request . path	substitute path_override for path if path_override is not None, otherwise substitute request.path for path
\return force_str ( '<%s\\npath:%s,\\nGET:%s,\\nPOST:%s,\\nCOOKIES:%s,\\nMETA:%s>' %  ( request . __class__ . __name__ ,  path ,  six . text_type ( get ) ,  six . text_type ( post ) ,  six . text_type ( cookies ) ,  six . text_type ( meta ) ) )\	\call the function force_str with an argument string '<%s\\npath:%s,\\nGET:%s,\\nPOST:%s,\\nCOOKIES:%s,\\nMETA:%s>',\
def bytes_to_text ( s , encoding ) :	where '%s' is replaced with request.__class__.__name__, path, return value of the function six.text_type called with an argument get,   return value of the function six.text_type called with an argument post, return value of the function six.text_type,   called with an argument cookies and return value of the function six.text_type called with an argument meta.   define the function bytes_to_text with 2 arguments s and encoding.
if isinstance ( s , bytes ) :	if s is an instance of bytes class,
return six . text_type ( s , encoding , 'replace' )	call the method six.text_type with 3 arguments: s, encoding and string 'replace'.
else :	if not,
return s	return s.
def split_domain_port ( host ) :	define the function split_domain_port with an argument host.
host = host . lower ( )	convert host to lowercase.
if not host_validation_re . match ( host ) :	call the method host_validation_re.match with an argument host.
return '' , ''	return an empty string and an empty string.
if host [ - 1 ] == ']' :	if last element of host equals character ']',
return host , ''	return host and an empty string.
bits = host . rsplit ( ':' , 1 )	split host from the right side into 2 parts at the ':', substitute the result for bits.
if len ( bits ) == 2 :	if length of bits equals integer 2,
return tuple ( bits )	add bits to a tuple, return it.
return bits [ 0 ] , ''	return the first element of bits and an empty string.
def validate_host ( host , allowed_hosts ) :	define the method validate_host with 2 arguments: host and allowed_hosts.
host = host [ : - 1 ] if host . endswith ( '.' ) else host	if host ends with '.', remove the last element from host.
for pattern in allowed_hosts :	for every pattern in allowed_hosts:
pattern = pattern . lower ( )	convert pattern to lowercase, substitute it for pattern.
match = (  pattern == '*' or  pattern . startswith ( '.' ) and (  host . endswith ( pattern ) or host == pattern [ 1 : ]  ) or  pattern == host  )	if pattern equals '*' or pattern starts with '.' or pattern equals host, and only if:
if match :	host ends with '.' and host ends with pattern or host is equal to all but first elements of pattern,   substitute boolean true for match, otherwise substitute boolean False for match.   if match is true,
return True	return boolean True.
return False	return boolean False.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import datetime	import module datetime.
import json	import module json.
import sys	import module sys.
import time	import module time.
from email . header import Header	from email.header import Header into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . core import signals	from django.core import signals into default name space.
from django . core import signing	from django.core import signing into default name space.
from django . core . exceptions import DisallowedRedirect	from django.core.exceptions import DisallowedRedirect into default name space.
from django . core . serializers . json import DjangoJSONEncoder	from django.core.serializers.json import DjangoJSONEncode into default name space.
from django . http . cookie import SimpleCookie	from django.http.cookie import SimpleCookie into default name space.
from django . utils import six , timezone	from django.utils import six and timezone into default name space.
from django . utils . encoding import force_bytes , force_text , iri_to_uri	from django.utils.encoding import force_bytes,  force_text and iri_to_uri into default name space.
from django . utils . http import cookie_date	from django.utils.http import cookie_date into default name space.
from django . utils . six . moves import map	from django.utils.six.moves import map into default name space.
from django . utils . six . moves . urllib . parse import urlparse	from django.utils.six.moves.urllib.parse import urlparse into default name space.
REASON_PHRASES = {  100 : 'CONTINUE' ,  101 : 'SWITCHING PROTOCOLS' ,  102 : 'PROCESSING' ,  200 : 'OK' ,  201 : 'CREATED' ,  202 : 'ACCEPTED' ,  203 : 'NON-AUTHORITATIVE INFORMATION' ,  204 : 'NO CONTENT' ,  205 : 'RESET CONTENT' ,  206 : 'PARTIAL CONTENT' ,  207 : 'MULTI-STATUS' ,  208 : 'ALREADY REPORTED' ,  226 : 'IM USED' ,  300 : 'MULTIPLE CHOICES' ,  301 : 'MOVED PERMANENTLY' ,  302 : 'FOUND' ,  303 : 'SEE OTHER' ,  304 : 'NOT MODIFIED' ,  305 : 'USE PROXY' ,  306 : 'RESERVED' ,  307 : 'TEMPORARY REDIRECT' ,  308 : 'PERMANENT REDIRECT' ,  400 : 'BAD REQUEST' ,  401 : 'UNAUTHORIZED' ,  402 : 'PAYMENT REQUIRED' ,  403 : 'FORBIDDEN' ,  404 : 'NOT FOUND' ,  405 : 'METHOD NOT ALLOWED' ,  406 : 'NOT ACCEPTABLE' ,  407 : 'PROXY AUTHENTICATION REQUIRED' ,  408 : 'REQUEST TIMEOUT' ,  409 : 'CONFLICT' ,  410 : 'GONE' ,  411 : 'LENGTH REQUIRED' ,  412 : 'PRECONDITION FAILED' ,  413 : 'REQUEST ENTITY TOO LARGE' ,  414 : 'REQUEST-URI TOO LONG' ,  415 : 'UNSUPPORTED MEDIA TYPE' ,  416 : 'REQUESTED RANGE NOT SATISFIABLE' ,  417 : 'EXPECTATION FAILED' ,  418 : 'I'M A TEAPOT' ,  422 : 'UNPROCESSABLE ENTITY' ,  423 : 'LOCKED' ,  424 : 'FAILED DEPENDENCY' ,  426 : 'UPGRADE REQUIRED' ,  428 : 'PRECONDITION REQUIRED' ,  429 : 'TOO MANY REQUESTS' ,  431 : 'REQUEST HEADER FIELDS TOO LARGE' ,  500 : 'INTERNAL SERVER ERROR' ,  501 : 'NOT IMPLEMENTED' ,  502 : 'BAD GATEWAY' ,  503 : 'SERVICE UNAVAILABLE' ,  504 : 'GATEWAY TIMEOUT' ,  505 : 'HTTP VERSION NOT SUPPORTED' ,  506 : 'VARIANT ALSO NEGOTIATES' ,  507 : 'INSUFFICIENT STORAGE' ,  508 : 'LOOP DETECTED' ,  510 : 'NOT EXTENDED' ,  511 : 'NETWORK AUTHENTICATION REQUIRED' ,  }	REASON_PHRASES is a dictionary containing 59 initial entries: 'CONTINUE' for 100, 'SWITCHING PROTOCOLS' for 101,
class BadHeaderError ( ValueError ) :	'PROCESSING' for 102, 'OK' for 200, 'CREATED' for 201, 'ACCEPTED' for 202, 'NON-AUTHORITATIVE INFORMATION' for 203,   'NO CONTENT' for 204, 'RESET CONTENT' for 205, 'PARTIAL CONTENT' for 206, 'MULTI-STATUS' for 207, 'ALREADY REPORTED' for 208,   'IM USED' for 226, 'MULTIPLE CHOICES' for 300, 'MOVED PERMANENTLY' for 301, 'FOUND' for 302, 'SEE OTHER' for 303,   'NOT MODIFIED' for 304, 'USE PROXY' for 305, 'RESERVED' for 306, 'TEMPORARY REDIRECT' for 307, 'PERMANENT REDIRECT' for 308,   'BAD REQUEST' for 400, 'UNAUTHORIZED' for 401, 'PAYMENT REQUIRED' for 402, 'FORBIDDEN' for 403, 'NOT FOUND' for 404,   'METHOD NOT ALLOWED' for 405, 'NOT ACCEPTABLE' for 406, 'PROXY AUTHENTICATION REQUIRED' for 407, 'REQUEST TIMEOUT' for 408,   'CONFLICT' for 409, 'GONE' for 410, 'LENGTH REQUIRED' for 411, 'PRECONDITION FAILED' for 412, 'REQUEST ENTITY TOO LARGE' for 413,   'REQUEST-URI TOO LONG' for 414, 'UNSUPPORTED MEDIA TYPE' for 415, 'REQUESTED RANGE NOT SATISFIABLE' for 416,   'EXPECTATION FAILED' for 417, 'I'M A TEAPOT' for 418, 'UNPROCESSABLE ENTITY' for 422, 'LOCKED' for 423, 'FAILED DEPENDENCY' for 424,   'UPGRADE REQUIRED' for 426, 'PRECONDITION REQUIRED' for 428, 'TOO MANY REQUESTS' for 429, 'REQUEST HEADER FIELDS TOO LARGE' for 431,   'INTERNAL SERVER ERROR' for 500, 'NOT IMPLEMENTED' for 501, 'BAD GATEWAY' for 502, 'SERVICE UNAVAILABLE' for 503,   'GATEWAY TIMEOUT' for 504, 'HTTP VERSION NOT SUPPORTED' for 505, 'VARIANT ALSO NEGOTIATES' for 506, 'INSUFFICIENT STORAGE' for 507,   'LOOP DETECTED' for 508, 'NOT EXTENDED' for 510 and 'NETWORK AUTHENTICATION REQUIRED' for 511.   derive the class BadHeaderError from the ValueError base class.
pass	do nothing.
class HttpResponseBase ( six . Iterator ) :	derive the class HttpResponseBase from the six.Iterator base class.
status_code = 200	status_code is an integer 200.
reason_phrase = None	reason_phrase is None.
def __init__ ( self , content_type = None , status = None , reason = None ) :	define the method __init__ with 4 arguments: self, content_type set to None, status set to None, reason set to None.
self . _headers = { }	  self._headers is an empty dictionary.
self . _charset = settings . DEFAULT_CHARSET	substitute settings.DEFAULT_CHARSET for self._charset.
self . _closable_objects = [ ]	self._closable_objects is an empty list.
self . _handler_class = None	self._handler_class is None.
if not content_type :	if content_type is false,
content_type = '%s; charset=%s' % ( settings . DEFAULT_CONTENT_TYPE ,  self . _charset )	replace '%s' in string '%s; charset=%s' with settings.DEFAULT_CONTENT_TYPE and self._charset, substitute it for content_type.
self . cookies = SimpleCookie ( )	self.cookies is an instance of a class SimpleCookie.
if status is not None :	if status is not None.
self . status_code = status	substitute status for self.status_code.
if reason is not None :	if reason is not None,
self . reason_phrase = reason	substitute reason for self.reason_phrase.
elif self . reason_phrase is None :	otherwise if self.reason_phrase is None,
self . reason_phrase = REASON_PHRASES . get ( self . status_code ,  'UNKNOWN STATUS CODE' )	get the value under the self.status_code key of the REASON_PHRASES dictionary, if it exists substitute it for the self.reason_phrase,
self [ 'Content-Type' ] = content_type	if not, self.reason_phrase is a string 'UNKNOWN STATUS CODE'.   substitute content_type for value under the 'Content-Type' key of the self dictionary.
def serialize_headers ( self ) :	define the method serialize_headers with an argument self.
def to_bytes ( val , encoding ) :	define the function to_bytes with arguments val and encoding.
return val if isinstance ( val , bytes ) else val . encode ( encoding )	if val is an instance of bytes, return val, otherwise return result of the method val.encode called with an argument encoding.
headers = [  ( b': ' . join ( [ to_bytes ( key , 'ascii' ) , to_bytes ( value , 'latin-1' ) ] ) )  for key , value in self . _headers . values ( )  ]	for every key and value in return value of the self._headers.values method, call the function to_bytes with 2 arguments: key,
\return b'\\r\\n' . join ( headers )\	\and string 'ascii' and call the function to_bytes with 2 arguments: value and string 'latin-1',   join the previous 2 results into a string, separated by ': ', append it to a list, substitute the resulting list for headers.   join headers into a string, separated by string '\\r\\n'.\
if six . PY3 :	if six.PY3 is true,
__bytes__ = serialize_headers	substitute serialize_headers for __bytes__.
else :	if not,
__str__ = serialize_headers	substitute serialize_headers for __str__.
def _convert_to_charset ( self , value , charset , mime_encode = False ) :	define the method _convert_to_charset with 4 arguments: self, value, charset and mime_encode set to boolean False.
if not isinstance ( value , ( bytes , six . text_type ) ) :	if value is not an instance of bytes or six.text_type classes,
value = str ( value )	convert value to an string and substitute it for value.
try :	try,
if six . PY3 :	if six.PY3 is true,
if isinstance ( value , str ) :	if value is an instance of str type,
  value . encode ( charset )	call the method value.encode with an argument charset.
else :	if not,
  value = value . decode ( charset )	call the method value.decode with an argument charset, substitute the result for value.
else :	if not,
if isinstance ( value , str ) :	if value is an instance of str type,
  value . decode ( charset )	call the method value.decode with an argument charset.
else :	if not,
  value = value . encode ( charset )	call the method value.encode with an argument charset, substitute the result for value.
except UnicodeError as e :	if UnicodeError, renamed to e, exception is caught,
if mime_encode :	if mime_encode is true,
value = str ( Header ( value , 'utf-8' , maxlinelen = sys . maxsize ) . encode ( ) )	instantiate class Header with 3 arguments: value, string 'utf-8', maxlinelen set to sys.maxsize, call the encode method on it,
else :	convert the result into a string and substitute it for value.   if not,
e . reason += ', HTTP response headers must be in %s format' % charset	replace '%s' in string ', HTTP response headers must be in %s format' for charset, append it to e.reason.
raise	raise an exception.
\if str ( '\\n' ) in value or str ( '\\r' ) in value :\	\convert '\\n' to a string, if it is contained in value or '\\r' converted to an string is contained in value,\
raise BadHeaderError ( 'Header values can't contain newlines (got %r)' % value )	raise an BadHeaderError exception with an argument string 'Header values can't contain newlines (got %r)', where '%r' is replaced with value.
return value	return value.
def __setitem__ ( self , header , value ) :	define the method __setitem__ with 3 arguments: self, header and value.
header = self . _convert_to_charset ( header , 'ascii' )	call the method self._convert_to_charset with arguments: header and string 'ascii', substitute the result for header.
value = self . _convert_to_charset ( value , 'latin-1' , mime_encode = True )	call the method self._convert_to_charset with arguments: header, string 'latin-1' and mime_encode set to boolean True,
self . _headers [ header . lower ( ) ] = ( header , value )	substitute the result for value.   substitute tuple containing 2 elements: header and value for the value under the header converted to lowercase key of the self._headers dictionary.
def __delitem__ ( self , header ) :	define the method __delitem__ with 2 arguments: self and header.
try :	try,
del self . _headers [ header . lower ( ) ]	delete the value under the header converted to lowercase key of the self._headers dictionary.
except KeyError :	if KeyError exception is caught,
pass	do nothing.
def __getitem__ ( self , header ) :	define the method __getitem__ with 2 arguments: self and header.
return self . _headers [ header . lower ( ) ] [ 1 ]	convert header to lowercase, use it as the key to get the value from the self._headers dictionary, return the second element of the result.
def __getstate__ ( self ) :	define the method __getstate__ with an argument self.
state = self . __dict__ . copy ( )	call the method self.__dict__.copy, substitute the result for state.
state [ 'cookies' ] = str ( state [ 'cookies' ] )	get the value under the 'cookies' key of the state dictionary,
return state	convert it to a string and substitute it for value under the 'cookies' key of the state dictionary.   return state.
def __setstate__ ( self , state ) :	define the method __setstate__ with 2 arguments: self and state.
self . __dict__ . update ( state )	add state element to self.__dict__ dictionary.
self . cookies = SimpleCookie ( self . cookies )	self.cookies is an instance of SimpleCookie class created with self.cookies as an argument.
def has_header ( self , header ) :	define the method has_header with 2 arguments: self and header.
return header . lower ( ) in self . _headers	convert deader to lowercase, if it is contained in self._headers return boolean True, if not, return boolean False.
__contains__ = has_header	substitute has_header for __contains__.
def items ( self ) :	define the method items with an argument self.
return self . _headers . values ( )	call the method self._headers.values, return the result,
def get ( self , header , alternate = None ) :	define the method get with 3 arguments: self, header and alternate set to None.
return self . _headers . get ( header . lower ( ) , ( None , alternate ) ) [ 1 ]	convert header to lowercase, use it to as a key to get the value of the self._headers dictionary,
def set_cookie ( self , key , value = '' , max_age = None , expires = None , path = '/' ,  domain = None , secure = False , httponly = False ) :	if it exists return the second element of the result, if not, return alternate.   define the method set_cookie with 9 arguments: self, key, value set to an empty string, max_age set to None, expires set to None,
self . cookies [ key ] = value	substitute value for self.cookies dictionary value under the key key.
if expires is not None :	if expires is not None,
if isinstance ( expires , datetime . datetime ) :	if expires is an instance of datetime.datetime class,
if timezone . is_aware ( expires ) :	call the method timezone.is_aware with an argument expires, if it evaluates to true,
expires = timezone . make_naive ( expires , timezone . utc )	call the method timezone.make_naive with arguments: expires, timezone.utc, substitute the result for expires.
delta = expires - expires . utcnow ( )	call the method expires.utcnow, subtract the result from expires, substitute the result for delta.
delta = delta + datetime . timedelta ( seconds = 1 )	call the method datetime.timedelta with an argument seconds set to integer 1, increment delta by it.
expires = None	expires is None.
max_age = max ( 0 , delta . days * 86400 + delta . seconds )	multiply delta.days with an integer 86400 add to the result delta.seconds, if the result is greater than integer 0,
else :	substitute it for max_age, if not, max_age is integer 0.   if not,
self . cookies [ key ] [ 'expires' ] = expires	get the value under the key key of the self.cookies dictionary, substitute expires for 'expires' key of the returned dictionary.
if max_age is not None :	if max_age is not None,
self . cookies [ key ] [ 'max-age' ] = max_age	get the value under the key key of the self.cookies dictionary, substitute max-age for 'max-age' key of the returned dictionary.
if not expires :	if expires is false,
self . cookies [ key ] [ 'expires' ] = cookie_date ( time . time ( ) +  max_age )	get the value under the key key of the self.cookies dictionary, call the cookie_date function with an argument:
if path is not None :	sum of the result of the function time.time and max_age, substitute it for 'expires' key of the previously returned dictionary.   if path is not None,
self . cookies [ key ] [ 'path' ] = path	get the value under the key key of the self.cookies dictionary, substitute path for 'path' key of the returned dictionary.
if domain is not None :	if domain is not None,
self . cookies [ key ] [ 'domain' ] = domain	get the value under the key key of the self.cookies dictionary, domain expires for 'domain' key of the returned dictionary.
if secure :	if secure is true,
self . cookies [ key ] [ 'secure' ] = True	get the value under the key key of the self.cookies dictionary, substitute boolean True for 'secure' key of the returned dictionary.
if httponly :	if httponly is true,
self . cookies [ key ] [ 'httponly' ] = True	get the value under the key key of the self.cookies dictionary, substitute boolean True for 'httponly' key of the returned dictionary.
def set_signed_cookie ( self , key , value , salt = '' , ** kwargs ) :	define the method set_signed_cookie with 5 arguments: self, key, value, salt as an empty string and unpacked dictionary kwarg.
value = signing . get_cookie_signer ( salt = key + salt ) . sign ( value )	call the method signing.get_cookie_signer with an argument salt set to sum of key and salt,
return self . set_cookie ( key , value , ** kwargs )	call the method sign on the result with an argument value, substitute the result for value.   call the method self.set_cookie with 3 arguments: key, value and unpacked dictionary kwargs, return the result.
def delete_cookie ( self , key , path = '/' , domain = None ) :	define the method delete_cookie with 4 arguments: self, key, path set to character '/' and domain set to None.
self . set_cookie ( key , max_age = 0 , path = path , domain = domain ,  expires = 'Thu, 01-Jan-1970 00:00:00 GMT' )	call the method self.set_cookie with 5 arguments: key, max_age as integer 0, path as path, domain as domain,
def make_bytes ( self , value ) :	expires as a string 'Thu, 01-Jan-1970 00:00:00 GMT', return the result.   define the method make_bytes with 2 arguments: self and value.
if self . has_header ( 'Content-Encoding' ) :	call the method self.has_header with string 'Content-Encoding' as an argument, if it evaluates to true,
return bytes ( value )	call the function bytes with an argument value, return the result.
if isinstance ( value , bytes ) :	if value is an instance of bytes class,
return bytes ( value )	call the function bytes with an argument value, return the result.
if isinstance ( value , six . text_type ) :	if value is an instance of six.text_type class,
return bytes ( value . encode ( self . _charset ) )	call the method value.encode with an argument self._charset, use the result as an argument for the call to the bytes function,
return force_bytes ( value , self . _charset )	return the result.   call the function force_bytes with arguments value and self._charset, return the result.
def close ( self ) :	define the method close with an argument self.
for closable in self . _closable_objects :	for every closable in self._closable_objects,
try :	try,
closable . close ( )	call the method closable.close.
except Exception :	if Exception exception is caught,
pass	do nothing.
signals . request_finished . send ( sender = self . _handler_class )	call the method signals.request_finished.send with an argument sender set to self._handler_class.
def write ( self , content ) :	define the method write with 2 arguments: self and value.
raise Exception ( 'This %s instance is not writable' % self . __class__ . __name__ )	raise an Exception exception with an argument string 'This %s instance is not writable',
def flush ( self ) :	where '%s' is replaced with self.__class__.__name__.   define the method flush with an argument self.
pass	do nothing.
def tell ( self ) :	define the method tell with an argument self.
raise Exception ( 'This %s instance cannot tell its position' % self . __class__ . __name__ )	raise an Exception exception with an argument string 'This %s instance cannot tell its position',
class HttpResponse ( HttpResponseBase ) :	where '%s' is replaced with self.__class__.__name__.   derive the class HttpResponse from the HttpResponseBase base class.
streaming = False	streaming is boolean False.
def __init__ ( self , content = b'' , * args , ** kwargs ) :	define the method __init__ with 4 arguments: self, content set to an empty list, unpacked list args and unpacked dictionary kwargs.
super ( HttpResponse , self ) . __init__ ( * args , ** kwargs )	call the __init__ method from the base class of the HttpResponse class, with the arguments: unpacked list args and unpacked dictionary kwargs.
self . content = content	substitute content for self.content.
def serialize ( self ) :	define the serialize content with an argument self.
\return self . serialize_headers ( ) + b'\\r\\n\\r\\n' + self . content\	\call method self.serialize_headers, append bytes string '\\r\\n\\r\\n' to the result, append self.content to the result, return it.\
if six . PY3 :	if six.PY3 is true,
__bytes__ = serialize	substitute serialize for __bytes__.
else :	if not,
__str__ = serialize	substitute serialize for __str__.
@ property	property decorator,
def content ( self ) :	define the method content with an argument self.
return b'' . join ( self . _container )	join self._container elements into a string, return it.
@ content . setter	content.setter decorator,
def content ( self , value ) :	define the method content with 2 arguments: self and value.
if hasattr ( value , '__iter__' ) and not isinstance ( value , ( bytes , six . string_types ) ) :	if value has an '__iter__' attribute and value is not an instance of bytes or six.string_types class.
if hasattr ( value , 'close' ) :	if value has an 'close' attribute,
self . _closable_objects . append ( value )	append value to the self._closable_objects list.
value = b'' . join ( self . make_bytes ( chunk ) for chunk in value )	call the self.make_bytes method with an argument chunk, for every chunk in value join the result to a bytes string,
else :	substitute the result for value.   if not,
value = self . make_bytes ( value )	call the method self.make_bytes with an argument value, substitute the result for value.
self . _container = [ value ]	self._container is a list containing element value.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
return iter ( self . _container )	return self._container converted into a iterable.
def write ( self , content ) :	define the method write with 2 arguments: self and content.
self . _container . append ( self . make_bytes ( content ) )	call the method self.make_bytes with an argument content, append it to self._container.
def tell ( self ) :	define the method tell with an argument self.
return len ( self . content )	return the length of self.content.
class StreamingHttpResponse ( HttpResponseBase ) :	derive the class StreamingHttpResponse from the HttpResponseBase base class.
streaming = True	streaming is boolean True.
def __init__ ( self , streaming_content = ( ) , * args , ** kwargs ) :	define the method __init__ with 4 arguments: self, result of the function streaming_content=(), unpacked list args,
super ( StreamingHttpResponse , self ) . __init__ ( * args , ** kwargs )	and unpacked dictionary kwargs.   call the __init__ method from the base class of the StreamingHttpResponse class, called with arguments: unpacked list args,
self . streaming_content = streaming_content	and unpacked dictionary kwargs.   substitute streaming_content for self.streaming_content.
@ property	property decorator,
def content ( self ) :	define the method content with an argument self.
raise AttributeError ( 'This %s instance has no `content` attribute. '  'Use `streaming_content` instead.' % self . __class__ . __name__ )	raise an AttributeError with an argument string 'This %s instance has no `content` attribute. 'Use `streaming_content` instead.',
@ property	where '%s' is replaced with self.__class__.__name__.   property decorator,
def streaming_content ( self ) :	define the method serialize_headers with an argument self.
return map ( self . make_bytes , self . _iterator )	map elements of self._iterator through self.make_bytes function, return the result.
@ streaming_content . setter	streaming_content.setter decorator,
def streaming_content ( self , value ) :	define the method streaming_content with 2 arguments: self and value.
self . _iterator = iter ( value )	convert value into a iterator, substitute the result for self._iterator.
if hasattr ( value , 'close' ) :	if value has an attribute 'close',
self . _closable_objects . append ( value )	append value to self._closable_objects list.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
return self . streaming_content	return self.streaming_content
class HttpResponseRedirectBase ( HttpResponse ) :	derive the class HttpResponseRedirectBase from the HttpResponse base class.
allowed_schemes = [ 'http' , 'https' , 'ftp' ]	allowed_schemes is an list containing 3 elements: strings 'http', 'https' and 'ftp'.
def __init__ ( self , redirect_to , * args , ** kwargs ) :	define the method __init__ with 4 arguments: self, redirect_to, unpacked list args and unpacked dictionary kwargs.
parsed = urlparse ( force_text ( redirect_to ) )	call the function force_text with an argument redirect_to, use the result as an argument for the call to the function urlparse,
if parsed . scheme and parsed . scheme not in self . allowed_schemes :	substitute the result for parsed.   if parsed.scheme is true and parsed.scheme is not contained in self.allowed_schemes,
super ( HttpResponseRedirectBase , self ) . __init__ ( * args , ** kwargs )	where '%s' is replaced with parsed.scheme.   call the __init__ method from the base class of the HttpResponseRedirectBase class, called with arguments: unpacked list args,
self [ 'Location' ] = iri_to_uri ( redirect_to )	and unpacked dictionary kwargs.   call the function iri_to_uri with an argument redirect_to, substitute the result for the value under the 'Location' key of the self dictionary.
url = property ( lambda self : self [ 'Location' ] )	url is a property of the class, lambda function is getter attribute with an argument self and return value is the value under the 'Location' key of the self dictionary.
class HttpResponseRedirect ( HttpResponseRedirectBase ) :	derive the class HttpResponseRedirect from the HttpResponseRedirectBase base class.
status_code = 302	status_code is an integer 302.
class HttpResponsePermanentRedirect ( HttpResponseRedirectBase ) :	derive the class HttpResponsePermanentRedirect from the HttpResponseRedirectBase base class.
status_code = 301	status_code is an integer 301.
class HttpResponseNotModified ( HttpResponse ) :	derive the class HttpResponseNotModified from the HttpResponse base class.
status_code = 304	status_code is an integer 304.
def __init__ ( self , * args , ** kwargs ) :	define the method __init__ with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
super ( HttpResponseNotModified , self ) . __init__ ( * args , ** kwargs )	call the __init__ method from the base class of the HttpResponseNotModified class, called with arguments: unpacked list args,
del self [ 'content-type' ]	and unpacked dictionary kwargs.   delete the value under the 'content-type' key of the self dictionary.
@ HttpResponse . content . setter	HttpResponse.content.setter property,
def content ( self , value ) :	define the method content with self and value.
if value :	if value,
raise AttributeError ( 'You cannot set content to a 304 (Not Modified) response' )	raise an AttributeError exception with an argument string 'You cannot set content to a 304 (Not Modified) response'.
self . _container = [ ]	self._container is an list.
class HttpResponseBadRequest ( HttpResponse ) :	derive the class HttpResponseBadRequest from the HttpResponse base class.
status_code = 400	status_code is an integer 400.
class HttpResponseNotFound ( HttpResponse ) :	derive the class HttpResponseNotFound from the HttpResponse base class.
status_code = 404	status_code is an integer 404.
class HttpResponseForbidden ( HttpResponse ) :	derive the class HttpResponseForbidden from the HttpResponse base class.
status_code = 403	status_code is an integer 403.
class HttpResponseNotAllowed ( HttpResponse ) :	derive the class HttpResponseNotAllowed from the HttpResponse base class.
status_code = 405	status_code is an integer 405.
def __init__ ( self , permitted_methods , * args , ** kwargs ) :	define the method __init__ with 4 arguments: self, permitted_methods, unpacked list args and unpacked dictionary kwargs.
super ( HttpResponseNotAllowed , self ) . __init__ ( * args , ** kwargs )	call the __init__ method from the base class of the HttpResponseNotAllowed class, called with arguments: unpacked list args,
self [ 'Allow' ] = ', ' . join ( permitted_methods )	and unpacked dictionary kwargs.   join into a string permitted_methods, separated by string ', ', substitute it for value under the 'Allow' key of the self dictionary.
class HttpResponseGone ( HttpResponse ) :	derive the class HttpResponseGone from the HttpResponse base class.
status_code = 410	status_code is an integer 410.
class HttpResponseServerError ( HttpResponse ) :	derive the class HttpResponseServerError from the HttpResponse base class.
status_code = 500	status_code is an integer 500.
class Http404 ( Exception ) :	derive the class Http404 from the Exception base class.
pass	do nothing.
class JsonResponse ( HttpResponse ) :	derive the class JsonResponse from the HttpResponse base class.
def __init__ ( self , data , encoder = DjangoJSONEncoder , safe = True , ** kwargs ) :	define the method __init__ with 5 arguments: self, data, encoder set to DjangoJSONEncoder, safe set to boolean True,
if safe and not isinstance ( data , dict ) :	and unpacked dictionary kwargs.   if safe is true and data is not an instance of dict type.
raise TypeError ( 'In order to allow non-dict objects to be '  'serialized set the safe parameter to False' )	raise an TypeError exception with an argument string 'In order to allow non-dict objects to be serialized set the safe parameter to False'.
kwargs . setdefault ( 'content_type' , 'application/json' )	if 'content_type' key doesnt exist in kwargs, set its value to 'application/json'.
data = json . dumps ( data , cls = encoder )	serialize data to JSON format with cls set to encoder, substitute it for data.
super ( JsonResponse , self ) . __init__ ( content = data , ** kwargs )	call the __init__ method from the base class of the JsonResponse class, called with arguments: content set to data,
def fix_location_header ( request , response ) :	define function fix_location_header with request and response as arguments.
if 'Location' in response and request . get_host ( ) :	if 'Location' is contained in response and function request.get_host evaluates to True,
response [ 'Location' ] = request . build_absolute_uri ( response [ 'Location' ] )	modify value at the key 'Location' of the dictionary response by applying function request.build_absolute_uri on it.
return response	return response.
def conditional_content_removal ( request , response ) :	define the function conditional_content_removal with request and response as the arguments.
if 100 <= response . status_code < 200 or response . status_code in ( 204 , 304 ) :	if response.status_code is lesser than integer 200 and grater or equal than 100, or response.status_code equals to integer 204 or 304,
if response . streaming :	if response.streaming is True,
response . streaming_content = [ ]	response.streaming_content is an empty list.
else :	if not,
response . content = b''	response.content is bytes empty string.
response [ 'Content-Length' ] = '0'	substitute char '0' for the value under the 'Content-Length' key of the response dictionary.
if request . method == 'HEAD' :	if request.method equals to string 'HEAD',
if response . streaming :	if response.streaming is true,
response . streaming_content = [ ]	response.streaming_content is an empty list.
else :	if not,
response . content = b''	response.content is bytes empty string.
return response	return response.
from django . template . base import ( ALLOWED_VARIABLE_CHARS , BLOCK_TAG_END ,  BLOCK_TAG_START , COMMENT_TAG_END , COMMENT_TAG_START ,  FILTER_ARGUMENT_SEPARATOR , FILTER_SEPARATOR , SINGLE_BRACE_END ,  SINGLE_BRACE_START , TOKEN_BLOCK , TOKEN_COMMENT , TOKEN_TEXT , TOKEN_VAR ,  TRANSLATOR_COMMENT_MARK , UNKNOWN_SOURCE , VARIABLE_ATTRIBUTE_SEPARATOR ,  VARIABLE_TAG_END , VARIABLE_TAG_START , filter_re , tag_re )	from django.template.base import ALLOWED_VARIABLE_CHARS, BLOCK_TAG_END, BLOCK_TAG_START, COMMENT_TAG_END, COMMENT_TAG_START,
from django . template . base import ( ContextPopException , InvalidTemplateLibrary ,  TemplateDoesNotExist , TemplateEncodingError , TemplateSyntaxError ,  VariableDoesNotExist )	FILTER_ARGUMENT_SEPARATOR, FILTER_SEPARATOR, SINGLE_BRACE_END, SINGLE_BRACE_START, TOKEN_BLOCK, TOKEN_COMMENT, TOKEN_TEXT, TOKEN_VAR,   TRANSLATOR_COMMENT_MARK, UNKNOWN_SOURCE, VARIABLE_ATTRIBUTE_SEPARATOR, VARIABLE_TAG_END, VARIABLE_TAG_START, filter_re and tag_re.   from django.template.base import ContextPopException, InvalidTemplateLibrary, TemplateDoesNotExist, TemplateEncodingError,
from django . template . base import ( Context , FilterExpression , Lexer , Node ,  NodeList , Parser , RequestContext , Origin , StringOrigin , Template ,  TextNode , Token , TokenParser , Variable , VariableNode , constant_string ,  filter_raw_string )	TemplateSyntaxError and VariableDoesNotExist.   from django.template.base import Context, FilterExpression, Lexer, Node, NodeList, Parser, RequestContext, Origin, StringOrigin,
from django . template . base import ( compile_string , resolve_variable ,  unescape_string_literal , generic_tag_compiler )	Template, TextNode, Token, TokenParser, Variable, VariableNode, constant_string and filter_raw_string.   from django.template.base import compile_string, resolve_variable, unescape_string_literal and generic_tag_compiler.
from django . template . base import ( Library , add_to_builtins , builtins ,  get_library , get_templatetags_modules , get_text_list , import_library ,  libraries )	from django.template.base import Library, add_to_builtins, builtins, get_library, get_templatetags_modules, get_text_list,
__all__ = ( 'Template' , 'Context' , 'RequestContext' , 'compile_string' )	import_library and libraries.   __all__  is a tuple containing 4 strings: 'Template', 'Context', 'RequestContext' and 'compile_string'.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import re	import module re.
from functools import partial	from functools import partial into default name space.
from importlib import import_module	from importlib import import_module into default name space.
from inspect import getargspec , getcallargs	from inspect import getargspec and getcallargs into default name space.
import warnings	import module warnings.
from django . apps import apps	from django.apps import apps into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . template . context import ( BaseContext , Context , RequestContext ,  ContextPopException )	from django.template.context import BaseContext, Context, RequestContext and ContextPopException into default namespace.
from django . utils . deprecation import RemovedInDjango20Warning	from django.utils.deprecation import RemovedInDjango20Warning into default name space.
from django . utils . itercompat import is_iterable	from django.utils.itercompat import is_iterable into default name space.
from django . utils . text import ( smart_split , unescape_string_literal ,  get_text_list )	from django.utils.text import smart_split, unescape_string_literal and get_text_list into default namespace.
from django . utils . encoding import force_str , force_text	from django.utils.encoding import force_str and force_text into default name space.
from django . utils . translation import ugettext_lazy , pgettext_lazy	from django.utils.translation import ugettext_lazy and pgettext_lazy into default name space.
from django . utils . safestring import ( SafeData , EscapeData , mark_safe ,  mark_for_escaping )	from django.utils.safestring import SafeData, EscapeData, mark_safe and mark_for_escaping into default namespace.
from django . utils . formats import localize	from django.utils.formats import localize into default name space.
from django . utils . html import escape	from django.utils.html import escape into default name space.
from django . utils . module_loading import module_has_submodule	from django.utils.module_loading import module_has_submodule into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . timezone import template_localtime	from django.utils.timezone import template_localtime into default name space.
from django . utils . encoding import python_2_unicode_compatible	from django.utils.encoding import python_2_unicode_compatible into default name space.
TOKEN_TEXT = 0	TOKEN_TEXT is integer 0
TOKEN_VAR = 1	TOKEN_VAR is integer 1
TOKEN_BLOCK = 2	TOKEN_BLOCK is integer 2
TOKEN_COMMENT = 3	TOKEN_COMMENT is integer 3.
TOKEN_MAPPING = {  TOKEN_TEXT : 'Text' ,  TOKEN_VAR : 'Var' ,  TOKEN_BLOCK : 'Block' ,  TOKEN_COMMENT : 'Comment' ,  }	TOKEN_MAPPING is a dictionary with 4 initial entries: 'Text' for TOKEN_TEXT, 'Var' for TOKEN_VAR, 'Block' for TOKEN_BLOCK,
FILTER_SEPARATOR = '|'	and 'Comment' for TOKEN_COMMENT.   FILTER_SEPARATOR is a string '|'.
FILTER_ARGUMENT_SEPARATOR = ':'	FILTER_ARGUMENT_SEPARATOR is a string ':'.
VARIABLE_ATTRIBUTE_SEPARATOR = '.'	VARIABLE_ATTRIBUTE_SEPARATOR is a string '.'.
BLOCK_TAG_START = '{%'	BLOCK_TAG_START is a string '{%'.
BLOCK_TAG_END = '%}'	BLOCK_TAG_END is a string '%}'.
VARIABLE_TAG_START = '{{'	VARIABLE_TAG_START is a string '{{'.
VARIABLE_TAG_END = '}}'	VARIABLE_TAG_END is a string '}}'.
COMMENT_TAG_START = '{#'	COMMENT_TAG_START is a string '{#'.
COMMENT_TAG_END = '#}'	COMMENT_TAG_END is a string '#}'.
TRANSLATOR_COMMENT_MARK = 'Translators'	TRANSLATOR_COMMENT_MARK is a string 'Translators'.
SINGLE_BRACE_START = '{'	SINGLE_BRACE_START is a string '{'.
SINGLE_BRACE_END = '}'	SINGLE_BRACE_END is a string '}'.
ALLOWED_VARIABLE_CHARS = ( 'abcdefghijklmnopqrstuvwxyz'  'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.' )	ALLOWED_VARIABLE_CHARS is a string 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.'.
UNKNOWN_SOURCE = '<unknown source>'	UNKNOWN_SOURCE is a string '<unknown source>'.
tag_re = ( re . compile ( '(%s.*?%s|%s.*?%s|%s.*?%s)' %  ( re . escape ( BLOCK_TAG_START ) , re . escape ( BLOCK_TAG_END ) ,  re . escape ( VARIABLE_TAG_START ) , re . escape ( VARIABLE_TAG_END ) ,  re . escape ( COMMENT_TAG_START ) , re . escape ( COMMENT_TAG_END ) ) ) )	call the function re.compile with an argument string '(%s.*?%s|%s.*?%s|%s.*?%s)', substitute all occurrences of '%s' with,
libraries = { }	return value of the function re.escape called with an argument BLOCK_TAG_START,   return value of the function re.escape called with an argument BLOCK_TAG_END,   return value of the function re.escape called with an argument VARIABLE_TAG_START,   return value of the function re.escape called with an argument VARIABLE_TAG_END,   return value of the function re.escape called with an argument COMMENT_TAG_START,   and return value of the function re.escape called with an argument COMMENT_TAG_END, substitute the result for tag_re.   libraries is an empty dictionary.
builtins = [ ]	builtins is an empty list.
invalid_var_format_string = None	invalid_var_format_string is None.
class TemplateSyntaxError ( Exception ) :	derive the class TemplateSyntaxError form the base class Exception.
pass	do nothing.
class TemplateDoesNotExist ( Exception ) :	derive the class TemplateDoesNotExist form the base class Exception.
pass	do nothing.
class TemplateEncodingError ( Exception ) :	derive the class TemplateEncodingError form the base class Exception.
pass	do nothing.
@ python_2_unicode_compatible	python_2_unicode_compatible decorator,
class VariableDoesNotExist ( Exception ) :	derive the class VariableDoesNotExist form the base class Exception.
def __init__ ( self , msg , params = ( ) ) :	define the method __init__ with 3 arguments: self, msg and params set to an empty tuple.
self . msg = msg	substitute msg for self.msg.
self . params = params	substitute params for self.params.
def __str__ ( self ) :	define the method __str__ with an argument self.
return self . msg % tuple ( force_text ( p , errors = 'replace' ) for p in self . params )	return self.msg formatted with a tuple, with elements generated from return value of the function force_text with 2 arguments:
class InvalidTemplateLibrary ( Exception ) :	p and errors set to string 'replace', for p in self.params.   derive the class InvalidTemplateLibrary form the base class Exception.
pass	do nothing.
class Origin ( object ) :	derive the class Origin form the base class object.
def __init__ ( self , name ) :	define the method __init__ with 2 arguments: self and name.
self . name = name	substitute name for self.name.
def reload ( self ) :	define the method reload with an argument self.
raise NotImplementedError ( 'subclasses of Origin must provide a reload() method' )	raise an NotImplementedError exception with an argument string 'subclasses of Origin must provide a reload() method'.
def __str__ ( self ) :	define the method with reload with an argument self.
return self . name	return self.name.
class StringOrigin ( Origin ) :	derive the class StringOrigin form the base class Origin.
def __init__ ( self , source ) :	define the method __init__ with 2 arguments: self and source.
super ( StringOrigin , self ) . __init__ ( UNKNOWN_SOURCE )	call the method __init__ with an argument UNKNOWN_SOURCE, from the base class of the class StringOrigin.
self . source = source	substitute source for self.source.
def reload ( self ) :	define the method with reload with an argument self.
return self . source	return self.source.
class Template ( object ) :	derive the class Template form the base class object.
def __init__ ( self , template_string , origin = None , name = None ) :	define the method __init__ with 4 arguments: self, template_string, origin set to None and name set to None.
try :	try,
template_string = force_text ( template_string )	call the function force_text with an argument template_string.
except UnicodeDecodeError :	if UnicodeDecodeError exception is caught,
raise TemplateEncodingError ( 'Templates can only be constructed '  'from unicode or UTF-8 strings.' )	raise an TemplateEncodingError exception with an argument 'Templates can only be constructed from unicode or UTF-8 strings.'.
if settings . TEMPLATE_DEBUG and origin is None :	if settings.TEMPLATE_DEBUG is true and origin is None,
origin = StringOrigin ( template_string )	origin is an instance of StringOrigin class created with an argument template_string.
self . nodelist = compile_string ( template_string , origin )	call the function compile_string with 2 arguments: template_string and origin, substitute the result for self.nodelist.
self . name = name	substitute name for self.name.
self . origin = origin	substitute origin for self.origin.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
for node in self . nodelist :	for every node in self.nodelist,
for subnode in node :	for every subnode in node,
yield subnode	yield subnode.
def _render ( self , context ) :	define the method _render with 2 arguments self and context.
return self . nodelist . render ( context )	call the method self.nodelist.render with an argument context, return the result.
def render ( self , context ) :	define the method render with 2 arguments self and context.
context . render_context . push ( )	call the method context.render_context.push.
try :	try,
return self . _render ( context )	call the method self._render with an argument context, return the result,
finally :	finally perform,
context . render_context . pop ( )	remove the first element from context.render_context.
def compile_string ( template_string , origin ) :	define the method compile_string with 2 arguments: template_string and origin.
if settings . TEMPLATE_DEBUG :	if settings.TEMPLATE_DEBUG is true,
from django . template . debug import DebugLexer , DebugParser	from django.template.debug import DebugLexer and DebugParser.
lexer_class , parser_class = DebugLexer , DebugParser	substitute DebugLexer and DebugParser for lexer_class and parser_class.
else :	if not,
lexer_class , parser_class = Lexer , Parser	substitute Lexer and Parser for lexer_class and parser_class.
lexer = lexer_class ( template_string , origin )	call the method lexer_class with an arguments template_string and origin, substitute the result for lexer.
parser = parser_class ( lexer . tokenize ( ) )	call the method lexer.tokenize, use it as an argument for the call to the parser_class function, substitute the result for parser.
return parser . parse ( )	call the method parser.parse, return the result.
class Token ( object ) :	derive the class Token form the base class object.
def __init__ ( self , token_type , contents ) :	define the method __init__ with 3 arguments: self, token_type and contents.
self . token_type , self . contents = token_type , contents	substitute token_type and contents for self.token_type and self.contents.
self . lineno = None	self.lineno is None.
def __str__ ( self ) :	define the method __str__ with an argument self.
token_name = TOKEN_MAPPING [ self . token_type ]	substitute value under the self.token_type key of the TOKEN_MAPPING dictionary for token_name.
\return ( '<%s token: '%s...'>' %  ( token_name , self . contents [ : 20 ] . replace ( '\\n' , '' ) ) )\	return a string '<%s token: '%s...'>' with '%s', replace '%s' with token_name and 20 self.contents elements with every newline deleted.
def split_contents ( self ) :	define the method split_contents with an argument self.
split = [ ]	split is an empty list.
bits = iter ( smart_split ( self . contents ) )	call the function smart_split with an argument self.contents, substitute the result converted to an iterable for bits.
for bit in bits :	for every bit in bits,
sentinal = bit [ 2 ] + ')'	append ')' to third element of bit, substitute it for sentinal.
trans_bit = [ bit ]	trans_bit is a list with an element bit.
while not bit . endswith ( sentinal ) :	while bit doesnt end with sential,
bit = next ( bits )	call the method next with an argument bits, substitute the result for bit.
trans_bit . append ( bit )	append bit to trans_bit.
bit = ' ' . join ( trans_bit )	join trans_bit into a string separated with whitespaces, substitute the result for bit.
split . append ( bit )	append bit to split.
return split	return split.
class Lexer ( object ) :	derive the class Lexer form the base class object.
def __init__ ( self , template_string , origin ) :	define the method __init__ with 3 arguments: self, template_string and origin.
self . template_string = template_string	substitute template_string for self.template_string.
self . origin = origin	substitute origin for self.origin.
self . lineno = 1	self.lineno is integer 1.
self . verbatim = False	self.verbatim is boolean False.
def tokenize ( self ) :	define the method tokenize with an argument self.
in_tag = False	in_tag is boolean False.
result = [ ]	result is an empty list.
for bit in tag_re . split ( self . template_string ) :	split tag_re by self.template_string separator, for every bit in result,
if bit :	if bit is true,
result . append ( self . create_token ( bit , in_tag ) )	call the method self.create_token with 2 arguments bit and in_tag, append the result to result.
in_tag = not in_tag	in_tag is boolean True if in_tag is False, otherwise is boolean False.
return result	return result.
def create_token ( self , token_string , in_tag ) :	define the method create_token with 3 arguments: self, token_string and in_tag.
if in_tag and token_string . startswith ( BLOCK_TAG_START ) :	if in_tag is true and token_string starts with BLOCK_TAG_START.
block_content = token_string [ 2 : - 2 ] . strip ( )	take elements of token_string from second to second last element and strip the whitespaces surrounding the result,
if self . verbatim and block_content == self . verbatim :	substitute the result for block_content.   if self.verbatim is true and block_content equals self.verbatim,
self . verbatim = False	self.verbatim is boolean False.
if in_tag and not self . verbatim :	if in_tag and is not contained in self.verbatim,
if token_string . startswith ( VARIABLE_TAG_START ) :	if token_string starts with VARIABLE_TAG_START,
token = Token ( TOKEN_VAR , token_string [ 2 : - 2 ] . strip ( ) )	token is an instance of Token class, created with 2 arguments: TOKEN_VAR,
elif token_string . startswith ( BLOCK_TAG_START ) :	and elements of token_string from second to second last element wiht the whitespaces striped from the both sides.   otherwise if token_string starts with BLOCK_TAG_START,
if block_content [ : 9 ] in ( 'verbatim' , 'verbatim ' ) :	if first nine elements of block_content is string 'verbatim' or 'verbatim ',
self . verbatim = 'end%s' % block_content	append block_content to a string 'end', substitute the result for self.verbatim.
token = Token ( TOKEN_BLOCK , block_content )	token is an instance of Token class, created with 2 arguments: TOKEN_BLOCK and block_content.
elif token_string . startswith ( COMMENT_TAG_START ) :	otherwise if token_string starts with COMMENT_TAG_START,
content = ''	content is an empty string.
if token_string . find ( TRANSLATOR_COMMENT_MARK ) :	call the method token_string.find with an argument TRANSLATOR_COMMENT_MARK, if it evaluates to true,
content = token_string [ 2 : - 2 ] . strip ( )	take elements of token_string from second to second last element and strip the whitespaces surrounding the result,
token = Token ( TOKEN_COMMENT , content )	substitute the result for content.   token is an instance of Token class, created with 2 arguments: TOKEN_COMMENT and content.
else :	if not,
token = Token ( TOKEN_TEXT , token_string )	token is an instance of Token class, created with 2 arguments: TOKEN_TEXT and token_string.
token . lineno = self . lineno	substitute self.lineno for token.lineno.
\self . lineno += token_string . count ( '\\n' )\	\call the method token_string.count with an argument '\\n', append the result to self.lineno.\
return token	return token.
class Parser ( object ) :	derive the class Parser form the base class object.
def __init__ ( self , tokens ) :	define the method __init__ with 2 arguments: self and token.
self . tokens = tokens	substitute tokens for self.tokens.
self . tags = { }	self.tags is an empty dictionary.
self . filters = { }	self.filters is an empty dictionary.
for lib in builtins :	for every lib in builtins,
self . add_library ( lib )	call the method self.add_library with an argument lib.
def parse ( self , parse_until = None ) :	define the emethod parse with 2 arguments: self and parse_until set to None.
if parse_until is None :	if parse_until is None,
parse_until = [ ]	parse_until is an empty list,
nodelist = self . create_nodelist ( )	call the method self.create_nodelist, substitute the result for nodelist.
while self . tokens :	while self.tokens is true,
token = self . next_token ( )	call the method self.next_token, substitute the result for token.
if token . token_type == 0 :	if token.token_type equals integer 0,
self . extend_nodelist ( nodelist , TextNode ( token . contents ) , token )	call the method self.extend_nodelist with 3 arguments: nodelist, instance of TextNode class, created with an argument token.contents,
elif token . token_type == 1 :	and token.   otherwise if token.token_type equals integer 1,
if not token . contents :	if token.contents is false,
self . empty_variable ( token )	call the method self.empty_variable with an argument token,
try :	try,
filter_expression = self . compile_filter ( token . contents )	call the method self.compile_filter with an argument token.contents, substitute the result for filter_expression.
except TemplateSyntaxError as e :	if TemplateSyntaxError, replaced with e, exception is caught,
if not self . compile_filter_error ( token , e ) :	call the method self.compile_filter_error with 2 arguments: token and e, if it evaluates to false,
    raise	raise an exception,
var_node = self . create_variable_node ( filter_expression )	call the method self.create_variable_node with an argument filter_expression, substitute the result for var_node.
self . extend_nodelist ( nodelist , var_node , token )	call the method self.extend_nodelist with 3 arguments: nodelist, var_node and token.
elif token . token_type == 2 :	otherwise if token.token_type equals integer 2,
try :	try,
command = token . contents . split ( ) [ 0 ]	split token.contents into separate words, substitute the first element of the result for command.
except IndexError :	if IndexError exception is caught,
self . empty_block_tag ( token )	call the method self.empty_block_tag with an argument token.
if command in parse_until :	if command is contained in parse_until,
  self . prepend_token ( token )	call the method self.prepend_token with an argument token,
return nodelist	return nodelist.
self . enter_command ( command , token )	call the method self.enter_command with 2 arguments command and token.
try :	try,
compile_func = self . tags [ command ]	substitute the value under the command key of self.tags dictionary for compile_func.
except KeyError :	if KeyError exception is caught,
self . invalid_block_tag ( token , command , parse_until )	call the method self.invalid_block_tag with 3 arguments: token, command and parse_until.
try :	try,
compiled_result = compile_func ( self , token )	call the method compile_func with 2 arguments self and token, substitute the result for compiled_result.
except TemplateSyntaxError as e :	if TemplateSyntaxError, renamed to e, exception is caught,
if not self . compile_function_error ( token , e ) :	call the method self.compile_function_error with 2 arguments token and e, if it evaluates to false,
    raise	raise an exception,
self . extend_nodelist ( nodelist , compiled_result , token )	call the method self.extend_nodelist with 3 arguments: nodelist, compiled_result and token.
self . exit_command ( )	call the method self.exit_command.
if parse_until :	if parse_until is true,
self . unclosed_block_tag ( parse_until )	call the method self.unclosed_block_tag with an argument parse_until.
return nodelist	return nodelist.
def skip_past ( self , endtag ) :	define the method skip_past with 2 arguments: self and endtag.
while self . tokens :	while self.tokens is true,
token = self . next_token ( )	call the method self.next_token, substitute the result for token.
if token . token_type == TOKEN_BLOCK and token . contents == endtag :	if token.token_type equals TOKEN_BLOCK and token.contents equals endtag,
return	return nothing.
self . unclosed_block_tag ( [ endtag ] )	call the method self.unclosed_block_tag with an argument list with an element endtag.
def create_variable_node ( self , filter_expression ) :	define the method create_variable_node with 2 arguments self and filter_expression.
return VariableNode ( filter_expression )	return an instance of VariableNode class with an argument filter_expression.
def create_nodelist ( self ) :	define the method create_nodelist with an argument self.
return NodeList ( )	return an instance of NodeList class.
def extend_nodelist ( self , nodelist , node , token ) :	define the method extend_nodelist with 4 arguments: self, nodelist, node and token.
if node . must_be_first and nodelist :	if node.must_be_first is true and nodelist is true,
try :	try,
if nodelist . contains_nontext :	if nodelist.contains_nontext is true,
raise AttributeError	raise AttributeError exception,
except AttributeError :	if AttributeError exception is raised,
raise TemplateSyntaxError ( '%r must be the first tag '  'in the template.' % node )	raise TemplateSyntaxError('%r must be the first tag in the template.', where '%s' is replaced with node.
if isinstance ( nodelist , NodeList ) and not isinstance ( node , TextNode ) :	if nodelist is an instance of NodeList and node is not an instance of TextNode class.
nodelist . contains_nontext = True	nodelist.contains_nontext is boolean True.
nodelist . append ( node )	append node to nodelist.
def enter_command ( self , command , token ) :	define the method enter_command with 3 arguments: self, command and token.
pass	do nothing.
def exit_command ( self ) :	define the method exit_command with an argument self.
pass	do nothing.
def error ( self , token , msg ) :	define the method enter_command with 3 arguments: self, token and msg.
return TemplateSyntaxError ( msg )	return an instance of TemplateSyntaxError class with an argument msg.
def empty_variable ( self , token ) :	define the method empty_variable with 2 arguments: self and token.
raise self . error ( token , 'Empty variable tag' )	call the method self.error with 2 arguments: token and string 'Empty variable tag', return the result.
def empty_block_tag ( self , token ) :	define the method empty_block_tag with 2 arguments: self and token.
raise self . error ( token , 'Empty block tag' )	call the method self.error with 2 arguments: token and string 'Empty block tag', return the result.
def invalid_block_tag ( self , token , command , parse_until = None ) :	define the method invalid_block_tag with 4 arguments: self, token, command and parse_until as None.
if parse_until :	if parse_until is true,
def unclosed_block_tag ( self , parse_until ) :	return the result.   define the method unclosed_block_tag with 2 arguments: self and parse_until.
raise self . error ( None , 'Unclosed tags: %s ' % ', ' . join ( parse_until ) )	raise an self.error with 2 arguments: None and string 'Unclosed tags: %s ',
def compile_filter_error ( self , token , e ) :	where '%s' is replaced with parse_until elements joined into a string, separated with ', '.   define the method compile_filter_error with 3 arguments: self, token and e.
pass	do nothing.
def compile_function_error ( self , token , e ) :	define the method compile_function_error with 3 arguments: self, token and e.
pass	do nothing.
def next_token ( self ) :	define the method next_token with an argument self.
return self . tokens . pop ( 0 )	remove first element from self.tokens, return removed element.
def prepend_token ( self , token ) :	define the function prepend_token with 2 arguments: self and token.
self . tokens . insert ( 0 , token )	insert token at the beginning of self.tokens.
def delete_first_token ( self ) :	define the method delete_first_token with an argument self.
del self . tokens [ 0 ]	delete the first element of self.tokens.
def add_library ( self , lib ) :	define the function add_library with 2 arguments: self and lib.
self . tags . update ( lib . tags )	update self.tags dictionary with lib.tags.
self . filters . update ( lib . filters )	update self.filters dictionary with lib.filters.
def compile_filter ( self , token ) :	define the function compile_filter with 2 arguments: self and token.
return FilterExpression ( token , self )	return an instance of FilterExpression class, created with 2 arguments: token and self.
def find_filter ( self , filter_name ) :	define the function find_filter with 2 arguments: self and filter_name.
if filter_name in self . filters :	if filter_name is contained in self.filters,
return self . filters [ filter_name ]	return the value under the filter_name key of the self.filters dictionary.
else :	if not,
class TokenParser ( object ) :	derive the class TokenParser form the base class object.
def __init__ ( self , subject ) :	define the function next_space_index with 2 arguments: self and subject.
self . subject = subject	substitute subject for self.subject.
self . pointer = 0	self.pointer is integer 0.
self . backout = [ ]	self.backout is an empty list.
self . tagname = self . tag ( )	call the method self.tag, substitute the result for self.tagname.
def top ( self ) :	define the method top with an argument self.
raise NotImplementedError ( 'subclasses of Tokenparser must provide a top() method' )	raise an NotImplementedError with an argument string 'subclasses of Tokenparser must provide a top() method'.
def more ( self ) :	define the method more with an argument self.
return self . pointer < len ( self . subject )	if self.pointer is smaller than length of self.subject, return boolean True, otherwise return False.
def back ( self ) :	define the method back with an argument self.
if not len ( self . backout ) :	if length of self.backout is greater than zero,
raise TemplateSyntaxError ( 'back called without some previous '  'parsing' )	raise an TemplateSyntaxError exception with an argument string 'back called without some previous parsing'.
self . pointer = self . backout . pop ( )	remove the first element from self.backout, substitute the result for self.pointer.
def tag ( self ) :	define the method tag with an argument self.
subject = self . subject	substitute self.subject for subject.
i = self . pointer	substitute self.pointer for i.
if i >= len ( subject ) :	if i is greater than or equal to length of subject.
raise TemplateSyntaxError ( 'expected another tag, found '  'end of string: %s' % subject )	raise an TemplateSyntaxError exception with an argument string 'expected another tag, found end of string: %s',
p = i	where '%s' is replaced with subject.   substitute i for p.
\while i < len ( subject ) and subject [ i ] not in ( ' ' , '\\t' ) :\	while i is lesser than length of subject and i-th element of subject is not an empty space or tab character,
i += 1	increment i by integer 1.
s = subject [ p : i ]	take subject elements from p-th to i-th index, substitute it for s.
\while i < len ( subject ) and subject [ i ] in ( ' ' , '\\t' ) :\	while i is lesser than length of subject and i-th element of subject is an empty space or tab character,
i += 1	increment i by integer 1.
self . backout . append ( self . pointer )	append self.pointer to self.backout.
self . pointer = i	substitute i for self.pointer.
return s	return s.
def value ( self ) :	define the method value with an argument self.
subject = self . subject	substitute self.subject for subject.
i = self . pointer	substitute self.pointer for i.
def next_space_index ( subject , i ) :	define the next_space_index with 2 arguments: subject and i.
\while i < len ( subject ) and subject [ i ] not in ( ' ' , '\\t' ) :\	while i is lesser than length of subject and i-th element of subject is not an empty space or tab character,
c = subject [ i ]	substitute i-th element of subject for c.
i += 1	increment i by integer 1.
while i < len ( subject ) and subject [ i ] != c :	while i is lesser than length of subject and i-th element of subject is not equal to c,
    i += 1	increment i by one.
if i >= len ( subject ) :	if i is greater than, or equal to subject,
    raise TemplateSyntaxError ( 'Searching for value. '  'Unexpected end of string in column %d: %s' %  ( i , subject ) )	raise an TemplateSyntaxError exception with an argument string 'Searching for value. Unexpected end of string in column %d: %s',
i += 1	where '%d' is replaced with i and '%s' is replaced with subject.   increment i by one.
return i	return i.
if i >= len ( subject ) :	if i is greater than or equal to length of subject,
raise TemplateSyntaxError ( 'Searching for value. Expected another '  'value but found end of string: %s' %  subject )	raise an TemplateSyntaxError exception with an argument 'Searching for value. Expected another value but found end of string: %s',
p = i	substitute i for p.
i += 1	increment i by integer 1,
while i < len ( subject ) and subject [ i ] != subject [ p ] :	while i is lesser than length of subject and i-th element of subject is not equal to p-th element of subject,
i += 1	increment i by integer 1,
if i >= len ( subject ) :	if i is greater than length of subject,
raise TemplateSyntaxError ( 'Searching for value. Unexpected '  'end of string in column %d: %s' %  ( i , subject ) )	raise an TemplateSyntaxError exception with an argument string 'Searching for value. Unexpected end of string in column %d: %s',
i += 1	where '%d' is replaced with i and '%s' is replaced with subject.   increment i by integer 1,
i = next_space_index ( subject , i )	call the function next_space_index with 2 arguments: subject and i, substitute the result for i.
res = subject [ p : i ]	substitute subject elements from p-th to i-th index for res.
\while i < len ( subject ) and subject [ i ] in ( ' ' , '\\t' ) :\	while i is lesser than length of subject and i-th element of subject is an empty space or tab character.
i += 1	increment i by integer 1,
self . backout . append ( self . pointer )	append self.pointer to self.backout.
self . pointer = i	substitute i for self.pointer.
return res	return res.
else :	if not,
p = i	substitute i for p.
i = next_space_index ( subject , i )	call the function next_space_index with 2 arguments subject and i, substitute the result for i.
s = subject [ p : i ]	take subject elements from p-th to i-th index, substitute it for s.
\while i < len ( subject ) and subject [ i ] in ( ' ' , '\\t' ) :\	while i is lesser than length of subject and i-th element of subject is an empty space or tab character.
i += 1	increment i by integer 1,.
self . backout . append ( self . pointer )	append self.pointer to self.backout.
self . pointer = i	substitute i for self.pointer.
return s	return s.
\filter_raw_string = r''' ^(?P<constant>%(constant)s)| ^(?P<var>[%(var_chars)s]+|%(num)s)|  (?:\\s*%(filter_sep)s\\s*      (?P<filter_name>\\w+)          (?:%(arg_sep)s              (?:               (?P<constant_arg>%(constant)s)|               (?P<var_arg>[%(var_chars)s]+|%(num)s)              )          )?  )''' % {  'constant' : constant_string ,  'num' : r'[-+\\.]?\\d[\\d\\.e]*' ,  'var_chars' : '\\w\\.' ,  'filter_sep' : re . escape ( FILTER_SEPARATOR ) ,  'arg_sep' : re . escape ( FILTER_ARGUMENT_SEPARATOR ) ,  }\	\filter_raw_string is a raw string '^(?P<constant>%(constant)s)|^(?P<var>[%(var_chars)s]+|%(num)s)| (?:\\s*%(filter_sep)s\\s*\
filter_re = re . compile ( filter_raw_string , re . UNICODE | re . VERBOSE )	\(?P<filter_name>\\w+)(?:%(arg_sep)s(?:(?P<constant_arg>%(constant)s)|(?P<var_arg>[%(var_chars)s]+|%(num)s)))?)',   where 'constant' is replaced with constant_string, 'num' with raw string '[-+\\.]?\\d[\\d\\.e]*', 'var_chars' with string '\\w\\.',   'filter_sep' with result of the function re.escape called with an argument FILTER_SEPARATOR,   anbd 'arg_sep' with result of the function re.escape called with an argument FILTER_ARGUMENT_SEPARATOR.   call the function re.compile with 2 arguments: filter_raw_string and result for bitwise OR on 2 operands re.UNICODE and re.VERBOSE,\
class FilterExpression ( object ) :	substitute the result for filter_re.   derive the class FilterExpression form the base class object.
def __init__ ( self , token , parser ) :	define the function __init__ with 3 arguments: self, token and parser.
self . token = token	substitute token for self.token.
matches = filter_re . finditer ( token )	call the method filter_re.finditer with an argument token, substitute the result for matches.
var_obj = None	var_obj is None.
filters = [ ]	filters is an empty list.
upto = 0	upto is integer 0.
for match in matches :	for every match in matches,
start = match . start ( )	call the method match.start, substitute the result for start.
if upto != start :	if upto is not equal to start.
raise TemplateSyntaxError ( 'Could not parse some characters: '  '%s|%s|%s' %  ( token [ : upto ] , token [ upto : start ] ,  token [ start : ] ) )	raise an TemplateSyntaxError exception with an argument string 'Could not parse some characters: %s|%s|%s',
if var_obj is None :	where '%s' is replaced with first upto elements of token string, token string elements from upto to start index,   and token string elements from start index to the end.   if var_obj is None,
var , constant = match . group ( 'var' , 'constant' )	call the method match.group with 2 arguments: strings 'var' and 'constant', substitute the result for var and constant, respectively.
if constant :	if constant is true,
try :	try,
    var_obj = Variable ( constant ) . resolve ( { } )	instantiate Variable class, with an argument constant, call the resolve method with an empty dictionary as an argument, substitute the result for var_obj.
except VariableDoesNotExist :	if VariableDoesNotExist exception is not caught,
    var_obj = None	var_obj is None.
elif var is None :	otherwise if var is None,
raise TemplateSyntaxError ( 'Could not find variable at '  'start of %s.' % token )	raise an TemplateSyntaxError exception with an argument 'Could not find variable at start of %s.', replace '%s' with token.
else :	if not,
var_obj = Variable ( var )	var_obj is an instance of Variable class, created with an argument var.
else :	if not,
filter_name = match . group ( 'filter_name' )	call the methof match.group with an argument 'filter_name', substitute the result for filter_name.
args = [ ]	args is an empty list.
constant_arg , var_arg = match . group ( 'constant_arg' , 'var_arg' )	call the method match.group with 2 arguments: strings 'constant_arg' and 'var_arg', substitute the result for constant_arg,
if constant_arg :	and var_arg, respectively.   if constant_arg is true,
args . append ( ( False , Variable ( constant_arg ) . resolve ( { } ) ) )	take a tuple with 2 elements: boolean False and method resolve called with an empty dictionary on the instance of Variable class,
elif var_arg :	created with an argument constant_arg, append it to args.   otherwise if var_arg is true,
args . append ( ( True , Variable ( var_arg ) ) )	take a tuple with 2 elements: boolean False and instance of Variable class, created with an argument constant_arg, append it to args.
filter_func = parser . find_filter ( filter_name )	call the method parser.find_filter with an argument filter_name, substitute the result for filter_func.
self . args_check ( filter_name , filter_func , args )	call the method self.args_check with 3 arguments: filter_name, filter_func and args.
filters . append ( ( filter_func , args ) )	append a tuple with 2 arguments: filter_func and args to filters.
upto = match . end ( )	call the method match.end, substitute the result for upto.
if upto != len ( token ) :	if upto is not equal to length of token,
self . filters = filters	where '%s' is replaced with elemnts of token from upto index till the end, and token.   substitute filters for self.filters.
self . var = var_obj	substitute var_obj for self.var.
def resolve ( self , context , ignore_failures = False ) :	define the method resolve with 3 arguments: self, context and ignore_failures set to boolean False.
if isinstance ( self . var , Variable ) :	if self.var is an instance of Variable class,
try :	try,
obj = self . var . resolve ( context )	call the method self.var.resolve with an argument context, substitute it for obj.
except VariableDoesNotExist :	if VariableDoesNotExist exception is caught,
if ignore_failures :	if ignore_failures is true,
obj = None	obj is None,
else :	if not,
if settings . TEMPLATE_STRING_IF_INVALID :	if settings.TEMPLATE_STRING_IF_INVALID is true,
    global invalid_var_format_string	use global variable invalid_var_format_string.
if invalid_var_format_string is None :	if invalid_var_format_string is None,
        invalid_var_format_string = '%s' in settings . TEMPLATE_STRING_IF_INVALID	if '%s' is contained in settings.TEMPLATE_STRING_IF_INVALID, invalid_var_format_string is boolean True, otherwise it is False.
if invalid_var_format_string :	if invalid_var_format_string is true,
        return settings . TEMPLATE_STRING_IF_INVALID % self . var	format settings.TEMPLATE_STRING_IF_INVALID with self.var, return the result.
return settings . TEMPLATE_STRING_IF_INVALID	return settings.TEMPLATE_STRING_IF_INVALID.
else :	if not,
    obj = settings . TEMPLATE_STRING_IF_INVALID	substitute settings.TEMPLATE_STRING_IF_INVALID with obj.
else :	if not,
obj = self . var	substitute self.var for obj.
for func , args in self . filters :	for every func and args in self.filters,
arg_vals = [ ]	arg_vals is an empty list,
for lookup , arg in args :	for every lookup and arg in args,
if not lookup :	if lookup is false,
arg_vals . append ( mark_safe ( arg ) )	call the function mark_safe with an argument arg, append it to arg_vals.
else :	if not,
arg_vals . append ( arg . resolve ( context ) )	call the method arg.resolve with an argument context, append the result to arg_vals.
if getattr ( func , 'expects_localtime' , False ) :	if 'expects_localtime' attribute of func object exists and is true,
obj = template_localtime ( obj , context . use_tz )	call the function template_localtime with 2 arguments: obj and context.use_tz, substitute the result for obj.
if getattr ( func , 'needs_autoescape' , False ) :	if 'needs_autoescape' attribute of func object exists and is true,
new_obj = func ( obj , autoescape = context . autoescape , * arg_vals )	call the function func with 3 arguments: obj, autoescape set to context.autoescape and unpacked list arg_vals,
else :	substitute the result for new_obj.   if not,
new_obj = func ( obj , * arg_vals )	call the function func with 2 arguments: obj and unpacked list arg_vals, substitute the result for new_obj.
if getattr ( func , 'is_safe' , False ) and isinstance ( obj , SafeData ) :	if 'is_safe' attribute of func object exists and is true and obj is an instance of SafeData,
obj = mark_safe ( new_obj )	call the function mark_safe with an argument new_obj, substitute the result for obj.
elif isinstance ( obj , EscapeData ) :	otherwise if obj is an instance of EscapeData,
obj = mark_for_escaping ( new_obj )	call the function mark_for_escaping with an argument new_obj, substitute the result for obj.
else :	if not,
obj = new_obj	substitute new_obj for obj.
return obj	return obj.
def args_check ( name , func , provided ) :	define the method args_check with 3 arguments: name, func and provided.
provided = list ( provided )	convert provided into a list and substitute it for provided.
plen = len ( provided ) + 1	calculate length of provided and increment it by one, substitute the result for plen.
func = getattr ( func , '_decorated_function' , func )	get the '_decorated_function' attribute from func object, if it exists substitute it for func.
args , varargs , varkw , defaults = getargspec ( func )	call the function getargspec with an argument func, substitute the result for args, varargs, varkw and defaults, respectively.
alen = len ( args )	calculate the length of args, substitute it for alen.
dlen = len ( defaults or [ ] )	substitute the length of defaults for dlen.
if plen < ( alen - dlen ) or plen > alen :	if plen is lesser than difference of alen and dlen, or if plen is greater than alen,
raise TemplateSyntaxError ( '%s requires %d arguments, %d provided' %  ( name , alen - dlen , plen ) )	raise an TemplateSyntaxError exception with an argument string '%s requires %d arguments, %d provided',
return True	where '%d' is replaced with name, dlen subtracted from alen, and plen.   return boolean True.
args_check = staticmethod ( args_check )	args_check is a static method.
def __str__ ( self ) :	define the method __str__ with an argument self.
return self . token	return self.token.
def resolve_variable ( path , context ) :	define the method resolve_variable with 2 arguments: path and context.
warnings . warn ( 'resolve_variable() is deprecated. Use django.template.'  'Variable(path).resolve(context) instead' ,  RemovedInDjango20Warning , stacklevel = 2 )	call the function warnings.warn with 3 arguments:
return Variable ( path ) . resolve ( context )	string 'resolve_variable() is deprecated. Use django.template. Variable(path).resolve(context) instead', RemovedInDjango20Warning,   and stacklevel set to integer 2.   call the method resolve with an argument context, from the instance of Variable class, created with an argument path.
class Variable ( object ) :	derive the class Variable form the base class object.
def __init__ ( self , var ) :	define the method __init__ with 2 arguments self and var.
self . var = var	substitute var for self.var.
self . literal = None	self.literal is None,
self . lookups = None	self.lookups is None.
self . translate = False	self.translate is boolean False.
self . message_context = None	self.message_context is None.
if not isinstance ( var , six . string_types ) :	if var is not an instance of six.string_types,
raise TypeError (  'Variable must be a string or number, got %s' % type ( var ) )	raise an TypeError exception with an argument string 'Variable must be a string or number, got %s', replace '%s' with type of var.
try :	try,
self . literal = float ( var )	convert var into an floating point number, substitute it for self.literal.
if '.' not in var and 'e' not in var . lower ( ) :	if '.' is not contained in var and 'e' is not contained in var converted into lowercase,
self . literal = int ( self . literal )	convert self.literal into an integer, substitute it for self.literal.
if var . endswith ( '.' ) :	if var ends with '.',
raise ValueError	raise an ValueError exception.
except ValueError :	if ValueError exception is caught,
if var . startswith ( '_(' ) and var . endswith ( ')' ) :	if var starts with '_(' and var ends with ')',
self . translate = True	self.translate is boolean True.
var = var [ 2 : - 1 ]	remove first 2 and last 2 elements from var.
try :	try,
self . literal = mark_safe ( unescape_string_literal ( var ) )	call the function unescape_string_literal with an argument var, use it as an argument for the call to the function mark_safe,
except ValueError :	substitute the result for self.literal.   if ValueError exception is caught,
if var . find ( VARIABLE_ATTRIBUTE_SEPARATOR + '_' ) > - 1 or var [ 0 ] == '_' :	call the function var.find with an argument: '_' appended to VARIABLE_ATTRIBUTE_SEPARATOR, if the result is greater than integer -1,
self . lookups = tuple ( var . split ( VARIABLE_ATTRIBUTE_SEPARATOR ) )	where '%s' is replaced with var.   call the method var.split with an argument VARIABLE_ATTRIBUTE_SEPARATOR, convert the result to a tuple and substitute it for self.lookups.
def resolve ( self , context ) :	define the method resolve with 2 arguments: self and context.
if self . lookups is not None :	if self.lookups is not None,
value = self . _resolve_lookup ( context )	call the function self._resolve_lookup with an argument context, substitute the result for value.
else :	if else,
value = self . literal	substitute self.literal for value.
if self . translate :	if self.translate is true,
if self . message_context :	if self.message_context is true,
return pgettext_lazy ( self . message_context , value )	call the function pgettext_lazy with an argument self.message_context and value, return the result.
else :	if not,
return ugettext_lazy ( value )	call the function ugettext_lazy with an argument value, return the result.
return value	return value.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return '<%s: %r>' % ( self . __class__ . __name__ , self . var )	return an string '<%s: %r>', where '%s' is replaced with self.__class__.__name__ and self.var, respectively.
def __str__ ( self ) :	define the method __str__ with an argument self.
return self . var	return self.var.
def _resolve_lookup ( self , context ) :	define the method _resolve_lookup with 2 arguments: self and context.
current = context	substitute context for current.
try :	try,
for bit in self . lookups :	for bit in self.lookups,
try :	try,
current = current [ bit ]	substitute element at the bit index of current for current.
except ( TypeError , AttributeError , KeyError , ValueError ) :	if TypeError, AttributeError, KeyError or ValueError exceptions are caught,
try :	try,
      if isinstance ( current , BaseContext ) and getattr ( type ( current ) , bit ) :	if current is an instance of BaseContext and bit attribute of type of current is true,
        raise AttributeError	raise an AttributeError exception.
current = getattr ( current , bit )	get the bit attribute of current object, substitute it for current.
except ( TypeError , AttributeError ) :	if TypeError and AttributeError exceptions are caught,
    try :	try,
        current = current [ int ( bit ) ]	convert bit to an integer and use it as index to obtain an element for list current, substitute it for current.
except ( IndexError ,  ValueError ,  KeyError ,  TypeError ) :	if IndexError, ValueError, KeyError or TypeError exceptions are caught,
        raise VariableDoesNotExist ( 'Failed lookup for key '  '[%s] in %r' ,  ( bit , current ) )	raise an VariableDoesNotExist exception with an argument string 'Failed lookup for key [%s] in %r',
if callable ( current ) :	where '%s' is replaced with bit and '%r' is replaced with current.   if current is callable object,
if getattr ( current , 'do_not_call_in_templates' , False ) :	get the 'do_not_call_in_templates' attribute of current object, if it exists and is true,
    pass	do nothing.
elif getattr ( current , 'alters_data' , False ) :	otherwise, get the 'alters_data' attribute of current object, if it exists and is true,
    current = settings . TEMPLATE_STRING_IF_INVALID	substitute settings.TEMPLATE_STRING_IF_INVALID for current.
else :	if not,
    try :	try,
        current = current ( )	call the function current, substitute the result for current.
except TypeError :	if TypeError exception is caught,
        try :	try,
            getcallargs ( current )	call the function getcallargs with an argument current,
except TypeError :	if TypeError exception is caught,
            current = settings . TEMPLATE_STRING_IF_INVALID	substitute settings.TEMPLATE_STRING_IF_INVALID for current,
else :	if not,
            raise	raise an exception,
except Exception as e :	if Exception, renamed to e, exception is caught,
if getattr ( e , 'silent_variable_failure' , False ) :	get the 'silent_variable_failure' attribute of e object, if it exists and is true,
current = settings . TEMPLATE_STRING_IF_INVALID	substitute settings.TEMPLATE_STRING_IF_INVALID for current.
else :	if not,
raise	raise an exception.
return current	return current.
class Node ( object ) :	derive the class Node form the base class object.
must_be_first = False	must_be_first is boolean False.
child_nodelists = ( 'nodelist' , )	child_nodelists is an tuple with an element 'nodelist'.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
pass	do nothing.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
yield self	yield self.
def get_nodes_by_type ( self , nodetype ) :	define the method get_nodes_by_type with 2 arguments: self and nodetype.
nodes = [ ]	nodes is an empty list.
if isinstance ( self , nodetype ) :	if self is an instance of nodetype,
nodes . append ( self )	append self to nodes.
for attr in self . child_nodelists :	for every attr in self.child_nodelists,
nodelist = getattr ( self , attr , None )	get attr attribute of self object, if it exists substitute it for nodelist, if not nodelist is None.
if nodelist :	if nodelist is true,
nodes . extend ( nodelist . get_nodes_by_type ( nodetype ) )	call the method nodelist.get_nodes_by_type with an argument nodetype, extend nodes with the result.
return nodes	return nodes.
class NodeList ( list ) :	derive the class NodeList form the base class list.
contains_nontext = False	contains_nontext is boolean False.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
bits = [ ]	bits is an empty list.
for node in self :	for every node in self,
if isinstance ( node , Node ) :	if node is an instance of Node,
bit = self . render_node ( node , context )	call the method self.render_node with 2 arguments: node and context, substitute the result for bit.
else :	if not,
bit = node	substitute node for bit.
bits . append ( force_text ( bit ) )	call the function force_text with an argument bit, append the result to bits.
return mark_safe ( '' . join ( bits ) )	call the function mark_safe with an argument, elements of bits joined into a string, return the result.
def get_nodes_by_type ( self , nodetype ) :	define the method get_nodes_by_type with 2 arguments: self and nodetype.
nodes = [ ]	modes is an empty list.
for node in self :	for every node in self,
nodes . extend ( node . get_nodes_by_type ( nodetype ) )	call the method node.get_nodes_by_type with an argument nodetype, extend nodes with it.
return nodes	return nodes.
def render_node ( self , node , context ) :	define the method render_node with 3 arguments: self, node and context.
return node . render ( context )	call the method node.render with an argument context, return the result.
class TextNode ( Node ) :	derive the class TextNode form the base class Node.
def __init__ ( self , s ) :	define the method __init__ with 2 arguments: self and s.
self . s = s	substitute s for self.s.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return force_str ( '<Text Node: '%s'>' % self . s [ : 25 ] , 'ascii' ,  errors = 'replace' )	call the function force_str with 3 arguments: string '<Text Node: '%s'>', with '%s' replaced with first 25 elements of self.s string,
def render ( self , context ) :	string 'ascii' and errors set to a string 'replace', return the result.   define the method render with 2 arguments: self and context.
return self . s	return self.s.
def render_value_in_context ( value , context ) :	define the function render_value_in_context with 2 arguments: value and context.
value = template_localtime ( value , use_tz = context . use_tz )	call the method template_localtime with 2 arguments: value and use_tz=context.use_tz, substitute the result for value.
value = localize ( value , use_l10n = context . use_l10n )	call the function localize with 2 arguments: value and use_l10n=context.use_l10n, substitute the result for value.
value = force_text ( value )	call the function force_text with an argument value, substitute the result for value.
if ( ( context . autoescape and not isinstance ( value , SafeData ) ) or  isinstance ( value , EscapeData ) ) :	if context.autoescape is true and value is not an instance of SafeData, or value is an instance of EscapeData,
return escape ( value )	call the function escape with an argument value, return the result.
else :	if not,
return value	return value.
class VariableNode ( Node ) :	derive the class VariableNode form the base class Node.
def __init__ ( self , filter_expression ) :	define the method __init__ with 2 arguments: self and filter_expression.
self . filter_expression = filter_expression	substitute filter_expression for self.filter_expression.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return '<Variable Node: %s>' % self . filter_expression	return a string '<Variable Node: %s>', substitute '%s' with self.filter_expression.
def render ( self , context ) :	define the method render with 2 arguments self and context.
try :	try,
output = self . filter_expression . resolve ( context )	call the method self.filter_expression.resolve with an argument context, substitute the result for output.
except UnicodeDecodeError :	if UnicodeDecodeError exception is caught,
return ''	return an empty string.
return render_value_in_context ( output , context )	call the function render_value_in_context with 2 arguments output and context, return the result.
\kwarg_re = re . compile ( r'(?:(\\w+)=)?(.+)' )\	\call the function re.compile with an argument raw string '(?:(\\w+)=)?(.+)', substitute the result for kwarg_re.\
def token_kwargs ( bits , parser , support_legacy = False ) :	define the method token_kwargs: bits, parser and support_legacy set to boolean False.
if not bits :	if bits is false,
return { }	return an empty dictionary.
match = kwarg_re . match ( bits [ 0 ] )	call the method kwarg_re.match with an argument first element of bits, substitute the result for match.
kwarg_format = match and match . group ( 1 )	if match is true and call to the method match.group with an argument integer 1 evaluates to true, kwarg_format is boolean True,
if not kwarg_format :	otherwise it is boolean False.   if kwarg_format is false,
if not support_legacy :	if support_legacy is false,
return { }	return an empty dictionary.
if len ( bits ) < 3 or bits [ 1 ] != 'as' :	if length of bits is lesser than integer 3 or second element of bits is not equal to string 'as',
return { }	return an empty dictionary.
kwargs = { }	kwargs is an empty dictionary,
while bits :	while bits is true,
if kwarg_format :	if kwarg_format is true,
match = kwarg_re . match ( bits [ 0 ] )	call the method kwarg_re.match with an argument first element of bits, substitute the result for match.
if not match or not match . group ( 1 ) :	if match is false or call to the method match.group with an argument integer 1 evaluates to boolean false,
return kwargs	return kwargs.
key , value = match . groups ( )	call the method match.groups with 2 arguments: key and value.
del bits [ : 1 ]	delete first element of bits.
else :	if not,
if len ( bits ) < 3 or bits [ 1 ] != 'as' :	if length of bits is lesser than integer 3 or second element of bits is not equal to string 'as',
return kwargs	return kwargs.
key , value = bits [ 2 ] , bits [ 0 ]	substitute third and first element of bits for key and value, respectively.
del bits [ : 3 ]	delete first 3 elements of bits.
kwargs [ key ] = parser . compile_filter ( value )	call the method parser.compile_filter with an argument value, substitute the result for value under the key key of kwargs dictionary.
if bits and not kwarg_format :	if bits is true and kwarg_format is false,
if bits [ 0 ] != 'and' :	if first element of bits is not equal to string 'and',
return kwargs	return kwargs.
del bits [ : 1 ]	delete first element of bits.
return kwargs	return kwargs.
def parse_bits ( parser , bits , params , varargs , varkw , defaults ,  takes_context , name ) :	define the function parse_bits with 8 arguments: parser, bits, params, varargs, varkw, defaults, takes_context and name.
if takes_context :	if takes_context is true,
if params [ 0 ] == 'context' :	if first element of params equals a string 'context',
params = params [ 1 : ]	substitute params without the first element for params.
else :	if not,
args = [ ]	where '%s' is replaced with name.   args is an empty list.
kwargs = { }	kwargs is an empty dictionary.
unhandled_params = list ( params )	convert params into a list, substitute it for unhandled_params.
for bit in bits :	for every bit in bits,
kwarg = token_kwargs ( [ bit ] , parser )	call the function
if kwarg :	if kwarg is true,
param , value = list ( six . iteritems ( kwarg ) ) [ 0 ]	call the method six.iteritems with an argument kwarg, convert the result into a list,
if param not in params and varkw is None :	substitute first element of the result for param and value.   if param is not in params and varkw is None,
elif param in kwargs :	where '%s' are replaced with name and param.   otherwise if param is contained in kwargs,
else :	where '%s' are replaced with name and param.   if not,
kwargs [ str ( param ) ] = value	convert param to a string, use it as a key to get the value from kwargs dictionary, assign it value.
if param in unhandled_params :	if param is contained in unhandled_params,
  unhandled_params . remove ( param )	call the method unhandled_params.remove with an argument param.
else :	if not,
if kwargs :	if kwargs is true,
else :	if not,
args . append ( parser . compile_filter ( bit ) )	call the method parser.compile_filter with an argument bit, append the result to args.
try :	try,
  unhandled_params . pop ( 0 )	remove first element of unhandled_params.
except IndexError :	if IndexError exception is caught,
if varargs is None :	if varargs is None,
if defaults is not None :	where '%s' is replaced with name.   if defaults is not None,
unhandled_params = unhandled_params [ : - len ( defaults ) ]	slice list unhandled_params from the beginning to the length of defaults last element,
if unhandled_params :	if unhandled_params is true,
return args , kwargs	return args and kwargs.
def generic_tag_compiler ( parser , token , params , varargs , varkw , defaults ,  name , takes_context , node_class ) :	define the method generic_tag_compiler with 9 arguments: parser, token, params, varargs, varkw, defaults, name, takes_context,
bits = token . split_contents ( ) [ 1 : ]	call the function token.split_contents, substitute the result without the first element for bits.
args , kwargs = parse_bits ( parser , bits , params , varargs , varkw ,  defaults , takes_context , name )	call the method parse_bits with 8 arguments: parser, bits, params, varargs, varkw, defaults, takes_context and name,
return node_class ( takes_context , args , kwargs )	substitute the result for args and kwargs, respectively.   call the function node_class with 3 arguments: takes_context, args and kwargs.
class TagHelperNode ( Node ) :	derive the class TagHelperNode form the base class Node.
def __init__ ( self , takes_context , args , kwargs ) :	define the method __init__ with 4 arguments: self, takes_context, args and kwargs.
self . takes_context = takes_context	substitute takes_context for self.takes_context.
self . args = args	substitute args for self.args.
self . kwargs = kwargs	substitute kwargs for self.kwargs.
def get_resolved_arguments ( self , context ) :	define the method get_resolved_arguments with 2 arguments: self and context.
resolved_args = [ var . resolve ( context ) for var in self . args ]	resolved_args is an list with elements, return value of the method var.resolve with an argument context, for every var in self.args.
if self . takes_context :	if self.takes_context is true,
resolved_args = [ context ] + resolved_args	append resolved_args to a list containing context element, substitute it for resolved_args.
resolved_kwargs = dict ( ( k , v . resolve ( context ) ) for k , v in self . kwargs . items ( ) )	resolved_kwargs is dictionary with elements: return value of the method v.resolve called with an argument context, for k,
return resolved_args , resolved_kwargs	for every k and v in return value of the method self.kwargs.items.   return resolved_args and resolved_kwargs.
class Library ( object ) :	derive the class Library form the base class object.
def __init__ ( self ) :	define the method with reload with an argument self.
self . filters = { }	self.filters is an empty dictionary.
self . tags = { }	self.tags is an empty dictionary.
def tag ( self , name = None , compile_function = None ) :	define the method tag with 3 arguments: self, name set to None and compile_function set to None.
if name is None and compile_function is None :	if name is None and compile_function is None,
return self . tag_function	return self.tag_function.
elif name is not None and compile_function is None :	otherwise if name is not None and compile_function is None,
if callable ( name ) :	if name is callable object,
return self . tag_function ( name )	call the method self.tag_function with an argument name, return the result.
else :	if not,
def dec ( func ) :	define the function dec with an argument func,
return self . tag ( name , func )	call the method self.tag with 2 arguments name and func, return the result.
return dec	return dec.
elif name is not None and compile_function is not None :	otherwise if name is not None and compile_function is not None,
self . tags [ name ] = compile_function	substitute compile_function for self.tags dictionary value under the name key.
return compile_function	return compile_function.
else :	if not,
raise InvalidTemplateLibrary ( 'Unsupported arguments to '  'Library.tag: (%r, %r)' , ( name , compile_function ) )	raise an InvalidTemplateLibrary exception with an argument string 'Unsupported arguments to Library.tag: (%r, %r)',
def tag_function ( self , func ) :	substitute '%r' with name and compile_function.   define the method tag_function with 2 argument: self and func.
self . tags [ getattr ( func , '_decorated_function' , func ) . __name__ ] = func	get '_decorated_function' attribute from func, return func if the attribute doesnt exists,
return func	use its __name__ field as a key to get the value from self.tags, assign func to it.   return func.
def filter ( self , name = None , filter_func = None , ** flags ) :	define the method filter with 4 arguments: self, name set to None, filter_func set to None and unpacked dictionary flags.
if name is None and filter_func is None :	if name is None and filter_func is None,
def dec ( func ) :	define the function dec with an argument func,
return self . filter_function ( func , ** flags )	call the method self.filter_function with 2 arguments func and unpacked dictionary flags, return the result.
return dec	return dec.
elif name is not None and filter_func is None :	otherwise if name is not None and filter_func is None,
if callable ( name ) :	if name is callable object,
return self . filter_function ( name , ** flags )	call the method self.filter_function with arguments name and unpacked dictionary flags, return the result.
else :	if not,
def dec ( func ) :	define the function dec with an argument func,
return self . filter ( name , func , ** flags )	call the method self.filter with 3 arguments: name, func and unpacked dictionary flags, return the result.
return dec	return dec.
elif name is not None and filter_func is not None :	otherwise if name is not None and filter_func is not None,
self . filters [ name ] = filter_func	substitute filter_func for value under the name key of self.filters dictionary.
for attr in ( 'expects_localtime' , 'is_safe' , 'needs_autoescape' ) :	for every attr in tuple with 3 arguments: strings 'expects_localtime', 'is_safe' and 'needs_autoescape',
if attr in flags :	if attr is contained in flags,
value = flags [ attr ]	substitute value under the attr key of flags dictionary for value.
setattr ( filter_func , attr , value )	set filter_func objec attr attribute to value.
if hasattr ( filter_func , '_decorated_function' ) :	if filter_func has an attribute '_decorated_function',
    setattr ( filter_func . _decorated_function , attr , value )	set filter_func._decorated_function objects attr attribute to value.
filter_func . _filter_name = name	substitute name for filter_func._filter_name.
return filter_func	return filter_func.
else :	if not,
raise InvalidTemplateLibrary ( 'Unsupported arguments to '  'Library.filter: (%r, %r)' , ( name , filter_func ) )	raise an InvalidTemplateLibrary exception with an argument string ('Unsupported arguments to Library.filter: (%r, %r)',
def filter_function ( self , func , ** flags ) :	where '%r' is replaced with name and filter_func, respectively.   define the method filter_function with 3 arguments: self, func and unpacked dictionary flags.
name = getattr ( func , '_decorated_function' , func ) . __name__	get '_decorated_function' attribute from func object, if it exists substitute __name__ field of the result for name,
return self . filter ( name , func , ** flags )	if not, substitute func.__name__ for name.   call the method self.filter with 3 arguments: name, func and unpacked dictionary flags.
def simple_tag ( self , func = None , takes_context = None , name = None ) :	define the method simple_tag with 4 arguments: self, func and None, takes_context and None and name set to None.
def dec ( func ) :	define the function dec with an argument func.
params , varargs , varkw , defaults = getargspec ( func )	call the function getargspec with an argument func, substitute the result for params, varargs, varkw and defaults, respectively.
class SimpleNode ( TagHelperNode ) :	derive the class SimpleNode form the base class TagHelperNode.
def render ( self , context ) :	define the method render with 2 arguments self and context.
resolved_args , resolved_kwargs = self . get_resolved_arguments ( context )	call the method self.get_resolved_arguments with an argument context, substitute the result for resolved_args and resolved_kwargs.
return func ( * resolved_args , ** resolved_kwargs )	call the function func with 2 arguments: unpacked list resolved_args and unpacked dictionary resolved_kwargs, return it.
function_name = ( name or  getattr ( func , '_decorated_function' , func ) . __name__ )	if name is true, substitute it for function_name, if not get attribute '_decorated_function' from func object,
compile_func = partial ( generic_tag_compiler ,  params = params , varargs = varargs , varkw = varkw ,  defaults = defaults , name = function_name ,  takes_context = takes_context , node_class = SimpleNode )	substitute its __name__ field for function name, if it doesnt exists substitute func.__name__ for function_name.   call the function generic_tag_compiler, params set to params, varargs set to varargs, varkw set to varkw, defaults set to defaults,
compile_func . __doc__ = func . __doc__	name set to function_name, and takes_context set to takes_context and node_class set to SimpleNode.   substitute func.__doc__ for compile_func.__doc__.
self . tag ( function_name , compile_func )	call the method self.tag with 2 arguments: function_name and compile_func.
return func	return func.
if func is None :	if func is None,
return dec	return dec.
elif callable ( func ) :	otherwise if func is callable object,
return dec ( func )	call the function dec with an argument func, return the result.
else :	if not,
raise TemplateSyntaxError ( 'Invalid arguments provided to simple_tag' )	raise an TemplateSyntaxError exception with an argument string 'Invalid arguments provided to simple_tag'.
def assignment_tag ( self , func = None , takes_context = None , name = None ) :	define the method assignment_tag with 4 arguments: self, func set to None, takes_context set to None and name set to None.
def dec ( func ) :	define the function dec with an argument func.
params , varargs , varkw , defaults = getargspec ( func )	call the function getargspec with an argument func, substitute the result for params, varargs, varkw and defaults.
class AssignmentNode ( TagHelperNode ) :	derive the class AssignmentNode form the base class TagHelperNode.
def __init__ ( self , takes_context , args , kwargs , target_var ) :	define the function __init__ with 5 arguments: self, takes_context, args, kwargs and target_var.
super ( AssignmentNode , self ) . __init__ ( takes_context , args , kwargs )	call the method __init__ from the base class of the class AssignmentNode, with 3 arguments: takes_context, args and kwargs.
self . target_var = target_var	substitute target_var for self.target_var.
def render ( self , context ) :	define the method render with 2 arguments self and context.
resolved_args , resolved_kwargs = self . get_resolved_arguments ( context )	call the method self.get_resolved_arguments with an argument context, substitute the result for resolved_args and resolved_kwargs.
context [ self . target_var ] = func ( * resolved_args , ** resolved_kwargs )	call the function func with 2 arguments: unpacked list resolved_args and unpacked dictionary resolved_kwargs,
return ''	substitute the result for value under the self.target_var key of the context dictionary.   return an empty string.
function_name = ( name or  getattr ( func , '_decorated_function' , func ) . __name__ )	if name is true, substitute it for function_name, if not get '_decorated_function' attribute from func object, if it exists,
def compile_func ( parser , token ) :	substitute __name__ field of the result for function_name, in not, substitute func.__name__ for function_name.   define the function compile_func with 2 arguments: parser and token.
bits = token . split_contents ( ) [ 1 : ]	call the function token.split_contents, substitute the result without the first element for bits.
if len ( bits ) < 2 or bits [ - 2 ] != 'as' :	if length of bits is smaller than integer 2 or second last element of bits is not equal to 'as',
bits = bits [ : - 2 ]	substitute bits without last two elements for bits.
args , kwargs = parse_bits ( parser , bits , params ,  varargs , varkw , defaults , takes_context , function_name )	call the function parse_bits with 8 arguments: parser, bits, params, varargs, varkw, defaults, takes_context and function_name,
return AssignmentNode ( takes_context , args , kwargs , target_var )	substitute the result for args and kwargs.   return an instance of AssignmentNode class created with 4 arguments: takes_context, args, kwargs and target_var.
compile_func . __doc__ = func . __doc__	substitute func.__doc__ for compile_func.__doc__.
self . tag ( function_name , compile_func )	call the method self.tag with 2 arguments: function_name and compile_func.
return func	return func.
if func is None :	if func is None,
return dec	return dec.
elif callable ( func ) :	otherwise if func is callable,
return dec ( func )	call the function dec with an argument func, return the result.
else :	if not,
raise TemplateSyntaxError ( 'Invalid arguments provided to assignment_tag' )	raise an TemplateSyntaxError exception with an argument string 'Invalid arguments provided to assignment_tag'.
def inclusion_tag ( self , file_name , context_class = Context , takes_context = False , name = None ) :	define the method inclusion_tag with 5 arguments: self, file_name, context_class set to Context, takes_context set to boolean False,
def dec ( func ) :	and name set to None.   define the function dec with an argument func.
params , varargs , varkw , defaults = getargspec ( func )	call the function getargspec with an argument func, substitute the result for params, varargs, varkw and defaults.
class InclusionNode ( TagHelperNode ) :	derive the class InclusionNode form the base class TagHelperNode.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
resolved_args , resolved_kwargs = self . get_resolved_arguments ( context )	call the method self.get_resolved_arguments with context as an argument, substitute the result for resolved_args and resolved_kwargs.
_dict = func ( * resolved_args , ** resolved_kwargs )	call the function func with 2 arguments: unpacked list resolved_args and unpacked dictionary resolved_kwargs, substitute the result for _dict.
if not getattr ( self , 'nodelist' , False ) :	get 'nodelist' attribute from self object. if it doesnt exists return boolean False, if the result evaluates to false,
    from django . template . loader import get_template , select_template	from django.template.loader import get_template, select_template.
if isinstance ( file_name , Template ) :	if file_name is an instance of Template class.
        t = file_name	substitute file_name for t.
elif not isinstance ( file_name , six . string_types ) and is_iterable ( file_name ) :	otherwise if file_name is not an instance of six.string_types and call to the function is_iterable with an argument file_name,
        t = select_template ( file_name )	evaluates to true,   call the function select_template with an argument file_name, substitute the result for t.
else :	if not,
        t = get_template ( file_name )	call the function get_template with an argument file_name, substitute the result for t.
self . nodelist = t . nodelist	substitute t.nodelist for self.nodelist.
new_context = context_class ( _dict , ** {  'autoescape' : context . autoescape ,  'current_app' : context . current_app ,  'use_l10n' : context . use_l10n ,  'use_tz' : context . use_tz ,  } )	call the function context_class with 2 arguments: _dict and unpacked dictionary containing 4 entries:
csrf_token = context . get ( 'csrf_token' , None )	context.autoescape for 'autoescape', context.autoescape for 'current_app', context.use_l10n for 'use_l10n',   and context.use_tz for 'use_tz', substitute the result for new_context.   call the function context.get with 2 argument 'csrf_token' and None, substitute the result for csrf_token.
if csrf_token is not None :	if csrf_token is not None,
    new_context [ 'csrf_token' ] = csrf_token	substitute csrf_token for value under the 'csrf_token' key of new_context dictionary.
return self . nodelist . render ( new_context )	call the method self.nodelist.render with an argument new_context, return the result.
function_name = ( name or  getattr ( func , '_decorated_function' , func ) . __name__ )	if name is true, substitute it for function_name, if not get '_decorated_function' attribute from func object, if it exists,
compile_func = partial ( generic_tag_compiler ,  params = params , varargs = varargs , varkw = varkw ,  defaults = defaults , name = function_name ,  takes_context = takes_context , node_class = InclusionNode )	substitute __name__ field of the result for function_name, in not, substitute func.__name__ for function_name.   call the function partial with 8 arguments: generic_tag_compiler, params set to params, varargs set to varargs, varkw set to varkw,
compile_func . __doc__ = func . __doc__	defaults set to defaults, name set to function_name, takes_context set to takes_context and node_class set to InclusionNode,   substitute the result for compile_func.   substitute func.__doc__ for compile_func.__doc__.
self . tag ( function_name , compile_func )	call the function self.tag with 2 arguments: function_name and compile_func.
return func	return func.
return dec	return dec.
def is_library_missing ( name ) :	define the function is_library_missing with an argument name.
path , module = name . rsplit ( '.' , 1 )	split string name into two parts from the right side by the separator '.', substitute parts for path and module, respectively.
try :	try,
package = import_module ( path )	call the function import_module with an argument path, substitute it for package.
return not module_has_submodule ( package , module )	call the function module_has_submodule with 2 arguments: package and module, return inverted boolean result.
except ImportError :	if ImportError exception is caught,
return is_library_missing ( path )	call the function is_library_missing with an argument path, return the result.
def import_library ( taglib_module ) :	define the function import_library with an argument taglib_module.
try :	try,
mod = import_module ( taglib_module )	call the function import_module with an argument taglib_module, substitute the result for mod.
except ImportError as e :	if ImportError, renamed to e, exception is caught,
if is_library_missing ( taglib_module ) :	call the function is_library_missing with an argument taglib_module, if it evaluates to true,
return None	return None.
else :	if not,
raise InvalidTemplateLibrary ( 'ImportError raised loading %s: %s' %  ( taglib_module , e ) )	raise an InvalidTemplateLibrary exception with an argument string 'ImportError raised loading %s: %s',
try :	where '%s' is replaced with taglib_module and e.   try,
return mod . register	return mod.register.
except AttributeError :	if AttributeError exception is caught,
templatetags_modules = [ ]	where '%s' is replaced with taglib_module.   templatetags_modules is an empty list.
def get_templatetags_modules ( ) :	define the function get_templatetags_modules.
global templatetags_modules	use global variable templatetags_modules.
if not templatetags_modules :	if templatetags_modules is false,
_templatetags_modules = [ ]	_templatetags_modules is an empty list.
templatetags_modules_candidates = [ 'django.templatetags' ]	templatetags_modules_candidates is an list with an argument string 'django.templatetags'.
templatetags_modules_candidates += [ '%s.templatetags' % app_config . name  for app_config in apps . get_app_configs ( ) ]	add string '%s.templatetags' to a list, where '%s' is replaced with app_config.name,
for templatetag_module in templatetags_modules_candidates :	for every app_config in result of the method apps.get_app_configs, append the resulting list to templatetags_modules_candidates.   for every templatetag_module in templatetags_modules_candidates,
try :	try,
import_module ( templatetag_module )	call the function import_module with an argument templatetag_module.
_templatetags_modules . append ( templatetag_module )	append templatetag_module to _templatetags_modules.
except ImportError :	if ImportError exception is caught,
continue	skip this loop iteration.
templatetags_modules = _templatetags_modules	substitute _templatetags_modules for templatetags_modules.
return templatetags_modules	return templatetags_modules.
def get_library ( library_name ) :	define the function get_library with an argument library_name.
lib = libraries . get ( library_name , None )	get the value under the library_name key of the libraries dictionary, if it exists, substitute it for lib, if not, lib is None.
if not lib :	if lib is false,
templatetags_modules = get_templatetags_modules ( )	call the function get_templatetags_modules, substitute the result for templatetags_modules.
tried_modules = [ ]	tried_modules is an empty list.
for module in templatetags_modules :	for every module in templatetags_modules,
taglib_module = '%s.%s' % ( module , library_name )	taglib_module is an string '%s.%s', where '%s' is replaced to module and library_name.
tried_modules . append ( taglib_module )	append taglib_module to tried_modules.
lib = import_library ( taglib_module )	call the function import_library with an argument taglib_module, substitute the result for lib.
if lib :	if lib is true,
libraries [ library_name ] = lib	substitute lib for value under the library_name key of libraries dictionary.
break	break loop execution.
if not lib :	if lib is false,
raise InvalidTemplateLibrary ( 'Template library %s not found, '  'tried %s' %  ( library_name ,  ',' . join ( tried_modules ) ) )	raise an InvalidTemplateLibrary exception with an argument string 'Template library %s not found, tried %s',
return lib	where '%s' is replaced with library_name and elements of tried_modules joined into a string, separated by ','.   return lib.
def add_to_builtins ( module ) :	define the function add_to_builtins with an argument module.
builtins . append ( import_library ( module ) )	call the function import_library with an argument module, append the result to builtins.
add_to_builtins ( 'django.template.defaulttags' )	call the function add_to_builtins with an argument string 'django.template.defaulttags'.
add_to_builtins ( 'django.template.defaultfilters' )	call the function add_to_builtins with an argument string 'django.template.defaultfilters'.
add_to_builtins ( 'django.template.loader_tags' )	call the function add_to_builtins with an argument string 'django.template.loader_tags'.
from copy import copy	from copy import copy into default name space.
from django . utils . module_loading import import_string	from django.utils.module_loading import import_string into default name space.
_standard_context_processors = None	_standard_context_processors is None.
_builtin_context_processors = ( 'django.core.context_processors.csrf' , )	_builtin_context_processors is a tuple containing a string 'django.core.context_processors.csrf'.
class ContextPopException ( Exception ) :	derive the class ContextPopException from the Exception base class.
pass	do nothing.
class ContextDict ( dict ) :	derive the class ContextDict from the dict base class.
def __init__ ( self , context , * args , ** kwargs ) :	define the method __init__ with 4 arguments: self, context, unpacked list args and unpacked dictionary kwargs.
super ( ContextDict , self ) . __init__ ( * args , ** kwargs )	call the method __init__ from the base class of the class ContextDict, with 2 arguments: unpacked list args and unpacked dictionary kwargs.
context . dicts . append ( self )	append self to context.dicts.
self . context = context	substitute context for self.context.
def __enter__ ( self ) :	define the method __enter__ with an argument self.
return self	return self.
def __exit__ ( self , * args , ** kwargs ) :	define the method __exit__ with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
self . context . pop ( )	remove the first element from the self.context.
class BaseContext ( object ) :	derive the class BaseContext from the object base class.
def __init__ ( self , dict_ = None ) :	define the method __init__ with 2 arguments: self and dict_ set to None.
self . _reset_dicts ( dict_ )	call the method self._reset_dicts with an argument dict_.
def _reset_dicts ( self , value = None ) :	define the method _reset_dicts with 2 arguments: self and value set to None.
builtins = { 'True' : True , 'False' : False , 'None' : None }	builtins is an dictionary with 3 initial entries: boolean True for 'True', boolean False for 'False' and None for 'None'.
self . dicts = [ builtins ]	self.dicts is an list with element builtins.
if value is not None :	if value is not None,
self . dicts . append ( value )	append value to self.dicts list.
def __copy__ ( self ) :	define the method __copy__ with an argument self.
duplicate = copy ( super ( BaseContext , self ) )	call the function copy with an argument base class of the class BaseContext, substitute the result for duplicate.
duplicate . dicts = self . dicts [ : ]	hard copy list self.dicts to duplicate.dicts.
return duplicate	return duplicate.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return repr ( self . dicts )	return printable representation of self.dicts.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
for d in reversed ( self . dicts ) :	for every d in reversed list self.dicts,
yield d	yield d.
def push ( self , * args , ** kwargs ) :	define the method push with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
return ContextDict ( self , * args , ** kwargs )	instantiate class ContextDict with 3 arguments: self, unpacked list args and unpacked dictionary kwargs, return it.
def pop ( self ) :	define the method pop with an argument self.
if len ( self . dicts ) == 1 :	if length of self.dicts is equal to an integer 1,
raise ContextPopException	raise an ContextPopException.
return self . dicts . pop ( )	call the method self.dicts.pop, return the result.
def __setitem__ ( self , key , value ) :	define the method __setitem__ with 3 arguments: self, key and value.
self . dicts [ - 1 ] [ key ] = value	substitute value for value under the key key of dictionary at last element of self.dicts.
def __getitem__ ( self , key ) :	define the method __getitem__ with 2 arguments: self and key.
for d in reversed ( self . dicts ) :	for every d in reversed list self.dicts,
if key in d :	if key is contained in d,
return d [ key ]	return value under the key key of d dictionary.
raise KeyError ( key )	raise KeyError exception with an argument key.
def __delitem__ ( self , key ) :	define the method __delitem__ with 2 arguments: self and key.
del self . dicts [ - 1 ] [ key ]	delete value under the key key of dictionary at last element of self.dicts.
def has_key ( self , key ) :	define the method has_key with 2 arguments: self and key.
for d in self . dicts :	for every d in self.dicts,
if key in d :	if key is contained in d,
return True	return boolean True.
return False	return boolean False.
def __contains__ ( self , key ) :	define the method __contains__ with 2 arguments: self and key.
return self . has_key ( key )	call the method self.has_key with an argument key, return the result.
def get ( self , key , otherwise = None ) :	define the method got with 3 arguments: self, key and otherwise set to None.
for d in reversed ( self . dicts ) :	for every d in reversed list self.dicts,
if key in d :	if key is contained in d,
return d [ key ]	return value under the key key of d dictionary.
return otherwise	return otherwise.
def new ( self , values = None ) :	define the method new with 2 arguments: self and values set to None.
new_context = copy ( self )	call the function copy with an argument self, substitute the result for new_context.
new_context . _reset_dicts ( values )	call the method new_context._reset_dicts values.
return new_context	return new_context.
def flatten ( self ) :	define the method flatten with an argument self.
flat = { }	flat is an empty dictionary,
for d in self . dicts :	for every d in self.dicts,
flat . update ( d )	update flat dictionary with d.
return flat	return flat.
def __eq__ ( self , other ) :	define the method __eq__ with 2 arguments: self and other.
if isinstance ( other , BaseContext ) :	if other is an instance of BaseContext class,
return self . flatten ( ) == other . flatten ( )	call the flatten method of the self and other objects, if they are equal, return boolean True, if not return boolean False.
return False	return boolean False.
class Context ( BaseContext ) :	derive the class Context from the BaseContext base class.
def __init__ ( self , dict_ = None , autoescape = True , current_app = None ,  use_l10n = None , use_tz = None ) :	define the method __init__ with 6 arguments: self, dict_ set to None, autoescape set to True, current_app set to None,
self . autoescape = autoescape	use_l10n set to None and use_tz set to None.   substitute autoescape for self.autoescape.
self . current_app = current_app	substitute current_app for self.current_app.
self . use_l10n = use_l10n	substitute use_l10n for self.use_l10n.
self . use_tz = use_tz	substitute use_tz for self.use_tz.
self . render_context = RenderContext ( )	self.render_context is a instance of RenderContext class.
super ( Context , self ) . __init__ ( dict_ )	call the the method __init__ from the base class of the class Context.
def __copy__ ( self ) :	define the method __copy__ with an argument self.
duplicate = super ( Context , self ) . __copy__ ( )	call the the method __copy__ from the base class of the class Context, substitute the result for duplicate.
duplicate . render_context = copy ( self . render_context )	call the function copy with an argument self.render_context, substitute the result for duplicate.render_context.
return duplicate	return duplicate
def update ( self , other_dict ) :	define the method update with 2 arguments: self and other_dict.
if not hasattr ( other_dict , '__getitem__' ) :	if other_dict doesnt have an '__getitem__' attribute,
raise TypeError ( 'other_dict must be a mapping (dictionary-like) object.' )	raise an TypeError exception with an argument string 'other_dict must be a mapping (dictionary-like) object.'.
self . dicts . append ( other_dict )	append other_dict to self.dicts.
return other_dict	return other_dict.
class RenderContext ( BaseContext ) :	derive the class RenderContext from the BaseContext base class.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
for d in self . dicts [ - 1 ] :	for every d in last element of self.dicts,
yield d	yield d.
def has_key ( self , key ) :	define the method has_key with 2 arguments: self and key.
return key in self . dicts [ - 1 ]	if key is contained in last element of self.dicts, return boolean True, otherwise return boolean False.
def get ( self , key , otherwise = None ) :	define the method get with 3 arguments: self, key and otherwise set to None.
return self . dicts [ - 1 ] . get ( key , otherwise )	return value under the key key of dictionary in last element of self.dicts,
def __getitem__ ( self , key ) :	if it doesnt exists return otherwise.   define the method __getitem__ with 2 arguments: self and key.
return self . dicts [ - 1 ] [ key ]	return value under the key key of dictionary in last element of self.dicts.
def get_standard_processors ( ) :	define the function get_standard_processors.
from django . conf import settings	from django.conf import settings into default namespace.
global _standard_context_processors	use global variable _standard_context_processors.
if _standard_context_processors is None :	if _standard_context_processors is None,
processors = [ ]	processors is an empty list.
collect = [ ]	collect is an empty list.
collect . extend ( _builtin_context_processors )	extend collect list with _builtin_context_processors.
collect . extend ( settings . TEMPLATE_CONTEXT_PROCESSORS )	extend collect list with settings.TEMPLATE_CONTEXT_PROCESSORS.
for path in collect :	for every path in collect,
func = import_string ( path )	call the function import_string with an argument path, substitute the result for func.
processors . append ( func )	append func to processors.
_standard_context_processors = tuple ( processors )	convert processors elements into a tuple, substitute it for _standard_context_processors.
return _standard_context_processors	return _standard_context_processors.
class RequestContext ( Context ) :	derive the class RequestContext from the Context base class.
def __init__ ( self , request , dict_ = None , processors = None , current_app = None ,  use_l10n = None , use_tz = None ) :	define the method __init__ with 7 arguments: self, request, dict_ set to None, processors set to None, current_app set to None,
Context . __init__ ( self , dict_ , current_app = current_app ,  use_l10n = use_l10n , use_tz = use_tz )	use_l10n set to None and use_tz set to None.   call the method Context.__init__ with 5 arguments: self, dict_, current_app as current_app, use_l10n as use_l10n, use_tz as use_tz.
if processors is None :	if processors is None,
processors = ( )	processors is an empty tuple.
else :	if not,
processors = tuple ( processors )	convert processors into a tuple and substitute it for processors.
updates = dict ( )	updates is an empty dictionary.
for processor in get_standard_processors ( ) + processors :	call the function get_standard_processors, append processors to the result, for every processor is the result,
updates . update ( processor ( request ) )	call the function processor with an argument request, update updates dictionary with the result.
self . update ( updates )	update self dictionary with updates.
from django . template . base import Lexer , Parser , tag_re , NodeList , VariableNode , TemplateSyntaxError	from django.template.base import Lexer, Parser, tag_re, NodeList, VariableNode and TemplateSyntaxError into default name space.
from django . utils . encoding import force_text	from django.utils.encoding import force_text into default name space.
from django . utils . html import escape	from django.utils.html import escape into default name space.
from django . utils . safestring import SafeData , EscapeData	from django.utils.safestring import SafeData and EscapeData into default name space.
from django . utils . formats import localize	from django.utils.formats import localize into default name space.
from django . utils . timezone import template_localtime	from django.utils.timezone import template_localtime into default name space.
class DebugLexer ( Lexer ) :	derive the class DebugLexer from the Lexer base class.
def __init__ ( self , template_string , origin ) :	define the method __init__ with 3 arguments: self, template_string and origin.
super ( DebugLexer , self ) . __init__ ( template_string , origin )	call the method __init__ from the base class of the class DebugLexer, with 2 arguments: template_string and origin.
def tokenize ( self ) :	define the method tokenize with an argument self.
result , upto = [ ] , 0	result is an empty list, upto is integer 0.
for match in tag_re . finditer ( self . template_string ) :	call the method tag_re.finditer with an argument self.template_string, for every match in result,
start , end = match . span ( )	call the method match.span, substitute the result for start an end, respectively.
if start > upto :	if start is greater than upto,
result . append ( self . create_token ( self . template_string [ upto : start ] , ( upto , start ) , False ) )	call the method self.create_token with 3 arguments: self.template_string list elements from upto index to start index,
upto = start	tuple with 2 elements: upto and start and boolean False, append the result to result.   substitute start for upto.
result . append ( self . create_token ( self . template_string [ start : end ] , ( start , end ) , True ) )	call the method self.create_token with 3 arguments: self.template_string list elements from start index to end index,
upto = end	tuple with 2 elements: start and end and boolean False, append the result to result.   substitute end for upto.
last_bit = self . template_string [ upto : ]	substitute elements of self.template_string list from upto index to the end for last_lit.
if last_bit :	if last_bit is true,
result . append ( self . create_token ( last_bit , ( upto , upto + len ( last_bit ) ) , False ) )	call the method self.create_token with 3 arguments: last_bit, tuple with 2 elements: upto and sum of upto and length of last_bit,
return result	and boolean False, append the result to result.   return result.
def create_token ( self , token_string , source , in_tag ) :	define the method create_token with 4 arguments: self, token_string, source and in_tag.
token = super ( DebugLexer , self ) . create_token ( token_string , in_tag )	call the method create_token from the base class of the class DebugLexer, with 2 arguments: template_string and in_tag,
token . source = self . origin , source	substitute the result for token.   assign self.origin, source to token.source.
return token	return token.
class DebugParser ( Parser ) :	derive the class DebugParser from the Parser base class.
def __init__ ( self , lexer ) :	define the method __init__ with 2 arguments: self and lexer.
super ( DebugParser , self ) . __init__ ( lexer )	call the method __init__ with an argument lexer, from the base class of the class DebugParser.
self . command_stack = [ ]	self.command_stack is an empty list.
def enter_command ( self , command , token ) :	define the method enter_command with 3 arguments: self, command and token.
self . command_stack . append ( ( command , token . source ) )	append tuple with 2 elements: command and token.source, append the result to self.command_stack.
def exit_command ( self ) :	define the method exit_command with an argument self.
self . command_stack . pop ( )	remove first element from self.command_stack.
def error ( self , token , msg ) :	define the method error with 3 arguments: self, token and msg.
return self . source_error ( token . source , msg )	call the method self.source_error with 2 arguments: token.source and msg, return the result.
def source_error ( self , source , msg ) :	define the method source_error with 3 arguments: self, source and msg.
e = TemplateSyntaxError ( msg )	e is an instance of TemplateSyntaxError class, created with an argument msg.
e . django_template_source = source	substitute source for e.django_template_source.
return e	return e.
def create_nodelist ( self ) :	define the method create_nodelist with an argument self.
return DebugNodeList ( )	return an instance of DebugNodeList class.
def create_variable_node ( self , contents ) :	define the method create_variable_node with 2 arguments: self and contents.
return DebugVariableNode ( contents )	return an instance of DebugVariableNode, created with an argument contents.
def extend_nodelist ( self , nodelist , node , token ) :	define the method extend_nodelist with 4 arguments: self, nodelist, node and token.
node . source = token . source	substitute token.source for node.source.
super ( DebugParser , self ) . extend_nodelist ( nodelist , node , token )	call the method extend_nodelist with 3 arguments: nodelist, node and token, from the base class of the class DebugParser.
def unclosed_block_tag ( self , parse_until ) :	define the method unclosed_block_tag with 2 arguments: self and parse_until.
command , source = self . command_stack . pop ( )	remove the first element from self.command_stack, assign the result to command and source, respectively.
msg = 'Unclosed tag '%s'. Looking for one of: %s ' % ( command , ', ' . join ( parse_until ) )	msg is an string 'Unclosed tag '%s'. Looking for one of: %s ', where '%s' is replaced with command,
raise self . source_error ( source , msg )	and elements of parse_until joined into a string, separated by string ', '.   raise an self.source_error exception with 2 arguments: source and msg.
def compile_filter_error ( self , token , e ) :	define the method compile_filter_error with 3 arguments: self, token and e.
if not hasattr ( e , 'django_template_source' ) :	if e doesnt have an 'django_template_source' attribute,
e . django_template_source = token . source	substitute token.source for e.django_template_source.
def compile_function_error ( self , token , e ) :	define the method compile_function_error with 3 arguments: self, token and e.
if not hasattr ( e , 'django_template_source' ) :	if e doesnt have an 'django_template_source' attribute,
e . django_template_source = token . source	substitute token.source for e.django_template_source.
class DebugNodeList ( NodeList ) :	derive the class DebugNodeList from the NodeList base class.
def render_node ( self , node , context ) :	define the method render_node with 3 arguments: self, node and context.
try :	try,
return node . render ( context )	call the method node.render with an argument context, return the result.
except Exception as e :	if Exception, renamed to e, exception is caught,
if not hasattr ( e , 'django_template_source' ) :	if e doesnt have an 'django_template_source' attribute,
e . django_template_source = node . source	substitute node.source for e.django_template_source.
raise	raise an exception.
class DebugVariableNode ( VariableNode ) :	derive the class DebugVariableNode from the VariableNode base class.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
try :	try,
output = self . filter_expression . resolve ( context )	call the method self.filter_expression.resolve with an argument context, substitute the result for output.
output = template_localtime ( output , use_tz = context . use_tz )	call the function template_localtime with 2 arguments: output and use_tz set to context.use_tz, substitute the result for output.
output = localize ( output , use_l10n = context . use_l10n )	call the function localize with 2 arguments: output and use_l10n set to context.use_l10n, substitute the result for output.
output = force_text ( output )	call the function force_text with an argument output, substitute the result for output.
except UnicodeDecodeError :	if UnicodeDecodeError exception is caught,
return ''	return an empty string.
except Exception as e :	if Exception, renamed to e, exception is caught,
if not hasattr ( e , 'django_template_source' ) :	if e doesnt have an 'django_template_source' attribute,
e . django_template_source = self . source	substitute self.source for e.django_template_source.
raise	raise an exception.
if ( context . autoescape and not isinstance ( output , SafeData ) ) or isinstance ( output , EscapeData ) :	if context.autoescape is true and output is not an instance of SafeData class or output is an instance of EscapeData class,
return escape ( output )	call the function escape with an argument output.
else :	if not,
return output	return output.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import re	import module re.
import random as random_module	import module random as random_module.
from decimal import Decimal , InvalidOperation , Context , ROUND_HALF_UP	from decimal import Decimal, InvalidOperation, Context and ROUND_HALF_UP into default name space.
from functools import wraps	from functools import wraps into default name space.
from pprint import pformat	from pprint import pformat into default name space.
from django . template . base import Variable , Library , VariableDoesNotExist	from django.template.base import Variable, Library and VariableDoesNotExist into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . utils import formats	from django.utils import formats into default name space.
from django . utils . dateformat import format , time_format	from django.utils.dateformat import format and time_format into default name space.
from django . utils . encoding import force_text , iri_to_uri	from django.utils.encoding import force_text and iri_to_uri into default name space.
from django . utils . html import ( conditional_escape , escapejs ,  escape , urlize as _urlize , linebreaks , strip_tags , avoid_wrapping ,  remove_tags )	from django.utils.html import conditional_escape, escapejs, escape, urlize as _urlize, linebreaks, strip_tags, avoid_wrapping,
from django . utils . http import urlquote	and remove_tags.   from django.utils.http import urlquote into default name space.
from django . utils . text import Truncator , wrap , phone2numeric	from django.utils.text import Truncator, wrap and phone2numeric into default name space.
from django . utils . safestring import mark_safe , SafeData , mark_for_escaping	from django.utils.safestring import mark_safe, SafeData and mark_for_escaping into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . timesince import timesince , timeuntil	from django.utils.timesince import timesince and timeuntil into default name space.
from django . utils . translation import ugettext , ungettext	from django.utils.translation import ugettext and ungettext into default name space.
from django . utils . text import normalize_newlines , slugify as _slugify	from django.utils.text import normalize_newlines and slugify as _slugify into default name space.
register = Library ( )	register is an instance of Library class.
def stringfilter ( func ) :	define the method stringfilter with an argument func.
def _dec ( * args , ** kwargs ) :	define the method _dec with 2 arguments: unpacked list args and unpacked dictionary kwargs.
if args :	if args in true,
args = list ( args )	convert args into a list, substitute it for args.
args [ 0 ] = force_text ( args [ 0 ] )	call the function force_text with an argument first element of args, substitute the result for first element of args.
if ( isinstance ( args [ 0 ] , SafeData ) and  getattr ( _dec . _decorated_function , 'is_safe' , False ) ) :	if first element of args is an instance of SafeData, and 'is_safe' attribute of dec._decorated_function object is true,
return mark_safe ( func ( * args , ** kwargs ) )	call the function func with 2 arguments: unpacked list args and unpacked dictionary kwargs,
return func ( * args , ** kwargs )	use the result as an argument for the call to the mark_safe function, return the result.   call the function func with 2 arguments: unpacked list args and unpacked dictionary kwargs, return the result.
_dec . _decorated_function = getattr ( func , '_decorated_function' , func )	get '_decorated_function' attribute from the func object, substitute it for _dec._decorated_function, if it doesnt exist,
return wraps ( func ) ( _dec )	substitute func for _dec._decorated_function.   call the function wraps with an argument func, call the result with an argument _dec, return the result.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def addslashes ( value ) :	define the function addslashes with an argument value.
@ stringfilter	decorator stringfilter,
def capfirst ( value ) :	define the function capfirst with an argument value.
return value and value [ 0 ] . upper ( ) + value [ 1 : ]	if value is false, return it, if it is true convert first element of value to uppercase letter, return the value.
@ register . filter ( 'escapejs' )	decorator function register.filter with an argument string 'escapejs'.
@ stringfilter	decorator stringfilter,
def escapejs_filter ( value ) :	define the function escapejs_filter with an argument value.
return escapejs ( value )	call the function escapejs with an argument value, return the result.
pos_inf = 1e200 * 1e200	multiply 10 to the power of 200, with itself, substitute the result for pos_inf.
neg_inf = - 1e200 * 1e200	multiply 10 to the power of 200, with 10 to the power of 200, negative, substitute the result for neg_inf.
nan = ( 1e200 * 1e200 ) // ( 1e200 * 1e200 )	divide 10 to the power of 400 by 10 to the power of 400, substitute the result for nan.
special_floats = [ str ( pos_inf ) , str ( neg_inf ) , str ( nan ) ]	special_floats is an list with 3 elements, pos_inf, neg_inf and nan, all converted to strings.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
def floatformat ( text , arg = - 1 ) :	define the function floatformat with 2 arguments text and arg set to integer -1.
try :	try,
input_val = force_text ( text )	call the function force_text with an argument text, substitute the result for input_val.
d = Decimal ( input_val )	d is an instance of Decimal class created with an argument input_val.
except UnicodeEncodeError :	if UnicodeEncodeError exception is caught,
return ''	return an empty string.
except InvalidOperation :	if InvalidOperation exception is caught,
if input_val in special_floats :	if every input_val in special_floats,
return input_val	return input_val.
try :	try,
d = Decimal ( force_text ( float ( text ) ) )	d is an instance of class Decimal, created with result of the function force_text,
except ( ValueError , InvalidOperation , TypeError , UnicodeEncodeError ) :	called with an argument text converted into a floating point number.   if ValueError, InvalidOperation, TypeError or UnicodeEncodeError exceptions are caught,
return ''	return an empty string.
try :	try,
p = int ( arg )	convert arg to an integer, substitute it for p.
except ValueError :	if ValueError exception is caught,
return input_val	return input_val.
try :	try,
m = int ( d ) - d	convert d into a integer, subtract d from it, substitute the result for m.
except ( ValueError , OverflowError , InvalidOperation ) :	if ValueError, OverflowError or InvalidOperation exceptions are caught,
return input_val	return input_val.
if not m and p < 0 :	if m is false and p is lesser than integer 0,
return mark_safe ( formats . number_format ( '%d' % ( int ( d ) ) , 0 ) )	call the method formats.number_format with 2 arguments, d converted to a integer and then to string, and integer 0,
if p == 0 :	use the result as an argument for the call to the function mark_safe, return the result.   if p equals integer 0,
exp = Decimal ( 1 )	exp is an instance of Decimal, created with an argument integer 1.
else :	if not,
exp = Decimal ( '1.0' ) / ( Decimal ( 10 ) ** abs ( p ) )	instantiate class Decimal with string '1.0' as argument, divide it by product of instance of Decimal class created with integer 10,
try :	and absolute value of p, substitute the result for exp.   try,
tupl = d . as_tuple ( )	call the method d.as_tuple, substitute the result for tupl.
units = len ( tupl [ 1 ] ) - tupl [ 2 ]	subtract third element of tupl from length of second element of tupl, substitute the result for units.
prec = abs ( p ) + units + 1	sum absolute p with units an integer 1, substitute the result for prec.
sign , digits , exponent = d . quantize ( exp , ROUND_HALF_UP ,  Context ( prec = prec ) ) . as_tuple ( )	call the method d.quantize with 3 arguments: exp, ROUND_HALF_UP and instance of Context class created with prec as prec,
digits = [ six . text_type ( digit ) for digit in reversed ( digits ) ]	call the method as_tuple on the result, substitute the result for sign, digits and exponent, respectively.   append result of method six.text_type called with an argument digit to an list, for every digit in reversed order of digits,
while len ( digits ) <= abs ( exponent ) :	substitute the resulting list for digits.   while length of digits is smaller than or equal to absolute value of exponent,
digits . append ( '0' )	append '0' to digits.
digits . insert ( - exponent , '.' )	insert '.' to digits at negative exponent index.
if sign :	if sign is true,
digits . append ( '-' )	append '-' to digits.
number = '' . join ( reversed ( digits ) )	reverse element order of dicts, join them in a string, substitute the result for number.
return mark_safe ( formats . number_format ( number , abs ( p ) ) )	call the method formats.number_format with 2 arguments: number and absolute value of p,
except InvalidOperation :	use the result as an argument for the call to the mark_safe function, return the result.   if InvalidOperation exception is caught,
return input_val	return input_val.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def iriencode ( value ) :	define the function iriencode with an argument value.
return force_text ( iri_to_uri ( value ) )	call the function iri_to_uri with an argument value, use the result as an argument for the call to the force_text function,
@ register . filter ( is_safe = True , needs_autoescape = True )	return the result.   decorator function register.filter with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True.
@ stringfilter	decorator stringfilter,
def linenumbers ( value , autoescape = None ) :	define the function linenumbers with 2 arguments value and autoescape set to None.
\lines = value . split ( '\\n' )\	split value by newline characters, substitute the result for lines.
width = six . text_type ( len ( six . text_type ( len ( lines ) ) ) )	call the function six.text_type with length of lines as an argument,
if not autoescape or isinstance ( value , SafeData ) :	use length of result as an argument for the call to the function six.text_type, substitute the result for width.   if autoescape is false, if value is an instance of SafeData,
for i , line in enumerate ( lines ) :	for every i and line in enumerated iterable lines,
lines [ i ] = ( '%0' + width + 'd. %s' ) % ( i + 1 , line )	concatenate string '%0', width and string 'd. %s', format the previous string with i incremented by 1 and line,
else :	substitute the result for i-th element of lines.   if not,
for i , line in enumerate ( lines ) :	for every i and line in enumerated iterable lines,
lines [ i ] = ( '%0' + width + 'd. %s' ) % ( i + 1 , escape ( line ) )	concatenate string '%0', width and string 'd. %s', format the previous string with i incremented by 1,
\return mark_safe ( '\\n' . join ( lines ) )\	and result of the function escape called with an argument line, substitute the result for i-th element of lines.   call the method mark_safe with lines joined into a string, separated by newlines as argument, return the result.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def lower ( value ) :	define the function lower with an argument value.
return value . lower ( )	convert value to lowercase and return the result.
@ register . filter ( is_safe = False )	decorator function register.filter with an argument is_safe set to boolean False.
@ stringfilter	decorator stringfilter,
def make_list ( value ) :	define the function make_list with an argument value.
return list ( value )	return value converted into a list.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def slugify ( value ) :	define the function slugify with an argument value.
return _slugify ( value )	call the function _slugify with an argument value, return the result.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
def stringformat ( value , arg ) :	define the function stringformat with 2 arguments value and arg.
try :	try,
return ( '%' + six . text_type ( arg ) ) % value	call the function six.text_type with an argument arg, append the result to '%', format the previous with value, return the result.
except ( ValueError , TypeError ) :	if TypeError or ValueError exceptions are caught,
return ''	return an empty string.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def title ( value ) :	define the function title with an argument value.
t = re . sub ( '([a-z])'([A-Z])' , lambda m : m . group ( 0 ) . lower ( ) , value . title ( ) )	call the function re.sub with 3 arguments: string '([a-z])'([A-Z])', lambda function with an argument m and return value,
\return re . sub ( '\\d([A-Z])' , lambda m : m . group ( 0 ) . lower ( ) , t )\	\result of the m.group method called with an argument integer 0 converted into lowercase and result of the method value.title,   substitute the result for t.   call the function re.sub with 3 arguments: string '\\d([A-Z])', lambda function with an argument m and return value,\
@ register . filter ( is_safe = True )	result of the m.group method called with an argument integer 0 converted into lowercase and t, return the result.   decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def truncatechars ( value , arg ) :	define the function truncatechars with 2 arguments value and arg.
try :	try,
length = int ( arg )	substitute arg converted into a integer for length.
except ValueError :	if ValueError exception is caught,
return value	return value.
return Truncator ( value ) . chars ( length )	instantiate class Truncator, with an argument value, call the method chars on the result with an argument length, return the result.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def truncatechars_html ( value , arg ) :	define the function truncatechars_html with 2 arguments value and arg.
try :	try,
length = int ( arg )	substitute arg converted into an integer for length.
except ValueError :	if ValueError exception is caught,
return value	return value.
return Truncator ( value ) . chars ( length , html = True )	instantiate class Truncator, with an argument value, call the method chars on the result with 2 arguments length,
@ register . filter ( is_safe = True )	and html set to boolean True, return the result.   decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def truncatewords ( value , arg ) :	define the function truncatewords with 2 arguments value and arg.
try :	try,
length = int ( arg )	substitute arg converted into an integer for length.
except ValueError :	if ValueError exception is caught,
return value	return value.
return Truncator ( value ) . words ( length , truncate = ' ...' )	instantiate class Truncator, with an argument value, call the method words on the result with 2 arguments length,
@ register . filter ( is_safe = True )	and truncate set to string ' ...', return the result.   decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def truncatewords_html ( value , arg ) :	define the function truncatewords_html with 2 arguments value and arg.
try :	try,
length = int ( arg )	substitute arg converted into an integer for length.
except ValueError :	if ValueError exception is caught,
return value	return value.
return Truncator ( value ) . words ( length , html = True , truncate = ' ...' )	instantiate class Truncator, with an argument value, call the method words on the result with 3 arguments length,
@ register . filter ( is_safe = False )	html set to boolean True and truncate set to string ' ...', return the result.   decorator function register.filter with an argument is_safe set to boolean False.
@ stringfilter	decorator stringfilter,
def upper ( value ) :	define the function upper with an argument value.
return value . upper ( )	convert value to uppercase, return the result.
@ register . filter ( is_safe = False )	decorator function register.filter with an argument is_safe set to boolean False.
@ stringfilter	decorator stringfilter,
def urlencode ( value , safe = None ) :	define the function urlencode with 2 arguments value and safe set to None.
kwargs = { }	kwargs is an empty dictionary.
if safe is not None :	if safe is not None,
kwargs [ 'safe' ] = safe	substitute safe for value under the 'safe' key of kwargs dictionary.
return urlquote ( value , ** kwargs )	call the function urlquote with 2 arguments value and unpacked dictionary kwargs, return the result.
@ register . filter ( is_safe = True , needs_autoescape = True )	decorator function register.filter with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True.
@ stringfilter	decorator stringfilter,
def urlize ( value , autoescape = None ) :	define the function urlize with 2 arguments value and autoescape set to None.
return mark_safe ( _urlize ( value , nofollow = True , autoescape = autoescape ) )	call the function _urlize with 3 arguments: value, nofollow set to boolean True, autoescape set to autoescape,
@ register . filter ( is_safe = True , needs_autoescape = True )	use the result as an argument for the call to the function mark_safe, return the result.   decorator function register.filter with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True.
@ stringfilter	decorator stringfilter,
def urlizetrunc ( value , limit , autoescape = None ) :	define the function urlizetrunc with 3 arguments value, limit and autoescape set to None.
return mark_safe ( _urlize ( value , trim_url_limit = int ( limit ) , nofollow = True ,  autoescape = autoescape ) )	call the function _urlize with 4 arguments: value, trim_url_limit as limit converted into an integer, nofollow as boolean True,
@ register . filter ( is_safe = False )	and autoescape as autoescape, use the result as an argument for the call to the function mark_safe, return the result.   decorator function register.filter with an argument is_safe set to boolean False.
@ stringfilter	decorator stringfilter,
def wordcount ( value ) :	define the function wordcount with an argument value.
return len ( value . split ( ) )	split value into words, return the length of the result.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def wordwrap ( value , arg ) :	define the function wordwrap with 2 arguments value and arg.
return wrap ( value , int ( arg ) )	call the method wrap with 2 arguments, value and arg converted into a integer, return the result.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def ljust ( value , arg ) :	define the function ljust with 2 arguments value and arg.
return value . ljust ( int ( arg ) )	call the method value.ljust with an argument, arg converted into a integer, return the result.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def rjust ( value , arg ) :	define the function rjust with 2 arguments value and arg.
return value . rjust ( int ( arg ) )	call the method value.rjust with an argument, arg converted into a integer, return the result.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def center ( value , arg ) :	define the function center with 2 arguments value and arg.
return value . center ( int ( arg ) )	call the method value.center with an argument, arg converted into a integer, return the result.
@ register . filter	decorator register.filter.
@ stringfilter	decorator stringfilter,
def cut ( value , arg ) :	define the function cut with 2 arguments value and arg.
safe = isinstance ( value , SafeData )	if value is an instance of SafeData, safe is boolean True, otherwise it is boolean False.
value = value . replace ( arg , '' )	replace every occurrence of arg is value for an empty string, substitute the result for value.
if safe and arg != ';' :	if safe is true and arg is not equal to string ';',
return mark_safe ( value )	call the function mark_safe with an argument value, return the result.
return value	return value.
@ register . filter ( 'escape' , is_safe = True )	decorator function register.filter with 2 arguments string 'escape' and is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def escape_filter ( value ) :	define the function escape_filter with an argument value.
return mark_for_escaping ( value )	call the function mark_for_escaping with an argument value, return the result.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def force_escape ( value ) :	define the function force_escape with an argument value.
return escape ( value )	call the function escape with an argument value, return the result.
@ register . filter ( 'linebreaks' , is_safe = True , needs_autoescape = True )	decorator function register.filter with 3 arguments string 'slice', is_safe set to boolean True and needs_autoescape set to True.
@ stringfilter	decorator stringfilter,
def linebreaks_filter ( value , autoescape = None ) :	define the function linebreaks_filter with 2 arguments value and autoescape set to None.
autoescape = autoescape and not isinstance ( value , SafeData )	if autoescape is true and value is not an instance of SafeData, autoescape is boolean True, otherwise it is boolean False.
return mark_safe ( linebreaks ( value , autoescape ) )	call the function linebreaks with 2 arguments value and autoescape, use the result as an argument for the call to the mark_safe,
@ register . filter ( is_safe = True , needs_autoescape = True )	return the result.   decorator function register.filter with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True.
@ stringfilter	decorator stringfilter,
def linebreaksbr ( value , autoescape = None ) :	define the function linebreaksbr with 2 arguments value and autoescape set to None.
autoescape = autoescape and not isinstance ( value , SafeData )	if autoescape is true and value is not an instance of SafeData, autoescape is boolean True, otherwise it is boolean False.
value = normalize_newlines ( value )	call the function normalize_newlines with an argument value, substitute the result for value.
if autoescape :	if autoescape is true,
value = escape ( value )	call the function escape with an argument value, substitute it for value.
\return mark_safe ( value . replace ( '\\n' , '<br />' ) )\	replace every occurrence of newline character in value with string '<br />', use it as an argument for the call to the mark_safe,
@ register . filter ( is_safe = True )	return the result.   decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def safe ( value ) :	define the function safe with an argument value.
return mark_safe ( value )	call the function mark_safe with an argument value, return the result.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
def safeseq ( value ) :	define the function safeseq with an argument value.
return [ mark_safe ( force_text ( obj ) ) for obj in value ]	for every obj in value call the function mark_safe with an argument result of the function force_text called with an argument obj,
@ register . filter ( is_safe = True )	return all the results in a list.   decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def removetags ( value , tags ) :	define the function removetags with 2 arguments value and arg.
return remove_tags ( value , tags )	call the function remove_tags with 2 arguments value and tags, return the result.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
@ stringfilter	decorator stringfilter,
def striptags ( value ) :	define the function striptags with an argument value.
return strip_tags ( value )	call the function strip_tags with an argument value, return the result.
@ register . filter ( is_safe = False )	decorator function register.filter with an argument is_safe set to boolean False.
def dictsort ( value , arg ) :	define the function dictsort with 2 arguments value and arg.
try :	try,
return sorted ( value , key = Variable ( arg ) . resolve )	sort value with key set to filed resolve of instance of a class Variable, created with an argument arg, return the result.
except ( TypeError , VariableDoesNotExist ) :	if TypeError or VariableDoesNotExist exceptions are caught,
return ''	return an empty string.
@ register . filter ( is_safe = False )	decorator function register.filter with an argument is_safe set to boolean False.
def dictsortreversed ( value , arg ) :	define the function dictsortreversed with 2 arguments value and arg.
try :	try,
return sorted ( value , key = Variable ( arg ) . resolve , reverse = True )	sort value with key set to filed resolve of instance of a class Variable, created with an argument arg, reverse the sort and return the result.
except ( TypeError , VariableDoesNotExist ) :	if TypeError or VariableDoesNotExist exceptions are caught,
return ''	return an empty string.
@ register . filter ( is_safe = False )	decorator function register.filter with an argument is_safe set to boolean False.
def first ( value ) :	define the function first with an argument value.
try :	try,
return value [ 0 ]	return first element of value.
except IndexError :	if IndexError exception is caught,
return ''	return an empty string.
@ register . filter ( is_safe = True , needs_autoescape = True )	decorator function register.filter with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True.
def join ( value , arg , autoescape = None ) :	define the function join with 3 arguments: value, arg and autoescape set to None.
value = map ( force_text , value )	map elements of value through mapping function force_text, substitute the result for value.
if autoescape :	if autoescape is true,
value = [ conditional_escape ( v ) for v in value ]	for every v in value call the function conditional_escape with an argument v, append the result in a list, substitute the resulting list for value.
try :	try,
data = conditional_escape ( arg ) . join ( value )	call the function conditional_escape with an argument arg, call the method join on the result with an argument value,
except AttributeError :	substitute the result for data.   if AttributeError exception is caught,
return value	return value.
return mark_safe ( data )	call the function mark_safe with an argument data, return the result.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
def last ( value ) :	define the function last with an argument value.
try :	try,
return value [ - 1 ]	return last element of value.
except IndexError :	if IndexError exception is caught,
return ''	return an empty string.
@ register . filter ( is_safe = False )	decorator function register.filter with an argument is_safe set to boolean False.
def length ( value ) :	define the function length with an argument value.
try :	try,
return len ( value )	return length of value,
except ( ValueError , TypeError ) :	if TypeError or ValueError exceptions are caught,
return 0	return integer 0.
@ register . filter ( is_safe = False )	decorator function register.filter with an argument is_safe set to boolean False.
def length_is ( value , arg ) :	define the function length_is with 2 arguments value and arg.
try :	try,
return len ( value ) == int ( arg )	if lengths of value and arg are equal, return boolean True, otherwise return boolean False.
except ( ValueError , TypeError ) :	if TypeError or ValueError exceptions are caught,
return ''	return an empty string.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
def random ( value ) :	define the function random with an argument value.
return random_module . choice ( value )	call the function random_module.choice with an argument value, return the result.
@ register . filter ( 'slice' , is_safe = True )	decorator function register.filter with 2 arguments string 'slice' and is_safe set to boolean True.
def slice_filter ( value , arg ) :	define the function slice_filter with 2 arguments value and arg.
try :	try,
bits = [ ]	bits is an empty list.
for x in arg . split ( ':' ) :	split arg by ':', for every x in result,
if len ( x ) == 0 :	if length of x is equal to integer 0,
bits . append ( None )	append None to bits.
else :	if not,
bits . append ( int ( x ) )	append x converted to an integer to bits.
return value [ slice ( * bits ) ]	slice the list value with unpacked list bits as an argument, return the result.
except ( ValueError , TypeError ) :	if TypeError or ValueError exceptions are caught,
return value	return value.
@ register . filter ( is_safe = True , needs_autoescape = True )	decorator function register.filter with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True.
def unordered_list ( value , autoescape = None ) :	define the function unordered_list with 2 arguments value and autoescape set to None.
if autoescape :	if autoescape is true,
escaper = conditional_escape	substitute conditional_escape for escaper.
else :	if not,
escaper = lambda x : x	escaper is an identity lambda function.
def convert_old_style_list ( list_ ) :	define the function convert_old_style_list with an argument list_.
if not isinstance ( list_ , ( tuple , list ) ) or len ( list_ ) != 2 :	if list_ is not an instance of tuple or list types and length of list_ is not equal to integer 2,
return list_ , False	return list_ and boolean False.
first_item , second_item = list_	substitute list_ for first_item and second_item, respectively.
if second_item == [ ] :	if second_item is an empty list,
return [ first_item ] , True	return list with an element first_item, and boolean True.
try :	try,
iter ( second_item )	convert second item to an iterable,
except TypeError :	if TypeError exception is caught,
return list_ , False	return list_ and boolean False.
old_style_list = True	old_style_list is boolean True.
new_second_item = [ ]	new_second_item is an empty list.
for sublist in second_item :	for every sublist in second_item,
item , old_style_list = convert_old_style_list ( sublist )	call the function convert_old_style_list with an argument sublist, substitute the result for item and old_style_list.
if not old_style_list :	if old_style_list is false,
break	break from the loop execution,
new_second_item . extend ( item )	extend new_second_item with item.
if old_style_list :	if old_style_list is true,
second_item = new_second_item	substitute new_second_item with second_item.
return [ first_item , second_item ] , old_style_list	return list with 2 elements: first_item and second_item, and old_style_list.
def _helper ( list_ , tabs = 1 ) :	define the function _helper with 2 arguments list and tabs set to integer 1.
\indent = '\\t' * tabs\	indent contain tabs number of tab character.
output = [ ]	output is an empty list.
list_length = len ( list_ )	substitute length of list_ for list_length.
i = 0	i is integer 0.
while i < list_length :	while i is smaller than list_length,
title = list_ [ i ]	substitute i-th element of list for title.
sublist = ''	sublist is an empty string.
sublist_item = None	sublist_item is None.
if isinstance ( title , ( list , tuple ) ) :	if title is an instance of list or tuple,
sublist_item = title	substitute title for sublist_item.
title = ''	title is an empty string.
elif i < list_length - 1 :	otherwise if i is smaller than list_length decremented by one,
next_item = list_ [ i + 1 ]	substitute (i+1)-th element of list_ for next_item.
if next_item and isinstance ( next_item , ( list , tuple ) ) :	if next_item is true and next_item is an instance of list or tuple type,
  sublist_item = next_item	substitute next_item for sublist_item.
i += 1	increment i by integer 1.
if sublist_item :	if sublist_item is true,
sublist = _helper ( sublist_item , tabs + 1 )	call the function _helper with 2 arguments: sublist_item and tabs incremented by 1, substitute the result for sublist.
\sublist = '\\n%s<ul>\\n%s\\n%s</ul>\\n%s' % ( indent , sublist ,  indent , indent )\	\sublist is an string '\\n%s<ul>\\n%s\\n%s</ul>\\n%s', where every '%s' is replaced with indent, sublist, indent and indent, respectively.\
output . append ( '%s<li>%s%s</li>' % ( indent ,  escaper ( force_text ( title ) ) , sublist ) )	substitute every '%s' in string '%s<li>%s%s</li>' with indent, with result of the function escaper called with an argument:
i += 1	result of the function force_text called with an argument title, and with sublist, append the string to output.   increment i by 1.
\return '\\n' . join ( output )\	join elements of output into a string, separated with newlines, return the result.
value , converted = convert_old_style_list ( value )	call the function convert_old_style_list with an argument value, substitute the result for value and converted, respectively.
return mark_safe ( _helper ( value ) )	call the function _helper with an argument value, use it as an argument for the call to the function mark_safe, return the result.
@ register . filter ( is_safe = False )	decorator function register.filter with an argument is_safe set to boolean False.
def add ( value , arg ) :	define the function add with 2 arguments value and arg.
try :	try,
return int ( value ) + int ( arg )	convert value and arg into a integers, return their sum.
except ( ValueError , TypeError ) :	if TypeError or ValueError exceptions are caught,
try :	try,
return value + arg	sum value and arg, return the result.
except Exception :	if Exception exception is caught,
return ''	return an empty string.
@ register . filter ( is_safe = False )	decorator function register.filter with an argument is_safe set to boolean False.
def get_digit ( value , arg ) :	define the function get_digit with 2 arguments value and arg.
try :	try,
arg = int ( arg )	convert arg to an integer.
value = int ( value )	convert value to an integer.
except ValueError :	if ValueError exception is caught,
return value	return value.
if arg < 1 :	if arg is smaller than integer 1,
return value	return value.
try :	try,
return int ( str ( value ) [ - arg ] )	convert value into a string, take character at the negative arg index, convert it into an integer, return it.
except IndexError :	if IndexError exception is caught,
return 0	return integer 0.
@ register . filter ( expects_localtime = True , is_safe = False )	decorator function register.filter with 2 arguments expects_localtime set to boolean True and is_safe set to boolean False.
def date ( value , arg = None ) :	define the function date with 2 arguments value and arg set to None.
if value in ( None , '' ) :	if vale is None or an empty string,
return ''	return an empty string.
if arg is None :	if arg is None,
arg = settings . DATE_FORMAT	substitute settings.DATE_FORMAT for arg.
try :	try,
return formats . date_format ( value , arg )	call the method formats.time_format with 2 arguments: value and arg, return the result.
except AttributeError :	if AttributeError exception is caught,
try :	try,
return format ( value , arg )	format value into printable data representation with formating rules arg, return the result.
except AttributeError :	if AttributeError exception is caught,
return ''	return an empty string.
@ register . filter ( expects_localtime = True , is_safe = False )	decorator function register.filter with 2 arguments expects_localtime set to boolean True and is_safe set to boolean False.
def time ( value , arg = None ) :	define the function time with 2 arguments value and arg set to None.
if value in ( None , '' ) :	if vale is None or an empty string,
return ''	return an empty string.
if arg is None :	if arg is None
arg = settings . TIME_FORMAT	substitute settings.TIME_FORMAT for arg.
try :	try,
return formats . time_format ( value , arg )	call the method formats.time_format with 2 arguments: value and arg, return the result.
except AttributeError :	if AttributeError exception is caught,
try :	try,
return time_format ( value , arg )	call the function time_format with 2 arguments: value and arg, return the result.
except AttributeError :	if AttributeError exception is caught,
return ''	return an empty string.
@ register . filter ( 'timesince' , is_safe = False )	decorator function register.filter with 2 arguments string 'timesince' and is_safe set to boolean False.
def timesince_filter ( value , arg = None ) :	define the function timesince_filter with 2 arguments value and arg set to None.
if not value :	if value is false,
return ''	return an empty string.
try :	try,
if arg :	if arg is true,
return timesince ( value , arg )	call the function timesince with 2 arguments: value and arg, return the result.
return timesince ( value )	call the function timesince with an argument value, return the result.
except ( ValueError , TypeError ) :	if TypeError or ValueError exceptions are caught,
return ''	return an empty string.
@ register . filter ( 'timeuntil' , is_safe = False )	decorator function register.filter with 2 arguments string 'timeuntil' and is_safe set to boolean False.
def timeuntil_filter ( value , arg = None ) :	define the function timeuntil_filter with 2 arguments value and arg set to None.
if not value :	if value is false,
return ''	return an empty string.
try :	try,
return timeuntil ( value , arg )	call the function timeuntil with 2 arguments value and arg, return the result.
except ( ValueError , TypeError ) :	if TypeError or ValueError exceptions are caught,
return ''	return an empty string.
@ register . filter ( is_safe = False )	decorator function register.filter with an argument is_safe set to boolean False.
def default ( value , arg ) :	define the function default with 2 arguments value and arg.
return value or arg	return value, if it is None return arg.
@ register . filter ( is_safe = False )	decorator function register.filter with an argument is_safe set to boolean False.
def default_if_none ( value , arg ) :	define the function default_if_none with 2 arguments value and arg.
if value is None :	if value is None,
return arg	return arg.
return value	return value.
@ register . filter ( is_safe = False )	decorator function register.filter with an argument is_safe set to boolean False.
def divisibleby ( value , arg ) :	define the function divisibleby with 2 arguments value and arg.
return int ( value ) % int ( arg ) == 0	convert value and arg to integers, if value is divisible by arg, return True, otherwise return boolean False.
@ register . filter ( is_safe = False )	decorator function register.filter with an argument is_safe set to boolean False.
def yesno ( value , arg = None ) :	define the function yesno with 2 arguments value and arg set to None.
if arg is None :	if arg is None
arg = ugettext ( 'yes,no,maybe' )	call the function ugettext with string 'yes,no,maybe' as an argument, substitute the result for arg.
bits = arg . split ( ',' )	split arg by ',', substitute the result for bits.
if len ( bits ) < 2 :	if length of bits is lesser than integer 2,
return value	return value.
try :	try,
yes , no , maybe = bits	assign bits elements to yes, no and maybe, respectively.
except ValueError :	if ValueError exception is caught,
yes , no , maybe = bits [ 0 ] , bits [ 1 ] , bits [ 1 ]	substitute first, second and second elements of bits for yes, no, maybe, respectively.
if value is None :	if value is None,
return maybe	return maybe.
if value :	if value is true,
return yes	return yes.
return no	return no.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
def filesizeformat ( bytes ) :	define the function filesizeformat with an argument bytes.
try :	try,
bytes = float ( bytes )	convert bytes to floating point number, substitute it for bytes.
except ( TypeError , ValueError , UnicodeDecodeError ) :	if TypeError, ValueError or UnicodeDecodeError exceptions are caught,
value = ungettext ( '%(size)d byte' , '%(size)d bytes' , 0 ) % { 'size' : 0 }	call the function ungettext with 3 arguments: string '%(size)d byte', string '%(size)d bytes' and 0, '%(size)d' is replaced with 0,
return avoid_wrapping ( value )	substitute the result for value.   call the function avoid_wrapping with an argument value, return the result.
filesize_number_format = lambda value : formats . number_format ( round ( value , 1 ) , 1 )	filesize_number_format is an lambda function with an argument value, return value is the result of the method formats.number_format,
KB = 1 << 10	called with 2 arguments: value rounded to 1 decimal point and integer 1.   move integer 1 left for 10 bits, substitute the result for KB.
MB = 1 << 20	move integer 1 left for 20 bits, substitute the result for MB.
GB = 1 << 30	move integer 1 left for 30 bits, substitute the result for GB.
TB = 1 << 40	move integer 1 left for 40 bits, substitute the result for TB.
PB = 1 << 50	move integer 1 left for 50 bits, substitute the result for PB.
if bytes < KB :	if bytes is smaller than KB,
value = ungettext ( '%(size)d byte' , '%(size)d bytes' , bytes ) % { 'size' : bytes }	call the function ugettext with 3 arguments, string '%(size)d byte', string '%(size)d bytes' and bytes,
elif bytes < MB :	replace '%(size)d with bytes, substitute the result for value.   otherwise if bytes is smaller than MB,
value = ugettext ( '%s KB' ) % filesize_number_format ( bytes / KB )	call the function ugettext with an argument string '%s KB', substitute '%s' with the result of the call to the function,
elif bytes < GB :	filesize_number_format with result of division of bytes by KB as an argument, substitute the result for value.   otherwise if bytes is smaller than GB,
value = ugettext ( '%s MB' ) % filesize_number_format ( bytes / MB )	call the function ugettext with an argument string '%s MB', substitute '%s' with the result of the call to the function,
elif bytes < TB :	filesize_number_format with result of division of bytes by MB as an argument, substitute the result for value.   otherwise if bytes is smaller than TB,
value = ugettext ( '%s GB' ) % filesize_number_format ( bytes / GB )	call the function ugettext with an argument string '%s GB', substitute '%s' with the result of the call to the function,
elif bytes < PB :	filesize_number_format with result of division of bytes by GB as an argument, substitute the result for value.   otherwise if bytes is smaller than PB,
value = ugettext ( '%s TB' ) % filesize_number_format ( bytes / TB )	call the function ugettext with an argument string '%s TB', substitute '%s' with the result of the call to the function,
else :	filesize_number_format with result of division of bytes by TB as an argument, substitute the result for value.   if not,
value = ugettext ( '%s PB' ) % filesize_number_format ( bytes / PB )	call the function ugettext with an argument string '%s PB', substitute '%s' with the result of the call to the function,
return avoid_wrapping ( value )	filesize_number_format with result of division of bytes by PB as an argument, substitute the result for value.   call the function avoid_wrapping with an argument value, return the result.
@ register . filter ( is_safe = False )	decorator function register.filter with an argument is_safe set to boolean False.
def pluralize ( value , arg = 's' ) :	define the function pluralize with 2 arguments value and arg set to character 's'.
if ',' not in arg :	if ',' is not contained in arg,
arg = ',' + arg	append arg to ',', substitute the result for arg.
bits = arg . split ( ',' )	split arg by ',', substitute the result for bits.s
if len ( bits ) > 2 :	if length of bits is greater than integer 2,
return ''	return an empty string.
singular_suffix , plural_suffix = bits [ : 2 ]	substitute first 2 elements of bits for singular_suffix and plural_suffix, respectively.
try :	try,
if float ( value ) != 1 :	convert value to an floating point number if it is not equal to integer 1,
return plural_suffix	return plural_suffix.
except ValueError :	if ValueError exception is caught,
pass	do nothing,
except TypeError :	if TypeError exception is caught,
try :	try,
if len ( value ) != 1 :	if length of value is not equal to integer 1,
return plural_suffix	return plural_suffix.
except TypeError :	if TypeError exception is caught,
pass	do nothing,
return singular_suffix	return singular_suffix.
@ register . filter ( 'phone2numeric' , is_safe = True )	decorator function register.filter with 2 arguments string 'phone2numeric' and is_safe set to boolean True.
def phone2numeric_filter ( value ) :	define the function phone2numeric_filter with an argument value.
return phone2numeric ( value )	call the function phone2numeric with an argument value, return the result.
@ register . filter ( is_safe = True )	decorator function register.filter with an argument is_safe set to boolean True.
def pprint ( value ) :	define the function pprint with an argument value.
try :	try,
return pformat ( value )	call the function pformat with an argument value, return the result.
except Exception as e :	if Exception, renamed to e, exception is caught,
return 'Error in formatting: %s' % force_text ( e , errors = 'replace' )	return an string 'Error in formatting: %s', replace '%s' with result of the function force_text,
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import os	import module os.
import sys	import module sys.
import re	import module re.
from datetime import datetime	from datetime import datetime into default name space.
from itertools import groupby , cycle as itertools_cycle	from itertools import groupby and cycle as itertools_cycle into default name space.
import warnings	import module warnings.
from django . conf import settings	from django.conf import settings into default name space.
from django . template . base import ( Node , NodeList , Template , Context , Library ,  TemplateSyntaxError , VariableDoesNotExist , InvalidTemplateLibrary ,  BLOCK_TAG_START , BLOCK_TAG_END , VARIABLE_TAG_START , VARIABLE_TAG_END ,  SINGLE_BRACE_START , SINGLE_BRACE_END , COMMENT_TAG_START , COMMENT_TAG_END ,  VARIABLE_ATTRIBUTE_SEPARATOR , get_library , token_kwargs , kwarg_re ,  render_value_in_context )	from django.template.base import Node, NodeList, Template, Context, Library, TemplateSyntaxError, VariableDoesNotExist,
from django . template . smartif import IfParser , Literal	validTemplateLibrary, BLOCK_TAG_START, BLOCK_TAG_END, VARIABLE_TAG_START, VARIABLE_TAG_END, SINGLE_BRACE_START, SINGLE_BRACE_END,   COMMENT_TAG_START, COMMENT_TAG_END, VARIABLE_ATTRIBUTE_SEPARATOR, get_library, token_kwargs, kwarg_re and render_value_in_context.   from django.template.smartif import IfParser and Literal into default name space.
from django . template . defaultfilters import date	from django.template.defaultfilters import date into default name space.
from django . utils . deprecation import RemovedInDjango20Warning	from django.utils.deprecation import RemovedInDjango20Warning into default name space.
from django . utils . encoding import force_text , smart_text	from django.utils.encoding import force_text and smart_text into default name space.
from django . utils . safestring import mark_safe	from django.utils.safestring import mark_safe into default name space.
from django . utils . html import format_html	from django.utils.html import format_html into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils import timezone	from django.utils import timezone into default name space.
register = Library ( )	register is an instance of Library class.
class AutoEscapeControlNode ( Node ) :	derive the class AutoEscapeControlNode from Node base class.
def __init__ ( self , setting , nodelist ) :	define the method __init__ with 3 arguments: self, setting and nodelist.
self . setting , self . nodelist = setting , nodelist	substitute setting and nodelist for self.setting and self.nodelist, respectively.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
old_setting = context . autoescape	substitute context.autoescape for old_setting.
context . autoescape = self . setting	substitute self.setting for context.autoescape.
output = self . nodelist . render ( context )	call the method self.nodelist.render with an argument context, substitute the result for output.
context . autoescape = old_setting	substitute old_setting for context.autoescape.
if self . setting :	if self.setting is true,
return mark_safe ( output )	call the function mark_safe with an argument output.
else :	if not,
return output	return output.
class CommentNode ( Node ) :	derive the class CommentNode from Node base class.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
return ''	return an empty string,
class CsrfTokenNode ( Node ) :	derive the class CsrfTokenNode from Node base class.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
csrf_token = context . get ( 'csrf_token' , None )	get the value under the 'csrf_token' key of the context dictionary, if it exists substitute the result for csrf_token,
if csrf_token :	if not csrf_token is None.   if csrf_token is true,
if csrf_token == 'NOTPROVIDED' :	if csrf_token equals string 'NOTPROVIDED',
return format_html ( '' )	call the function format_html with an argument empty string, return the result.
else :	if not,
return format_html ( '<input type='hidden' name='csrfmiddlewaretoken' value='{0}' />' , csrf_token )	call the function format_html with 2 arguments: string '<input type='hidden' name='csrfmiddlewaretoken' value='{0}' />',
else :	and csrf_token, return the result.   if not,
if settings . DEBUG :	if settings.DEBUG is true,
warnings . warn ( 'A {% csrf_token %} was used in a template, but the context did not provide the value.  This is usually caused by not using RequestContext.' )	call the function warnings.warn with an argument string 'A {% csrf_token %} was used in a template, but the context did not provide the value.  This is usually caused by not using RequestContext.'.
return ''	return an empty string,
class CycleNode ( Node ) :	derive the class CycleNode from Node base class.
def __init__ ( self , cyclevars , variable_name = None , silent = False ) :	define the method __init__ with 4 arguments: self, cyclevars, variable_name set to None and silent set to boolean False.
self . cyclevars = cyclevars	substitute cyclevars for self.cyclevars.
self . variable_name = variable_name	substitute variable_name for self.variable_name.
self . silent = silent	substitute silent for self.silent.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
if self not in context . render_context :	if self is not contained in context.render_context,
context . render_context [ self ] = itertools_cycle ( self . cyclevars )	call the function itertools_cycle with an argument self.cyclevars, substitute the result for value under the self dictionary context.render_context.
cycle_iter = context . render_context [ self ]	get the value under the self key of the context.render_context dictionary, substitute it for cycle_iter.
value = next ( cycle_iter ) . resolve ( context )	call the function next with an argument cycle_iter, call the method resolve on the result with an argument context, substitute the result for value.
if self . variable_name :	if self.variable_name is true.
context [ self . variable_name ] = value	substitute value for value under the self.variable_name key of the context dictionary.
if self . silent :	if self.silent is true,
return ''	return an empty string,
return render_value_in_context ( value , context )	call the function render_value_in_context with 2 arguments: value and context, return the result.
class DebugNode ( Node ) :	derive the class DebugNode from Node base class.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
from pprint import pformat	from pprint import pformat.
output = [ pformat ( val ) for val in context ]	output is an list with initial elements generated with call to the function pformat with an argument val, for every val in context.
\output . append ( '\\n\\n' )\	append 2 consecutive newlines to output.
output . append ( pformat ( sys . modules ) )	call the function pformat with an argument sys.modules, append the result for output.
return '' . join ( output )	join elements of output into a string, return the result.
class FilterNode ( Node ) :	derive the class FilterNode from Node base class.
def __init__ ( self , filter_expr , nodelist ) :	define the method __init__ with 3 arguments: self, filter_expr and nodelist).
self . filter_expr , self . nodelist = filter_expr , nodelist	substitute filter_expr and nodelist for self.filter_expr and self.nodelist, respectively.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
output = self . nodelist . render ( context )	call the method self.nodelist.render with an argument context, substitute the result output.
with context . push ( var = output ) :	call the method context.push with an argument var set to output, with the result perform,
return self . filter_expr . resolve ( context )	call the function self.filter_expr.resolve with an argument context, return the result.
class FirstOfNode ( Node ) :	derive the class FirstOfNode from Node base class.
def __init__ ( self , variables ) :	define the method __init__ with 2 arguments: self and variables.
self . vars = variables	substitute variables for self.vars.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
for var in self . vars :	for every var in self.vars,
value = var . resolve ( context , True )	call the method var.resolve with 2 arguments: context and True, substitute the result for value.
if value :	if value is true,
return render_value_in_context ( value , context )	call the function render_value_in_context with 2 arguments: value and context, return the result.
return ''	return an empty string,
class ForNode ( Node ) :	derive the class ForNode from Node base class.
child_nodelists = ( 'nodelist_loop' , 'nodelist_empty' )	child_nodelists is an tuple with 2 elements: strings 'nodelist_loop' and 'nodelist_empty'.
def __init__ ( self , loopvars , sequence , is_reversed , nodelist_loop , nodelist_empty = None ) :	define the method __init__ with 6 arguments: self, loopvars, sequence, is_reversed, nodelist_loop and nodelist_empty set to None.
self . loopvars , self . sequence = loopvars , sequence	substitute loopvars and sequence for self.loopvars and self.sequence, respectively.
self . is_reversed = is_reversed	substitute is_reversed for self.is_reversed.
self . nodelist_loop = nodelist_loop	substitute nodelist_loop for self.nodelist_loop.
if nodelist_empty is None :	if nodelist_empty is None,
self . nodelist_empty = NodeList ( )	self.nodelist_empty is an instance of NodeList class.
else :	if not,
self . nodelist_empty = nodelist_empty	substitute nodelist_empty for self.nodelist_empty.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
reversed_text = ' reversed' if self . is_reversed else ''	if self.is_reversed is true, substitute reversed_text is an string ' reversed', if not, reversed_text is an empty string.
return '<For Node: for %s in %s, tail_len: %d%s>' % ( ', ' . join ( self . loopvars ) , self . sequence , len ( self . nodelist_loop ) ,  reversed_text )	return an string '<For Node: for %s in %s, tail_len: %d%s>', substitute '%s' with elements of self.loopvars joined into a string,
def __iter__ ( self ) :	separated with string ', ', substitute '%s' with self.sequence, substitute '%d' with length of self.nodelist_loop,   substitute '%s' with reversed_text.   define the method __iter__ with an argument self.
for node in self . nodelist_loop :	for every node in self.nodelist_loop,
yield node	yield node.
for node in self . nodelist_empty :	for every node in self.nodelist_empty,
yield node	yield node.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
if 'forloop' in context :	if string 'forloop' is contained in context,
parentloop = context [ 'forloop' ]	substitute value under the the 'forloop' key of the context dictionary for parentloop.
else :	if not,
parentloop = { }	parentloop is an empty dictionary.
with context . push ( ) :	call the method context.push, with the result perform,
try :	try,
values = self . sequence . resolve ( context , True )	call the method self.sequence.resolve with 2 arguments: context and boolean True, substitute the result for values.
except VariableDoesNotExist :	if VariableDoesNotExist exception is caught,
values = [ ]	values is an empty list.
if values is None :	if values is None,
values = [ ]	if values is None,
if not hasattr ( values , '__len__' ) :	if values has an attribute '__len__',
values = list ( values )	convert values into a list, substitute it for value.
len_values = len ( values )	substitute length of values for len_values.
if len_values < 1 :	if len_values is smaller than integer 1,
return self . nodelist_empty . render ( context )	call the method self.nodelist_empty.render with an argument context, return the result.
nodelist = [ ]	nodelist is an empty list.
if self . is_reversed :	if self.is_reversed is true,
values = reversed ( values )	reverse elements order of values.
num_loopvars = len ( self . loopvars )	substitute length of self.loopvars for num_loopvars.
unpack = num_loopvars > 1	if num_loopvars is greater than integer 1, unpack is an boolean True, otherwise is an boolean False.
loop_dict = context [ 'forloop' ] = { 'parentloop' : parentloop }	loop_dict and value under the 'forloop' key of the context dictionary are dictionaries with an entry: parentloop for 'parentloop'.
for i , item in enumerate ( values ) :	for every i and item in enumerated iterable values,
loop_dict [ 'counter0' ] = i	substitute i for value under the 'counter0' key of the loop_dict dictionary.
loop_dict [ 'counter' ] = i + 1	substitute i incremented by 1 for value under the 'counter' key of the loop_dict dictionary.
loop_dict [ 'revcounter' ] = len_values - i	subtract i from len_values, substitute the result for value under the 'revcounter' key of the loop_dict dictionary.
loop_dict [ 'revcounter0' ] = len_values - i - 1	subtract i from len_values, decrement the result by integer 1, substitute it for value under the 'revcounter' key of the loop_dict dictionary.
loop_dict [ 'first' ] = ( i == 0 )	if i is equal to integer 0, value under the 'first' key of the loop_dict dictionary is boolean True, otherwise it is False.
loop_dict [ 'last' ] = ( i == len_values - 1 )	if i is equal to len_values decremented by 1, value under the 'last' key of the loop_dict dictionary is boolean True, otherwise it is False.
pop_context = False	pop_context is boolean False.
if unpack :	if unpack is true,
      if not isinstance ( item , ( list , tuple ) ) :	if item is not an instance of list or tuple class,
    len_item = 1	len_item is integer 1.
else :	if not,
    len_item = len ( item )	substitute length of item for len_item.
if num_loopvars != len_item :	if num_loopvars is not equal to len_item,
    warnings . warn (  'Need {0} values to unpack in for loop; got {1}. '  'This will raise an exception in Django 2.0.'  . format ( num_loopvars , len_item ) ,  RemovedInDjango20Warning )	call the function warnings.warn with 2 arguments: string 'Need {0} values to unpack in for loop; got {1}. This will raise an
try :	exception in Django 2.0.' formated with num_loopvars and len_item, respectively, and RemovedInDjango20Warning.   try,
    unpacked_vars = dict ( zip ( self . loopvars , item ) )	zip self.loopvars and item is a list to tuples, convert the result to an dictionary, substitute it for unpacked_vars.
except TypeError :	if TypeError exception is caught,
    pass	do nothing.
else :	if not,
    pop_context = True	pop_context is boolean True.
context . update ( unpacked_vars )	call the method context.update with an argument unpacked_vars.
else :	if not,
context [ self . loopvars [ 0 ] ] = item	substitute item for value under the first element of self.loopvars key of the context dictionary.
if settings . TEMPLATE_DEBUG :	if settings.TEMPLATE_DEBUG is true,
for node in self . nodelist_loop :	for every node in self.nodelist_loop,
    try :	try,
        nodelist . append ( node . render ( context ) )	call the method node.render with an argument context, append the result to the nodelist.
except Exception as e :	if Exception, renamed to e, exception is caught,
        if not hasattr ( e , 'django_template_source' ) :	if e doesnt have an 'django_template_source' attribute,
            e . django_template_source = node . source	substitute node.source for e.django_template_source.
raise	raise an exception.
else :	if not,
for node in self . nodelist_loop :	for every node in self.nodelist_loop,
    nodelist . append ( node . render ( context ) )	call the method node.render with an argument context, append the result to the nodelist.
if pop_context :	if pop_context is true,
      context . pop ( )	remove the first element of context.
return mark_safe ( '' . join ( force_text ( n ) for n in nodelist ) )	call the function mark_safe with an arguments: for every n in nodelist results of the function force_text called with an argument n,  joined in a string, return the result.
class IfChangedNode ( Node ) :	derive the class IfChangedNode from Node base class.
child_nodelists = ( 'nodelist_true' , 'nodelist_false' )	child_nodelists is a tuple with 2 initial elements: strings 'nodelist_true' and 'nodelist_false'.
def __init__ ( self , nodelist_true , nodelist_false , * varlist ) :	define the method __init__ with 4 arguments: self, nodelist_true, nodelist_false and unpacked list varlist.
self . nodelist_true , self . nodelist_false = nodelist_true , nodelist_false	substitute nodelist_true and nodelist_false for self.nodelist_true and self.nodelist_false, respectively.
self . _varlist = varlist	substitute varlist for self.varlist.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
state_frame = self . _get_context_stack_frame ( context )	call the method self._get_context_stack_frame with an argument context, substitute the result for state_frame.
if self not in state_frame :	if self is not contained in state_frame,
state_frame [ self ] = None	value under the self key of state_frame dictionary is None.
nodelist_true_output = None	nodelist_true_output is None.
try :	try,
if self . _varlist :	if self._varlist is true,
compare_to = [ var . resolve ( context , True ) for var in self . _varlist ]	compare_to is an list with elements generated by calling the var.resolve method with 2 arguments: context and boolean True,
else :	for every var in self._varlist.   if not,
compare_to = nodelist_true_output = self . nodelist_true . render ( context )	call the method self.nodelist_true.render with an argument context, assign the result to compare_to and nodelist_true_output.
except VariableDoesNotExist :	if VariableDoesNotExist exception is caught,
compare_to = None	compare_to is None.
if compare_to != state_frame [ self ] :	if compare_to is not equal to value under the self key of state_frame.
state_frame [ self ] = compare_to	substitute compare_to for value under the state_frame dictionary under the self key.
return nodelist_true_output or self . nodelist_true . render ( context )	return nodelist_true_output, if true, if not call the method self.nodelist_true.render with an argument context and return the result.
elif self . nodelist_false :	otherwise if self.nodelist_false is true,
return self . nodelist_false . render ( context )	call the method self.nodelist_false.render with an argument context, return the result.
return ''	return an empty string,
def _get_context_stack_frame ( self , context ) :	define the method _get_context_stack_frame with 2 arguments: self and context.
if 'forloop' in context :	if string 'forloop' is contained in context,
return context [ 'forloop' ]	return value under the 'forloop' key of the context dictionary.
else :	if not,
return context . render_context	return context.render_context.
class IfEqualNode ( Node ) :	derive the class IfEqualNode from Node base class.
child_nodelists = ( 'nodelist_true' , 'nodelist_false' )	child_nodelists is a tuple with 2 elements strings 'nodelist_true' and 'nodelist_false'.
def __init__ ( self , var1 , var2 , nodelist_true , nodelist_false , negate ) :	define the method __init__ with 6 arguments: (self, var1, var2, nodelist_true, nodelist_false and negate.
self . var1 , self . var2 = var1 , var2	substitute var1 and var2 for self.var1 and self.var2, respectively.
self . nodelist_true , self . nodelist_false = nodelist_true , nodelist_false	substitute nodelist_true and nodelist_false for self.nodelist_true and self.nodelist_false, respectively.
self . negate = negate	substitute negate for self.negate.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return '<IfEqualNode>'	return an string '<IfEqualNode>'.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
val1 = self . var1 . resolve ( context , True )	call the method self.var1.resolve with 2 arguments: context and boolean True, substitute the result for val2.
val2 = self . var2 . resolve ( context , True )	call the method self.var2.resolve with 2 arguments: context and boolean True, substitute the result for val2.
if ( self . negate and val1 != val2 ) or ( not self . negate and val1 == val2 ) :	if self.negate is true and val1 is not equal to val2, or if, self.negate is false and val1 equals val2,
return self . nodelist_true . render ( context )	call the method self.nodelist_true.render with an argument context, return the result.
return self . nodelist_false . render ( context )	call the method self.nodelist_false.render with an arguments context, return the result.
class IfNode ( Node ) :	derive the class IfNode from Node base class.
def __init__ ( self , conditions_nodelists ) :	define the method __init__ with 2 arguments: self and conditions_nodelists.
self . conditions_nodelists = conditions_nodelists	substitute conditions_nodelists for self.conditions_nodelists.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return '<IfNode>'	return an string '<IfNode>'.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
for _ , nodelist in self . conditions_nodelists :	for every _ and nodelist in self.conditions_nodelists,
for node in nodelist :	for every node in nodelist,
yield node	yield node as an return value of a generator.
@ property	property decorator,
def nodelist ( self ) :	define the method nodelist with an argument self.
return NodeList ( node for _ , nodelist in self . conditions_nodelists for node in nodelist )	return an instance of a NodeList class, created with arguments node, for every node in nodelist,
def render ( self , context ) :	and for every _, nodelist in self.conditions_nodelists.   define the method render with 2 arguments: self and context.
for condition , nodelist in self . conditions_nodelists :	for every condition and nodelist in self.conditions_nodelists,
if condition is not None :	if condition is not None,
try :	try,
match = condition . eval ( context )	call the method condition.eval with an argument context, substitute the result for match.
except VariableDoesNotExist :	if VariableDoesNotExist exception is caught,
match = None	match is None.
else :	if not,
match = True	match is boolean True.
if match :	if match is true,
return nodelist . render ( context )	call the method nodelist.render with an argument context, return the result.
return ''	return an empty string,
class RegroupNode ( Node ) :	derive the class RegroupNode from Node base class.
def __init__ ( self , target , expression , var_name ) :	define the method __init__ with 4 arguments: self, target, expression and var_name.
self . target , self . expression = target , expression	substitute target and expression for self.target and self.expression, respectively.
self . var_name = var_name	substitute var_name for self.var_name.
def resolve_expression ( self , obj , context ) :	define the method resolve_expression with 3 arguments: self, obj and context.
context [ self . var_name ] = obj	substitute obj for value under the self.var_name key of the context dictionary.
return self . expression . resolve ( context , True )	call the method self.expression.resolve with 2 arguments: context and boolean True, return the result.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
obj_list = self . target . resolve ( context , True )	call the method self.target.resolve with 2 arguments: context and boolean True, substitute it for obj_list.
if obj_list is None :	if obj_list is None,
context [ self . var_name ] = [ ]	value under the self.var_name key of the context dictionary is an empty list.
return ''	return an empty string,
context [ self . var_name ] = [  { 'grouper' : key , 'list' : list ( val ) }  for key , val in  groupby ( obj_list , lambda obj : self . resolve_expression ( obj , context ) )  ]	value under the self.var_name key of the context dictionary is an list with dictionary elements with 2 entries:
return ''	key for 'grouper' and val converted into a list for 'list', for every key and val in result of the function groupby,   called with 2 arguments: obj_list and lambda function with an argument obj and return value as a result of the function,   self.resolve_expression called with 2 arguments obj and context.   return an empty string,
def include_is_allowed ( filepath ) :	define the function include_is_allowed with an argument filepath.
filepath = os . path . abspath ( filepath )	return the absolute path of file path filepath, substitute it for filepath.
for root in settings . ALLOWED_INCLUDE_ROOTS :	for every root in settings.ALLOWED_INCLUDE_ROOTS,
if filepath . startswith ( root ) :	if filepath starts with root,
return True	return boolean True.
return False	return boolean False.
class SsiNode ( Node ) :	derive the class SsiNode from Node base class.
def __init__ ( self , filepath , parsed ) :	define the method __init__ with 3 arguments: self, filepath and parsed.
self . filepath = filepath	substitute filepath for self.filepath.
self . parsed = parsed	substitute parsed for self.parsed.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
filepath = self . filepath . resolve ( context )	call the function self.filepath.resolve with an argument context, substitute the result for filepath.
if not include_is_allowed ( filepath ) :	call the function include_is_allowed with an argument filepath, if it evaluates to false,
if settings . DEBUG :	if settings.DEBUG is true,
return '[Didn't have permission to include file]'	return string '[Didn't have permission to include file]'.
else :	if not,
return ''	return an empty string,
try :	try,
with open ( filepath , 'r' ) as fp :	open filepath file in read mode, with file descriptor as fp, perform,
output = fp . read ( )	read file fp, substitute the read data for output.
except IOError :	if IOError exception is caught,
output = ''	output is an empty string.
if self . parsed :	if self.parsed is true,
try :	try,
t = Template ( output , name = filepath )	t is an instance of Template class, created with 2 arguments output and name set to filepath.
return t . render ( context )	call the function t.render with an argument context, return the result.
except TemplateSyntaxError as e :	if TemplateSyntaxError, renamed to e, exception is caught,
if settings . DEBUG :	if settings.DEBUG is true,
return '[Included template had syntax error: %s]' % e	return an string '[Included template had syntax error: %s]', where '%s' is replaced with e.
else :	if not,
return ''	return an empty string,
return output	return output.
class LoadNode ( Node ) :	derive the class LoadNode from Node base class.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
return ''	return an empty string,
class NowNode ( Node ) :	derive the class NowNode from Node base class.
def __init__ ( self , format_string ) :	define the method __init__ with 2 arguments: self and format_string.
self . format_string = format_string	substitute format_string for self.format_string.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
tzinfo = timezone . get_current_timezone ( ) if settings . USE_TZ else None	if settings.USE_TZ is true substitute result of the function timezone.get_current_timezone for tzinfo, if not tzinfo is None.
return date ( datetime . now ( tz = tzinfo ) , self . format_string )	call the function date with 2 arguments: result of the call to the function datetime.now with an argument tz set to tzinfo,
class SpacelessNode ( Node ) :	and self.format_string, return the result.   derive the class SpacelessNode from Node base class.
def __init__ ( self , nodelist ) :	define the method __init__ with 2 arguments: self and nodelist.
self . nodelist = nodelist	substitute nodelist for self.nodelist.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
from django . utils . html import strip_spaces_between_tags	from django.utils.html import strip_spaces_between_tags.
return strip_spaces_between_tags ( self . nodelist . render ( context ) . strip ( ) )	call the method self.nodelist.render with an argument context, strip the result of the surrounding whitespaces,
class TemplateTagNode ( Node ) :	use the result as an argument for the call to the function strip_spaces_between_tags, return the result.   derive the class TemplateTagNode from Node base class.
mapping = { 'openblock' : BLOCK_TAG_START ,  'closeblock' : BLOCK_TAG_END ,  'openvariable' : VARIABLE_TAG_START ,  'closevariable' : VARIABLE_TAG_END ,  'openbrace' : SINGLE_BRACE_START ,  'closebrace' : SINGLE_BRACE_END ,  'opencomment' : COMMENT_TAG_START ,  'closecomment' : COMMENT_TAG_END ,  }	mapping is an dictionary with 8 initial entries: BLOCK_TAG_START for 'openblock', BLOCK_TAG_END for 'closeblock',
def __init__ ( self , tagtype ) :	VARIABLE_TAG_START for 'openvariable', VARIABLE_TAG_END for 'closevariable', SINGLE_BRACE_START for 'openbrace',   SINGLE_BRACE_END 'closebrace', COMMENT_TAG_START 'opencomment' and COMMENT_TAG_END for 'closecomment'.   define the method __init__ with 2 arguments: self and tagtype.
self . tagtype = tagtype	substitute tagtype for self.tagtype.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
return self . mapping . get ( self . tagtype , '' )	call the method self.mapping.get with 2 arguments: self.tagtype and an empty list, return the result.
class URLNode ( Node ) :	derive the class URLNode from Node base class.
def __init__ ( self , view_name , args , kwargs , asvar ) :	define the method __init__ with 5 arguments: self, view_name, args, kwargs and asvar.
self . view_name = view_name	substitute view_name for self.view_name.
self . args = args	substitute args for self.args.
self . kwargs = kwargs	substitute kwargs for self.kwargs.
self . asvar = asvar	substitute asvar for self.asvar.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
from django . core . urlresolvers import reverse , NoReverseMatch	from django.core.urlresolvers import reverse, NoReverseMatch.
args = [ arg . resolve ( context ) for arg in self . args ]	for every arg in self.args call the method arg.resolve with an argument context, substitute the results in a list for args.
kwargs = dict ( ( smart_text ( k , 'ascii' ) , v . resolve ( context ) )  for k , v in self . kwargs . items ( ) )	kwargs is an dictionary, populated for every k and v in result of the method self.kwargs.items with:
view_name = self . view_name . resolve ( context )	result of the call to the method v.resolve with an argument context,   for result of the function smart_text called with 2 arguments k and string 'ascii'.   call the method self.view_name.resolve with an argument context, substitute the result for view_name.
url = ''	url is an empty string.
try :	try,
url = reverse ( view_name , args = args , kwargs = kwargs , current_app = context . current_app )	call the function reverse with 4 arguments: view_name, args as args, kwargs as kwargs and current_app as context.current_app,
except NoReverseMatch :	substitute the result for url.   if NoReverseMatch exception is caught,
exc_info = sys . exc_info ( )	call the function sys.exc_info with an argument exc_info.
if settings . SETTINGS_MODULE :	if settings.SETTINGS_MODULE is true,
project_name = settings . SETTINGS_MODULE . split ( '.' ) [ 0 ]	split settings.SETTINGS_MODULE by '.' character, substitute the first element of the result for project_name.
try :	try,
url = reverse ( project_name + '.' + view_name ,  args = args , kwargs = kwargs ,  current_app = context . current_app )	call the function reverse with 4 arguments: concatenated project_name, character '.' and view_name, args as args, kwargs as kwargs,
except NoReverseMatch :	current_app as context.current_app, substitute the result for url.   if NoReverseMatch exception is caught,
if self . asvar is None :	if self.asvar is None,
        six . reraise ( * exc_info )	call the function six.reraise with unpacked list exc_info as an argument.
else :	if not,
if self . asvar is None :	if self.asvar is None,
raise	raise an exception.
if self . asvar :	if self.asvar is true,
context [ self . asvar ] = url	substitute url for value under the self.asvar key of context dictionary.
return ''	return an empty string.
else :	if not,
return url	return url.
class VerbatimNode ( Node ) :	derive the class VerbatimNode from Node base class.
def __init__ ( self , content ) :	define the method __init__ with 2 arguments: self and content.
self . content = content	substitute content for self.content.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
return self . content	return self.content
class WidthRatioNode ( Node ) :	derive the class WidthRatioNode from Node base class.
def __init__ ( self , val_expr , max_expr , max_width , asvar = None ) :	define the method __init__ with 5 arguments: self, val_expr, max_expr, max_width and asvar set to None.
self . val_expr = val_expr	substitute val_expr for self.val_expr.
self . max_expr = max_expr	substitute max_expr for self.max_expr.
self . max_width = max_width	substitute max_width for self.max_width.
self . asvar = asvar	substitute asvar for self.asvar.
def render ( self , context ) :	define the method render with 2 arguments: self and context.
try :	try,
value = self . val_expr . resolve ( context )	call the method self.val_expr.resolve with an argument context, substitute the result for value.
max_value = self . max_expr . resolve ( context )	call the method self.max_expr.resolve with an argument context, substitute the result for max_value.
max_width = int ( self . max_width . resolve ( context ) )	call the method self.max_width.resolve with an argument context, convert the result to an integer and substitute it for max_width.
except VariableDoesNotExist :	if VariableDoesNotExist exception is caught,
return ''	return an empty string.
except ( ValueError , TypeError ) :	if ValueError or TypeError exceptions are caught,
raise TemplateSyntaxError ( 'widthratio final argument must be a number' )	raise an TemplateSyntaxError exception with an argument string 'widthratio final argument must be a number'.
try :	try,
value = float ( value )	convert value into an floating point number, substitute it for value.
max_value = float ( max_value )	convert max_value into an floating point number, substitute it for max_value.
ratio = ( value / max_value ) * max_width	divide value by max_value, multiply the result with max_width, substitute it for ratio.
result = str ( int ( round ( ratio ) ) )	round up radio, convert it to an integer and the convert it to a string and substitute the result for result.
except ZeroDivisionError :	if ZeroDivisionError exception is caught,
return '0'	return an string '0'.
except ( ValueError , TypeError , OverflowError ) :	if ValueError, TypeError or OverflowError exceptions are caught,
return ''	return an empty string,
if self . asvar :	if self.asvar is true,
context [ self . asvar ] = result	substitute result for value under the self.asvar key of context dictionary.
return ''	return an empty string,
else :	if not,
return result	return result.
class WithNode ( Node ) :	derive the class WithNode from Node base class.
def __init__ ( self , var , name , nodelist , extra_context = None ) :	define the method __init__ with 5 arguments: self, var, name, nodelist and extra_context set to None.
self . nodelist = nodelist	substitute nodelist for self.nodelist.
self . extra_context = extra_context or { }	if extra_context is true, substitute it for self.extra_context, if not self.extra_context is an empty dictionary.
if name :	if name is true,
self . extra_context [ name ] = var	substitute var for value under the name key of the self.extra_context dictionary.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return '<WithNode>'	return a string '<WithNode>'
def render ( self , context ) :	define the method render with 2 arguments: self and context.
values = dict ( ( key , val . resolve ( context ) ) for key , val in  six . iteritems ( self . extra_context ) )	values is an dictionary created with result of the method val.resolve called with an argument context, for key,
with context . push ( ** values ) :	for every key and val in return value of the function six.iteritems called with an arguments self.extra_context.   call the method context.push with an argument unpacked dictionary values, with the result as an argument,
return self . nodelist . render ( context )	call the method self.nodelist.render with an argument context, return the result.
@ register . tag	register.tag decorator,
def autoescape ( parser , token ) :	define the function autoescape with 2 arguments: parser and token.
args = token . contents . split ( )	call the method token.contents.split, substitute the result for args.
if len ( args ) != 2 :	if length of args is not equal to integer 2,
arg = args [ 1 ]	substitute first element of args for arg.
if arg not in ( 'on' , 'off' ) :	if arg is not string 'on' or 'off',
nodelist = parser . parse ( ( 'endautoescape' , ) )	call the method parser.parse with an argument tuple with an element string 'endautoescape', substitute the result for nodelist.
parser . delete_first_token ( )	call the method parser.delete_first_token.
return AutoEscapeControlNode ( ( arg == 'on' ) , nodelist )	return an instance of AutoEscapeControlNode with 2 arguments: boolean exception arg equals to string 'on', and nodelist.
@ register . tag	register.tag decorator,
def comment ( parser , token ) :	define the function comment with 2 arguments: parser and token.
parser . skip_past ( 'endcomment' )	call the method parser.skip_past with an argument string 'endcomment'.
return CommentNode ( )	return an instance of CommentNode class.
@ register . tag	register.tag decorator,
def cycle ( parser , token ) :	define the function cycle with 2 arguments: parser and token.
args = token . split_contents ( )	call the method token.split_contents, substitute the result for args.
if len ( args ) < 2 :	if length of args is smaller than integer 2,
if ',' in args [ 1 ] :	if ',' is contained in second element of args,
if len ( args ) == 2 :	for second and third element of args, respectively.   if length of args equals integer 2,
name = args [ 1 ]	substitute second element of args for name.
if not hasattr ( parser , '_namedCycleNodes' ) :	if parser doesnt have an '_namedCycleNodes' attribute,
raise TemplateSyntaxError ( 'No named cycles in template. '%s' is not defined' % name )	raise an TemplateSyntaxError exception with an argument string 'No named cycles in template. '%s' is not defined',
if name not in parser . _namedCycleNodes :	where '%s' is replaced with name.   if name is not contained in parser._namedCycleNodes,
raise TemplateSyntaxError ( 'Named cycle '%s' does not exist' % name )	raise an TemplateSyntaxError exception with an argument string 'Named cycle '%s' does not exist', where '%s' is replaced with name.
return parser . _namedCycleNodes [ name ]	get the index name, of the parser._namedCycleNodes, return the result.
as_form = False	as_form is boolean False.
if len ( args ) > 4 :	if length of args is greater than 4.
if args [ - 3 ] == 'as' :	if third element from the end of the args equals string 'as',
if args [ - 1 ] != 'silent' :	if last element of args is not equal to a string 'silent',
raise TemplateSyntaxError ( 'Only 'silent' flag is allowed after cycle's name, not '%s'.' % args [ - 1 ] )	raise an TemplateSyntaxError exception with an argument string 'Only 'silent' flag is allowed after cycle's name, not '%s'.',
as_form = True	where '%s' is replaced with last element of args.   as_form is boolean True
silent = True	silent is boolean True.
args = args [ : - 1 ]	substitute args, without the last element for args.
elif args [ - 2 ] == 'as' :	if second from the end element of args equals a string 'as',
as_form = True	as_form is boolean True.
silent = False	silent is boolean False.
if as_form :	if as_form is true,
name = args [ - 1 ]	substitute the last element of args for name.
values = [ parser . compile_filter ( arg ) for arg in args [ 1 : - 2 ] ]	call the function parser.compile_filter with an argument arg for every arg in args from the index 1 to the index -2,
node = CycleNode ( values , name , silent = silent )	append the results into a list, substitute it for value.   node is an instance CycleNode class, created with  values,name and silent set to silent.
if not hasattr ( parser , '_namedCycleNodes' ) :	if parser doesnt have an '_namedCycleNodes' attribute,
parser . _namedCycleNodes = { }	parser._namedCycleNodes is an empty dictionary.
parser . _namedCycleNodes [ name ] = node	substituet node for value under the name key of the parser._namedCycleNodes dictionary.
else :	if not,
values = [ parser . compile_filter ( arg ) for arg in args [ 1 : ] ]	call the function parser.compile_filter with an argument arg for every arg in args from first element to the end,
node = CycleNode ( values )	append the results into a list, substitute it for value.   node is an instance of CycleNode class, created wiht an argument values.
return node	return node.
@ register . tag	register.tag decorator,
def csrf_token ( parser , token ) :	define the function csrf_token with 2 arguments: parser and token.
return CsrfTokenNode ( )	return an instance of CsrfTokenNode class.
@ register . tag	register.tag decorator,
def debug ( parser , token ) :	define the function debug with 2 arguments: parser and token.
return DebugNode ( )	return an instance of DebugNode class.
@ register . tag ( 'filter' )	register.tag decorator function with an argument 'filter',
def do_filter ( parser , token ) :	define the function do_filter with 2 arguments: parser and token.
_ , rest = token . contents . split ( None , 1 )	split into two parts token.contents by None, substitute the parts for _ and rest, respectively.
filter_expr = parser . compile_filter ( 'var|%s' % ( rest ) )	call the method parser.compile_filter with an argument string 'var|%s', where '%s' is replaced with rest, substitute the result for filter_expr.
for func , unused in filter_expr . filters :	for every func and unused in filter_expr.filters,
filter_name = getattr ( func , '_filter_name' , None )	get '_filter_name' attribute of the func object, if it exists, substitute it for filter_name, if not, filter_name is None.
if filter_name in ( 'escape' , 'safe' ) :	if every filter_name in strings 'escape' or 'safe',
nodelist = parser . parse ( ( 'endfilter' , ) )	where '%s' is replaced with filter_name.   call the method parser.parse with an argument tuple with an element string 'endfilter', substitute the result for nodelist.
parser . delete_first_token ( )	call the method parser.delete_first_token.
return FilterNode ( filter_expr , nodelist )	return a class instance FilterNode, called with an arguments filter_expr and nodelist.
@ register . tag	register.tag decorator,
def firstof ( parser , token ) :	define the function firstof with 2 arguments: parser and token.
bits = token . split_contents ( ) [ 1 : ]	call the method token.split_contents, substitute the result without the first element for bits.
if len ( bits ) < 1 :	if length of bits is smaller than integer 1,
return FirstOfNode ( [ parser . compile_filter ( bit ) for bit in bits ] )	return an instance of FirstOfNode class, created with an argument, result of the method parser.compile_filter called with bit,
@ register . tag ( 'for' )	for every bit in bits.   register.tag decorator function with an argument 'for',
def do_for ( parser , token ) :	define the function do_for with 2 arguments: parser and token.
bits = token . split_contents ( )	call the method token.split_contents, substitute the result.
if len ( bits ) < 4 :	if length bits is smaller than intger 4,
is_reversed = bits [ - 1 ] == 'reversed'	where '%s' is replaced with token.contents.   assign the string 'reversed' to is_reversed and bits last elements.
in_index = - 3 if is_reversed else - 2	if index is negative inter 3, if is_reversed, substitute it for in_index, if not, in_index is negative integer 2.
if bits [ in_index ] != 'in' :	if in_index-th element of bits equals to string 'in',
loopvars = re . split ( r' *, *' , ' ' . join ( bits [ 1 : in_index ] ) )	where '%s' is replaced with token.contents.   call the method re.split with 2 arguments: raw string ' *, *' and elements of bits from 1 index to in_index index,
for var in loopvars :	joined into a string, separated by whitespaces, substitute the result for loopvars.   for every var in loopvars,
if not var or ' ' in var :	if var is false or whitespaces are contained in var,
sequence = parser . compile_filter ( bits [ in_index + 1 ] )	where '%s' is replaced with token.contents.   call the method parser.compile_filter with an argument, in_index incremented by one, and used to index parser.compile_filter,
nodelist_loop = parser . parse ( ( 'empty' , 'endfor' , ) )	substitute the result for sequence.   call the method parser.parse with an argument tuple with 2 elements strings 'empty' and 'endfor', substitute the result for nodelist_loop.
token = parser . next_token ( )	call the method parser.next_token, substitute the result for token.
if token . contents == 'empty' :	if token.contents equals string 'empty',
nodelist_empty = parser . parse ( ( 'endfor' , ) )	call the method parser.parse with an argument tuple with an element string 'endfor', substitute the result for nodelist_empty.
parser . delete_first_token ( )	call the method parser.delete_first_token.
else :	if not,
nodelist_empty = None	nodelist_empty is None.
return ForNode ( loopvars , sequence , is_reversed , nodelist_loop , nodelist_empty )	return an instance of ForNode class, created with 5 arguments: loopvars, sequence, is_reversed, nodelist_loop and nodelist_empty.
def do_ifequal ( parser , token , negate ) :	define the function do_ifequal with 2 arguments: parser, token and negate.
bits = list ( token . split_contents ( ) )	call the method token.split_contents, convert the result into a list and substitute it for bits.
if len ( bits ) != 3 :	if length of bits is not equal to integer 3,
raise TemplateSyntaxError ( '%r takes two arguments' % bits [ 0 ] )	raise an TemplateSyntaxError exception with an argument string '%r takes two arguments',
end_tag = 'end' + bits [ 0 ]	where '%r' is replaced with first element of bits.   append first element of bits to 'end'. substitute the result for end_tag.
nodelist_loop = parser . parse ( ( 'else' , end_tag ) )	call the method parser.parse with an argument tuple with an element string 'else' and end_tag, substitute the result for nodelist_true.
token = parser . next_token ( )	call the method parser.next_token, substitute the result for token.
if token . contents == 'else' :	if token.contents equals a string 'else',
nodelist_false = parser . parse ( ( end_tag , ) )	call the method parser.parse with an argument tuple with an element end_tag, substitute the result for nodelist_false.
parser . delete_first_token ( )	call the method parser.delete_first_token.
else :	if not,
nodelist_false = NodeList ( )	nodelist_false is an instance of NodeList class.
val1 = parser . compile_filter ( bits [ 1 ] )	call the method parser.compile_filter with an argument, second element of bits, substitute the result for val1.
val2 = parser . compile_filter ( bits [ 2 ] )	call the method parser.compile_filter with an argument, third element of bits, substitute the result for val2.
return IfEqualNode ( val1 , val2 , nodelist_true , nodelist_false , negate )	return an instance of IfEqualNode class, created with 5 arguments: val1, val2, nodelist_true, nodelist_false and negate.
@ register . tag	register.tag decorator,
def ifequal ( parser , token ) :	define the function ifequal with 2 arguments: parser and token.
return do_ifequal ( parser , token , False )	call the function do_ifequal with 3 arguments: parser, token and boolean False, return the result.
@ register . tag	register.tag decorator,
def ifnotequal ( parser , token ) :	define the function ifnotequal with 2 arguments: parser and token.
return do_ifequal ( parser , token , True )	call the function do_ifequal with 3 arguments: parser, token and boolean False, return the result.
class TemplateLiteral ( Literal ) :	derive the class TemplateLiteral from Literal base class.
def __init__ ( self , value , text ) :	define the method __init__ with 3 arguments: self, value and text.
self . value = value	substitute value for self.value.
self . text = text	substitute text for self.text.
def display ( self ) :	define the method display with an argument self.
return self . text	return self.text.
def eval ( self , context ) :	define the method eval with 2 arguments: self and context.
return self . value . resolve ( context , ignore_failures = True )	call the method self.value.resolve with 2 arguments context and ignore_failures set to boolean True, return the result.
class TemplateIfParser ( IfParser ) :	derive the class TemplateIfParser from IfParser base class.
error_class = TemplateSyntaxError	substitute TemplateSyntaxError for error_class.
def __init__ ( self , parser , * args , ** kwargs ) :	define the method __init__ with 4 arguments: self, parser, unpacked list args and unpacked dictionary kwargs.
self . template_parser = parser	substitute parser for self.template_parser.
super ( TemplateIfParser , self ) . __init__ ( * args , ** kwargs )	call the method __init__ from the base class of the class TemplateIfParser, with 2 arguments: unpacked list args and unpacked dictionary.
def create_var ( self , value ) :	define the method create_var with 2 arguments: self and value.
return TemplateLiteral ( self . template_parser . compile_filter ( value ) , value )	return an instance of TemplateLiteral with 2 arguments: result of the function self.template_parser.compile_filter,
@ register . tag ( 'if' )	called with an argument value and value.   register.tag decorator function with an argument 'if',
def do_if ( parser , token ) :	define the function do_if with 2 arguments: parser and token.
bits = token . split_contents ( ) [ 1 : ]	call the method token.split_contents, substitute results without the first element for bits.
condition = TemplateIfParser ( parser , bits ) . parse ( )	call the method parse from the instance of TemplateIfParser class, created with 2 arguments parser and bits, substitute the result for condition.
nodelist = parser . parse ( ( 'elif' , 'else' , 'endif' ) )	call the method parser.parse with an argument tuple with 3 elements: strings 'elif', 'else' and 'endif', substitute the result for nodelist.
conditions_nodelists = [ ( condition , nodelist ) ]	conditions_nodelists is a list containing tuple with 2 elements condition and nodelist.
token = parser . next_token ( )	call the method parser.next_token, substitute the result for token.
while token . contents . startswith ( 'elif' ) :	while token.contents starts with a string 'elif',
bits = token . split_contents ( ) [ 1 : ]	call the method token.split_contents, substitute results without the first element for bits.
condition = TemplateIfParser ( parser , bits ) . parse ( )	call the method parse from the instance of TemplateIfParser class, created with 2 arguments parser and bits, substitute the result for condition.
nodelist = parser . parse ( ( 'elif' , 'else' , 'endif' ) )	call the method parser.parse with an argument tuple with 3 elements strings 'elif', 'else' and 'endif', substitute the result for nodelist.
conditions_nodelists . append ( ( condition , nodelist ) )	append a tuple with 2 elements: condition and nodelist to conditions_nodelists.
token = parser . next_token ( )	call the method parser.next_token, substitute the result for token.
if token . contents == 'else' :	if token.contents equals string 'else',
nodelist = parser . parse ( ( 'endif' , ) )	call the method parser.parse with an argument tuple with an element string 'endif', substitute the result for nodelist.
conditions_nodelists . append ( ( None , nodelist ) )	append a tuple with 2 elements: None and nodelist to conditions_nodelists.
token = parser . next_token ( )	call the method parser.next_token, substitute the result for token.
assert token . contents == 'endif'	if token.contents doesn not equals a string 'endif', raise an AssertionError exception,
return IfNode ( conditions_nodelists )	return an instance of IfNode class, created with an argument conditions_nodelists.
@ register . tag	register.tag decorator,
def ifchanged ( parser , token ) :	define the function ifchanged with 2 arguments: parser and token.
bits = token . split_contents ( )	call the method token.split_contents, substitute the result for bits.
nodelist_true = parser . parse ( ( 'else' , 'endifchanged' ) )	call the method parser.parse with an argument tuple with 2 elements strings: 'else' and 'endfilter', substitute the result for nodelistelse.
token = parser . next_token ( )	call the method parser.next_token, substitute the result for token.
if token . contents == 'else' :	if token.contents equals string 'else',
nodelist_false = parser . parse ( ( 'endifchanged' , ) )	call the method parser.parse with an argument tuple with an element string 'endifchanged', substitute the result for nodelist_false.
parser . delete_first_token ( )	call the method parser.delete_first_token.
else :	if not,
nodelist_false = NodeList ( )	nodelist_false is an instance of NodeList.
values = [ parser . compile_filter ( bit ) for bit in bits [ 1 : ] ]	for every bit in elements of bits without the first element, call the method parser.compile_filter, with an argument bit,
return IfChangedNode ( nodelist_true , nodelist_false , * values )	substitute the list of results for values.   return an instance of a class IfChangedNode, created with 3 arguments: nodelist_true, nodelist_false and unpacked list values.
@ register . tag	register.tag decorator,
def ssi ( parser , token ) :	define the function ssi with 2 arguments: parser and token.
bits = token . split_contents ( )	call the method token.split_contents, substitute the result for bits.
parsed = False	parsed is boolean False.
if len ( bits ) not in ( 2 , 3 ) :	if length of bits is not integer 2 or 3,
if len ( bits ) == 3 :	if length of bits equals integer 3,
if bits [ 2 ] == 'parsed' :	if third element of bits equals a string 'parsed',
parsed = True	parsed is boolean True.
else :	if not,
filepath = parser . compile_filter ( bits [ 1 ] )	where '%s' is replaced with first element of bits.   call the method parser.compile_filter with second element of bits as an argument, substitute the result for filepath.
return SsiNode ( filepath , parsed )	return an instance of a SsiNode class, created with 2 arguments: filepath and parsed.
@ register . tag	register.tag decorator,
def load ( parser , token ) :	define the function load with 2 arguments: parser and token.
bits = token . contents . split ( )	call the method token.split_contents, substitute the result for bits.
if len ( bits ) >= 4 and bits [ - 2 ] == 'from' :	if length of bits is greater or equal to integer 4 and second last element of bits equals sting 'from',
try :	try,
taglib = bits [ - 1 ]	substitute last element of bits for taglib.
lib = get_library ( taglib )	call the function get_library with an argument taglib, substitute the result for lib.
except InvalidTemplateLibrary as e :	if InvalidTemplateLibrary, renamed to e, exception is caught,
else :	where '%s' is replaced with taglib and e.   if not,
temp_lib = Library ( )	temp_lib is an instance of Library class.
for name in bits [ 1 : - 2 ] :	for every name in bits from the start index 1 to the end index negative 2,
if name in lib . tags :	if name is contained in lib.tags,
temp_lib . tags [ name ] = lib . tags [ name ]	substitute value under the name key of the lib.tags dictionary for value under the name key of the temp_lib.tags dictionary.
if name in lib . filters :	if name is contained in lib.filters.
    temp_lib . filters [ name ] = lib . filters [ name ]	substitute value under the name key of the lib.filters dictionary for value under the name key of the temp_lib.filters dictionary.
elif name in lib . filters :	otherwise if name is contained in lib.filters,
temp_lib . filters [ name ] = lib . filters [ name ]	substitute value under the name key of the lib.filters dictionary for value under the name key of the temp_lib.filters dictionary.
else :	if not,
parser . add_library ( temp_lib )	where '%s' is replaced with name and taglib.   call the method parser.add_library with an argument temp_lib.
else :	if not,
for taglib in bits [ 1 : ] :	for every taglib in bits without the first element,
try :	try,
lib = get_library ( taglib )	call the function get_library with an argument taglib, substitute the result for lib.
parser . add_library ( lib )	call the method parser.add_library with an argument lib.
except InvalidTemplateLibrary as e :	if InvalidTemplateLibrary, renamed to e, exception is caught,
return LoadNode ( )	where '%s' is replaced with taglib and e.   return an instance of a LoadNode class.
@ register . tag	register.tag decorator,
def now ( parser , token ) :	define the function now with 2 arguments: parser and token.
bits = token . split_contents ( )	call the method token.split_contents, substitute the result for bits.
if len ( bits ) != 2 :	if length of bits is not equal to integer 2,
format_string = bits [ 1 ] [ 1 : - 1 ]	substitute second element of bits without the first and last element for format_string.
return NowNode ( format_string )	return an instance of a NowNode class, created with an argument format_string.
@ register . tag	register.tag decorator,
def regroup ( parser , token ) :	define the function regroup with 2 arguments: parser and token.
bits = token . split_contents ( )	call the method token.split_contents, substitute the result for bits.
if len ( bits ) != 6 :	if length of bits is not equal to integer 6,
target = parser . compile_filter ( bits [ 1 ] )	call the method parser.compile_filter with an argument first element of bits, substitute the result for target.
if bits [ 2 ] != 'by' :	if third element of bits is not equal to a string 'by',
if bits [ 4 ] != 'as' :	if fift element of bits is not equal to a string 'as',
var_name = bits [ 5 ]	substitute sixth element of bits for var_name.
expression = parser . compile_filter ( var_name +  VARIABLE_ATTRIBUTE_SEPARATOR +  bits [ 3 ] )	concatenate var_name, VARIABLE_ATTRIBUTE_SEPARATOR and fourth element of bits, use the result as an argument for the call the method,
return RegroupNode ( target , expression , var_name )	parser.compile_filter, substitute the result for expression.   return an instance of a RegroupNode class, created with 3 arguments target, expression and var_name.
@ register . tag	register.tag decorator,
def spaceless ( parser , token ) :	define the function spaceless with 2 arguments: parser and token.
nodelist = parser . parse ( ( 'endspaceless' , ) )	call the method parser.parse with an argument tuple with an element string 'endspaceless', substitute the result for nodelist.
parser . delete_first_token ( )	call the method parser.delete_first_token.
return SpacelessNode ( nodelist )	return an instance of a SpacelessNode class, created with an argument nodelist.
@ register . tag	register.tag decorator,
def templatetag ( parser , token ) :	define the function templatetag with 2 arguments: parser and token.
bits = token . contents . split ( )	call the method token.split_contents, substitute the result for bits.
if len ( bits ) != 2 :	if length of bits is not equal to integer 2,
tag = bits [ 1 ]	substitute second element of bits for tag.
if tag not in TemplateTagNode . mapping :	if tag is not contained in TemplateTagNode.mapping,
raise TemplateSyntaxError ( 'Invalid templatetag argument: '%s'.'  ' Must be one of: %s' %  ( tag , list ( TemplateTagNode . mapping ) ) )	raise an TemplateSyntaxError exception with an argument string 'Invalid templatetag argument: '%s'. Must be one of: %s',
return TemplateTagNode ( tag )	where '%s' is replaced with tag and TemplateTagNode.mapping converted into a list.   return an instance of a TemplateTagNode class, created with an argument tag.
@ register . tag	register.tag decorator,
def url ( parser , token ) :	define the function url with 2 arguments: parser and token.
bits = token . split_contents ( )	call the method token.split_contents, substitute the result for bits.
if len ( bits ) < 2 :	if length of bits is lesser than integer 2,
viewname = parser . compile_filter ( bits [ 1 ] )	where '%s' is replaced with first element of bits.   call the method parser.compile_filter with second element of bits as an argument, substitute the result for viewname.
args = [ ]	args is an empty list.
kwargs = { }	kwargs is an empty dictionary.
asvar = None	asvar is None.
bits = bits [ 2 : ]	remove first two elements from bits.
if len ( bits ) >= 2 and bits [ - 2 ] == 'as' :	if length of bits is greater or equal to intger 2 and second last element of bits is equal to string 'as',
asvar = bits [ - 1 ]	substitute last element of bits for asvar.
bits = bits [ : - 2 ]	remove last 2 elements from bits.
if len ( bits ) :	if length of bits is not zero,
for bit in bits :	for every bit in bits,
match = kwarg_re . match ( bit )	call the method kwarg_re.match with an argument bit, substitute it for match.
if not match :	if match is true,
raise TemplateSyntaxError ( 'Malformed arguments to url tag' )	raise an TemplateSyntaxError exception with an argument string 'Malformed arguments to url tag'.
name , value = match . groups ( )	call the method match.groups, assign the result to name and value, respectively.
if name :	if name is true,
kwargs [ name ] = parser . compile_filter ( value )	call the method parser.compile_filter with an argument value, substitute the result for value under the name key of kwargs dictionary.
else :	if not,
args . append ( parser . compile_filter ( value ) )	call the method parser.compile_filter with an argument value, append the result to args.
return URLNode ( viewname , args , kwargs , asvar )	return an instance of a URLNode class, created with 4 arguments viewname, args, kwargs and asvar.
@ register . tag	register.tag decorator,
def verbatim ( parser , token ) :	define the function verbatim with 2 arguments: parser and token.
nodelist = parser . parse ( ( 'endverbatim' , ) )	call the method parser.parse with an argument tuple with an element string 'endverbatim', substitute the result for nodelist.
parser . delete_first_token ( )	call the method parser.delete_first_token.
return VerbatimNode ( nodelist . render ( Context ( ) ) )	call the method nodelist.render with an argument, an instance of Context class, use the result as an argument for the creation of,
@ register . tag	an instance of VerbatimNode class, return it.   register.tag decorator,
def widthratio ( parser , token ) :	define the function widthratio with 2 arguments: parser and token.
bits = token . split_contents ( )	call the method token.split_contents, substitute the result for bits.
if len ( bits ) == 4 :	if length of bits equals integer 4,
tag , this_value_expr , max_value_expr , max_width = bits	assign the bits elements to tag, this_value_expr, max_value_expr and max_width, respectively.
asvar = None	asvar is None.
elif len ( bits ) == 6 :	otherwise if length of bits equals integer 6,
tag , this_value_expr , max_value_expr , max_width , as_ , asvar = bits	assign the bits elements to tag, this_value_expr, max_value_expr, max_width, as_ and asvar.
if as_ != 'as' :	if as_ is not equal to string 'as',
raise TemplateSyntaxError ( 'Invalid syntax in widthratio tag. Expecting 'as' keyword' )	raise an TemplateSyntaxError exception with an argument string 'Invalid syntax in widthratio tag. Expecting 'as' keyword'.
else :	if not,
raise TemplateSyntaxError ( 'widthratio takes at least three arguments' )	raise an TemplateSyntaxError exception with an argument string 'widthratio takes at least three arguments'.
return WidthRatioNode ( parser . compile_filter ( this_value_expr ) ,  parser . compile_filter ( max_value_expr ) ,  parser . compile_filter ( max_width ) ,  asvar = asvar )	return an instance of a class WidthRatioNode, created with 4 arguments: result of the method parser.compile_filter,
@ register . tag ( 'with' )	called with an argument this_value_expr, result of the method parser.compile_filter called with an argument max_value_expr,   return value of the method parser.compile_filter called with an argument max_width and asvar as asvar.   register.tag decorator function with an argument 'with',
def do_with ( parser , token ) :	define the function do_with with 2 arguments: parser and token.
bits = token . split_contents ( )	call the method token.split_contents, substitute the result for bits.
remaining_bits = bits [ 1 : ]	substitute bits without the first element for remaining_bits.
extra_context = token_kwargs ( remaining_bits , parser , support_legacy = True )	call the function token_kwargs with 3 arguments: remaining_bits, parser and support_legacy set to boolean True, substitute the result for extra_context.
if not extra_context :	if extra_context is false,
raise TemplateSyntaxError ( '%r expected at least one variable '  'assignment' % bits [ 0 ] )	raise an TemplateSyntaxError exception with an argument string '%r expected at least one variable assignment',
if remaining_bits :	where '%r' is replaced with first element of bits.   if remaining_bits is true,
raise TemplateSyntaxError ( '%r received an invalid token: %r' %  ( bits [ 0 ] , remaining_bits [ 0 ] ) )	raise an TemplateSyntaxError exception with an argument string '%r received an invalid token: %r', where '%r' is replaced with,
nodelist = parser . parse ( ( 'endwith' , ) )	first element of bits and first element of remaining_bits.   call the method parser.parse with an argument tuple, with an element string 'endwith', substitute the result for nodelist.
parser . delete_first_token ( )	call the method parser.delete_first_token.
return WithNode ( None , None , nodelist , extra_context = extra_context )	return an instance of a class WithNode, created with 4 arguments: None, None, nodelist and extra_context as extra_context.
      from django . core . exceptions import ImproperlyConfigured	from django.core.exceptions import ImproperlyConfigured into default name space.
from django . template . base import Origin , Template , Context , TemplateDoesNotExist	from django.template.base import Origin,  Template,  Context and TemplateDoesNotExist into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . utils . module_loading import import_string	from django.utils.module_loading import import_string into default name space.
from django . utils import six	from django.utils import six into default name space.
template_source_loaders = None	template_source_loaders is None.
class BaseLoader ( object ) :	derive the class BaseLoader from the object base class.
is_usable = False	is_usable is boolean False.
def __init__ ( self , * args , ** kwargs ) :	define the method __init__ with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
pass	do nothing.
def __call__ ( self , template_name , template_dirs = None ) :	define the method __call__ with 3 arguments: self, template_name and template_dirs set to None.
return self . load_template ( template_name , template_dirs )	call the method self.load_template with 2 arguments: template_name and template_dirs, return the result.
def load_template ( self , template_name , template_dirs = None ) :	define the method load_template with 3 arguments: self, template_name and template_dirs set to None.
source , display_name = self . load_template_source ( template_name , template_dirs )	call the method self.load_template_source with arguments template_name and template_dirs, assign the result to source and display_name.
origin = make_origin ( display_name , self . load_template_source , template_name , template_dirs )	call the function make_origin with 4 arguments: display_name, self.load_template_source, template_name and template_dirs,
try :	substitute the result for origin.   try,
template = get_template_from_string ( source , origin , template_name )	call the function get_template_from_string with 3 arguments: source, origin and template_name, substitute the result for template.
return template , None	return template and None.
except TemplateDoesNotExist :	if TemplateDoesNotExist exception is caught,
return source , display_name	return source and display_name.
def load_template_source ( self , template_name , template_dirs = None ) :	define the method load_template_source with 3 arguments: self, template_name and template_dirs set to None.
raise NotImplementedError ( 'subclasses of BaseLoader must provide a load_template_source() method' )	raise an NotImplementedError with an argument string 'subclasses of BaseLoader must provide a load_template_source() method'.
def reset ( self ) :	define the method reset with an argument self.
pass	do nothing.
class LoaderOrigin ( Origin ) :	derive the class LoaderOrigin from the Origin base class.
def __init__ ( self , display_name , loader , name , dirs ) :	define the method __init__ with 5 arguments: self, display_name, loader, name and dirs.
super ( LoaderOrigin , self ) . __init__ ( display_name )	call the method __init__ with an argument display_name, from the base class of the LoaderOrigin class.
self . loader , self . loadname , self . dirs = loader , name , dirs	substitute loader, name and dirs for self.loader, self.loadname and self.dirs, respectively.
def reload ( self ) :	define the method reload with an argument self.
return self . loader ( self . loadname , self . dirs ) [ 0 ]	call the method self.loader with 2 arguments: self.loadname and self.dirs, return the first element of the result.
def make_origin ( display_name , loader , name , dirs ) :	define the function make_origin with 4 arguments: display_name, loader, name and dirs.
if settings . TEMPLATE_DEBUG and display_name :	if settings.TEMPLATE_DEBUG and display_name are both true,
return LoaderOrigin ( display_name , loader , name , dirs )	return an instance of LoaderOrigin class, created with 4 arguments: display_name, loader, name and dirs.
else :	if not,
return None	return None.
def find_template_loader ( loader ) :	define the function find_template_loader with an argument loader.
if isinstance ( loader , ( tuple , list ) ) :	if loader is an instance of tuple or list,
loader , args = loader [ 0 ] , loader [ 1 : ]	substitute first element of loader for loader and loader without the first element for args.
else :	if not,
args = [ ]	args is an empty list.
if isinstance ( loader , six . string_types ) :	if loader is an instance of six.string_types,
TemplateLoader = import_string ( loader )	call the function import_string with an argument loader, substitute the result for TemplateLoader.
if hasattr ( TemplateLoader , 'load_template_source' ) :	if TemplateLoader has an attribute 'load_template_source',
func = TemplateLoader ( * args )	func is an instance of TemplateLoader class, created with unpacked list args.
else :	if not,
if args :	if args is true,
raise ImproperlyConfigured ( 'Error importing template source loader %s - can't pass arguments to function-based loader.' % loader )	raise an ImproperlyConfigured exception with an argument string 'Error importing template source loader %s - can't pass arguments to
func = TemplateLoader	function-based loader.', where '%s' is replaced with loader.   substitute TemplateLoader for func.
if not func . is_usable :	func.is_usable in false,
import warnings	import module warnings.
warnings . warn ( 'Your TEMPLATE_LOADERS setting includes %r, but your Python installation doesn't support that type of template loading. Consider removing that line from TEMPLATE_LOADERS.' % loader )	call the function warnings.warn with an argument string 'Your TEMPLATE_LOADERS setting includes %r, but your Python installation
return None	doesn't support that type of template loading. Consider removing that line from TEMPLATE_LOADERS.',   where '%r' is replaced with loader.   return None.
else :	if not,
return func	return func.
else :	if not,
raise ImproperlyConfigured ( 'Loader does not define a 'load_template' callable template source loader' )	raise an ImproperlyConfigured with an argument string 'Loader does not define a 'load_template' callable template source loader'.
def find_template ( name , dirs = None ) :	define the function find_template with 2: template_name and dirs set to None.
global template_source_loaders	use global variable template_source_loaders.
if template_source_loaders is None :	if template_source_loaders is None,
loaders = [ ]	loaders is an empty list.
for loader_name in settings . TEMPLATE_LOADERS :	for every loader_name in settings.TEMPLATE_LOADERS,
loader = find_template_loader ( loader_name )	call the function find_template_loader with an argument loader_name, substitute the result for loader.
if loader is not None :	if loader is not None,
loaders . append ( loader )	append loader to loaders.
template_source_loaders = tuple ( loaders )	put loaders elements in a tuple, substitute it for template_source_loaders.
for loader in template_source_loaders :	for every loader in template_source_loaders,
try :	try,
source , display_name = loader ( name , dirs )	call the function loader with 2 arguments name and dirs, substitute the result for source and display_name, respectively.
return ( source , make_origin ( display_name , loader , name , dirs ) )	call the function make_origin with 4 arguments: display_name, loader, name and dirs, return a tuple containing 2 elements:
except TemplateDoesNotExist :	source and previous result.   if TemplateDoesNotExist exception is caught,
pass	do nothing,
raise TemplateDoesNotExist ( name )	raise an TemplateDoesNotExist exception with an argument name.
def get_template ( template_name , dirs = None ) :	define the function get_template with 2: template_name and dirs set to None.
template , origin = find_template ( template_name , dirs )	call the function find_template with 2 arguments: template_name and dirs, substitute the result for template and origin.
if not hasattr ( template , 'render' ) :	if template has an attribute 'render',
template = get_template_from_string ( template , origin , template_name )	call the function get_template_from_string with 3 arguments: template, origin and template_name, substitute the result for template.
return template	return template.
def get_template_from_string ( source , origin = None , name = None ) :	define the function get_template_from_string with 3: source, origin set to None and name set to None.
return Template ( source , origin , name )	return an instance of Template class, created with 2 arguments: source, origin and name, return the result.
def render_to_string ( template_name , dictionary = None , context_instance = None ,  dirs = None ) :	define the function render_to_string with 4 arguments: template_name, dictionary set to None, context_instance set to None and dirs set to None.
if isinstance ( template_name , ( list , tuple ) ) :	if template_name is an instance of list or tuple types,
t = select_template ( template_name , dirs )	call the function select_template with 2 arguments: template_name, dirs, substitute the result for t.
else :	if not,
t = get_template ( template_name , dirs )	call the function get_template with 2 arguments: template_name and dirs, substitute the result for t.
if not context_instance :	if context_instance is false,
return t . render ( Context ( dictionary ) )	call the method t.render with an argument, instance of Context class, created with an argument dictionary, return the result.
if not dictionary :	if dictionary is false,
return t . render ( context_instance )	call the function t.render with an argument context_instance, return the result.
with context_instance . push ( dictionary ) :	call the method context_instance.push with an argument dictionary, with the result perform,
return t . render ( context_instance )	call the function t.render with an argument context_instance, return the result.
def select_template ( template_name_list , dirs = None ) :	define the function select_template with 2 arguments: template_name_list and dirs set to None.
if not template_name_list :	if template_name_list is false,
raise TemplateDoesNotExist ( 'No template names provided' )	raise an TemplateDoesNotExist exception with an argument string 'No template names provided'.
not_found = [ ]	not_found is an empty list.
for template_name in template_name_list :	for every template_name in template_name_list,
try :	try,
return get_template ( template_name , dirs )	call the function get_template with 2 arguments template_name and dirs, return the result.
except TemplateDoesNotExist as e :	if TemplateDoesNotExist, renamed to e, exception is caught,
if e . args [ 0 ] not in not_found :	if first element of e.args is not contained in not_found,
not_found . append ( e . args [ 0 ] )	append first element of e.args to not_found list.
continue	skip this loop iteration.
raise TemplateDoesNotExist ( ', ' . join ( not_found ) )	raise an TemplateDoesNotExist exception with an argument, elements of not_found joined into a string, separated with ', '
from collections import defaultdict	from collections import defaultdict into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . template . base import TemplateSyntaxError , Library , Node , TextNode , token_kwargs , Variable	from django.template.base import TemplateSyntaxError, Library, Node, TextNode, token_kwargs and Variable into default namespace.
from django . template . loader import get_template	from django.template.loader import get_template into default name space.
from django . utils . safestring import mark_safe	from django.utils.safestring import mark_safe into default name space.
from django . utils import six	from django.utils import six into default name space.
register = Library ( )	register is an instance of Library class.
BLOCK_CONTEXT_KEY = 'block_context'	BLOCK_CONTEXT_KEY is a strign 'block_context'.
class ExtendsError ( Exception ) :	derive the class ExtendsError from the Exception base class.
pass	do nothing.
class BlockContext ( object ) :	derive the class BlockContext from the Exception base class.
def __init__ ( self ) :	define the method __init__ with an argument self.
self . blocks = defaultdict ( list )	convert elements of defaultdict to list, substitute it for self.blocks.
def add_blocks ( self , blocks ) :	define the method self and blocks.
for name , block in six . iteritems ( blocks ) :	call the function  six.iteritems with an argument blocks, for every name and block in result,
self . blocks [ name ] . insert ( 0 , block )	get the value under the name key of self.blocks dictionary, insert to it block at the beginning.
def pop ( self , name ) :	define the method self and name.
try :	try,
return self . blocks [ name ] . pop ( )	remove the first element of value under the name key of self.blocks dictionary, return it.
except IndexError :	if IndexError exception is caught,
return None	return None.
def push ( self , name , block ) :	define the method push with 3 arguments: self, name and block.
self . blocks [ name ] . append ( block )	append block to the value under the name key of self.blocks dictionary.
def get_block ( self , name ) :	define the method get_block with 2 arguments self and name.
try :	try,
return self . blocks [ name ] [ - 1 ]	get value under the self.blocks dictionary under the name key, return the last element.
except IndexError :	if IndexError exception is caught,
return None	return None.
class BlockNode ( Node ) :	derive the class BlockNode from the Node base class.
def __init__ ( self , name , nodelist , parent = None ) :	define the method __init__ with 4 arguments: self, name, nodelist, parent set to None.
self . name , self . nodelist , self . parent = name , nodelist , parent	substitute name, nodelist and parent for self.name, self.nodelist and self.parent.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return '<Block Node: %s. Contents: %r>' % ( self . name , self . nodelist )	return string '<Block Node: %s. Contents: %r>', where '%s' is replaced with self.name and '%r' with self.nodelist.
def render ( self , context ) :	define the method render with 2 arguments self and context.
block_context = context . render_context . get ( BLOCK_CONTEXT_KEY )	get value under the BLOCK_CONTEXT_KEY key of context.render_context dictionary, substitute it for block_context.
with context . push ( ) :	call the context.push method, with the result, perform,
if block_context is None :	if block_context is None,
context [ 'block' ] = self	substitute self for value under the 'block' key of context dictionary.
result = self . nodelist . render ( context )	call the method self.nodelist.render with an argument context, substitute the result for result.
else :	if not,
push = block = block_context . pop ( self . name )	call the method block_context.pop with an argument self.name, assign the result to push and block.
if block is None :	if block is None,
block = self	substitute self for block.
block = type ( self ) ( block . name , block . nodelist )	convert self to a tuple, call the result with 2 arguments: block.name and block.nodelist, substitute the result for block.
block . context = context	substitute context for block.context.
context [ 'block' ] = block	substitute block for value under the 'block' key of context dictionary.
result = block . nodelist . render ( context )	call the method block.nodelist.render with an argument context, substitute the result for result.
if push is not None :	if push is not None,
block_context . push ( self . name , push )	call the method block_context.push with 2 arguments: self.name and push.
return result	return result.
def super ( self ) :	define the method super with an argument self.
render_context = self . context . render_context	substitute self.context.render_context for render_context.
if ( BLOCK_CONTEXT_KEY in render_context and  render_context [ BLOCK_CONTEXT_KEY ] . get_block ( self . name ) is not None ) :	if BLOCK_CONTEXT_KEY is contained in render_context and call to the method get_block with an argument self.name from the object,
return mark_safe ( self . render ( self . context ) )	under the BLOCK_CONTEXT_KEY key of render_context dictionary dictionary evaluates to be not equal to None,   call the method self.render with an argument self.context, use it as an argument for the call to the mark_safe function, return the result.
return ''	return an empty string.
class ExtendsNode ( Node ) :	derive the class ExtendsNode from the Node base class.
must_be_first = True	must_be_first is boolean True.
def __init__ ( self , nodelist , parent_name , template_dirs = None ) :	define the method __init__ with 4 arguments: self, nodelist, parent_name and template_dirs set to None.
self . nodelist = nodelist	substitute nodelist for self.nodelist.
self . parent_name = parent_name	substitute parent_name for self.parent_name.
self . template_dirs = template_dirs	substitute template_dirs for self.template_dirs.
self . blocks = dict ( ( n . name , n ) for n in nodelist . get_nodes_by_type ( BlockNode ) )	self.blocks is a dictionary with elements: n for n.name, for every n in return value of the method nodelist.get_nodes_by_type,
def __repr__ ( self ) :	called with an argument BlockNode.   define the method __repr__ with an argument self.
return '<ExtendsNode: extends %s>' % self . parent_name . token	return an string '<ExtendsNode: extends %s>', where '%s' is replaced with self.parent_name.token.
def get_parent ( self , context ) :	define the method get_parent with 2 arguments self and context.
parent = self . parent_name . resolve ( context )	call the method self.parent_name.resolve with an argument context.
if not parent :	if parent is false,
error_msg = 'Invalid template name in 'extends' tag: %r.' % parent	error_msg is a string 'Invalid template name in 'extends' tag: %r.', where '%s' is replaced with parent.
if self . parent_name . filters or isinstance ( self . parent_name . var , Variable ) :	if self.parent_name.filters is true or self.parent_name.var is an instance of Variable.
error_msg += ' Got this from the '%s' variable.' % self . parent_name . token	append string ' Got this from the '%s' variable.' to error_msg, where '%s is replaced with self.parent_name.token.
raise TemplateSyntaxError ( error_msg )	raise an TemplateSyntaxError exception with an argument error_msg.
if hasattr ( parent , 'render' ) :	if parent has an attribute 'render',
return parent	return parent.
return get_template ( parent )	call the function get_template with an argument parent, return the result.
def render ( self , context ) :	define the method render with 2 arguments self and context.
compiled_parent = self . get_parent ( context )	call the method self.get_parent with an argument context, substitute the result for compiled_parent.
if BLOCK_CONTEXT_KEY not in context . render_context :	if BLOCK_CONTEXT_KEY is not contained in context.render_context,
context . render_context [ BLOCK_CONTEXT_KEY ] = BlockContext ( )	value under the BLOCK_CONTEXT_KEY key of context.render_context dictionary is BlockContext class instance.
block_context = context . render_context [ BLOCK_CONTEXT_KEY ]	get the value under the BLOCK_CONTEXT_KEY key of the context.render_context dictionary, substitute it for block_context.
block_context . add_blocks ( self . blocks )	call the method block_context.add_blocks with an argument self.block.
for node in compiled_parent . nodelist :	for every node in compiled_parent.nodelist,
if not isinstance ( node , TextNode ) :	if node is not an instance of TextNode,
if not isinstance ( node , ExtendsNode ) :	if node is not an instance of ExtendsNode,
blocks = dict ( ( n . name , n ) for n in  compiled_parent . nodelist . get_nodes_by_type ( BlockNode ) )	blocks is a dictionary with elements: n for n.name, for every n in return value of the method,
block_context . add_blocks ( blocks )	compiled_parent.nodelist.get_nodes_by_type, called with an argument BlockNode.   call the method block_context.add_blocks with an argument blocks.
break	break from the loop execution.
return compiled_parent . _render ( context )	call the method compiled_parent._render with an argument context, return the result.
class IncludeNode ( Node ) :	derive the class IncludeNode from the Node base class.
def __init__ ( self , template , * args , ** kwargs ) :	define the method __init__ with 4 arguments: self, template, unpacked list args and unpacked dictionary kwargs.
self . template = template	substitute template for self.template.
self . extra_context = kwargs . pop ( 'extra_context' , { } )	remove kwargs dictionary entry under the 'extra_context' key, if it exists substitute it for self.extra_context,
self . isolated_context = kwargs . pop ( 'isolated_context' , False )	if not self.extra_context is an empty dictionary.   remove kwargs dictionary entry under the 'isolated_context' key, if it exists substitute it for self.isolated_context,
super ( IncludeNode , self ) . __init__ ( * args , ** kwargs )	if not self.isolated_context is boolean False.   call the method __init__ from the base class of the class IncludeNode, called with 2 arguments: unpacked dictionary args,
def render ( self , context ) :	and unpacked dictionary kwargs.   define the method render with 2 arguments self and context.
try :	try,
template = self . template . resolve ( context )	call the method self.template.resolve with an argument context, substitute the result for template.
if not callable ( getattr ( template , 'render' , None ) ) :	get 'render' attribute of template object, if it is callable,
template = get_template ( template )	call the method get_template with an argument template, substitute the result for template.
values = {  name : var . resolve ( context )  for name , var in six . iteritems ( self . extra_context )  }	values is an dictionary with entries: return value of the method var.resolve with an argument context for name,
if self . isolated_context :	for every name and var in return value of the function six.iteritems called with an argument self.extra_context.   if self.isolated_context is true,
return template . render ( context . new ( values ) )	call the method context.new with an argument values, use it as an argument for the call to the method template.render, return the result.
with context . push ( ** values ) :	call the method context.push with unpacked dictionary values as an argument, with the result perform,
return template . render ( context )	call the method template.render with an argument context, return the result.
except Exception :	if Exception exception is caught,
if settings . TEMPLATE_DEBUG :	if settings.TEMPLATE_DEBUG is true,
raise	raise an exception,
return ''	return an empty string.
@ register . tag ( 'block' )	decorator method register.tag with an argument 'block',
def do_block ( parser , token ) :	define the function do_block with 2 arguments parser and token.
bits = token . contents . split ( )	call the method token.contents.split, substitute the result for bits.
if len ( bits ) != 2 :	if length of bits is not equal to integer 2,
block_name = bits [ 1 ]	where '%s' is replaced with first element of bits.   substitute second element for bits for block_name.
try :	try,
if block_name in parser . __loaded_blocks :	if block_name is contained in parser.__loaded_blocks,
parser . __loaded_blocks . append ( block_name )	substitute '%s' with first element of bits and block_name, respectively.   append block_name to parser.__loaded_blocks.
except AttributeError :	if AttributeError exception is caught,
parser . __loaded_blocks = [ block_name ]	substitute list with an element block_name for parser.__loaded_blocks.
nodelist = parser . parse ( ( 'endblock' , ) )	call the method parser.parse with an argument tuple with one element string 'endblock', substitute the result for nodelist.
endblock = parser . next_token ( )	call the method parser.next_token, substitute the result for endblock.
acceptable_endblocks = ( 'endblock' , 'endblock %s' % block_name )	acceptable_endblocks is a tuple with 2 elements: string 'endblock' and 'endblock %s', where '%s' replaced with block_name.
if endblock . contents not in acceptable_endblocks :	if endblock.contents is not contained in acceptable_endblocks,
parser . invalid_block_tag ( endblock , 'endblock' , acceptable_endblocks )	call the method parser.invalid_block_tag with 3 arguments: endblock, 'endblock' and acceptable_endblocks.
return BlockNode ( block_name , nodelist )	return an instance of a BlockNode class, created with 2 arguments: block_name and nodelist.
@ register . tag ( 'extends' )	decorator method register.tag with an argument 'extends',
def do_extends ( parser , token ) :	define the function do_extends with 2 arguments parser and token.
bits = token . split_contents ( )	call the method token.split_contents, substitute the result for bits.
if len ( bits ) != 2 :	if length of bits is not equalt to integer 2,
parent_name = parser . compile_filter ( bits [ 1 ] )	call the method parser.compile_filter with an argument second element for bits, substitute the result for parent_name.
nodelist = parser . parse ( )	call the method parser.parse, substitute the result for nodelist.
if nodelist . get_nodes_by_type ( ExtendsNode ) :	call the method nodelist.get_nodes_by_type with an argument ExtendsNode, if it evaluates to true,
return ExtendsNode ( nodelist , parent_name )	where '%s' is replaced with first element of bits.   return an instance of ExtendsNode with 2 arguments nodelist and parent_name.
@ register . tag ( 'include' )	decorator method register.tag with an argument 'include',
def do_include ( parser , token ) :	define the function do_include with 2 arguments parser and token.
bits = token . split_contents ( )	call the method token.split_contents, substitute the result for bits.
if len ( bits ) < 2 :	if length of bits is lesser than integer 2,
raise TemplateSyntaxError ( '%r tag takes at least one argument: the name of the template to be included.' % bits [ 0 ] )	raise an TemplateSyntaxError with an argument string '%r tag takes at least one argument: the name of the template to be included.',
options = { }	where '%r' is replaced with first element of bits.   options is an empty dictionary.
remaining_bits = bits [ 2 : ]	substitute bits, without the first two elements, substitute the result for remaining_bits.
while remaining_bits :	while remaining_bits is true,
option = remaining_bits . pop ( 0 )	remove first element from remaining_bits, substitute the result for option.
if option in options :	if option is contained in options,
raise TemplateSyntaxError ( 'The %r option was specified more '  'than once.' % option )	raise an TemplateSyntaxError exception with an argument string 'The %r option was specified more than once.',
if option == 'with' :	where '%r' is replaced with options.   if option equals a string 'with',
value = token_kwargs ( remaining_bits , parser , support_legacy = False )	call the function token_kwargs with 3 arguments: remaining_bits, parser, support_legacy set to boolean False, substitute the result for value.
if not value :	if value is true,
elif option == 'only' :	where '%s' is replaced with first element of bits.   otherwise if options equals 'only',
value = True	value is boolean True.
else :	if not,
raise TemplateSyntaxError ( 'Unknown argument for %r tag: %r.' %  ( bits [ 0 ] , option ) )	raise an TemplateSyntaxError with an argument string 'Unknown argument for %r tag: %r.', where '%r' is replaced with first element of bits and options.
options [ option ] = value	substitute value for value under the options key of options dictionary.
isolated_context = options . get ( 'only' , False )	get the value under the key 'only' of the options dictionary, if it exists substitute the result for isolated_context,
namemap = options . get ( 'with' , { } )	if not, isolated_context is boolean False.   get the value under the 'width' key of the options dictionary, if it exists, substitute it for namemap, if not namemap is an empty dictionary.
return IncludeNode ( parser . compile_filter ( bits [ 1 ] ) , extra_context = namemap ,  isolated_context = isolated_context )	return an instance of IncludeNode class, created with 3 arguments: return value of the method parser.compile_filter,
import os	import module os.
import sys	import module sys.
from django . apps import apps	from django.apps import apps into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . template . base import TemplateDoesNotExist	from django.template.base import TemplateDoesNotExist into default name space.
from django . template . loader import BaseLoader	from django.template.loader import BaseLoader into default name space.
from django . utils . _os import safe_join	from django.utils._os import safe_join into default name space.
from django . utils import six	from django.utils import six into default name space.
def calculate_app_template_dirs ( ) :	define the function calculate_app_template_dirs.
if six . PY2 :	if six.PY2 is true,
fs_encoding = sys . getfilesystemencoding ( ) or sys . getdefaultencoding ( )	call the function sys.getfilesystemencoding, if it evaluates to true, substitute the result for fs_encoding,
app_template_dirs = [ ]	if not, call the function sys.getdefaultencoding and substitute the result for fs_encoding.   app_template_dirs is an empty list.
for app_config in apps . get_app_configs ( ) :	call the function apps.get_app_configs, for every app_config in result,
if not app_config . path :	if app_config.path is true,
continue	skip this loop iteration.
template_dir = os . path . join ( app_config . path , 'templates' )	join app_config.path and string 'templates' into file path, substitute it for template_dir.
if os . path . isdir ( template_dir ) :	if template_dir is directory,
if six . PY2 :	if six.PY2 is true,
template_dir = template_dir . decode ( fs_encoding )	call the function template_dir.decode with an argument fs_encoding, substitute the result for template_dir.
app_template_dirs . append ( template_dir )	append template_dir to app_template_dirs.
return tuple ( app_template_dirs )	convert app_template_dirs to a tuple, return it.
app_template_dirs = calculate_app_template_dirs ( )	call the function calculate_app_template_dirs, substitute the result for app_template_dirs.
class Loader ( BaseLoader ) :	derive the class Loader from the BaseLoader base class.
is_usable = True	is_usable is boolean True.
def get_template_sources ( self , template_name , template_dirs = None ) :	define the method get_template_sources with 3 arguments: self, template_name, template_dirs set to None.
if not template_dirs :	if template_dirs is false,
template_dirs = app_template_dirs	substitute app_template_dirs for template_dirs.
for template_dir in template_dirs :	for every template_dir in template_dirs,
try :	try,
yield safe_join ( template_dir , template_name )	call the function safe_join with 2 arguments template_dir and template_name, yield the result.
except UnicodeDecodeError :	if UnicodeDecodeError exception is caught,
raise	raise an exception.
except ValueError :	if ValueError exception is caught,
pass	do nothing.
def load_template_source ( self , template_name , template_dirs = None ) :	define the method load_template_source with 3 arguments: self, template_name, template_dirs set to None.
for filepath in self . get_template_sources ( template_name , template_dirs ) :	call the method self.get_template_sources with 2 arguments template_name and template_dirs, for every filepath in the result,
try :	try,
with open ( filepath , 'rb' ) as fp :	open the file named filepath in read mode, with file descriptor renamed to fp perform,
return ( fp . read ( ) . decode ( settings . FILE_CHARSET ) , filepath )	read file fp, call the method decode on the result with an argument settings.FILE_CHARSET, return tuple containing 2 elements,
except IOError :	previous result and filepath.   if IOError exception is caught,
pass	do nothing.
raise TemplateDoesNotExist ( template_name )	raise an TemplateDoesNotExist exception with an argument template_name.
import hashlib	import module hashlib.
from django . template . base import TemplateDoesNotExist	from django.template.base import TemplateDoesNotExist into default name space.
from django . template . loader import BaseLoader , get_template_from_string , find_template_loader , make_origin	from django.template.loader import BaseLoader, get_template_from_string, find_template_loader and make_origin into default name space.
from django . utils . encoding import force_bytes	from django.utils.encoding import force_bytes into default name space.
class Loader ( BaseLoader ) :	derive the class Loader from the BaseLoader base class.
is_usable = True	is_usable is boolean True.
def __init__ ( self , loaders ) :	define the method __init__ with 2 arguments: self and loaders.
self . template_cache = { }	self.template_cache is an empty dictionary.
self . find_template_cache = { }	self.find_template_cache is an empty dictionary.
self . _loaders = loaders	substitute loaders for self._loaders.
self . _cached_loaders = [ ]	self._cached_loaders is an empty list.
@ property	property decorator.
def loaders ( self ) :	define the method loaders with an argument self.
if not self . _cached_loaders :	if self._cached_loaders is false,
cached_loaders = [ ]	cached_loaders is an empty list.
for loader in self . _loaders :	for every loader in self._loaders,
cached_loaders . append ( find_template_loader ( loader ) )	call the function find_template_loader with an argument loader, append the result to cached_loaders.
self . _cached_loaders = cached_loaders	substitute cached_loaders for self._cached_loaders.
return self . _cached_loaders	return self._cached_loaders.
def cache_key ( self , template_name , template_dirs ) :	define the method cache_key with 3 arguments: self, template_name and template_dirs.
if template_dirs :	if template_dirs is true,
return '-' . join ( [ template_name , hashlib . sha1 ( force_bytes ( '|' . join ( template_dirs ) ) ) . hexdigest ( ) ] )	join template_dirs elements into a string, separated by '|', use it as an argument for the call to the function force_bytes,
else :	use the result as the argument for the call to the function hashlib.sha1, call the hexdigest method on the result,   join template_name and previous final result into a string, separated with '-', return it.   if not,
return template_name	return template_name.
def find_template ( self , name , dirs = None ) :	define the method find_template with 3 arguments: self, name, dirs set to None.
key = self . cache_key ( name , dirs )	call the method self.cache_key with 2 arguments name and dirs, substitute the result for key.
try :	try,
result = self . find_template_cache [ key ]	get the value under the key key of the self.find_template_cache dictionary, substitute it for result.
except KeyError :	if KeyError exception is caught,
result = None	result is None.
for loader in self . loaders :	for every loader in self.loaders,
try :	try,
template , display_name = loader ( name , dirs )	call the function loader with arguments name and dirs, assign the result to template and display_name, respectively.
except TemplateDoesNotExist :	if TemplateDoesNotExist exception is caught,
pass	do nothing.
else :	if not,
result = ( template , make_origin ( display_name , loader , name , dirs ) )	result is an tuple with 2 elements: template and return value of the function make_origin called with 4 arguments: display_name,  loader, name and dirs.
break	break from the loop execution.
self . find_template_cache [ key ] = result	substitute result for self.find_template_cache dictionary value under the key key.
if result :	if result is true,
return result	return result
else :	if not,
self . template_cache [ key ] = TemplateDoesNotExist	substitute TemplateDoesNotExist for self.find_template_cache dictionary value under the key key.
raise TemplateDoesNotExist ( name )	raise an TemplateDoesNotExist exception with an argument name.
def load_template ( self , template_name , template_dirs = None ) :	define the method load_template with 3 arguments: self, template_name, template_dirs set to None.
key = self . cache_key ( template_name , template_dirs )	get the value under the template_name key of the self.cache_key dictionary, if it exists, substitute it for key,
template_tuple = self . template_cache . get ( key )	if not, substitute template_dirs for key.   get the value under the key key of the self.template_cache dictionary, substitute it for template_tuple.
if template_tuple is TemplateDoesNotExist :	if template_tuple is contained in TemplateDoesNotExist,
raise TemplateDoesNotExist	raise an TemplateDoesNotExist exception.
elif template_tuple is None :	otherwise if template_tuple is None,
template , origin = self . find_template ( template_name , template_dirs )	call the method self.find_template with 2 argumetns: template_name and template_dirs, assign the result to template, origin, respectively.
if not hasattr ( template , 'render' ) :	if template doesnt have a 'render' attribute,
try :	try,
template = get_template_from_string ( template , origin , template_name )	call the function get_template_from_string with 3 arguments: template, origin and template_name, substitute the result for template.
except TemplateDoesNotExist :	if TemplateDoesNotExist exception is caught,
    self . template_cache [ key ] = ( template , origin )	substitute a tuple with 2 elements: template and origin, for self.find_template_cache dictionary value under the key key.
self . template_cache [ key ] = ( template , None )	substitute a tuple with 2 elements: template and None, for self.find_template_cache dictionary value under the key key.
return self . template_cache [ key ]	return self.find_template_cache dictionary value under the key key.
def reset ( self ) :	define the method reset with an argument self.
self . template_cache . clear ( )	call the method self.template_cache.clear.
self . find_template_cache . clear ( )	call the method self.find_template_cache.clear.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
try :	try,
from pkg_resources import resource_string	from pkg_resources import resource_string into default name space.
except ImportError :	if ImportError exception is caught,
resource_string = None	resource_string is None.
from django . apps import apps	from django.apps import apps into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . template . base import TemplateDoesNotExist	from django.template.base import TemplateDoesNotExist into default name space.
from django . template . loader import BaseLoader	from django.template.loader import BaseLoader into default name space.
from django . utils import six	from django.utils import six into default name space.
class Loader ( BaseLoader ) :	derive the class Loader from the BaseLoader base class.
is_usable = resource_string is not None	if resource_string is not None, is_usable is boolean True, otherwise is_usable is boolean False.
def load_template_source ( self , template_name , template_dirs = None ) :	define the method load_template_source with 3 arguments: self, template_name, template_dirs set to None.
if resource_string is not None :	if resource_string is not None,
pkg_name = 'templates/' + template_name	concatenate string 'templates/' and template_name, substitute the result for pkg_name.
for app_config in apps . get_app_configs ( ) :	call the method apps.get_app_configs, for app_config in the result,
try :	try,
resource = resource_string ( app_config . name , pkg_name )	call the function resource_string with 2 arguments app_config.name and pkg_name, substitute the result for resource.
except Exception :	if Exception exception is caught,
continue	skip this loop iteration.
if six . PY2 :	if six.PY2 is true,
resource = resource . decode ( settings . FILE_CHARSET )	call the method resource.decode with an argument settings.FILE_CHARSET, substitute the result for resource.
return ( resource , 'egg:%s:%s' % ( app_config . name , pkg_name ) )	return a tuple with 2 elements: resource and string 'egg:%s:%s', where '%s' is replaced with app_config.name and pkg_name, respective.
raise TemplateDoesNotExist ( template_name )	raise an TemplateDoesNotExist exception with an argument template_name.
from django . conf import settings	from django.conf import settings into default name space.
from django . template . base import TemplateDoesNotExist	from django.template.base import TemplateDoesNotExist into default name space.
from django . template . loader import BaseLoader	from django.template.loader import BaseLoader into default name space.
from django . utils . _os import safe_join	from django.utils._os import safe_join into default name space.
class Loader ( BaseLoader ) :	derive the class Loader from the BaseLoader base class.
is_usable = True	is_usable is boolean True.
def get_template_sources ( self , template_name , template_dirs = None ) :	define the method get_template_source with 3 arguments: self, template_name, template_dirs set to None.
if not template_dirs :	if template_dirs is false,
template_dirs = settings . TEMPLATE_DIRS	substitute settings.TEMPLATE_DIRS for template_dirs.
for template_dir in template_dirs :	for every template_dir in template_dirs,
try :	try,
yield safe_join ( template_dir , template_name )	call the function safe_join with 2 arguments template_dir and template_name, yield the result.
except UnicodeDecodeError :	if UnicodeDecodeError exception is caught,
raise	raise an exception.
except ValueError :	if ValueError exception is caught,
pass	do nothing.
def load_template_source ( self , template_name , template_dirs = None ) :	define the method load_template_source with 3 arguments: self, template_name, template_dirs set to None.
tried = [ ]	tried is an empty list.
for filepath in self . get_template_sources ( template_name , template_dirs ) :	call the method self.get_template_sources with 2 arguments template_name and template_dirs, for every filepath in the result,
try :	try,
with open ( filepath , 'rb' ) as fp :	open the file named filepath in read mode, with file descriptor renamed to fp perform,
return ( fp . read ( ) . decode ( settings . FILE_CHARSET ) , filepath )	read file fp, call the method decode on the result with an argument settings.FILE_CHARSET, return tuple containing 2 elements,
except IOError :	previous result and filepath.   if IOError exception is caught,
tried . append ( filepath )	append filepath to tried.
if tried :	if tried is true,
error_msg = 'Tried %s' % tried	err_msg is a string 'Tried %s', where '%s' is replaced with tried.
else :	if not,
error_msg = 'Your TEMPLATE_DIRS setting is empty. Change it to point to at least one template directory.'	error_msg is a string 'Your TEMPLATE_DIRS setting is empty. Change it to point to at least one template directory.'.
raise TemplateDoesNotExist ( error_msg )	raise an TemplateDoesNotExist exception with an argument error_msg.
load_template_source . is_usable = True	load_template_source.is_usable is boolean True.
from django . http import HttpResponse	from django.http import HttpResponse into default name space.
from django . template import loader , Context , RequestContext	from django.template import loader,  Context and RequestContext into default name space.
from django . utils import six	from django.utils import six into default name space.
class ContentNotRenderedError ( Exception ) :	derive the class ContentNotRenderedError from the Exception base class.
pass	do nothing.
class SimpleTemplateResponse ( HttpResponse ) :	derive the class SimpleTemplateResponse from the HttpResponse base class.
rendering_attrs = [ 'template_name' , 'context_data' , '_post_render_callbacks' ]	rendering_attrs is a list containing 3 strings: 'template_name', 'context_data' and '_post_render_callbacks'.
def __init__ ( self , template , context = None , content_type = None , status = None ) :	define the method __init__ with 5 arguments: self, template, context set to None, content_type set to None and status set to None.
self . template_name = template	substitute template for self.template_name.
self . context_data = context	substitute context for self.context_data.
self . _post_render_callbacks = [ ]	self._post_render_callbacks is an empty list.
super ( SimpleTemplateResponse , self ) . __init__ ( '' , content_type , status )	call the __init__ method from the base class of the class SimpleTemplateResponse, with 3 arguments: an empty string, content_type and status.
self . _is_rendered = False	self._is_rendered is boolean False.
def __getstate__ ( self ) :	define the method __getstate__ with an argument self.
obj_dict = super ( SimpleTemplateResponse , self ) . __getstate__ ( )	call the __getstate__ method from the base class of the class SimpleTemplateResponse, substitute the result for obj_dict.
if not self . _is_rendered :	if self._is_rendered is false,
raise ContentNotRenderedError ( 'The response content must be '  'rendered before it can be pickled.' )	raise an ContentNotRenderedError exception with an argument string 'The response content must be rendered before it can be pickled.'.
for attr in self . rendering_attrs :	for every attr in self.rendering_attrs,
if attr in obj_dict :	if attr is contained in obj_dict,
del obj_dict [ attr ]	delete entry under the attr key of obj_dict dictionary.
return obj_dict	return obj_dict.
def resolve_template ( self , template ) :	define the method resolve_template with 2 arguments: self and template.
if isinstance ( template , ( list , tuple ) ) :	if template is an instance of list or tuple types,
return loader . select_template ( template )	call the method loader.select_template with an argument template, return the result.
elif isinstance ( template , six . string_types ) :	otherwise is template is six.string_types instance,
return loader . get_template ( template )	call the method loader.get_template with an argument template, return the result.
else :	if not,
return template	return template.
def resolve_context ( self , context ) :	define the method resolve_context with 2 arguments: self and context.
if isinstance ( context , Context ) :	if context is an instance of Context,
return context	return context.
else :	if not,
return Context ( context )	return an instance of Context class, created with an argument context.
@ property	property decorator,
def rendered_content ( self ) :	define the method rendered_content with an argument self.
template = self . resolve_template ( self . template_name )	call the method self.resolve_template with an argument self.template_name, substitute the result for template.
context = self . resolve_context ( self . context_data )	call the method self.resolve_context with an argument self.context_data, substitute the result for context.
content = template . render ( context )	call the method template.render with an argument context, substitute the result for content.
return content	return content.
def add_post_render_callback ( self , callback ) :	define the method add_post_render_callback with 2 arguments: self and callback.
if self . _is_rendered :	if self._is_rendered is true,
callback ( self )	call the functoin callback with an argument self.
else :	if not,
self . _post_render_callbacks . append ( callback )	append callback to self._post_render_callbacks list.
def render ( self ) :	define the method render with an argument self.
retval = self	substitute self for retval.
if not self . _is_rendered :	if self._is_rendered is false,
self . content = self . rendered_content	substitute self.rendered_content for self.content.
for post_callback in self . _post_render_callbacks :	for every post_callback in self._post_render_callbacks,
newretval = post_callback ( retval )	call the function post_callback with an argument retval, substitute the result for newretval.
if newretval is not None :	if newretval is not None,
retval = newretval	substitute newretval for retval.
return retval	return retval.
@ property	property decorator,
def is_rendered ( self ) :	define the method is_rendered with an argument self.
return self . _is_rendered	return self._is_rendered.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
if not self . _is_rendered :	if self._is_rendered is false,
raise ContentNotRenderedError ( 'The response content must be '  'rendered before it can be iterated over.' )	raise an ContentNotRenderedError exception with an string 'The response content must be rendered before it can be iterated over.'.
return super ( SimpleTemplateResponse , self ) . __iter__ ( )	call the method __init__ from the base class of the class SimpleTemplateResponse, return the result.
@ property	property decorator,
def content ( self ) :	define the method content with an argument self.
if not self . _is_rendered :	if self._is_rendered is false.
raise ContentNotRenderedError ( 'The response content must be '  'rendered before it can be accessed.' )	raise an ContentNotRenderedError exception with an sring 'The response content must be rendered before it can be accessed.'.
return super ( SimpleTemplateResponse , self ) . content	return the content field of the base class of the class SimpleTemplateResponse.
@ content . setter	content.setter decorator,
def content ( self , value ) :	define the method content with 2 arguments: self and value.
HttpResponse . content . fset ( self , value )	call the method HttpResponse.content.fset with 2 arguments: self and value.
self . _is_rendered = True	self._is_rendered is boolean True.
class TemplateResponse ( SimpleTemplateResponse ) :	derive the class TemplateResponse from the SimpleTemplateResponse base class.
rendering_attrs = SimpleTemplateResponse . rendering_attrs + [ '_request' , '_current_app' ]	append list with 2 strings: '_request' and '_current_app' to SimpleTemplateResponse.rendering_attrs, substitute the result for rendering_attrs.
def __init__ ( self , request , template , context = None , content_type = None ,  status = None , current_app = None ) :	define the method __init__ with 7 arguments: self, request, template, context set to None, content_type set to None,
self . _request = request	status set to None and current_app set to None.   substitute request for self._request.
self . _current_app = current_app	substitute current_app for self._current_app.
super ( TemplateResponse , self ) . __init__ (  template , context , content_type , status )	call the __init__ method from the base class of the class TemplateResponse, with 4 arguments: template, context, content_type, status.
def resolve_context ( self , context ) :	define the method resolve_context with 2 arguments: self and context.
if isinstance ( context , Context ) :	if context is an instance of Context class.
return context	return context.
return RequestContext ( self . _request , context , current_app = self . _current_app )	return an instance of RequestContext class, created with 3 arguments: self._request, context and current_app set to self._current_app.
class TokenBase ( object ) :	derive the class TokenBase from the object base class.
id = None	id is None.
value = None	value is None.
first = second = None	first and second are None.
def nud ( self , parser ) :	define the method nud with 2 arguments: self and parser.
raise parser . error_class (  'Not expecting '%s' in this position in if tag.' % self . id  )	raise an exception parser.error_class with an argument string 'Not expecting '%s' in this position in if tag.',
def led ( self , left , parser ) :	where '%s' is replaced with self.id.   define the method led with 3 arguments: self, left and parser.
raise parser . error_class (  'Not expecting '%s' as infix operator in if tag.' % self . id  )	raise an exception parser.error_class with an argument string 'Not expecting '%s' as infix operator in if tag.',
def display ( self ) :	where '%s' is replaced with self.id.   define the method display with an argument self.
return self . id	return self.id.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
out = [ str ( x ) for x in [ self . id , self . first , self . second ] if x is not None ]	for x in a list containing 3 elements: self.id, self.first and self.second, if x is not None,
return '(' + ' ' . join ( out ) + ')'	convert x into a string and append it to a list, substitute the resulting list for out.   join elements of out into a string, separated with whitespaces, append ')' to it, append the result to '(', return it.
def infix ( bp , func ) :	define the function infix with 2 arguments bp and func.
class Operator ( TokenBase ) :	derive the class Operator from the base class TokenBase.
lbp = bp	substitute bp for lbp.
def led ( self , left , parser ) :	define the method led with 3 arguments self, left and parser.
self . first = left	substitute left for self.first.
self . second = parser . expression ( bp )	call the method parser.expression with an argument bp, substitute it for self.seconds.
return self	return self.
def eval ( self , context ) :	define the method eval with 2 arguments self and context.
try :	try,
return func ( context , self . first , self . second )	call the function func with 3 arguments: context, self.first and self.second, return the result.
except Exception :	if Exception exception is caught,
return False	return boolean False.
return Operator	return Operator.
def prefix ( bp , func ) :	define the function prefix with 2 arguments bp and func.
class Operator ( TokenBase ) :	derive the class Operator from the base class TokenBase.
lbp = bp	substitute bp for lbp.
def nud ( self , parser ) :	define the method nud with 2 arguments self and parser.
self . first = parser . expression ( bp )	call the method parser.expression with an argument bp, substitute the result for self.first.
self . second = None	self.second is None.
return self	return self.
def eval ( self , context ) :	define the method evalu with 2 arguments self and context.
try :	try,
return func ( context , self . first )	call the function func with 2 arguments: context and self.first, return the result.
except Exception :	if Exception exception is caught,
return False	return boolean False.
return Operator	return Operator.
OPERATORS = {  'or' : infix ( 6 , lambda context , x , y : x . eval ( context ) or y . eval ( context ) ) ,  'and' : infix ( 7 , lambda context , x , y : x . eval ( context ) and y . eval ( context ) ) ,  'not' : prefix ( 8 , lambda context , x : not x . eval ( context ) ) ,  'in' : infix ( 9 , lambda context , x , y : x . eval ( context ) in y . eval ( context ) ) ,  'not in' : infix ( 9 , lambda context , x , y : x . eval ( context ) not in y . eval ( context ) ) ,  '=' : infix ( 10 , lambda context , x , y : x . eval ( context ) == y . eval ( context ) ) ,  '==' : infix ( 10 , lambda context , x , y : x . eval ( context ) == y . eval ( context ) ) ,  '!=' : infix ( 10 , lambda context , x , y : x . eval ( context ) != y . eval ( context ) ) ,  '>' : infix ( 10 , lambda context , x , y : x . eval ( context ) > y . eval ( context ) ) ,  '>=' : infix ( 10 , lambda context , x , y : x . eval ( context ) >= y . eval ( context ) ) ,  '<' : infix ( 10 , lambda context , x , y : x . eval ( context ) < y . eval ( context ) ) ,  '<=' : infix ( 10 , lambda context , x , y : x . eval ( context ) <= y . eval ( context ) ) ,  }	OPERATORS is an dictionary with 12 initial entries: result of the function inflix called with 2 arguments, integer 6,
for key , op in OPERATORS . items ( ) :	and lambda function with 3 arguments context, x and y, returns boolean True if x.eval(context) or y.eval(context) is True, for 'or',   result of the function inflix called with 2 arguments, integer 7,   and lambda function with 3 arguments context, x and y, returns boolean True if x.eval(context) and y.eval(context) is True for 'and',   result of the function prefix called with 2 arguments, integer 8,   and lambda function with 2 arguments context and x, returns boolean True if x.eval(context) is True for 'not',   result of the function inflix called with 2 arguments, integer 9,   and lambda function with 2 arguments context and x, returns boolean True if x.eval(context) is contained in y.eval(context) for 'in',   result of the function inflix called with 2 arguments, integer 9,   and lambda function with 2 arguments context and x, returns boolean True if x.eval(context) is not contained in y.eval(context),   for 'not in', result of the function inflix called with 2 arguments, integer 10,   and lambda function with 3 arguments context, x and y, returns boolean True if x.eval(context) equals y.eval(context) for '=',   result of the function inflix called with 2 arguments, integer 10,   and lambda function with 3 arguments context, x and y, returns boolean True if x.eval(context) equals y.eval(context) for '==',   result of the function inflix called with 2 arguments, integer 10,   and lambda function with 3 arguments context, x and y, returns boolean True if x.eval(context) doesnt equals y.eval(context) for '!=',   result of the function inflix called with 2 arguments, integer 10 and,   lambda function with 3 arguments context, x and y, returns boolean True if x.eval(context) is greater than y.eval(context) for '>',   result of the function inflix called with 2 arguments, integer 10 and and lambda function with 3 arguments context, x and y,   returns boolean True if x.eval(context) is greater than or equal to y.eval(context) for '>=',   result of the function inflix called with 2 arguments, integer 10 and and lambda function with 3 arguments context, x and y,   returns boolean True if x.eval(context) is smaller than y.eval(context) for '<',   result of the function inflix called with 2 arguments, integer 10 and and lambda function with 3 arguments context, x and y,   returns boolean True if x.eval(context) is smaller than or equal to y.eval(context) for '<=',   call the function OPERATORS.items, for every key and op in result,
op . id = key	substitute key for op.id.
class Literal ( TokenBase ) :	derive the class Literal from the TokenBase base class.
id = 'literal'	id is a string 'literal'.
lbp = 0	lbp is integer 0.
def __init__ ( self , value ) :	define the method __init__ with 2 arguments: self and value.
self . value = value	substitute value for self.value.
def display ( self ) :	define the method display with an argument self.
return repr ( self . value )	return printable representation of self.value.
def nud ( self , parser ) :	define the method nud with 2 arguments: self and parser.
return self	return self.
def eval ( self , context ) :	define the method eval with 2 arguments: self and context.
return self . value	return self.value.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return '(%s %r)' % ( self . id , self . value )	return string '(%s %r)', replace '%s' with self.if and '%r' with self.value.
class EndToken ( TokenBase ) :	derive the class EndToken from the TokenBase base class.
lbp = 0	lbp is an integer 0.
def nud ( self , parser ) :	define the method nud with 2 arguments: self and parser.
raise parser . error_class ( 'Unexpected end of expression in if tag.' )	raise an exception parser.error_class with an argument string 'Unexpected end of expression in if tag.'.
EndToken = EndToken ( )	EndToken is an instance of EndToken class.
class IfParser ( object ) :	derive the class IfParser from the object base class.
error_class = ValueError	substitute ValueError for error_class.
def __init__ ( self , tokens ) :	define the method __init__ with 2 arguments: self and tokens.
l = len ( tokens )	substitute length of tokens for l.
mapped_tokens = [ ]	mapped_tokens is an empty list.
i = 0	i is integer 0.
while i < l :	while i is smaller than l,
token = tokens [ i ]	substitute i-th element of tokens for token.
if token == 'not' and i + 1 < l and tokens [ i + 1 ] == 'in' :	if token equals a string 'not' and i incremented by 1 is lesser than l,
token = 'not in'	and element of tokens at i incremented by 1 index equals a string 'in',   token is a string 'not in'.
i += 1	increment i by integer 1.
mapped_tokens . append ( self . translate_token ( token ) )	call the method self.translate_token with an argument token, append the result to mapped_tokens.
i += 1	increment i by integer 1.
self . tokens = mapped_tokens	substitute mapped_tokens for self.tokens.
self . pos = 0	self.pos is integer 0.
self . current_token = self . next_token ( )	call the method self.next_token, substitute the result for self.current_token.
def translate_token ( self , token ) :	define the method translate_token with 2 arguments: self and token.
try :	try,
op = OPERATORS [ token ]	substitute OPERATORS dictionary element under token key for op.
except ( KeyError , TypeError ) :	if KeyError and TypeError exceptions are caught,
return self . create_var ( token )	call the function self.create_var with an argument token, return the result.
else :	if not,
return op ( )	call the function op, return the result.
def next_token ( self ) :	define the method next_token with an argument self.
if self . pos >= len ( self . tokens ) :	if self.pos is greater than or equal to self.tokens,
return EndToken	return EndToken.
else :	if not,
retval = self . tokens [ self . pos ]	substitute element at self.pos index of self.tokens for retval.
self . pos += 1	increment self.pos by integer 1.
return retval	return retval.
def parse ( self ) :	define the method parse with an argument self.
retval = self . expression ( )	call the method self.expression, substitute the result for retval.
if self . current_token is not EndToken :	if self.current_token is not EndToken,
raise self . error_class ( 'Unused '%s' at end of if expression.' %  self . current_token . display ( ) )	raise an exception self.error_class with an argument string ''Unused '%s' at end of if expression',
return retval	where '%s' is replaced with result of the method self.current_token.display.   return retval.
def expression ( self , rbp = 0 ) :	define the method expression with 2 arguments: self and rbp set to integer 0.
t = self . current_token	substitute self.current_token for t.
self . current_token = self . next_token ( )	call the method self.next_token, substitute the result for self.current_token.
left = t . nud ( self )	call the method t.nud with an argument self, substitute the result for left.
while rbp < self . current_token . lbp :	while rbp is smaller than self.current_token.lbp,
t = self . current_token	substitute self.current_token for t.
self . current_token = self . next_token ( )	call the method self.next_token, substitute the result for self.current_token.
left = t . led ( left , self )	call the method t.led with 2 arguments left and self.
return left	return left.
def create_var ( self , value ) :	define the method create_var with 2 arguments: self and value.
return Literal ( value )	return an instance of Literal class, created with an argumen value.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from lib2to3 import fixer_base	from lib2to3 import fixer_base into default name space.
from lib2to3 . fixer_util import find_indentation , Name , syms , touch_import	from lib2to3.fixer_util import find_indentation, Name, syms and touch_import into default name space.
from lib2to3 . pgen2 import token	from lib2to3.pgen2 import token into default name space.
from lib2to3 . pytree import Leaf , Node	from lib2to3.pytree import Leaf and Node into default name space.
class FixUnicode ( fixer_base . BaseFix ) :	derive the class FixUnicode from the base class fixer_base.BaseFix.
BM_compatible = True	BM_compatible is boolean True.
PATTERN = '''     classdef< 'class' any+ ':'               suite< any*                      funcdef< 'def' unifunc='__unicode__'                               parameters< '(' NAME ')' > any+ >                      any* > >     '''	PATTERN is a string  'classdef< 'class' any+ ':'suite< any*funcdef< 'def' unifunc='__unicode__'parameters< '(' NAME ')' > any+ >any* > >'.
def transform ( self , node , results ) :	define the method transform with 3 arguments: self, node and results.
unifunc = results [ 'unifunc' ]	substitute value under the 'unifunc' key of the results dictionary for unifunc.
strfunc = Name ( '__str__' , prefix = unifunc . prefix )	strfunc is an instance of a class Name, created with 2 arguments: string '__str__' and prefix as unifunc.prefix.
unifunc . replace ( strfunc )	call the method unifunc.replace with an argument strfunc.
klass = node . clone ( )	call the method node.clone, substitute the result for klass.
\klass . prefix = '\\n' + find_indentation ( node )\	call the method find_indentation with an argument node, append the result to newline, substitute the result for klass.prefix.
decorator = Node ( syms . decorator , [ Leaf ( token . AT , '@' ) , Name ( 'python_2_unicode_compatible' ) ] )	decorator is an instance of class Node, created with 2 arguments: instance of Leaf class created with 2 arguments: token.AT and '@',
decorated = Node ( syms . decorated , [ decorator , klass ] , prefix = node . prefix )	and instance of Name class created with an argument string 'python_2_unicode_compatible'.   decorated is an instance of class Node, created with 3 arguments: syms.decorated, list with 2 arguments: decorator and klass,
node . replace ( decorated )	and prefix as node.prefix.   call the method node.replace with an argument decorated.
touch_import ( 'django.utils.encoding' , 'python_2_unicode_compatible' , decorated )	call the function touch_import with 3 arguments: string 'django.utils.encoding', string 'python_2_unicode_compatible' and decorated.
import os	import module os.
import stat	import module sta.
import sys	import module sys.
import tempfile	import module tempfile.
from os . path import join , normcase , normpath , abspath , isabs , sep , dirname	from os.path import join, normcase, normpath, abspath, isabs, sep and dirname into default name space.
from django . utils . encoding import force_text	from django.utils.encoding import force_text into default name space.
from django . utils import six	from django.utils import six into default name space.
try :	try,
WindowsError = WindowsError	substitute WindowsError for WindowsError.
except NameError :	if NameError exception is caught,
class WindowsError ( Exception ) :	derive class WindowsError from Exception base class.
pass	do nothing.
if six . PY2 :	if six.PY2 is true,
fs_encoding = sys . getfilesystemencoding ( ) or sys . getdefaultencoding ( )	call the function sys.getfilesystemencoding if it evaluates to true, substitute its result for fs_encoding,
if six . PY3 or os . name == 'nt' :	otherwise call the function sys.getdefaultencoding and substitute its result for fs_encoding.   if six.PY3 is true or os.name equals a string 'nt',
abspathu = abspath	substitute abspath for abspathu.
else :	if not,
def abspathu ( path ) :	define the function abspathu with an argument path.
if not isabs ( path ) :	call the function isabs with an argument path, if it evaluates to false,
path = join ( os . getcwdu ( ) , path )	get the unicode representation of current working directory, join it and path into a string, substitute the result for path.
return normpath ( path )	call the function normpath with an argument path, return the result.
def upath ( path ) :	define the function upath with an argument path.
if six . PY2 and not isinstance ( path , six . text_type ) :	if six.PY2 is true and path is not an instance of six.text_type type,
return path . decode ( fs_encoding )	call the method path.decode with an argument fs_encoding, return the result.
return path	return path.
def npath ( path ) :	define the function npath with an argument path.
if six . PY2 and not isinstance ( path , bytes ) :	if six.PY2 is true and path is not an instance of byes type,
return path . encode ( fs_encoding )	call the method path.encode with an argument fs_encoding, return the result.
return path	return path.
def safe_join ( base , * paths ) :	define the function safe_join with 2 arguments base and unpacked dictionary paths.
base = force_text ( base )	call the function force_text with an argument base, substitute the result for base.
paths = [ force_text ( p ) for p in paths ]	paths is a list containing results of the function force_text called with an argument p, for every p in paths.
final_path = abspathu ( join ( base , * paths ) )	join base an unpacked list paths into a string, get the absolute path in unicode representation of the result, substitute the result for final_path.
base_path = abspathu ( base )	get the unicode representation of the absolute path of base, substitute it for base_path.
if ( not normcase ( final_path ) . startswith ( normcase ( base_path + sep ) ) and  normcase ( final_path ) != normcase ( base_path ) and  dirname ( normcase ( base_path ) ) != normcase ( base_path ) ) :	if return value of the function normcase called with an argument final_path doesnt starts with result of the function normcase,
raise ValueError ( 'The joined path (%s) is located outside of the base '  'path component (%s)' % ( final_path , base_path ) )	called with sep appended to base_path as an argument and results of the function normcase called twice with final_path,   and base_pah are not equal and directory name of the result of the function normcase called with an argument base_path,   if not equal to the result of the function normcase called with an argument base_path.   raise an ValueError with an argument string 'The joined path (%s) is located outside of the base path component (%s)',
return final_path	where '%s' is replaced with final_path and base_path.   return final_path.
def rmtree_errorhandler ( func , path , exc_info ) :	define the function rmtree_errorhandler with 3 arguments func, path and exc_info.
exctype , value = exc_info [ : 2 ]	substitute fist and second element of exc_info for exctype and value, respectively.
if exctype is not WindowsError or 'Access is denied' not in str ( value ) :	if exctype is not WindowsError or string 'Access is denied' is not contained in value converted into a string,
raise	raise an exception.
if ( ( os . stat ( path ) . st_mode & stat . S_IREAD ) != stat . S_IREAD ) :	call the function os.stat with an argument path, perform bitwise and on 2 operands st_mode field of the result and stat.S_IREAD,
raise	if it is not equal to stat.S_IREAD,   raise an exception.
os . chmod ( path , stat . S_IWRITE )	change access mode of path to stat.S_IWRITE mode.
func ( path )	call the function func with an argument path.
def symlinks_supported ( ) :	define the method symlinks_supported.
tmpdir = tempfile . mkdtemp ( )	call the function tempfile.mkdtemp, substitute the result for tmpdir.
original_path = os . path . join ( tmpdir , 'original' )	join tmpdir and sting 'original' into a file path name, substitute it for original_path.
symlink_path = os . path . join ( tmpdir , 'symlink' )	join tmpdir and sting 'symlink' into a file path name, substitute it for symlink_path.
os . makedirs ( original_path )	make a directory named original_path.
try :	try,
os . symlink ( original_path , symlink_path )	make a system symbolic link between original_path and symlink_path.
supported = True	supported is boolean True.
except ( OSError , NotImplementedError , AttributeError ) :	if OSError, NotImplementedError or AttributeError exceptions are caught,
supported = False	supported is boolean False.
else :	if not,
os . remove ( symlink_path )	remove symlink_path file.
finally :	finally perform,
os . rmdir ( original_path )	remove original_path directory.
os . rmdir ( tmpdir )	remove tmpdir directory.
return supported	return supported.
import os	import module os.
import shutil	import module shutil.
import tarfile	import module tarfile.
import zipfile	import module zipfile.
from django . utils import six	from django.utils import six into default name space.
class ArchiveException ( Exception ) :	derive the class ArchiveException from the Exception base class.
class UnrecognizedArchiveFormat ( ArchiveException ) :	derive the class UnrecognizedArchiveFormat from the ArchiveException base class.
def extract ( path , to_path = '' ) :	define the function extract with 2 arguments path and to_path set to empty string.
with Archive ( path ) as archive :	instantiate Archive class with an argument path, with it renamed to archive, perform,
archive . extract ( to_path )	call the method archive.extract with an argument to_path.
class Archive ( object ) :	derive the class Archive from the object base class.
def __init__ ( self , file ) :	define the method __init__ with 2 arguments self and file.
self . _archive = self . _archive_cls ( file ) ( file )	call the method self._archive_cls with an argument file, call the result with an argument file, substitute the result for self._archive.
@ staticmethod	static method,
def _archive_cls ( file ) :	define the method _archive_cls with an argument file.
cls = None	cls is None.
if isinstance ( file , six . string_types ) :	if file is an instance of six.string_types.
filename = file	substitute file for filename.
else :	if not,
try :	try,
filename = file . name	substitute file.name for filename.
except AttributeError :	if AttributeError exception is caught.
raise UnrecognizedArchiveFormat (  'File object not a recognized archive format.' )	raise an UnrecognizedArchiveFormat exception with an argument string 'File object not a recognized archive format.'.
base , tail_ext = os . path . splitext ( filename . lower ( ) )	convert filename to lowercase, use the result as an argument for the call to the function os.path.splitext,
cls = extension_map . get ( tail_ext )	substitute the result for base and tail_ext.   get the value under the tail_ext key of the extension_map dictionary, substitute it for cls.
if not cls :	if cls is false,
base , ext = os . path . splitext ( base )	call the method os.path.splitext with an argument base, substitute the result for base and ext, respectively.
cls = extension_map . get ( ext )	get the value under the ext key of the extension_map dictionary, substitute it for cls.
if not cls :	if cls is false,
raise UnrecognizedArchiveFormat (  'Path not a recognized archive format: %s' % filename )	raise an UnrecognizedArchiveFormat exception with an argument string 'Path not a recognized archive format: %s',
return cls	where '%s' is replaced with filename.   return cls.
def __enter__ ( self ) :	define the method __enter__ with an argument self.
return self	return self.
def __exit__ ( self , exc_type , exc_value , traceback ) :	define the method __exit__ with 4 arguments: self, exc_type, exc_value and traceback.
self . close ( )	call the method self.close.
def extract ( self , to_path = '' ) :	define the method extract with 2 arguments: self and to_path set to an empty string.
self . _archive . extract ( to_path )	call the method self._archive.extract with an argument to_path.
def list ( self ) :	define the method list with an argument self.
self . _archive . list ( )	call the method self._archive.list.
def close ( self ) :	define the method close with an argument self.
self . _archive . close ( )	call the method self._archive.close.
class BaseArchive ( object ) :	derive the class BaseArchive from the object base class.
def split_leading_dir ( self , path ) :	define the method split_leading_dir with 2 arguments self and path.
path = str ( path )	convert path to a string, substitute the result for path.
\path = path . lstrip ( '/' ) . lstrip ( '\\\\' )\	\strip path of all leading '/' and '\\\\' characters, substitute the result for path.\
\if '/' in path and ( ( '\\\\' in path and path . find ( '/' ) < path . find ( '\\\\' ) )  or '\\\\' not in path ) :\	\if '/' is contained in path, and only if '\\\\' is contained in path and index of the first occurrence of '/' in path is lesser than,\
return path . split ( '/' , 1 )	\index of the first occurrence of '\\\\' in path, or alternatively if '\\\\' is not contained in path,   split path in two parts by '/' character, return the result.\
\elif '\\\\' in path :\	\otherwise if '\\\\' is contained in path,\
\return path . split ( '\\\\' , 1 )\	\split path in two parts by '\\\\' string, return the result.\
else :	if not,
return path , ''	return path an an empty string.
def has_leading_dir ( self , paths ) :	define the method has_leading_dir with 2 arguments self and paths.
common_prefix = None	common_prefix is None.
for path in paths :	for every path in paths,
prefix , rest = self . split_leading_dir ( path )	call the method self.split_leading_dir with an argument path, assign the result to prefix and rest, respectively.
if not prefix :	if prefix is false,
return False	return boolean False.
elif common_prefix is None :	otherwise if common_prefix is None,
common_prefix = prefix	substitute prefix for common_prefix.
elif prefix != common_prefix :	otherwise if prefix is not equal to common_prefix,
return False	return boolean False.
return True	return boolean True.
def extract ( self ) :	define the method list with an argument self.
raise NotImplementedError ( 'subclasses of BaseArchive must provide an extract() method' )	raise an NotImplementedError exception with an argument string 'subclasses of BaseArchive must provide an extract() method'.
def list ( self ) :	define the method list with an argument self.
raise NotImplementedError ( 'subclasses of BaseArchive must provide a list() method' )	raise an NotImplementedError exception with an argument string 'subclasses of BaseArchive must provide a list() method'.
class TarArchive ( BaseArchive ) :	derive the class TarArchive from the BaseArchive base class.
def __init__ ( self , file ) :	define the method __init__ with 2 arguments self and file.
self . _archive = tarfile . open ( file )	call the method tarfile.open with an argument file, substitute the result for self._archive.
def list ( self , * args , ** kwargs ) :	define the method __init__ with 3 arguments self and unpacked list args and unpacked dictionary kwargs.
self . _archive . list ( * args , ** kwargs )	define the method list with 3 arguments: self and unpacked list args and unpacked dictionary kwargs.
def extract ( self , to_path ) :	define the method extract with 2 arguments self and to_path.
members = [ member for member in self . _archive . getmembers ( )  if member . name != 'pax_global_header' ]	members is a list with elements member for every member in the result of the function self._archive.getmembers,
leading = self . has_leading_dir ( x . name for x in members )	only if member.name is not equal to string 'pax_global_header'.   call the method self.has_leading_dir with an argument list, with elements x.name for every x in members, substitute the result for leading.
for member in members :	for every member in members,
name = member . name	substitute member.name for name.
if leading :	if leading is true,
name = self . split_leading_dir ( name ) [ 1 ]	call the method self.split_leading_dir with an argument name, substitute the first element of result for name.
filename = os . path . join ( to_path , name )	join to_path and name into a valid system path, substitute the result for filename.
if member . isdir ( ) :	if member is a directory,
if filename and not os . path . exists ( filename ) :	if filename is true and filename path doesnt exist,
os . makedirs ( filename )	create directories from the elements in filename.
else :	if not,
try :	try,
extracted = self . _archive . extractfile ( member )	call the method self._archive.extractfile with an argument member, substitute the result for extracted.
except ( KeyError , AttributeError ) as exc :	if KeyError or AttributeError, renamed to exc, exceptions are caught,
  print ( 'In the tar file %s the member %s is invalid: %s' %  ( name , member . name , exc ) )	print a string 'In the tar file %s the member %s is invalid: %s', where '%s' is substituted with: name, member.name and exc, respectively.
else :	if not,
dirname = os . path . dirname ( filename )	get the directory name of filename, substitute it for dirname.
if dirname and not os . path . exists ( dirname ) :	if dirname is true and dirname directory doesnt exists,
    os . makedirs ( dirname )	create directories from the elements in filename.
with open ( filename , 'wb' ) as outfile :	open filename file in write mode, with the file descriptor renamed to outfile, perform,
    shutil . copyfileobj ( extracted , outfile )	call the method shutil.copyfileobj with 2 arguments: extracted and outfile.
finally :	finally,
if extracted :	if extracted is true,
    extracted . close ( )	call the method extracted.close.
def close ( self ) :	define the method close with an argument self.
self . _archive . close ( )	call the method self._archive.close.
class ZipArchive ( BaseArchive ) :	derive the class ZipArchive from the BaseArchive base class.
def __init__ ( self , file ) :	define the method __init__ with 2 arguments self and file.
self . _archive = zipfile . ZipFile ( file )	call the method zipfile.ZipFile with an argument self, substitute the result for self._archive.
def list ( self , * args , ** kwargs ) :	define the method list with 3 arguments: self and unpacked list args and unpacked dictionary kwargs.
self . _archive . printdir ( * args , ** kwargs )	call the method self._archive.printdir with 2 arguments: unpacked list args and unpacked dictionary kwargs.
def extract ( self , to_path ) :	define the method extract with 2 arguments self and to_path.
namelist = self . _archive . namelist ( )	call the method self._archive.namelist, substitute the result for namelist.
leading = self . has_leading_dir ( namelist )	call the method self.has_leading_dir with an argument namelist, substitute the result for leading.
for name in namelist :	for every name in namelist,
data = self . _archive . read ( name )	call the method self._archive.read with an argument name, substitute the result for data.
if leading :	if leading is true,
name = self . split_leading_dir ( name ) [ 1 ]	call the method self.split_leading_dir with an argument name, substitute the second element of the result for name.
filename = os . path . join ( to_path , name )	join to_path and name into a file path, substitute the result for filename.
dirname = os . path . dirname ( filename )	get the directory name of filename, substitute the result for dirname.
if dirname and not os . path . exists ( dirname ) :	if dirname is true and dirname path doesnt exists,
os . makedirs ( dirname )	create directories from the elements in filename.
\if filename . endswith ( ( '/' , '\\\\' ) ) :\	\if filename ends with '/' or with '\\\\',\
if not os . path . exists ( filename ) :	if filename path doesnt exists,
os . makedirs ( filename )	create directories from the elements in filename.
else :	if not,
with open ( filename , 'wb' ) as outfile :	open filename file in write mode, with the file descriptor renamed to outfile, perform,
outfile . write ( data )	write data bytes to outfile.
def close ( self ) :	define the method close with an argument self.
self . _archive . close ( )	call the method self._archive.close.
extension_map = {  '.tar' : TarArchive ,  '.tar.bz2' : TarArchive ,  '.tar.gz' : TarArchive ,  '.tgz' : TarArchive ,  '.tz2' : TarArchive ,  '.zip' : ZipArchive ,  }	extension_map is a dictioanry with 6 initial elntries: TarArchive for '.tar', TarArchive for '.tar.bz2', TarArchive for '.tar.gz',
        from __future__ import absolute_import	from __future__ import absolute_import into default name space.
import os	import module os.
import signal	import module signal.
import sys	import module sys.
import time	import module time.
import traceback	import module traceback.
from django . apps import apps	from django.apps import apps into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . signals import request_finished	from django.core.signals import request_finished into default name space.
try :	try,
from django . utils . six . moves import _thread as thread	from django.utils.six.moves import _thread as thread into default name space.
except ImportError :	if imoportError exception is caught,
from django . utils . six . moves import _dummy_thread as thread	from django.utils.six.moves import _dummy_thread as thread into default name space.
try :	try,
import threading	import threading module.
except ImportError :	if ImportError exception is caught,
pass	do nothing.
try :	try,
import termios	import termios module.
except ImportError :	if ImportError exception is caught,
termios = None	termios is None.
USE_INOTIFY = False	USE_INOTIFY is boolean False.
try :	try,
import pyinotify	import pyinotify module.
fd = pyinotify . INotifyWrapper . create ( ) . inotify_init ( )	call the method pyinotify.INotifyWrapper.create, on the return value call the inotify_init method, substitute the result for fd.
if fd >= 0 :	if fd is greater or equal to integer 0.
USE_INOTIFY = True	USE_INOTIFY is boolean True.
os . close ( fd )	close fd file descriptor.
except ImportError :	if ImportError exception is caught,
pass	do nothing.
RUN_RELOADER = True	RUN_RELOADER is boolean True.
FILE_MODIFIED = 1	FILE_MODIFIED is integer 1.
I18N_MODIFIED = 2	I18N_MODIFIED is integer 2
_mtimes = { }	_mtimes is an empty dictionary.
_win = ( sys . platform == 'win32' )	_win is a tuple containing 1 initial boolean: True is sys.platform equals to string 'win32', False otherwise.
_error_files = [ ]	_error_files is an empty list.
_cached_modules = set ( )	_cached_modules is an empty set.
_cached_filenames = [ ]	_cached_filenames is an empty list.
def gen_filenames ( only_new = False ) :	define the function gen_filenames with an argument only_new defaulting to boolean False.
global _cached_modules , _cached_filenames	declare that we use global variables cached_modules and _cached_filenames in this function.
module_values = set ( sys . modules . values ( ) )	module_values is a set created from the elements of sys.modules.values method return value.
if _cached_modules == module_values :	if _cached_modules equals to module_values,
if only_new :	if only_new is true,
return [ ]	return an empty list.
else :	if not,
return _cached_filenames	return _cached_filenames.
new_modules = module_values - _cached_modules	subtract _cached_modules from module_values, assign the result to new_modules.
new_filenames = [ filename . __file__ for filename in new_modules  if hasattr ( filename , '__file__' ) ]	create the list of paths from which filename module was included for every filename in new_modules, only is filename has '__file__' attribute, substitute the resulting list for new_filenames.
if not _cached_filenames and settings . USE_I18N :	if _cached_filenames is empty and settings.USE_I18N is True,
basedirs = [ os . path . join ( os . path . dirname ( os . path . dirname ( __file__ ) ) ,  'conf' , 'locale' ) ,  'locale' ]	return the directory name two directories up from the __file__ path, join it with 'conf' and 'locale' into valid path, separated by '/', basedirs is a list containing 2 elements: previous result and string 'locale'.
for app_config in reversed ( list ( apps . get_app_configs ( ) ) ) :	for app_config in reversed list of apps.get_app_configs() elements,
basedirs . append ( os . path . join ( app_config . path , 'locale' ) )	join app_config.path and 'locale' into a valid directory path, separated by '/', append it to basedirs.
basedirs . extend ( settings . LOCALE_PATHS )	extend basedirs list with settings.LOCALE_PATHS.
basedirs = [ os . path . abspath ( basedir ) for basedir in basedirs  if os . path . isdir ( basedir ) ]	replace all the elements of the basedir list by its corresponding absolute directory path, only is that directory exists.
for basedir in basedirs :	for every basedir in basedirs,
for dirpath , dirnames , locale_filenames in os . walk ( basedir ) :	for every dirpath, dirnames and locale_filenames in directory tree starting at the basedir directory.
for filename in locale_filenames :	for every filenam in locale_filenames,
if filename . endswith ( '.mo' ) :	if filename ends with string '.mo',
    new_filenames . append ( os . path . join ( dirpath , filename ) )	join dirpath and filename into a path separated by '/', append it to new_filenames.
if only_new :	if only_new is True,
filelist = new_filenames	substitute new_filenames for filelist.
else :	if not,
filelist = _cached_filenames + new_filenames + _error_files	sum _cached_filenames, new_filenames and _error_files, store the result in filelist.
filenames = [ ]	filenames is an empty list.
for filename in filelist :	for every filename is filelist,
if not filename :	if filename is empty,
continue	skip this loop iteration,
if filename . endswith ( '.pyc' ) or filename . endswith ( '.pyo' ) :	if filename ends with string '.pyc' or it ends with '.pyo',
filename = filename [ : - 1 ]	truncate the last element of filename.
if filename . endswith ( '$py.class' ) :	if filename ends with string '$py.class',
filename = filename [ : - 9 ] + '.py'	truncate last 9 elements of filename and append it string '.py'.
if os . path . exists ( filename ) :	if file filename exists,
filenames . append ( filename )	append filename to filenames.
_cached_modules = _cached_modules . union ( new_modules )	add elements from new_modules set to _cached_modules set.
_cached_filenames += new_filenames	append new_filenames to _cached_filenames.
return filenames	return filenames.
def reset_translations ( ) :	define the function reset_translation.
import gettext	import gettext module.
from django . utils . translation import trans_real	from django.utils.translation import trans_real into default namespace.
gettext . _translations = { }	gettext._translations is an empty dictionary.
trans_real . _translations = { }	trans_real._translations is an empty dictionary.
trans_real . _default = None	trans_real._default is None.
trans_real . _active = threading . local ( )	call the threading.local method, assign the result to trans_real._active.
def inotify_code_changed ( ) :	define the function inotify_code_changed.
class EventHandler ( pyinotify . ProcessEvent ) :	derive the EventHandler class from the base class pyinotify.ProcessEvent.
modified_code = None	modified_code is None.
def process_default ( self , event ) :	define the method process_default with self class instance and event as arguments.
if event . path . endswith ( '.mo' ) :	if event.path ends with string '.mo',
EventHandler . modified_code = I18N_MODIFIED	EventHandler.modified_code is I18N_MODIFIED.
else :	if not,
EventHandler . modified_code = FILE_MODIFIED	EventHandler.modified_code is FILE_MODIFIED.
wm = pyinotify . WatchManager ( )	call the pyinotify.WatchManager method, assign the result to wm.
notifier = pyinotify . Notifier ( wm , EventHandler ( ) )	call the method pyinotify.Notifier with wm and EventHandler() as arguments, assign the result to notifier.
def update_watch ( sender = None , ** kwargs ) :	define the method update_watch with sender defaulting to None and dictionary pair of elements kwargs.
if sender and getattr ( sender , 'handles_files' , False ) :	if sender is true and sender attribute 'handles_files' is also True,
return	return nothing.
mask = (  pyinotify . IN_MODIFY |  pyinotify . IN_DELETE |  pyinotify . IN_ATTRIB |  pyinotify . IN_MOVED_FROM |  pyinotify . IN_MOVED_TO |  pyinotify . IN_CREATE  )	perform the bitwise or operation on the next 6 operands pyinotify.IN_MODIFY pyinotify.IN_DELETE, pyinotify.IN_ATTRIB,
for path in gen_filenames ( only_new = True ) :	pyinotify.IN_MOVED_FROM, pyinotify.IN_MOVED_TO and pyinotify.IN_CREATE, store the result in mask.   for every path in return value of the call to the function gen_filenames with argument only_new set to boolean True,
wm . add_watch ( path , mask )	call the method wm.add_watch with path and mask as arguments.
request_finished . connect ( update_watch )	call the method request_finished.connect with argument update_watch.
update_watch ( )	call the method update_watch.
notifier . check_events ( timeout = None )	call the method notifier.check_events with argument timeout set to None.
notifier . read_events ( )	call the method notifier.read_events.
notifier . process_events ( )	call the method notifier.process_events.
notifier . stop ( )	call the method notifier.stop.
return EventHandler . modified_code	return EventHandler.modified_code.
def code_changed ( ) :	define the function code_changed.
global _mtimes , _win	use the global variables _mtimes and _win in this function.
for filename in gen_filenames ( ) :	for every filename in gen_filenames(),
stat = os . stat ( filename )	call the os.stat function with argument filename, store the return value in stat.
mtime = stat . st_mtime	substitute stat.st_mtime for mtime.
if _win :	if _win is true,
mtime -= stat . st_ctime	decrement mtime by stat.st_ctime.
if filename not in _mtimes :	if filename is not contained in _mtimes,
_mtimes [ filename ] = mtime	substitute mtime for the value under the filename key of _mtimes dictionary.
continue	skip this loop iteration.
if mtime != _mtimes [ filename ] :	if mtime is different than the value of dictionary _mtimes under the key filename,
_mtimes = { }	_mtimes is an empty dictionary.
try :	try,
del _error_files [ _error_files . index ( filename ) ]	remove the first occurrence of the filename value in the _error_files list.
except ValueError :	if ValueError exception is caught,
pass	do nothing.
return I18N_MODIFIED if filename . endswith ( '.mo' ) else FILE_MODIFIED	if filename ends with string '.mo' return I18N_MODIFIED, otherwise return FILE_MODIFIED.
return False	return boolean False.
def check_errors ( fn ) :	define the function check_errors with argument fn.
def wrapper ( * args , ** kwargs ) :	define the function wrapper with list args, and dictionary pair of values kwargs as arguments.
try :	try,
fn ( * args , ** kwargs )	call the function fn with list of arguments args and dictionary of argument values kwargs.
except ( ImportError , IndentationError , NameError , SyntaxError ,  TypeError , AttributeError ) :	if ImportError, IndentationError, NameError, SyntaxError, TypeError or AttributeErrorexception is caught,
et , ev , tb = sys . exc_info ( )	call the sys.exc_info function, assign the result to et, ev and tb, respectively.
if getattr ( ev , 'filename' , None ) is None :	if 'filename' attribute of ev is None,
filename = traceback . extract_tb ( tb ) [ - 1 ] [ 0 ]	call the traceback.extract_tb method with argument tb, substitute the first element of last row of the result to filename.
else :	if not,
filename = ev . filename	substitute ev.filename for filename.
if filename not in _error_files :	if filename is not contained in _error_files,
_error_files . append ( filename )	append filename to _error_files.
raise	raise an exception.
return wrapper	return wrapper.
def ensure_echo_on ( ) :	define ensure_echo_on function.
if termios :	if termios is true,
fd = sys . stdin	substitute sys.stdin for fd.
if fd . isatty ( ) :	evaluate the fd.isatty method, if the result is true,
attr_list = termios . tcgetattr ( fd )	call the method termios.tcgetattr with argument fd, substitute the result for attr_list.
if not attr_list [ 3 ] & termios . ECHO :	if fourth element of attr_list and termios.ECHO are both true,
attr_list [ 3 ] |= termios . ECHO	perform binary or for operands: fourth element of_attr_list and termios.ECHO, store the result in fourth element of attr_list.
if hasattr ( signal , 'SIGTTOU' ) :	if signal has an attribute 'SIGTTOU',
old_handler = signal . signal ( signal . SIGTTOU , signal . SIG_IGN )	call the signal.signal method with signal.SIGTTOU and signal.SIG_IGN as arguments, store the result in old_handler.
else :	if not,
old_handler = None	old_handler is None.
termios . tcsetattr ( fd , termios . TCSANOW , attr_list )	call the method termios.tcsetattr with fd, termios.TCSANOW and attr_list, as arguments.
if old_handler is not None :	if old_handler is not None,
signal . signal ( signal . SIGTTOU , old_handler )	call the method signal.signal with signal.SIGTTOU and old_handler, as arguments.
def reloader_thread ( ) :	define the function reloader_thread.
ensure_echo_on ( )	call the function ensure_echo_on.
if USE_INOTIFY :	if USE_INOTIFY is true,
fn = inotify_code_changed	substitute inotify_code_changed for fn.
else :	if not,
fn = code_changed	substitute code_changed for fn.
while RUN_RELOADER :	while RUN_RELOADER is true.
change = fn ( )	assign the return value of the function fn to change.
if change == FILE_MODIFIED :	if change equals to FILE_MODIFIED,
sys . exit ( 3 )	call the function sys.exit with argument integer 3.
elif change == I18N_MODIFIED :	otherwise id change equals to I18N_MODIFIED,
reset_translations ( )	call the function reset_translations.
time . sleep ( 1 )	call the function time.sleep with an argument integer 1.
def restart_with_reloader ( ) :	define the function restart_with_reloader.
while True :	endless loop,
args = [ sys . executable ] + [ '-W%s' % o for o in sys . warnoptions ] + sys . argv	in string '-W%s' replace '%s' with o for every o in sys.warnoptions, put the result into a list, append the list to a list containing sys.executable, append sys.argv to the end of the resulting list, substitute the result for args.
if sys . platform == 'win32' :	if sys.platform equals to string 'win32',
new_environ = os . environ . copy ( )	call the method os.environ.copy, substitute the result for new_environ.
new_environ [ 'RUN_MAIN' ] = 'true'	value under the 'RUN_MAIN' key of new_environ dictionary is a string 'true'.
exit_code = os . spawnve ( os . P_WAIT , sys . executable , args , new_environ )	call the function os.spawnve with os.P_WAIT, sys.executable, args and new_environ as arguments, substitute the result for exit_code.
if exit_code != 3 :	if exit_code is not equal to integer 3.
return exit_code	return exit_code.
def python_reloader ( main_func , args , kwargs ) :	define the function python_reloader with main_func and kwargs as arguments.
if os . environ . get ( 'RUN_MAIN' ) == 'true' :	if value under the 'RUN_MAIN' key of the os.environ dictionary equals to string 'true',
thread . start_new_thread ( main_func , args , kwargs )	call the function thread.start_new_thread with main_func, args and kwargs as arguments.
try :	try,
reloader_thread ( )	call the function reloader_thread.
except KeyboardInterrupt :	if KeyboardInterrupt exception is caught,
pass	do nothing.
else :	if not,
try :	try,
exit_code = restart_with_reloader ( )	call the function restart_with_reloader, substitute the return value for exit_code.
if exit_code < 0 :	if exit_code is lesser than integer 0,
os . kill ( os . getpid ( ) , - exit_code )	call the function os.kill with os.getpid() and negative exit_code as arguments.
else :	if not,
sys . exit ( exit_code )	call the function sys.exit with argument exit_code.
except KeyboardInterrupt :	if KeyboardInterrupt exception is caught,
pass	do nothing,
def jython_reloader ( main_func , args , kwargs ) :	define the function jython_reloader with main_func, args and kwargs as arguments.
from _systemrestart import SystemRestart	from _systemrestart import SystemRestart into default name space.
thread . start_new_thread ( main_func , args )	call the function thread.start_new_thread with main_func and args as arguments.
while True :	endless loop,
if code_changed ( ) :	if return value of the code_changed function is true,
raise SystemRestart	raise an SystemRestart exception,
time . sleep ( 1 )	call the function time.sleep with argument integer 1.
def main ( main_func , args = None , kwargs = None ) :	define the function main, with main_func, args defaulting to None and kwargs defaulting to None as arguments.
if args is None :	if args is None,
args = ( )	args is a empty tuple.
if kwargs is None :	if kwargs is None,
kwargs = { }	kwargs is a empty dictionary.
if sys . platform . startswith ( 'java' ) :	if sys.platform starts with string 'java',
reloader = jython_reloader	substitute jython_reloader for reloader.
else :	if not,
reloader = python_reloader	substitute python_reloader for reloader.
wrapped_main_func = check_errors ( main_func )	call the function check_errors with argument main_func, substitute the result for wrapped_main_func.
reloader ( wrapped_main_func , args , kwargs )	call the function reloader with wrapped_main_func, args and kwargs as arguments.
BASE2_ALPHABET = '01'	BASE2_ALPHABET is a string '01'.
BASE16_ALPHABET = '0123456789ABCDEF'	BASE16_ALPHABET is a string '0123456789ABCDEF'.
BASE56_ALPHABET = '23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz'	BASE56_ALPHABET is a string '23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz'.
BASE36_ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz'	BASE36_ALPHABET is a string '0123456789abcdefghijklmnopqrstuvwxyz'.
BASE62_ALPHABET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'	BASE62_ALPHABET is string '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.
BASE64_ALPHABET = BASE62_ALPHABET + '-_'	append string '-_' to the BASE62_ALPHABET, substitute it for BASE64_ALPHABET.
class BaseConverter ( object ) :	derive class BaseCOnverter from object base class.
decimal_digits = '0123456789'	decimal_digits is a string '0123456789'.
def __init__ ( self , digits , sign = '-' ) :	define the initialization function with self class instance, digits and sign defaulting to '-' as arguments.
self . sign = sign	substitute sign for self.sign.
self . digits = digits	substitute digits for self.digits.
if sign in self . digits :	if sign is contained in self.digits,
raise ValueError ( 'Sign character found in converter base digits.' )	raise ValueError exception with string 'Sign character found in converter base digits.' as an argument.
def __repr__ ( self ) :	define private method __repr__ with argument self.
return '<BaseConverter: base%s (%s)>' % ( len ( self . digits ) , self . digits )	replace '%s' in the string '<BaseConverter: base%s (%s)>' with length of self.digits and self.digits, respectively, return the string.
def encode ( self , i ) :	define the method encode with self class instance and i as arguments.
neg , value = self . convert ( i , self . decimal_digits , self . digits , '-' )	call the self.convert method with i, self.decimal_digits, self.digits and '-' as arguments, assign the result to the neg and value, respectively.
if neg :	if neg is true,
return self . sign + value	append value to the self.sign, return the result.
return value	return value.
def decode ( self , s ) :	define the decode method with self class instance and s as arguments.
neg , value = self . convert ( s , self . digits , self . decimal_digits , self . sign )	call the self.convert method with s, self.decimal, self.decimal_digits and self.sign as arguments, assign the result to the neg and value, respectively.
if neg :	if neg is true,
value = '-' + value	append value to the '-', substitute it for value.
return int ( value )	convert value to an integer, return it.
def convert ( self , number , from_digits , to_digits , sign ) :	define convert method with self class instance, number, from_digits, to_digits and sign as arguments.
if str ( number ) [ 0 ] == sign :	convert number to string, if first element equals to sign,
number = str ( number ) [ 1 : ]	convert number to a string, truncate first element.
neg = 1	neg is integer 1.
else :	if not,
neg = 0	neg is integer 0.
x = 0	x is integer 0.
for digit in str ( number ) :	for every digit in number coverted to a string,
x = x * len ( from_digits ) + from_digits . index ( digit )	multiply x by length of from_digits add the return value of method from_digits.index with digit argument, substitute the result for x.
if x == 0 :	if x equals to integer 0,
res = to_digits [ 0 ]	substitute first element of to_digits for res.
else :	if not,
res = ''	res is an empty string.
while x > 0 :	while x is greater than zero,
digit = x % len ( to_digits )	calculate reminder of division of x by length to_digits, substitute it for digit.
res = to_digits [ digit ] + res	increment res by element of to_digit at the digit index.
x = int ( x // len ( to_digits ) )	divide x by length of to_digits, convert floor value of the result to an integer, substitute it for x.
return neg , res	return neg and res.
base2 = BaseConverter ( BASE2_ALPHABET )	call the BaseConverter function with BASE2_ALPHABET as argument, store the result in base2.
base16 = BaseConverter ( BASE16_ALPHABET )	call the BaseConverter function with BASE16_ALPHABET as argument, store the result in base16.
base36 = BaseConverter ( BASE36_ALPHABET )	call the BaseConverter function with BASE36_ALPHABET as argument, store the result in base36.
base56 = BaseConverter ( BASE56_ALPHABET )	call the BaseConverter function with BASE56_ALPHABET as argument, store the result in base56.
base62 = BaseConverter ( BASE62_ALPHABET )	call the BaseConverter function with BASE62_ALPHABET as argument, store the result in base62.
base64 = BaseConverter ( BASE64_ALPHABET , sign = '$' )	call the BaseConverter function with BASE64_ALPHABET and sign set to '$' as arguments, store the result in base64.
from __future__ import unicode_literals	from module __future__ import unicode_literals to default name space.
import hashlib	import hashlib module.
import re	import re module.
import time	import time module.
from django . conf import settings	from django.conf import settings object to the default name space.
from django . core . cache import caches	from django.core.cache import caches to the default name space.
from django . utils . encoding import iri_to_uri , force_bytes , force_text	from django.utils import iri_to_uri, force_bytes, force_text to the default name space.
from django . utils . http import http_date	from django.utils.http import http_date to the default name space.
from django . utils . timezone import get_current_timezone_name	from django.utils.timezone import get_current_timezone_name to the default name space.
from django . utils . translation import get_language	from django.utils.translation import get_language to the default name space.
\cc_delim_re = re . compile ( r'\\s*,\\s*' )\	\compile regular expression based on the string '\\s*,\\s*' and assign the result to cc_delim_re.\
def patch_cache_control ( response , ** kwargs ) :	define function patch_cache_control, with response and dictionary set of arguments, kwargs, as arguments.
def dictitem ( s ) :	define function dictitem with s as an argument.
t = s . split ( '=' , 1 )	split string s once, with '=' sign as a delimiter, assign the resulting list to the t.
if len ( t ) > 1 :	if length of t is greater than integer 1,
return ( t [ 0 ] . lower ( ) , t [ 1 ] )	return first element of t converted to lowercase and second element of t, as a tuple.
else :	if not,
return ( t [ 0 ] . lower ( ) , True )	return first element of t converted to lowercase and boolean True, as a tuple.
def dictvalue ( t ) :	define function dictvale, with an argument t.
if t [ 1 ] is True :	if second element of t is boolean True,
return t [ 0 ]	return first element of t.
else :	if not,
return '%s=%s' % ( t [ 0 ] , t [ 1 ] )	return string first element of t, '=', second element of t.
if response . has_header ( 'Cache-Control' ) :	if call to the method response.has_header with string 'Cache-Control' as an argument returns boolean True,
cc = cc_delim_re . split ( response [ 'Cache-Control' ] )	find the value of response under the key 'Cache-Control', use it as a delimiter to split string ss_delim_re,
cc = dict ( dictitem ( el ) for el in cc )	assign the result to cc.   cc is a dictionary populated with items by calling function dictitem with el as argument, for every el in cc.
else :	if not,
cc = { }	cc is an empty dictionary.
if 'max-age' in cc and 'max_age' in kwargs :	if cc contains item 'max-age' and kwargs contains item 'max_age',
kwargs [ 'max_age' ] = min ( int ( cc [ 'max-age' ] ) , kwargs [ 'max_age' ] )	convert to integer value of dictionary cc under the key 'max-age',
if 'private' in cc and 'public' in kwargs :	if it is smaller than the value of dictionary kwargs under the key 'max_age', substitute kwargs value under the key 'max-age' by it.   if cc contains item 'private' and kwargs contains item 'public',
del cc [ 'private' ]	delete dictionary item 'private' from cc.
elif 'public' in cc and 'private' in kwargs :	if cc contains item 'public' and kwargs contains item 'private',
del cc [ 'public' ]	delete dictionary item 'public' from cc.
for ( k , v ) in kwargs . items ( ) :	for every k and v in items of dictionary kwargs, respectively,
cc [ k . replace ( '_' , '-' ) ] = v	replace all occurrences of symbol '_' in string k with symbol '-', use new string as key to find a value in dictionary cc,
cc = ', ' . join ( dictvalue ( el ) for el in cc . items ( ) )	replace this value with v.   call the function dictvalue with el as argument for every el in values of dictionary cc,
response [ 'Cache-Control' ] = cc	join the resulting sequence in a string with comma as separator, assign the string to cc.   substitute response dictionary value under the key 'Cache-Control' for cc.
def get_max_age ( response ) :	define function get_max_age with response as an argument.
if not response . has_header ( 'Cache-Control' ) :	if the result to the method call response.has_header, with string 'Cache-Control' as an argument is boolean False,
return	return from the function
cc = dict ( _to_tuple ( el ) for el in  cc_delim_re . split ( response [ 'Cache-Control' ] ) )	cc is a dictionary populated with items by calling function _to_tuple with el as an argument,
if 'max-age' in cc :	for every el in split string cc_delim_re, with delimiter being the value of dictionary response under the key 'Cache-Control'.   if cc contains item 'max-age',
try :	try,
return int ( cc [ 'max-age' ] )	convert to integer the value of dictionary cc under the key 'max-age', and return it
except ( ValueError , TypeError ) :	if exception ValueError or TypeError is raised,
pass	do nothing.
def _set_response_etag ( response ) :	define the function _set_response_etag, with response as an argument.
if not response . streaming :	if response.streaming is boolean False,
return response	and store it in the value of the dictionary response under the key 'ETag'.   return response
def patch_response_headers ( response , cache_timeout = None ) :	define the function patch_response_headers, with response and cache_timeout with None as default value, as arguments.
if cache_timeout is None :	if cache_timeout equals to None,
cache_timeout = settings . CACHE_MIDDLEWARE_SECONDS	substitute settings.CACHE_MIDDLEWARE_SECONDS for cache_timeout.
if cache_timeout < 0 :	if cache_timeout is lesser than integer 0,
cache_timeout = 0	substitute integer 0 for cache_timeout.
if settings . USE_ETAGS and not response . has_header ( 'ETag' ) :	if settings.USE_ETAGS is True and function call response.has_header with string 'ETag' as argument returns boolean False,
if hasattr ( response , 'render' ) and callable ( response . render ) :	if object response has an attribute 'render' and if response.render is callable object,
response . add_post_render_callback ( _set_response_etag )	call the method response.add_post_render_callback with _set_response_etag as argument.
else :	if not,
response = _set_response_etag ( response )	substitute return value of call to the function _set_response_etag with response as an argument, for response.
if not response . has_header ( 'Last-Modified' ) :	if call to the function response.has_header with string 'Last-Modified' as an argument returns boolean False,
response [ 'Last-Modified' ] = http_date ( )	call the function http_date with no arguments, and substitute its return value
if not response . has_header ( 'Expires' ) :	for value of dictionary response under the key 'Last-Modified'.   if call to the function response.has_header with 'Expires' as argument returns boolean False,
response [ 'Expires' ] = http_date ( time . time ( ) + cache_timeout )	sum return value of the function call time.time() and cache_timeout, use it as an argument for function call of http_date,
patch_cache_control ( response , max_age = cache_timeout )	and substitute the return value for value under the key 'Expires' of dictionary response.   call the function patch_cache_control, with response and max_age set to cache_timeout as arguments.
def add_never_cache_headers ( response ) :	define function add_never_cache_headers, with response as an argument.
patch_response_headers ( response , cache_timeout = - 1 )	call the function patch_response with response and cache_timeout decremented by integer 1 as arguments.
def patch_vary_headers ( response , newheaders ) :	define function patch_vary_headers, with response and newheaders as arguments.
if response . has_header ( 'Vary' ) :	if call to the function response.has_header with argument 'Vary' returns boolean True,
vary_headers = cc_delim_re . split ( response [ 'Vary' ] )	split the string cc_delim_re with value under the key 'Vary' of response dictionary as delimiter, substitute result for vary_headers.
else :	if not,
vary_headers = [ ]	vary_headers is an empty list.
existing_headers = set ( header . lower ( ) for header in vary_headers )	existing_headers is a set of lowercase headers for every header in vary_headers.
additional_headers = [ newheader for newheader in newheaders  if newheader . lower ( ) not in existing_headers ]	put every header in newheaders in a list, only if newheader converted to lowercase does not exist in existing_headers,
response [ 'Vary' ] = ', ' . join ( vary_headers + additional_headers )	substitute this list for additional_headers.   join all of the elements of vary_headers and additional_headers in a string delimited by a comma,
def has_vary_header ( response , header_query ) :	substitute it for value of dictionary response under the key 'Vary'.   define function has_vary_header, with response and header_query as arguments.
if not response . has_header ( 'Vary' ) :	if return value of function response.has_header with string 'Vary' as argument is boolean False,
return False	return boolean False.
vary_headers = cc_delim_re . split ( response [ 'Vary' ] )	split string cc_delim_re by value of dictionary response under the key 'Vary' as a delimiter, substitute it for vary_headers.
existing_headers = set ( header . lower ( ) for header in vary_headers )	existing_headers is a set containing lowercase strings header for every header in vary_headers.
return header_query . lower ( ) in existing_headers	check if lowercase header_query exists is existing_headers, return the boolean result.
def _i18n_cache_key_suffix ( request , cache_key ) :	define function _i18n_cache_key_suffix, with request and cache_key as arguments.
if settings . USE_I18N or settings . USE_L10N :	if eather one of settings.USE_I18N or settings.USE_L10N is True,
cache_key += '.%s' % getattr ( request , 'LANGUAGE_CODE' , get_language ( ) )	call the function getattr with request, string 'LANGUAGE_CODE' and function get_language as arguments,
if settings . USE_TZ :	append the result at the end of string '.', append it all at the end of string cache_key.   if settings.USE_TZ is True,
tz_name = force_text ( get_current_timezone_name ( ) , errors = 'ignore' )	call the function force_text, with the function get_current_timezone_name and errors set to string 'ignore' as arguments,
cache_key += '.%s' % tz_name . encode ( 'ascii' , 'ignore' ) . decode ( 'ascii' ) . replace ( ' ' , '_' )	replace the result for tz_name.   call the method tz_name.encode with the arguments 'ascii' and 'ignore', call the method decode on the result with 'ascii' as argument,
return cache_key	in the resulting string replace all occurrences of ' ' with '_' and append it to the end of cache_key.   return cache_key.
def _generate_cache_key ( request , method , headerlist , key_prefix ) :	define function _generate_cache_key, with request, method, headerlist and key_prefix as arguments.
ctx = hashlib . md5 ( )	ctx is an hashlib object, for calculating hash function with md5 algorithm.
for header in headerlist :	for every header in headerlist,
value = request . META . get ( header , None )	call method request.META.get with arguments header and None.
if value is not None :	if value is not None,
ctx . update ( force_bytes ( value ) )	call function force_bytes with value as argument, use the result to as the result for the call to the methgod ctx.update.
url = hashlib . md5 ( force_bytes ( iri_to_uri ( request . build_absolute_uri ( ) ) ) )	call iri_to_uri with return value of the request.build_absolute_uri method, us the result as the argument for the call to the
cache_key = 'views.decorators.cache.cache_page.%s.%s.%s.%s' % (  key_prefix , method , url . hexdigest ( ) , ctx . hexdigest ( ) )	force_bytes function, use the result as the argument for the call to the hashlib.mdb function, store the result in url.   substitute the '%s' in string 'views.decorators.cache.cache_page.%s.%s.%s.%s' with key_prefix, method,
return _i18n_cache_key_suffix ( request , cache_key )	return value of method url.hexdigest(), return value of method ctx.hexdigest, respectively, substitute it for cache_key.   call the function _i18n_cache_key_suffix with request and cache_key as arguments, return the result.
def _generate_cache_header_key ( key_prefix , request ) :	define the funtion _generate_cache_header_key with key_prefix and request as arguments.
url = hashlib . md5 ( force_bytes ( iri_to_uri ( request . build_absolute_uri ( ) ) ) )	call method request.build_absolute_uri, use the result as an argument for function call of iri_to_uri,
cache_key = 'views.decorators.cache.cache_header.%s.%s' % (  key_prefix , url . hexdigest ( ) )	use the result as an argument for function call of force_bytes, use the result as an argument for calling the method hashlib.md5,   put the result in url.   substitute the '%s' in string 'views.decorators.cache.cache_header.%s.%s' with key_prefix and result of the function call,
return _i18n_cache_key_suffix ( request , cache_key )	to the function url.hexdigest(), respectively, substitute it for cache_key.   call the function _i18n_cache_key_suffix with request and cache_key as arguments, return the result.
def get_cache_key ( request , key_prefix = None , method = 'GET' , cache = None ) :	define the function get_cache_key, with request key_prefix set to None, method set to 'GET' and cache set to None as arguments.
if key_prefix is None :	if key_prefix is None,
key_prefix = settings . CACHE_MIDDLEWARE_KEY_PREFIX	substitute settings.CACHE_MIDDLEWARE_KEY_PREFIX for key_prefix.
cache_key = _generate_cache_header_key ( key_prefix , request )	call the function _generate_cache_header_key with key_prefix and request as arguments, substitute the result for cache_key.
if cache is None :	if cache is None,
cache = caches [ settings . CACHE_MIDDLEWARE_ALIAS ]	set cache to the value of the dictionary caches under the key settings.CACHE_MIDDLEWARE_ALIAS.
headerlist = cache . get ( cache_key , None )	get the value of dictionary cache under the key cache_key, if key is not available return None, substitute it for headerlist.
if headerlist is not None :	if header list is not None,
return _generate_cache_key ( request , method , headerlist , key_prefix )	call the function _generate_cache_key with request, method, headerlist, key_prefix as arguments, return the result.
else :	if not,
return None	return None.
def learn_cache_key ( request , response , cache_timeout = None , key_prefix = None , cache = None ) :	define function learn_cache_key with request, response, cache_timeout set to None, key_prefix set to None, cache set to None as arguments.
if key_prefix is None :	if key_prefix is None,
key_prefix = settings . CACHE_MIDDLEWARE_KEY_PREFIX	substitute settings.CACHE_MIDDLEWARE_KEY_PREFIX for key_prefix.
if cache_timeout is None :	if cache_timeout is None,
cache_timeout = settings . CACHE_MIDDLEWARE_SECONDS	substitute settings.CACHE_MIDDLEWARE_SECONDS for cache_timeout.
cache_key = _generate_cache_header_key ( key_prefix , request )	call function _generate_cache_header_key with arguments key_prefix and request, substitute the result for cache_key.
if cache is None :	if cache is None,
cache = caches [ settings . CACHE_MIDDLEWARE_ALIAS ]	get value under the key settings.CACHE_MIDDLEWARE_ALIAS of caches dictionary, substitute with it the cache.
if response . has_header ( 'Vary' ) :	if call to the function response.has_header with string 'Vary' as an argument returns True,
is_accept_language_redundant = settings . USE_I18N or settings . USE_L10N	if eather of settings.USE_I18N or settings.USE_L10N is True, set is_accept_language_redundant to True.
headerlist = [ ]	headerlist is an empty list.
for header in cc_delim_re . split ( response [ 'Vary' ] ) :	for every header in list of strings compiled by splitting string cc_delim_re with value under the key 'Vary' of response dictionary as a delimiter.
header = header . upper ( ) . replace ( '-' , '_' )	convert string header to uppercase and replace all occurrences of '-' with '_', substitute it for header.
if header == 'ACCEPT_LANGUAGE' and is_accept_language_redundant :	if header equals a string 'ACCEPT_LANGUAGE' and is_accept_language_redundant is boolean True,
continue	continue with the next iteration of the for loop.
headerlist . append ( 'HTTP_' + header )	append header to the string 'HTTP_', append the result to the list headerlist.
headerlist . sort ( )	call method sort on the headerlist.
cache . set ( cache_key , headerlist , cache_timeout )	call the method cache.set, with cache_key, headerlist, cache_timeout as arguments.
return _generate_cache_key ( request , request . method , headerlist , key_prefix )	call the function _generate_cache_key with request, request.method, headerlist, key_prefix as arguments, return the result.
else :	if not,
cache . set ( cache_key , [ ] , cache_timeout )	call the method cache.set with cache_key, an empty list and cache_timeout as arguments.
return _generate_cache_key ( request , request . method , [ ] , key_prefix )	call the function _generate_cache_key with request, request.method, an empty list and key_prefix as arguments, return the result.
def _to_tuple ( s ) :	define function _to_tuple with s as an argument.
t = s . split ( '=' , 1 )	split string s once, with '=' as delimiter, substitute the result for t.
if len ( t ) == 2 :	if length of t equals to integer 2,
return t [ 0 ] . lower ( ) , t [ 1 ]	return tuple, consisting of first element of t converted to lowercase and second element of t.
return t [ 0 ] . lower ( ) , True	return tuple, consisting of first element of t converted to lowercase and True.
__all__ = [ 'luhn' ]	__all__ is an list with an element 'luhn'.
from django . utils import six	from django.utils import six into default name space.
LUHN_ODD_LOOKUP = ( 0 , 2 , 4 , 6 , 8 , 1 , 3 , 5 , 7 , 9 )	LUHN_ODD_LOOKUP is a tuple with 10 elements: integers 0, 2, 4, 6, 8, 1, 3, 5, 7 and 9.
def luhn ( candidate ) :	define the function luhn with an argument candidate.
if not isinstance ( candidate , six . string_types ) :	if candidate is not an instance of six.string_types,
candidate = str ( candidate )	convert candidate to a string.
try :	try,
evens = sum ( int ( c ) for c in candidate [ - 1 : : - 2 ] )	for every c in reversed order of candidate, convert c into an integer, sum all the results and substitute the result for evens.
odds = sum ( LUHN_ODD_LOOKUP [ int ( c ) ] for c in candidate [ - 2 : : - 2 ] )	for every c in candidate without the last element and in reversed order, convert c into an integer,
return ( ( evens + odds ) % 10 == 0 )	use the result as an key to get the value from the LUHN_ODD_LOOKUP dictionary, sum all the results and substitute the result for odds.   sum evens and odds, if the result is divisible by integer 10, return boolean True, if not return boolean False.
except ValueError :	if ValueError exception is caught,
return False	return boolean False.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import hmac	import module hmac.
import struct	import module struc.
import hashlib	import module hashlib.
import binascii	import module binascii.
import time	import module time.
import random	import module random.
try :	try,
random = random . SystemRandom ( )	random is an instance of random.SystemRandom class.
using_sysrandom = True	using_sysrandom is boolean True.
except NotImplementedError :	if NotImplementedError exception is caught,
import warnings	import warnings.
warnings . warn ( 'A secure pseudo-random number generator is not available '  'on your system. Falling back to Mersenne Twister.' )	call the function warnings.warn with an argument,
using_sysrandom = False	string 'A secure pseudo-random number generator is not available on your system. Falling back to Mersenne Twister.'.   using_sysrandom is boolean False.
from django . conf import settings	from django.conf import settings into default name space.
from django . utils . encoding import force_bytes	from django.utils.encoding import force_bytes into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . six . moves import xrange	from django.utils.six.moves import xrange into default name space.
def salted_hmac ( key_salt , value , secret = None ) :	define the function salted_hmac with 3 arguments: key_salt, value and secret set to None.
if secret is None :	if secret is None,
secret = settings . SECRET_KEY	substitute settings.SECRET_KEY for secret.
key_salt = force_bytes ( key_salt )	call the function force_bytes with an argument key_salt, substitute the result for key_salt.
secret = force_bytes ( secret )	call the function force_bytes with an argument secret, substitute the result for secret.
key = hashlib . sha1 ( key_salt + secret ) . digest ( )	call the method hashlib.sha1 with an argument secret appended to key_salt, call the method digest on the result, return the result.
return hmac . new ( key , msg = force_bytes ( value ) , digestmod = hashlib . sha1 )	call the method hmac.new with 3 arguments: key, msg set to result of the function force_bytes with an argument value,
def get_random_string ( length = 12 ,  allowed_chars = 'abcdefghijklmnopqrstuvwxyz'  'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' ) :	and digestmod set to hashlib.sha1, return the result.   define the function constant_time_compare with 2 arguments: length set to integer 12,
if not using_sysrandom :	if using_sysrandom is false,
random . seed (  hashlib . sha256 (  ( '%s%s%s' % (  random . getstate ( ) ,  time . time ( ) ,  settings . SECRET_KEY ) ) . encode ( 'utf-8' )  ) . digest ( ) )	format string '%s%s%s' with 3 elements: result of the function random.getstate, result of the call the the function time.time,
return '' . join ( random . choice ( allowed_chars ) for i in range ( length ) )	and settings.SECRET_KEY, call on it method encode with an argument string 'utf-8',   use the result as an argument for the call to the method hashlib.sha256, call the method digest on the result,   use the result as an argument for the call to the function random.seed.   call the function random.choice with an argument allowed_chars, for every i in range of integers from 0 to lengths,
if hasattr ( hmac , 'compare_digest' ) :	join the results into a string, return it.   if hmac has an attribute 'compare_digest',
def constant_time_compare ( val1 , val2 ) :	define the function constant_time_compare with 2 arguments: val1 and val2.
return hmac . compare_digest ( force_bytes ( val1 ) , force_bytes ( val2 ) )	call the function hmac.compare_digest with 2 arguments: result of the function force_bytes called with an argument val1,
else :	and result of the function force_bytes called with an argument val2, return the result.   if not,
def constant_time_compare ( val1 , val2 ) :	call the function constant_time_compare with 2 arguments: val1 and val2.
if len ( val1 ) != len ( val2 ) :	if lengths of val1 and val2 are not equal,
return False	return boolean False.
result = 0	result is an integer 0.
if six . PY3 and isinstance ( val1 , bytes ) and isinstance ( val2 , bytes ) :	if six.PY3 is true and val1 and val2 are an instances of bytes,
for x , y in zip ( val1 , val2 ) :	zip val1 and va2 into list of tuples, for every x and y in the result,
result |= x ^ y	perform bitwise exclusive OR on 2 operands x and y, perform bitwise OR with 2 operands: previous result and result, substitute the result for result.
else :	if not,
for x , y in zip ( val1 , val2 ) :	zip val1 and va2 into list of tuples, for every x and y in the result,
result |= ord ( x ) ^ ord ( y )	perform bitwise exclusive OR on 2 operands integer representation of x and integer representation of y,
return result == 0	perform bitwise OR with 2 operands: previous result and result, substitute the result for result.   if result is equal to integer 0, return boolean True, otherwise return boolean False.
def _bin_to_long ( x ) :	define the function _bin_to_long with an argument x.
return int ( binascii . hexlify ( x ) , 16 )	call the function binascii.hexlify with an argument x, convert the result to base 16 integer, return the result.
def _long_to_bin ( x , hex_format_string ) :	define the function _long_to_bin with 2 arguments: x and hex_format_string.
return binascii . unhexlify ( ( hex_format_string % x ) . encode ( 'ascii' ) )	format string hex_format_string with x, call the method encode on the result with an argument string 'ascii',
if hasattr ( hashlib , 'pbkdf2_hmac' ) :	use the result as an argument for the call to the function binascii.unhexlify, return the result.   if hashlib had an instance 'pbkdf2_hmac',
def pbkdf2 ( password , salt , iterations , dklen = 0 , digest = None ) :	define the function pbkdf2 with 5 arguments: password, salt, iterations, dklen set to integer 0 and digest set to None.
if digest is None :	if digest is None,
digest = hashlib . sha256	substitute hashlib.sha256 for digest.
if not dklen :	if dklen is false,
dklen = None	dklen is None.
password = force_bytes ( password )	call the function force_bytes with an argument password, substitute the result for password.
salt = force_bytes ( salt )	call the function force_bytes with an argument salt, substitute the result for salt.
return hashlib . pbkdf2_hmac (  digest ( ) . name , password , salt , iterations , dklen )	call the function hashlib.pbkdf2_hmac with 5 arguments: field name of the result of the function digest, password, salt,
else :	iterations and dklen, return the result.   if not,
def pbkdf2 ( password , salt , iterations , dklen = 0 , digest = None ) :	define the function pbkdf2 with 5 arguments: password, salt, iterations, dklen set to integer 0 and digest set to None.
assert iterations > 0	if iterations is lesser than integer 0, raise an error.
if not digest :	if digest is false,
digest = hashlib . sha256	substitute hashlib.sha256 for digest.
password = force_bytes ( password )	call the function force_bytes with an argument password, substitute the result for password.
salt = force_bytes ( salt )	call the function force_bytes with an argument salt, substitute the result for salt.
hlen = digest ( ) . digest_size	call the function digest, substitute the filed digest_size of the result for hlen.
if not dklen :	if dklen is false,
dklen = hlen	substitute hlen for dklen.
if dklen > ( 2 ** 32 - 1 ) * hlen :	bring intger 2 to integer 32, decrement the result by 1, multiply it with hlen, if dklen is greater than the previous result,
raise OverflowError ( 'dklen too big' )	raise an OverflowError exception with an argument string 'dklen too big'.
l = - ( - dklen // hlen )	divide negative dklen with hlen, substitute floored result for l.
r = dklen - ( l - 1 ) * hlen	decrement l by integer 1, multiply it with hlen, subtract the result from dklen, substitute the result for r.
hex_format_string = '%%0%ix' % ( hlen * 2 )	hex_format_string is a string '%%0%ix' formated with hlen multiplied with integer 2.
inner , outer = digest ( ) , digest ( )	call the function digest twice, substitute the results for inner, outer, respectively.
if len ( password ) > inner . block_size :	if length of password is greater than inner.block_size,
password = digest ( password ) . digest ( )	call the function digest with an argument password, call the method digest on the result, substitute the result or password.
\password += b'\\x00' * ( inner . block_size - len ( password ) )\	\decrement by length of password, create bytes string with previous result number of characters '\\x00',\
inner . update ( password . translate ( hmac . trans_36 ) )	append the result to password.   call the method password.translate with an argument hmac.trans_36, update inner dictionary with the result.
outer . update ( password . translate ( hmac . trans_5C ) )	call the method password.translate with an argument hmac.trans_5C, update outer dictionary with the result.
def F ( i ) :	define the function F with an argument i.
u = salt + struct . pack ( b'>I' , i )	call the method struct.pack with 2 arguments: bytes string '>I' and i, append the result to salt, substitute the result or u.
result = 0	result is an integer 0.
for j in xrange ( int ( iterations ) ) :	for every j in range of integers from 0 to iterations converted to an integer,
dig1 , dig2 = inner . copy ( ) , outer . copy ( )	call the function inner.copy, substitute the result for dig1, call the function outer.copy, substitute the result for dig2.
dig1 . update ( u )	call the method dig1.update with an argument u.
dig2 . update ( dig1 . digest ( ) )	call the method dig1.digest, use the result as an argument for the call to the function dig2.update.
u = dig2 . digest ( )	call the method dig2.digest, substitute the result for u.
result ^= _bin_to_long ( u )	call the function _bin_to_long with an argument u perform bitwise exclusive OR with 2 operands, previous result an result,
return _long_to_bin ( result , hex_format_string )	substitute the result for result.   call the function _long_to_bin with 2 arguments: result and hex_format_string, return the result.
T = [ F ( x ) for x in range ( 1 , l ) ]	call the function F with an argument x, for every x in sequence of integers from 1 to l, not included,
return b'' . join ( T ) + F ( l ) [ : r ]	substitute the results in a list for T.   join elements of T in a bytes string, append first r elements of result of the call to the function F with an argument l to it,
import os	import module os.
import sys	import module sys.
from . import six	from . import six into default name space.
buffering = int ( six . PY3 )	convert six.PY3 to an integer, substitute it for buffering.
if os . name == 'posix' :	if os.name equals string 'posix',
def become_daemon ( our_home_dir = '.' , out_log = '/dev/null' ,  err_log = '/dev/null' , umask = 0o022 ) :	define the function become_daemon with 4 arguments: our_home_dir set to '.', out_log set to a string '/dev/null',
try :	try,
if os . fork ( ) > 0 :	fork a child process, if the result equals integer 0,
sys . exit ( 0 )	close the process with an argument 0.
except OSError as e :	if OSError, renamed to e, exception is caught,
\sys . stderr . write ( 'fork #1 failed: (%d) %s\\n' % ( e . errno , e . strerror ) )\	\call the method sys.stderr.write with an argument string 'fork #1 failed: (%d) %s\\n', formated with e.errno and e.strerror.\
sys . exit ( 1 )	close the process with an argument 1.
os . setsid ( )	call the method os.setsid.
os . chdir ( our_home_dir )	call the method os.chdir with an argument our_home_dir.
os . umask ( umask )	call the function os.umask with an argument umask.
try :	try,
if os . fork ( ) > 0 :	fork a child process, if the result equals integer 0,
os . _exit ( 0 )	close the process with an argument 0.
except OSError as e :	if OSError, renamed to e, exception is caught,
\sys . stderr . write ( 'fork #2 failed: (%d) %s\\n' % ( e . errno , e . strerror ) )\	\call the method sys.stderr.write with an argument string 'fork #2 failed: (%d) %s\\n', formated with e.errno and e.strerror.\
os . _exit ( 1 )	call the method os._exit with an argument integer 1.
si = open ( '/dev/null' , 'r' )	open '/dev/null' file in read mode, substitute the result for si.
so = open ( out_log , 'a+' , buffering )	open out_log flie in append mode with buffering size of input buffer, substitute the result for so.
se = open ( err_log , 'a+' , buffering )	open err_log flie in append mode with buffering size of input buffer, substitute the result for se.
os . dup2 ( si . fileno ( ) , sys . stdin . fileno ( ) )	call the method os.dup2 with 2 arguments: result of the method si.fileno and result of the method sys.stdin.fileno.
os . dup2 ( so . fileno ( ) , sys . stdout . fileno ( ) )	call the method os.dup2 with 2 arguments: result of the method so.fileno and result of the method sys.stdout.fileno.
os . dup2 ( se . fileno ( ) , sys . stderr . fileno ( ) )	call the method os.dup2 with 2 arguments: result of the method se.fileno and result of the method sys.stderr.fileno.
sys . stdout , sys . stderr = so , se	substitute so and se for sys.stdout and sys.stderr.
else :	if not,
def become_daemon ( our_home_dir = '.' , out_log = None , err_log = None , umask = 0o022 ) :	define the function become_daemon with 4 argument: our_home_dir set to '.', out_log set to None, err_log set to None,
os . chdir ( our_home_dir )	call the method os.chdir with an argument our_home_dir.
os . umask ( umask )	call the method os.umask with an argument umask.
sys . stdin . close ( )	call the method sys.stdin.close.
sys . stdout . close ( )	call the method sys.stdout.close.
sys . stderr . close ( )	call the method sys.stderr.close.
if err_log :	if err_log is true,
sys . stderr = open ( err_log , 'a' , buffering )	open err_log file in append mode with buffering size of the input buffer, substitute the result for sys.stderr.
else :	if not,
sys . stderr = NullDevice ( )	sys.stderr is an instance of NullDevice class.
if out_log :	if out_log is true,
sys . stdout = open ( out_log , 'a' , buffering )	open out_log file in append mode with buffering size of the input buffer, substitute the result for sys.stdout.
else :	if not,
sys . stdout = NullDevice ( )	sys.stdout is an instance of NullDevice class.
class NullDevice :	derive the class NullDevice.
def write ( self , s ) :	define the method write with 2 arguments: self and s.
pass	do nothing.
import copy	import module copy.
import warnings	import module warnings.
from collections import OrderedDict	from collections import OrderedDict into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
class MergeDict ( object ) :	derive the class MergeDict from the object base class.
def __init__ ( self , * dicts ) :	define the method __init__ with 2 arguments: self and unpacked list dicts.
warnings . warn ( '`MergeDict` is deprecated, use `dict.update()` '  'instead.' , RemovedInDjango19Warning , 2 )	call the function warnings.warn with 3 arguments: string '`MergeDict` is deprecated, use `dict.update()` instead.',
self . dicts = dicts	RemovedInDjango19Warning and integer 2.   substitute dicts for self.dicts.
def __bool__ ( self ) :	define the method __bool__ with an argument self.
return any ( self . dicts )	if any element of self.dicts is true, return boolean True, otherwise return boolean False.
def __nonzero__ ( self ) :	define the method __nonzero__ with an argument self.
return type ( self ) . __bool__ ( self )	get the type of self object, call its method __bool__ with an argument self, return the result.
def __getitem__ ( self , key ) :	define the method __getitem__ with 2 arguments: self and key.
for dict_ in self . dicts :	for every dict_ in self.dicts,
try :	try,
return dict_ [ key ]	return value under key key of dict_ dictionary.
except KeyError :	if KeyError exception is caught,
pass	do nothing.
raise KeyError ( key )	rise an KeyError exception with an argument key.
def __copy__ ( self ) :	define the method __copy__ with an argument self.
return self . __class__ ( * self . dicts )	call the method __copy__ with an argument unpacked list self.dicts, return the result.
def get ( self , key , default = None ) :	define the method get with 3 arguments: self, key and default set to None.
try :	try,
return self [ key ]	return value under key key of self dictionary
except KeyError :	if KeyError exception is caught,
return default	return default.
def getlist ( self , key ) :	define the method getlist with 2 arguments: self and key.
for dict_ in self . dicts :	for every dict_ in self.dicts,
if key in dict_ :	if key is contained in dict_,
return dict_ . getlist ( key )	call the method dict_.getlist with an argument key, return the result.
return [ ]	return an empty list.
def _iteritems ( self ) :	define the method _iteritems with an argument self.
seen = set ( )	seen is an empty set.
for dict_ in self . dicts :	for every dict_ in self.dicts,
for item in six . iteritems ( dict_ ) :	call the function six.iteritems with an argument dict_, for every item in the result,
k = item [ 0 ]	substitute first element of item for k.
if k in seen :	if k is contained in seen,
continue	skip this loop iteration.
seen . add ( k )	add k to seen.
yield item	yield item.
def _iterkeys ( self ) :	define the method _iterkeys with an argument self.
for k , v in self . _iteritems ( ) :	call the method self._iteritems, for every k and v in the result,
yield k	yield k.
def _itervalues ( self ) :	define the method _itervalues with an argument self.
for k , v in self . _iteritems ( ) :	call the method self._iteritems, for every k and v in the result,
yield v	yield v.
if six . PY3 :	if six.PY3 is true,
items = _iteritems	substitute _iteritems for items.
keys = _iterkeys	substitute _iterkeys for keys.
values = _itervalues	substitute _itervalues for values.
else :	if not,
iteritems = _iteritems	substitute _iteritems for iteritems.
iterkeys = _iterkeys	substitute _iterkeys for iterkeys.
itervalues = _itervalues	substitute _itervalues for itervalues.
def items ( self ) :	define the method items with an argument self.
return list ( self . iteritems ( ) )	call the method self.iteritems, return the list of results.
def keys ( self ) :	define the method keys with an argument self.
return list ( self . iterkeys ( ) )	call the method self.iterkeys, return the list of results.
def values ( self ) :	define the method values with an argument self.
return list ( self . itervalues ( ) )	call the method self.itervalues, return the list of results.
def has_key ( self , key ) :	define the method has_key with 2 arguments: self and key.
for dict_ in self . dicts :	for every dict_ in self.dicts,
if key in dict_ :	if key is contained in dict_,
return True	return boolean True.
return False	return boolean False.
__contains__ = has_key	substitute has_key for __contains__.
__iter__ = _iterkeys	substitute _iterkeys for __iter__.
def copy ( self ) :	define the method copy with an argument self.
return self . __copy__ ( )	call the method self.__copy__, return the result.
def __str__ ( self ) :	define the method __str__ with an argument self.
return str ( dict ( self . items ( ) ) )	get dictionary self items, convert the result into a dictionary, convert the result into a string and return it.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
dictreprs = ', ' . join ( repr ( d ) for d in self . dicts )	join printable representation of d into a string separated with ', ', for every d in self.dicts, substitute the result for dictreprs.
return '%s(%s)' % ( self . __class__ . __name__ , dictreprs )	return a string '%s(%s)' formated with self.__class__.__name__ and dictreprs.
class SortedDict ( dict ) :	derive the class SortedDict from the dict base class.
def __new__ ( cls , * args , ** kwargs ) :	define the method __new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs.
instance = super ( SortedDict , cls ) . __new__ ( cls , * args , ** kwargs )	call the method __new__ from the base class of the class SortedDict, with 3 arguments: cls, unpacked list args,
instance . keyOrder = [ ]	and unpacked dictionary kwargs.   instance.keyOrder is an empty list.
return instance	return instance.
def __init__ ( self , data = None ) :	define the method __init__ with 2 arguments: self and data set to None.
warnings . warn (  'SortedDict is deprecated and will be removed in Django 1.9.' ,  RemovedInDjango19Warning , stacklevel = 2  )	call the function warnings.warn with 3 arguments: string 'SortedDict is deprecated and will be removed in Django 1.9.',
if data is None or isinstance ( data , dict ) :	RemovedInDjango19Warning and stacklevel set to integer 2.   if data is None or data is an instance of dict type,
data = data or [ ]	if data is true, substitute it for data, otherwise data is an empty list.
super ( SortedDict , self ) . __init__ ( data )	call the method __init__ from the base class of the class SortedDict, called with an argument data.
self . keyOrder = list ( data ) if data else [ ]	if data is true, substitute list created from elements of data, substitute it for self.keyOrder, otherwise self.keyOrder is an empty list.
else :	if not,
super ( SortedDict , self ) . __init__ ( )	call the method __init__ from the base class of the class SortedDict.
super_set = super ( SortedDict , self ) . __setitem__	substitute __setitem__ filed of the base class of the class SortedDict for super_set.
for key , value in data :	for every key and value in data,
if key not in self :	if key is not contained in self,
self . keyOrder . append ( key )	append key to self.keyOrder.
super_set ( key , value )	call the function super_set with 2 arguments: key and value.
def __deepcopy__ ( self , memo ) :	define the method __deepcopy__ with 2 arguments: self and memo.
return self . __class__ ( [ ( key , copy . deepcopy ( value , memo ) )  for key , value in self . items ( ) ] )	call the method self.__class__ with an argument list, with 2 elements: key and result of the function copy.deepcopy,
def __copy__ ( self ) :	called with 2 arguments: value and memo, for every key and value in result for the method self.items, return the result.   define the method __copy__ with an argument self.
return self . copy ( )	call the method self.copy, return the result.
def __setitem__ ( self , key , value ) :	define the method __setitem__ with 3 arguments: self, kay and value.
if key not in self :	if key is not contained in self,
self . keyOrder . append ( key )	append key to self.keyOrder.
super ( SortedDict , self ) . __setitem__ ( key , value )	call the method __setitem__ from the base class of the class SortedDict, with 2 arguments key and value.
def __delitem__ ( self , key ) :	define the method __delitem__ with 2 arguments: self and key.
super ( SortedDict , self ) . __delitem__ ( key )	call the method __delitem__ from the base class of the class SortedDict, with an argument key.
self . keyOrder . remove ( key )	remove key element from self.keyOrder dictionary.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
return iter ( self . keyOrder )	return iterable self.keyOrder.
def __reversed__ ( self ) :	define the method __reversed__ with an argument self.
return reversed ( self . keyOrder )	reverse order of elements of self.keyOrder, return the result.
def pop ( self , k , * args ) :	define the method pop with 3 arguments: self, k and unpacked list args.
result = super ( SortedDict , self ) . pop ( k , * args )	call the method pop from the base class of the class SortedDict, with 2 arguments k and unpacked list args,
try :	substitute the result for result.   try,
self . keyOrder . remove ( k )	remove k element from self.keyOrder dictionary.
except ValueError :	if ValueError exception is caught,
pass	do nothing.
return result	return result.
def popitem ( self ) :	define the method popitem with an argument self.
result = super ( SortedDict , self ) . popitem ( )	call the method popitem from the base class of the class SortedDict, substitute the result for result.
self . keyOrder . remove ( result [ 0 ] )	remove first element of result from self.keyOrder dictionary.
return result	return result.
def _iteritems ( self ) :	define the method _iteritems with an argument self.
for key in self . keyOrder :	for every key in self.keyOrder,
yield key , self [ key ]	yield key and value under key key of self dictionary.
def _iterkeys ( self ) :	define the method _iterkeys with an argument self.
for key in self . keyOrder :	for every key in self.keyOrder,
yield key	yield key.
def _itervalues ( self ) :	define the method _itervalues with an argument self.
for key in self . keyOrder :	for every key in self.keyOrder,
yield self [ key ]	yield value under key key of self dictionary.
if six . PY3 :	if six.PY3 is true,
items = _iteritems	substitute _iteritems for items.
keys = _iterkeys	substitute _iterkeys for keys.
values = _itervalues	substitute _itervalues for values.
else :	if not,
iteritems = _iteritems	substitute _iteritems for iteritems.
iterkeys = _iterkeys	substitute _iterkeys for iterkeys.
itervalues = _itervalues	substitute _itervalues for itervalues.
def items ( self ) :	define the method items with an argument self.
return [ ( k , self [ k ] ) for k in self . keyOrder ]	put a tuple with 2 elements: k and value under k key of self dictionary into a list, for every k in self.keyOrder,
def keys ( self ) :	return resulting list.   define the method keys with an argument self.
return self . keyOrder [ : ]	return hard copy of self.keyOrder elements.
def values ( self ) :	define the method values with an argument self.
return [ self [ k ] for k in self . keyOrder ]	append value under k key of self dictionary to a list, for every k in self.keyOrder, return the result.
def update ( self , dict_ ) :	define the method update with 2 arguments: self and dict_.
for k , v in six . iteritems ( dict_ ) :	call the method six.iteritems with an argument dict_, for every k and v in the result,
self [ k ] = v	substitute v for value under the k key of self dictionary.
def setdefault ( self , key , default ) :	define the method setdefault with 3 arguments: self, key and default.
if key not in self :	if key is not contained in self,
self . keyOrder . append ( key )	append key to self.keyOrder dictionary.
return super ( SortedDict , self ) . setdefault ( key , default )	call the method setdefault from the base class of the class SortedDict, with 2 arguments key and default, return the result.
def copy ( self ) :	define the method copy with an argument self.
return self . __class__ ( self )	call the method self.__class__ with an argument self, return the result.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return '{%s}' % ', ' . join ( '%r: %r' % ( k , v ) for k , v in six . iteritems ( self ) )	for every k and v in result of the function six.iteritems,called with an argument self,
def clear ( self ) :	joining string '%r: %r' formated with k and v into a string, separated with ', ', use it to format a string '{%s}', return it.   define the method clear with an argument self.
super ( SortedDict , self ) . clear ( )	call the method clear from the base class of the class SortedDict.
self . keyOrder = [ ]	self.keyOrder is an empty list.
class OrderedSet ( object ) :	derive the class OrderedSet from the object base class.
def __init__ ( self , iterable = None ) :	define the method __init__ with 2 arguments: self and iterable set to None.
self . dict = OrderedDict ( ( ( x , None ) for x in iterable ) if iterable else [ ] )	self.dict is an instance of OrderedDict class, created with arguments: tuples with 2 argument x and None, for every x in iterables,
def add ( self , item ) :	if iterable is true, otherwise use an empty list as an argument.   define the method add with 2 arguments: self and item.
self . dict [ item ] = None	value under the item key of self.dict dictionary is None.
def remove ( self , item ) :	define the method remove with 2 arguments: self and item.
del self . dict [ item ]	delete entry under item key of self.dict dictionary.
def discard ( self , item ) :	define the method discard with 2 arguments: self and item.
try :	try,
self . remove ( item )	remove item from self dictionary.
except KeyError :	if KeyError exception is caught,
pass	do nothing.
def __iter__ ( self ) :	define the method __iter__ with an argument self.
return iter ( self . dict . keys ( ) )	convert keys of dictionary self.dict into a iterable, return it.
def __contains__ ( self , item ) :	define the method __contains__ with 2 arguments: self and item.
return item in self . dict	if item is contained in self.dict, return boolean True, otherwise return boolean False.
def __nonzero__ ( self ) :	define the method __nonzero__ with an argument self.
return bool ( self . dict )	convert self.dict into boolean, return the result.
class MultiValueDictKeyError ( KeyError ) :	derive the class MultiValueDictKeyError from the KeyError base class.
pass	do nothing.
class MultiValueDict ( dict ) :	derive the class MultiValueDict from the dict base class.
def __init__ ( self , key_to_list_mapping = ( ) ) :	define the method __init__ with 2 arguments: self and key_to_list_mapping set to an empty tuple.
super ( MultiValueDict , self ) . __init__ ( key_to_list_mapping )	call the method __init__ from the base class of the class MultiValueDict, with an argument key_to_list_mapping.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return '<%s: %s>' % ( self . __class__ . __name__ ,  super ( MultiValueDict , self ) . __repr__ ( ) )	return a string '<%s: %s>' formated with self.__class__.__name__,
def __getitem__ ( self , key ) :	and a result of the method __repr__ called from instance of base class of the MultiValueDict class.   define the method __getitem__ with 2 arguments: self and key.
try :	try,
list_ = super ( MultiValueDict , self ) . __getitem__ ( key )	call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, substitute the result for list_.
except KeyError :	if KeyError exception is caught,
raise MultiValueDictKeyError ( repr ( key ) )	raise an MultiValueDictKeyError exception with printable representation of key.
try :	try,
return list_ [ - 1 ]	return last element of list_.
except IndexError :	if IndexError exception is caught,
return [ ]	return an empty list.
def __setitem__ ( self , key , value ) :	define the method __setitem__ with 3 arguments: self, key and value.
super ( MultiValueDict , self ) . __setitem__ ( key , [ value ] )	call the method __setitem__ from the base class of the class MultiValueDict, with 2 arguments key and list containing element value.
def __copy__ ( self ) :	define the method __copy__ with an argument self.
return self . __class__ ( [  ( k , v [ : ] )  for k , v in self . lists ( )  ] )	call the method self.__class__ with an argument list, with elements: tuples with 2 elements: k and hard copy of list v,
def __deepcopy__ ( self , memo = None ) :	for every k and v in result of method the self.lists.   define the method __deepcopy__ with 2 arguments: self and memo set to None.
if memo is None :	if memo is None,
memo = { }	memo is an empty dictionary.
result = self . __class__ ( )	call the method self.__class__, substitute the result for result.
memo [ id ( self ) ] = result	substitute result for value under the id of self key of memo dictionary.
for key , value in dict . items ( self ) :	for every key and value in items of dictionary self,
dict . __setitem__ ( result , copy . deepcopy ( key , memo ) ,  copy . deepcopy ( value , memo ) )	call the method dict.__setitem__ with 3 arguments: result, result of the function copy.deepcopy, called with 2 arguments: key,
return result	and memo, and result of the function copy.deepcopy called with 2 arguments: value and memo.   return result.
def __getstate__ ( self ) :	define the method __getstate__ with an argument self.
obj_dict = self . __dict__ . copy ( )	call the method self.__dict__.copy, substitute the result for obj_dict.
obj_dict [ '_data' ] = dict ( ( k , self . getlist ( k ) ) for k in self )	value under '_data' key of obj_dict is a dictionary created with tuples containing 2 elements: k and result of the function,
return obj_dict	self.getlist with an argument k, for every k in self.   return obj_dict.
def __setstate__ ( self , obj_dict ) :	define the method __setstate__ with 2 arguments: self and obj_dict.
data = obj_dict . pop ( '_data' , { } )	remove element under '_data' key of obj_dict dictionary, if it exists substitute it for data, if not data is an empty list.
for k , v in data . items ( ) :	call the method data.items, for every k and v in the result,
self . setlist ( k , v )	call the method self.setlist with 2 arguments: k and v.
self . __dict__ . update ( obj_dict )	update self.__dict__ dictionary with obj_dict.
def get ( self , key , default = None ) :	define the method get with 3 arguments: self, key and default set to None.
try :	try,
val = self [ key ]	substitute value under the key key of self dictionary for val.
except KeyError :	if KeyError exception is caught,
return default	return default,
if val == [ ] :	if val equals an empty list.
return default	return default.
return val	return val.
def getlist ( self , key , default = None ) :	define the method getlist with 3 arguments: self, key and default set to None.
try :	try,
return super ( MultiValueDict , self ) . __getitem__ ( key )	call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, return the result..
except KeyError :	if KeyError exception is caught,
if default is None :	if default is None,
return [ ]	return an empty list.
return default	return default.
def setlist ( self , key , list_ ) :	define the method setlist with 3 arguments: self, key and list_.
super ( MultiValueDict , self ) . __setitem__ ( key , list_ )	call the method __setitem__ from the base class of the class MultiValueDict, with 2 arguments key and list_.
def setdefault ( self , key , default = None ) :	define the method setdefault with 3 arguments: self, key and default set to None.
if key not in self :	if key is not contanied in self,
self [ key ] = default	substitute default for value under the key key of self dictionary.
return self [ key ]	return value under the key key of self dictionary.
def setlistdefault ( self , key , default_list = None ) :	define the method setlistdefault with 3 arguments: self, key and default_list set to None.
if key not in self :	if key is not contained in self,
if default_list is None :	if default_list is None,
default_list = [ ]	default_list is an empty list.
self . setlist ( key , default_list )	call the method self.setlist with 2 arguments: key and default_list.
return self . getlist ( key )	call the method self.getlist with an argument key, return the result.
def appendlist ( self , key , value ) :	define the method appendlist with 3 arguments: self, key and value.
self . setlistdefault ( key ) . append ( value )	call the method self.setlistdefault with an argument key, append value to the result.
def _iteritems ( self ) :	define the method _iteritems with an argument self.
for key in self :	for every key in self,
yield key , self [ key ]	yield key and value under the key key of self dictionary.
def _iterlists ( self ) :	define the method _iterlists with an argument self.
return six . iteritems ( super ( MultiValueDict , self ) )	call the function six.iteritems with an argument: instance of base class of the MultiValueDict class, return the result.
def _itervalues ( self ) :	define the method _itervalues with an argument self.
for key in self :	for every key in self,
yield self [ key ]	yield value under key key of self dictionary.
if six . PY3 :	if six.PY3 is true,
items = _iteritems	substitute _iteritems for items.
lists = _iterlists	substitute _iterlists for lists.
values = _itervalues	substitute _itervalues for values.
else :	if not,
iteritems = _iteritems	substitute _iteritems for iteritems.
iterlists = _iterlists	substitute _iterlists for iterlists.
itervalues = _itervalues	substitute _itervalues for itervalues.
def items ( self ) :	define the method items with an argument self.
return list ( self . iteritems ( ) )	call the method self.iteritems, return list of results.
def lists ( self ) :	define the method lists with an argument self.
return list ( self . iterlists ( ) )	call the method self.iterlists, return list of results.
def values ( self ) :	define the method values with an argument self.
return list ( self . itervalues ( ) )	call the method self.itervalues, return list of results.
def copy ( self ) :	define the method copy with an argument self.
return copy . copy ( self )	call the method copy.copy with an argument self, return the result.
def update ( self , * args , ** kwargs ) :	define the method update with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
if len ( args ) > 1 :	if length of args is greater than integer 1,
raise TypeError ( 'update expected at most 1 arguments, got %d' % len ( args ) )	raise an TypeError with an argument string 'update expected at most 1 arguments, got %d' formated with length of args.
if args :	if args is true,
other_dict = args [ 0 ]	substitute first args for other_dict.
if isinstance ( other_dict , MultiValueDict ) :	if other_dict is an instance of MultiValueDict.
for key , value_list in other_dict . lists ( ) :	call the method other_dict.lists, for every key and value_list in result,
self . setlistdefault ( key ) . extend ( value_list )	call the method self.setlistdefault with an argument key, extend the result with value_list.
else :	if not,
try :	trym
for key , value in other_dict . items ( ) :	for every key and value in items of other_dict dictionary,
    self . setlistdefault ( key ) . append ( value )	call the method self.setlistdefault with an argument key, append value to the result.
except TypeError :	if TypeError exception is caught,
raise ValueError ( 'MultiValueDict.update() takes either a MultiValueDict or dictionary' )	raise an ValueError with an argument string 'MultiValueDict.update() takes either a MultiValueDict or dictionary'.
for key , value in six . iteritems ( kwargs ) :	call the function six.iteritems with an argument kwargs, for every key and value in the result,
self . setlistdefault ( key ) . append ( value )	call the method self.setlistdefault with an argument key, append value to the result.
def dict ( self ) :	define the method dict with an argument self.
return dict ( ( key , self [ key ] ) for key in self )	return dictionary created with tuples with 2 elements: key and value under the key key of self dictionary, for every key in self.
class ImmutableList ( tuple ) :	derive the class ImmutableList from the tuple base class.
def __new__ ( cls , * args , ** kwargs ) :	define the method __new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs.
if 'warning' in kwargs :	if 'warning' is contained in kwargs,
warning = kwargs [ 'warning' ]	substitute value under 'warning' key of kwargs dictionary for warning.
del kwargs [ 'warning' ]	delete element under 'warning' key of kwargs dictionary.
else :	if not,
warning = 'ImmutableList object is immutable.'	warning is a string 'ImmutableList object is immutable.'.
self = tuple . __new__ ( cls , * args , ** kwargs )	call the method tuple.__new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs, substitute the result for self.
self . warning = warning	substitute warning for self.warning.
return self	return self.
def complain ( self , * wargs , ** kwargs ) :	define the method complain with 3 arguments: self, unpacked dictionary wargs and unpacked dictionary kwargs.
if isinstance ( self . warning , Exception ) :	if self.warning is an instance of Exception class,
raise self . warning	raise self.warning.
else :	if not,
raise AttributeError ( self . warning )	raise an raise self.warning with an argument self.warning.
__delitem__ = complain	substitute complain for __delitem__.
__delslice__ = complain	substitute complain for __delslice__.
__iadd__ = complain	substitute complain for __iadd__.
__imul__ = complain	substitute complain for __imul__.
__setitem__ = complain	substitute complain for __setitem__.
__setslice__ = complain	substitute complain for __setslice__.
append = complain	substitute complain for append.
extend = complain	substitute complain for extend.
insert = complain	substitute complain for insert.
pop = complain	substitute complain for pop.
remove = complain	substitute complain for remove.
sort = complain	substitute complain for sort.
reverse = complain	substitute complain for reverse.
class DictWrapper ( dict ) :	derive the class DictWrapper from the dict base class.
def __init__ ( self , data , func , prefix ) :	define the method __init__ with 4 arguments: self, data, func and prefix.
super ( DictWrapper , self ) . __init__ ( data )	call the method __init__ with an argument data, from the base class of the class DictWrapper.
self . func = func	substitute func for self.func.
self . prefix = prefix	substitute prefix for self.prefix.
def __getitem__ ( self , key ) :	define the method __getitem__ with 2 arguments: self and key.
if key . startswith ( self . prefix ) :	if key starts with self.prefix.
use_func = True	use_func is boolean True.
key = key [ len ( self . prefix ) : ]	key is a list with elements of list key from length of self.prefixes index to the end,
else :	if not,
use_func = False	use_func is boolean False.
value = super ( DictWrapper , self ) . __getitem__ ( key )	call the method __getitem__ with an argument key from the base class of the class DictWrapper, substitute the result for value.
if use_func :	if use_func is true,
return self . func ( value )	call the method self.func with an argument value.
return value	return value.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import re	import module re.
import time	import module time.
import calendar	import module calendar.
import datetime	import module datetime.
from django . utils . dates import MONTHS , MONTHS_3 , MONTHS_ALT , MONTHS_AP , WEEKDAYS , WEEKDAYS_ABBR	from django.utils.dates import MONTHS, MONTHS_3, MONTHS_ALT, MONTHS_AP, WEEKDAYS and WEEKDAYS_ABBR into default name space.
from django . utils . translation import ugettext as _	from django.utils.translation import ugettext as _ into default name space.
from django . utils . encoding import force_text	from django.utils.encoding import force_text into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . timezone import get_default_timezone , is_aware , is_naive	from django.utils.timezone import get_default_timezone, is_aware and is_naive into default name space.
\re_formatchars = re . compile ( r'(?<!\\\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])' )\	\compile regex from a string '(?<!\\\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])', substitute it for re_formatchars.\
\re_escaped = re . compile ( r'\\\\(.)' )\	\compile regex from a string '\\\\(.)', substitute it for re_escaped.\
class Formatter ( object ) :	derive the class Formatter from object base class.
def format ( self , formatstr ) :	define the function format with 2 arguments self and formatstr.
pieces = [ ]	pieces is an empty list.
for i , piece in enumerate ( re_formatchars . split ( force_text ( formatstr ) ) ) :	call the function force_text with an argument formatstr, use the result as an argument for the call to the method,
if i % 2 :	re_formatchars.split, for every i and piece in enumerated result,   if i is even number,
pieces . append ( force_text ( getattr ( self , piece ) ( ) ) )	get attribute piece of the self object, call it and use the result as an argument for the call to the function force_text,
elif piece :	append the result to pieces.   otherwise if piece is true,
\pieces . append ( re_escaped . sub ( r'\\1' , piece ) )\	\call the method re_escaped.sub with 2 arguments: raw string '\\1' and piece, append the result to pieces.\
return '' . join ( pieces )	join elements of pieces into a string, return it.
class TimeFormat ( Formatter ) :	derive the class TimeFormat from the base class Formatter.
def __init__ ( self , obj ) :	define the method __init__ with 2 arguments: self and obj.
self . data = obj	substitute obj for self.data.
self . timezone = None	self.timezone is None.
if isinstance ( obj , datetime . datetime ) :	if obj is an instance of datetime.datetime,
if is_naive ( obj ) :	call the function is_naive with an argument obj.
self . timezone = get_default_timezone ( )	call the function get_default_timezone, substitute the result for self.timezone.
else :	if not,
self . timezone = obj . tzinfo	substitute obj.tzinfo for self.timezone.
def a ( self ) :	define the method a with an argument self.
if self . data . hour > 11 :	if self.data.hour is greater than integer 11,
return _ ( 'p.m.' )	call the function _ with an argument string 'p.m.', return the result.
return _ ( 'a.m.' )	call the function _ with an argument string 'a.m.', return the result.
def A ( self ) :	define the method A with an argument self.
if self . data . hour > 11 :	if self.data.hour is greater than integer 11,
return _ ( 'PM' )	call the function _ with an argument string 'PM', return the result.
return _ ( 'AM' )	call the function _ with an argument string 'AM', return the result.
def B ( self ) :	define the method B with an argument self.
raise NotImplementedError ( 'may be implemented in a future release' )	raise an NotImplementedError exception with an argument string 'may be implemented in a future release'.
def e ( self ) :	define the method e with an argument self.
if not self . timezone :	if self.timezone is false,
return ''	return an empty string.
try :	try,
if hasattr ( self . data , 'tzinfo' ) and self . data . tzinfo :	is self.data has an attribute 'tzinfo' and self.data.tzinfo is true,
return self . data . tzinfo . tzname ( self . data ) or ''	call the method self.data.tzinfo.tzname with an argument self.data, if it is true, return it, otherwise return an empty string.
except NotImplementedError :	if NotImplementedError exception is caught,
pass	do nothing.
return ''	return an empty string.
def f ( self ) :	define the method f with an argument self.
if self . data . minute == 0 :	if self.data.minute equals integer 0,
return self . g ( )	call the method self.g, return the result.
return '%s:%s' % ( self . g ( ) , self . i ( ) )	return a string '%s:%s' formated with the results of the functions self.g and self.i, respectivley.
def g ( self ) :	define the method g with an argument self.
if self . data . hour == 0 :	if self.data.hour equals integer 0,
return 12	return integer 12.
if self . data . hour > 12 :	if self.data.hour is greater than inreger 12,
return self . data . hour - 12	subtract integer 12 from self.data.hour, return the result.
return self . data . hour	return self.data.hour.
def G ( self ) :	define the method G with an argument self.
return self . data . hour	return self.data.hour.
def h ( self ) :	define the method h with an argument self.
return '%02d' % self . g ( )	return a string '%02d' formated with the result of the function self.g.
def H ( self ) :	define the method H with an argument self.
return '%02d' % self . G ( )	return a string '%02d' formated with the result of the function self.G.
def i ( self ) :	define the method i with an argument self.
return '%02d' % self . data . minute	return a string '%02d' formated with self.data.minute.
def O ( self ) :	define the method O with an argument self.
if not self . timezone :	if self.timezone is false,
return ''	return an empty string.
seconds = self . Z ( )	call the method self.Z, substitute the result for seconds.
sign = '-' if seconds < 0 else '+'	if seconds smaller than integer 0, sign is '-', otherwise sign is '+',
seconds = abs ( seconds )	substitute absolute seconds for seconds.
return '%s%02d%02d' % ( sign , seconds // 3600 , ( seconds // 60 ) % 60 )	return a string '%s%02d%02d' formated with sign, floored result of the division of seconds by integer 3000,
def P ( self ) :	reminder of the division of floored result of division of seconds by 60, by integer 60.   define the method P with an argument self.
if self . data . minute == 0 and self . data . hour == 0 :	if self.data.minute equals integer 0 and self.data.hour equals integer 0,
return _ ( 'midnight' )	call the function _ with an argument string 'midnight', return the result.
if self . data . minute == 0 and self . data . hour == 12 :	if self.data.minute equals integer 0 and self.data.hour equals integer 12,
return _ ( 'noon' )	call the function _ with an argument string 'noon', return the result.
return '%s %s' % ( self . f ( ) , self . a ( ) )	return a string '%02d' formated with self.data.month.
def s ( self ) :	define the method s with an argument self.
return '%02d' % self . data . second	return a string '%02d' formated with self.data.second.
def T ( self ) :	define the method T with an argument self.
if not self . timezone :	if self.timezone is false,
return ''	return an empty string.
name = self . timezone . tzname ( self . data ) if self . timezone else None	if self.timezone is true, call the method self.timezone.tzname with an argument self.data, substitute the result for name,
if name is None :	otherwise name is None.   if name is None,
name = self . format ( 'O' )	call the method self.format with an argument string '0', substitute the result for name.
return six . text_type ( name )	call the function six.text_type with an argument name, return the result.
def u ( self ) :	define the method u with an argument self.
return '%06d' % self . data . microsecond	return a string '%06d' formated with self.data.microsecond.
def Z ( self ) :	define the method Z with an argument self.
if not self . timezone :	if self.timezone is true,
return ''	return an empty string.
offset = self . timezone . utcoffset ( self . data )	call the method self.timezone.utcoffset with an argument self.data, substitute the result for offset.
return offset . days * 86400 + offset . seconds	multiply offset.days with 86400, add offset.seconds to the result, return the result.
class DateFormat ( TimeFormat ) :	derive the class DateFormat from the base class TimeFormat.
year_days = [ None , 0 , 31 , 59 , 90 , 120 , 151 , 181 , 212 , 243 , 273 , 304 , 334 ]	year_days is a list with 13 elements: None, integer 0, integer 31, integer 59, integer 90, integer 120, integer 151, integer 181,
def b ( self ) :	integer 212, integer 243, integer 273, integer 304 and integer 334.   define the method b with an argument self.
return MONTHS_3 [ self . data . month ]	return the value under the self.data.month key of the MONTHS_3 dictionary.
def c ( self ) :	define the method c with an argument self.
return self . data . isoformat ( )	call the method self.data.isoformat, return the result.
def d ( self ) :	define the method d with an argument self.
return '%02d' % self . data . day	return a string '%02d' formated with self.data.day.
def D ( self ) :	define the method D with an argument self.
return WEEKDAYS_ABBR [ self . data . weekday ( ) ]	call the method self.data.weekday, use the result as an key for obtaining WEEKDAYS_ABBR dictionary value, return it.
def E ( self ) :	define the method E with an argument self.
return MONTHS_ALT [ self . data . month ]	return the value under the self.data.month key of the MONTHS_ALT dictionary.
def F ( self ) :	define the method F with an argument self.
return MONTHS [ self . data . month ]	return the value under the self.data.month key of the MONTHS dictionary.
def I ( self ) :	define the method I with an argument self.
if self . timezone and self . timezone . dst ( self . data ) :	if self.timezone is true and call to the method self.timezone.dst with an argument self.data, evaluates to true,
return '1'	return string '1'.
else :	if not,
return '0'	return string '0'.
def j ( self ) :	define the method j with an argument self.
return self . data . day	return self.data.day.
def l ( self ) :	define the method l with an argument self.
return WEEKDAYS [ self . data . weekday ( ) ]	call the method self.data.weekday, use the result as an key for obtaining WEEKDAYS dictionary value, return it.
def L ( self ) :	define the method L with an argument self.
return calendar . isleap ( self . data . year )	call the method calendar.isleap with an argument self.data.year, return the result.
def m ( self ) :	define the method m with an argument self.
return '%02d' % self . data . month	return a string '%02d' formated with self.data.month.
def M ( self ) :	define the method M with an argument self.
return MONTHS_3 [ self . data . month ] . title ( )	get the value under the self.data.month key of the MONTHS_3 dictionary, call on it the method title, return the result.
def n ( self ) :	define the method n with an argument self.
return self . data . month	return self.data.month.
def N ( self ) :	define the method N with an argument self.
return MONTHS_AP [ self . data . month ]	return the value under the self.data.month key of the MONTHS_AP dictionary.
def o ( self ) :	define the method o with an argument self.
return self . data . isocalendar ( ) [ 0 ]	call the method self.data.isocalendar, return the first element of the result.
def r ( self ) :	define the method r with an argument self.
return self . format ( 'D, j M Y H:i:s O' )	call the method return self.format with an argument string 'D, j M Y H:i:s O', return the result.
def S ( self ) :	define the method S with an argument self.
if self . data . day in ( 11 , 12 , 13 ) :	if self.data.day equals integer 11, 12 or 13,
return 'th'	return string 'th'.
last = self . data . day % 10	divide self.data.day by 10, substitute reminder of the result for last.
if last == 1 :	if las equals integer 1,
return 'st'	return string 'st'.
if last == 2 :	if las equals integer 2,
return 'nd'	return string 'nd'.
if last == 3 :	if las equals integer 3,
return 'rd'	return string 'rd'.
return 'th'	return string 'th'.
def t ( self ) :	define the method t with an argument self.
return '%02d' % calendar . monthrange ( self . data . year , self . data . month ) [ 1 ]	call the method calendar.monthrange with 2 arguments: self.data.year and self.data.month,
def U ( self ) :	format string '%02d' with the second element of the result, return it.   define the method U with an argument self.
if isinstance ( self . data , datetime . datetime ) and is_aware ( self . data ) :	if self.data is an instance of datetime.datetime and result of the function is_aware called with an argument self.data evaluates to true,
return int ( calendar . timegm ( self . data . utctimetuple ( ) ) )	call the method self.data.utctimetuple, use the result as an argument for the call to the function calendar.timegm,
else :	return result converted into an integer.   if not,
return int ( time . mktime ( self . data . timetuple ( ) ) )	call the method self.data.timetuple, use the result as an argument for the call to the function time.mktime,
def w ( self ) :	return result converted into an integer.   define the method w with an argument self.
return ( self . data . weekday ( ) + 1 ) % 7	call the method self.data.weekday, increment the result by an integer 1, divide it with integer 7, return the reminder of the division.
def W ( self ) :	define the method W with an argument self.
week_number = None	week_number is None.
jan1_weekday = self . data . replace ( month = 1 , day = 1 ) . weekday ( ) + 1	call the method self.data.replace with 2 arguments: month as integer 1 and day as integer 1, on the result call the method,
weekday = self . data . weekday ( ) + 1	weekday, increment the result by integer 1 and substitute it for jan1_weekday.   call the method self.data.weekday, increment the result by integer 1, substitute the result for weekday.
day_of_year = self . z ( )	call the method self.z, substitute the result for day_of_year.
if day_of_year <= ( 8 - jan1_weekday ) and jan1_weekday > 4 :	if day_of_year is smaller than or equalt to jan1_weekday subtracted from integer 8 and jan1_weekday is greater than integer 4,
if jan1_weekday == 5 or ( jan1_weekday == 6 and calendar . isleap ( self . data . year - 1 ) ) :	if jan1_weekday equals integer 5, or if jan1_weekday equals integer 6 and call to the function calendar.isleap,
week_number = 53	with an argument self.data.year decremented by 1, evaluates to true,   week_number is integer 53.
else :	if not,
week_number = 52	week_number is integer 52.
else :	if not,
if calendar . isleap ( self . data . year ) :	call the function calendar.isleap with an argument self.data.year, if it evaluates to true,
i = 366	i is integer 366.
else :	if not,
i = 365	i is integer 365.
if ( i - day_of_year ) < ( 4 - weekday ) :	subtract day_of_year from i, if the result is smaller than the result of subtraction of weekday from integer 4,
week_number = 1	week_number is integer 1.
else :	if not,
j = day_of_year + ( 7 - weekday ) + ( jan1_weekday - 1 )	sum day_of_year, result of the subtraction of weekday from integer 7 and subtraction of integer 1 from jan1_weekday.
week_number = j // 7	divide j by integer 7, substitute the floored result for week_number.
if jan1_weekday > 4 :	if jan1_weekday is greater than integer 4,
week_number -= 1	decrement week_number by integer 1.
return week_number	return week_number.
def y ( self ) :	define the method y with an argument self.
return six . text_type ( self . data . year ) [ 2 : ]	call the function six.text_type with an argument self.data.year, return the result without the first 2 elements.
def Y ( self ) :	define the method Y with an argument self.
return self . data . year	return self.data.year.
def z ( self ) :	define the method z with an argument self.
doy = self . year_days [ self . data . month ] + self . data . day	append self.data.day to the value under the self.data.month key of the self.year_days dictionary, substitute the result for doy.
if self . L ( ) and self . data . month > 2 :	if call to the method self.L evaluates to true, and result of the call to the method self.data.month is greater than integer 2,
doy += 1	increment doy by integer 1.
return doy	return doy.
def format ( value , format_string ) :	define the function format with 2 arguments: value and format_string.
df = DateFormat ( value )	df is an instance of DateFormat class, created with an argument value.
return df . format ( format_string )	call the method df.format with an argument format_string, return the result.
def time_format ( value , format_string ) :	define the function time_format with 2 arguments: value and format_string.
tf = TimeFormat ( value )	tf is an instance of TimeFormat class, created with an argument value.
return tf . format ( format_string )	call the method tf.format with an argument format_string, return the result.
import datetime	import module datetime.
import re	import module re.
from django . utils import six	from django.utils import six into default name space.
from django . utils . timezone import utc , get_fixed_timezone	from django.utils.timezone import utc and get_fixed_timezone into default name space.
\date_re = re . compile (  r'(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})$'  )\	\compile regex from raw string '(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})$', substitute it for date_re.\
\time_re = re . compile (  r'(?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})'  r'(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?'  )\	\compile regex from raw string '(?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?',\
\datetime_re = re . compile (  r'(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})'  r'[T ](?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})'  r'(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?'  r'(?P<tzinfo>Z|[+-]\\d{2}(?::?\\d{2})?)?$'  )\	\substitute it for time_re.   compile regex from raw string '(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})[T ](?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})'\
def parse_date ( value ) :	\'(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?(?P<tzinfo>Z|[+-]\\d{2}(?::?\\d{2})?)?$', substitute it for datetime_re.   define the function parse_date with an argument value.\
match = date_re . match ( value )	match regex date_re with value, substitute the result for match.
if match :	if match is true,
kw = dict ( ( k , int ( v ) ) for k , v in six . iteritems ( match . groupdict ( ) ) )	call the method match.groupdict, use the result as an argument for the call to the function six.iteritems,
return datetime . date ( ** kw )	for every k and v in the previous result, add a key into a dictionary: v converted to an integer for k,   substitute the resulting dictionary for kw.   call the method datetime.date with an argument unpacked dictionary kw, return the result.
def parse_time ( value ) :	define the function parse_time with an argument value.
match = time_re . match ( value )	match regex time_re with value, substitute the result for match.
if match :	if match is true,
kw = match . groupdict ( )	call the method match.groupdict, substitute the result for kw.
if kw [ 'microsecond' ] :	if value under the 'microsecond' key of the kw dictionary is true,
kw [ 'microsecond' ] = kw [ 'microsecond' ] . ljust ( 6 , '0' )	left justify value under the 'microsecond' key of the kw dictionary, in the field of width 6, fill the rest with '0',
kw = dict ( ( k , int ( v ) ) for k , v in six . iteritems ( kw ) if v is not None )	substitute the result for value under the 'microsecond' key of the kw dictionary.   update a dictionary with an entry v converted to an integer for k, for every k and v in result of the function six.iteritems,
return datetime . time ( ** kw )	called with an argument kw, only if v is not None, substitute the result for kw.   call the method datetime.time with an argument unpacked dictionary kw, return the result.
def parse_datetime ( value ) :	define the function parse_datetime with an argument value.
match = datetime_re . match ( value )	match regex datetime_re with value, substitute the result for match.
if match :	if match is true,
kw = match . groupdict ( )	call the method match.groupdict, substitute the result for kw.
if kw [ 'microsecond' ] :	if value under the 'microsecond' key of the kw dictionary is true,
kw [ 'microsecond' ] = kw [ 'microsecond' ] . ljust ( 6 , '0' )	left justify value under the 'microsecond' key of the kw dictionary, in the field of width 6, fill the rest with '0',
tzinfo = kw . pop ( 'tzinfo' )	substitute the result for value under the 'microsecond' key of the kw dictionary.   remove entry under the 'tzinfo' key of the kw dictionary, substitute it for tzinfo.
if tzinfo == 'Z' :	if tzinfo equals a string 'Z',
tzinfo = utc	substitute utc for tzinfo.
elif tzinfo is not None :	otherwise if tzinfo is not None,
offset_mins = int ( tzinfo [ - 2 : ] ) if len ( tzinfo ) > 3 else 0	if length of tzinfo is greater than integer 3, convert elements of tzinfo from indexes 1 to 3 to an integer,
offset = 60 * int ( tzinfo [ 1 : 3 ] ) + offset_mins	substitute the result for offset_mins, otherwise offset_mins is integer 0.   convert elements of tzinfo from indexes 1 to 3 to an integer, multiply it by integer 60 and increment it by offset_mins,
if tzinfo [ 0 ] == '-' :	substitute the result for offset.   if first element of tzinfo equals '-',
offset = - offset	multiply offset by integer -1.
tzinfo = get_fixed_timezone ( offset )	call the function get_fixed_timezone with an argument offset, substitute the result for tzinfo.
kw = dict ( ( k , int ( v ) ) for k , v in six . iteritems ( kw ) if v is not None )	update a dictionary with an entry v converted to an integer for k, for every k and v in result of the function six.iteritems,
kw [ 'tzinfo' ] = tzinfo	called with an argument kw, only if v is not None, substitute the result for kw.   substitute tzinfo for value under the 'tzinfo' key of the kw dictionary.
return datetime . datetime ( ** kw )	call the method datetime.datetime with an argument unpacked dictionary kw, return the result.
from django . utils . translation import ugettext_lazy as _ , pgettext_lazy	from django.utils.translation import ugettext_lazy as _ and pgettext_lazy into default name space.
WEEKDAYS = {  0 : _ ( 'Monday' ) , 1 : _ ( 'Tuesday' ) , 2 : _ ( 'Wednesday' ) , 3 : _ ( 'Thursday' ) , 4 : _ ( 'Friday' ) ,  5 : _ ( 'Saturday' ) , 6 : _ ( 'Sunday' )  }	WEEKDAYS is an dictionary with 7 entries: result of the call to the function _ with an argument string 'Monday' for 0,
WEEKDAYS_ABBR = {  0 : _ ( 'Mon' ) , 1 : _ ( 'Tue' ) , 2 : _ ( 'Wed' ) , 3 : _ ( 'Thu' ) , 4 : _ ( 'Fri' ) ,  5 : _ ( 'Sat' ) , 6 : _ ( 'Sun' )  }	result of the call to the function _ with an argument string 'Tuesday' for 1,   result of the call to the function _ with an argument string 'Wednesday' for 2,   result of the call to the function _ with an argument string 'Thursday' for 3,   result of the call to the function _ with an argument string 'Friday' for 4,   result of the call to the function _ with an argument string 'Saturday' for 5,   and result of the call to the function _ with an argument string 'Sunday' for 6.   WEEKDAYS_ABBR is an dictionary with 7 entries: result of the call to the function _ with an argument string 'Mon' for 0,
WEEKDAYS_REV = {  'monday' : 0 , 'tuesday' : 1 , 'wednesday' : 2 , 'thursday' : 3 , 'friday' : 4 ,  'saturday' : 5 , 'sunday' : 6  }	result of the call to the function _ with an argument string 'Tue' for 1,   result of the call to the function _ with an argument string 'Wed' for 2,   result of the call to the function _ with an argument string 'Thu' for 3,   result of the call to the function _ with an argument string 'Fri' for 4,   result of the call to the function _ with an argument string 'Sat' for 5,   and result of the call to the function _ with an argument string 'Sun' for 6.   WEEKDAYS_REV is an dictionary with 7 entries: 0 for 'monday', 1 for 'tuesday', 2 for 'wednesday', 3 for 'thursday', 4 for 'friday',   5 for 'saturday' and 6 for 'sunday'.
MONTHS = {  1 : _ ( 'January' ) , 2 : _ ( 'February' ) , 3 : _ ( 'March' ) , 4 : _ ( 'April' ) , 5 : _ ( 'May' ) , 6 : _ ( 'June' ) ,  7 : _ ( 'July' ) , 8 : _ ( 'August' ) , 9 : _ ( 'September' ) , 10 : _ ( 'October' ) , 11 : _ ( 'November' ) ,  12 : _ ( 'December' )  }	MONTHS is an dictionary with 12 entries: result of the call to the function _ with an argument string 'January' for 1,
MONTHS_3 = {  1 : _ ( 'jan' ) , 2 : _ ( 'feb' ) , 3 : _ ( 'mar' ) , 4 : _ ( 'apr' ) , 5 : _ ( 'may' ) , 6 : _ ( 'jun' ) ,  7 : _ ( 'jul' ) , 8 : _ ( 'aug' ) , 9 : _ ( 'sep' ) , 10 : _ ( 'oct' ) , 11 : _ ( 'nov' ) , 12 : _ ( 'dec' )  }	result of the call to the function _ with an argument string 'February' for 2,   result of the call to the function _ with an argument string 'March' for 3,   result of the call to the function _ with an argument string 'April' for 4,   result of the call to the function _ with an argument string 'May' for 5,   result of the call to the function _ with an argument string 'June' for 6,   result of the call to the function _ with an argument string 'July' for 7,   result of the call to the function _ with an argument string 'August' for 8,   result of the call to the function _ with an argument string 'September' for 9,   result of the call to the function _ with an argument string 'October' for 10,   result of the call to the function _ with an argument string 'November' for 11,   and result of the call to the function _ with an argument string 'December' for 12.   MONTHS_3 is an dictionary with 12 entries: result of the call to the function _ with an argument string 'jan' for 1,
MONTHS_3_REV = {  'jan' : 1 , 'feb' : 2 , 'mar' : 3 , 'apr' : 4 , 'may' : 5 , 'jun' : 6 , 'jul' : 7 , 'aug' : 8 ,  'sep' : 9 , 'oct' : 10 , 'nov' : 11 , 'dec' : 12  }	result of the call to the function _ with an argument string 'feb' for 2,   result of the call to the function _ with an argument string 'mar' for 3,   result of the call to the function _ with an argument string 'apr' for 4,   result of the call to the function _ with an argument string 'may' for 5,   result of the call to the function _ with an argument string 'jun' for 6,   result of the call to the function _ with an argument string 'jul' for 7,   result of the call to the function _ with an argument string 'aug' for 8,   result of the call to the function _ with an argument string 'sep' for 9,   result of the call to the function _ with an argument string 'oct' for 10,   result of the call to the function _ with an argument string 'nov' for 11,   result of the call to the function _ with an argument string 'dec' for 12.   MONTHS_3_REV is an dictionary with 12 entries: 1 for 'jan', 2 for 'feb', 3 for 'mar', 4 for 'apr', 5 for 'may', 6 for 'jun',
MONTHS_AP = {  1 : pgettext_lazy ( 'abbrev. month' , 'Jan.' ) ,  2 : pgettext_lazy ( 'abbrev. month' , 'Feb.' ) ,  3 : pgettext_lazy ( 'abbrev. month' , 'March' ) ,  4 : pgettext_lazy ( 'abbrev. month' , 'April' ) ,  5 : pgettext_lazy ( 'abbrev. month' , 'May' ) ,  6 : pgettext_lazy ( 'abbrev. month' , 'June' ) ,  7 : pgettext_lazy ( 'abbrev. month' , 'July' ) ,  8 : pgettext_lazy ( 'abbrev. month' , 'Aug.' ) ,  9 : pgettext_lazy ( 'abbrev. month' , 'Sept.' ) ,  10 : pgettext_lazy ( 'abbrev. month' , 'Oct.' ) ,  11 : pgettext_lazy ( 'abbrev. month' , 'Nov.' ) ,  12 : pgettext_lazy ( 'abbrev. month' , 'Dec.' )  }	7 for 'jul', 8 for 'aug', 9 for 'sep', 10 for 'oct', 11 for 'nov' and 12 for 'dec'.   MONTHS_AP is an dictionary with 12 entries: result of the function pgettext_lazy with 2 arguments: 'abbrev. month' and 'Jan.' for 1,
MONTHS_ALT = {  1 : pgettext_lazy ( 'alt. month' , 'January' ) ,  2 : pgettext_lazy ( 'alt. month' , 'February' ) ,  3 : pgettext_lazy ( 'alt. month' , 'March' ) ,  4 : pgettext_lazy ( 'alt. month' , 'April' ) ,  5 : pgettext_lazy ( 'alt. month' , 'May' ) ,  6 : pgettext_lazy ( 'alt. month' , 'June' ) ,  7 : pgettext_lazy ( 'alt. month' , 'July' ) ,  8 : pgettext_lazy ( 'alt. month' , 'August' ) ,  9 : pgettext_lazy ( 'alt. month' , 'September' ) ,  10 : pgettext_lazy ( 'alt. month' , 'October' ) ,  11 : pgettext_lazy ( 'alt. month' , 'November' ) ,  12 : pgettext_lazy ( 'alt. month' , 'December' )  }	result of the function pgettext_lazy with 2 arguments: strings 'abbrev. month' and 'Feb.' for 2,   result of the function pgettext_lazy with 2 arguments: strings 'abbrev. month' and 'March' for 3,   result of the function pgettext_lazy with 2 arguments: strings 'abbrev. month' and 'April' for 4,   result of the function pgettext_lazy with 2 arguments: strings 'abbrev. month' and 'May' for 5,   result of the function pgettext_lazy with 2 arguments: strings 'abbrev. month' and 'June' for 6,   result of the function pgettext_lazy with 2 arguments: strings 'abbrev. month' and 'July' for 7,   result of the function pgettext_lazy with 2 arguments: strings 'abbrev. month' and 'Aug.' for 8,   result of the function pgettext_lazy with 2 arguments: strings 'abbrev. month' and 'Sept.' for 9,   result of the function pgettext_lazy with 2 arguments: strings 'abbrev. month' and 'Oct.' for 10,   result of the function pgettext_lazy with 2 arguments: strings 'abbrev. month' and 'Nov.' for 11,   result of the function pgettext_lazy with 2 arguments: strings 'abbrev. month' and 'Dec.' for 12,   MONTHS_ALT is an dictionary with 12 entries: result of the function pgettext_lazy with 2 arguments: 'alt. month' and 'January' for 1,
from datetime import date as real_date , datetime as real_datetime	from datetime import date as real_date and datetime as real_datetime into default name space.
import re	import module re.
import time	import module time.
class date ( real_date ) :	derive the class date from the real_date base class.
def strftime ( self , fmt ) :	define the method strftime with 2 arguments: self and fmt.
return strftime ( self , fmt )	call the function strftime with 2 arguments: self and fmt, return the result.
class datetime ( real_datetime ) :	derive the class datetime from the real_datetime base class.
def strftime ( self , fmt ) :	define the method strftime with 2 arguments: self and fmt.
return strftime ( self , fmt )	call the function strftime with 2 arguments: self and fmt, return the result.
@ classmethod	decorator classmethod,
def combine ( cls , date , time ) :	define the method combine with 3 arguments: cls, date and time.
return cls ( date . year , date . month , date . day ,  time . hour , time . minute , time . second ,  time . microsecond , time . tzinfo )	call the function cls with 8 arguments: date.year, date.month, date.day, time.hour, time.minute, time.second, time.microsecond,
def date ( self ) :	and time.tzinfo, return the result.   define the method date with an argument self.
return date ( self . year , self . month , self . day )	call the function data with 3 arguments: self.year, self.month and self.day, return the result.
def new_date ( d ) :	define the function new_date with an argument d.
return date ( d . year , d . month , d . day )	call the function data with 3 arguments: d.year, d.month and d.day, return the result.
def new_datetime ( d ) :	define the function new_datetime with an argument d.
kw = [ d . year , d . month , d . day ]	kw is a list with 3 elements: d.year, d.month and d.day.
if isinstance ( d , real_datetime ) :	if d is an instance of real_datetime class,
kw . extend ( [ d . hour , d . minute , d . second , d . microsecond , d . tzinfo ] )	extend list kw with a list with 5 elements: d.hour, d.minute, d.second, d.microsecond and d.tzinfo.
return datetime ( * kw )	call the function datetime with an argument unpacked list kw, return the result.
_illegal_formatting = re . compile ( r'((^|[^%])(%%)*%[sy])' )	compile the regex from the raw string '((^|[^%])(%%)*%[sy])', substitute the result for _illegal_formatting.
def _findall ( text , substr ) :	define the function _findall with 2 arguments text and substr.
sites = [ ]	sites is an empty list.
i = 0	i is integer 0.
while 1 :	endless loop,
j = text . find ( substr , i )	call the method text.find with 2 arguments: substr and i, substitute the result for j.
if j == - 1 :	if j equals to integer -1,
break	break from the loop execution.
sites . append ( j )	append j to sites.
i = j + 1	add j and integer 1, substitute the result for i.
return sites	return sites.
def strftime ( dt , fmt ) :	define the function strftime with 2 arguments dt and fmt.
if dt . year >= 1900 :	if dt.year is greater than or equal to integer 1900,
return super ( type ( dt ) , dt ) . strftime ( fmt )	call the method strftime with an argument fmt, from the base class of the type of dt class.
illegal_formatting = _illegal_formatting . search ( fmt )	call the method _illegal_formatting.search with an argument fmt, substitute the result for illegal_formatting.
if illegal_formatting :	if illegal_formatting is true,
raise TypeError ( 'strftime of dates before 1900 does not handle' + illegal_formatting . group ( 0 ) )	raise an TypeError exception with an argument: result of the method illegal_formatting.group called with an argument,
year = dt . year	integer 0, appended to a string 'strftime of dates before 1900 does not handle'.   substitute dt.year for year.
delta = 2000 - year	subtract year from integer 2000, substitute the result for delta.
off = 6 * ( delta // 100 + delta // 400 )	floor the division of delta by integer 100 and delta by integer 400, sum the two results, multiply integer 6 by it, substitute the result for off.
year = year + off	sum year and off, substitute the result for year.
year = year + ( ( 2000 - year ) // 28 ) * 28	subtract year from integer 2000, divide the result by integer 28, floor the result, multiply it with 28 and increment by year,
timetuple = dt . timetuple ( )	substitute the result for year.   call the method dt.timetuple, substitute the result for timetuple.
s1 = time . strftime ( fmt , ( year , ) + timetuple [ 1 : ] )	call the function time.strftime with 2 arguments: fmt and and timetuple without the first element,
sites1 = _findall ( s1 , str ( year ) )	added to a tuple with an element year, substitute the result for s1.   call the function _findall with 2 arguments: s1 and year converted into a string, substitute the result for sites1.
s2 = time . strftime ( fmt , ( year + 28 , ) + timetuple [ 1 : ] )	call the function time.strftime with 2 arguments: fmt and and timetuple without the first element,
sites2 = _findall ( s2 , str ( year + 28 ) )	added to a tuple with an element sum of year an integer 28, substitute the result for s2.   call the function _findall with 2 arguments: s2 and sum of year and integer 28, converted into a string, substitute the result for sites2.
sites = [ ]	sites is an empty list.
for site in sites1 :	if site is contained in sites1,
if site in sites2 :	if site is contained in sites2,
sites . append ( site )	append site to sites.
s = s1	substitute s1 for s.
syear = '%04d' % ( dt . year , )	syear is a string '%04d' formated with dt.year.
for site in sites :	for every site in sites,
s = s [ : site ] + syear + s [ site + 4 : ]	concatenate first site elements of s, syear and elements of s from the site incremented by integer 4 index, substitute the result for s.
return s	return s.
def deconstructible ( * args , ** kwargs ) :	define the function deconstructible with 2 arguments: unpacked list args and unpacked dictionary kwargs.
path = kwargs . pop ( 'path' , None )	remove elements under the 'path' key of the kwargs dictionary, if it exists substitute it for path, if not path is None.
def decorator ( klass ) :	define the function decorator with an argument klass.
def __new__ ( cls , * args , ** kwargs ) :	define the method __new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs.
obj = super ( klass , cls ) . __new__ ( cls )	call the method __new__ with an argument cls from the base class of the klass function.
obj . _constructor_args = ( args , kwargs )	obj._constructor_args is a tuple with 2 elements: args and kwargs.
return obj	return obj.
def deconstruct ( obj ) :	define the function deconstruct with an argument obj.
return (  path or '%s.%s' % ( obj . __class__ . __module__ , obj . __class__ . __name__ ) ,  obj . _constructor_args [ 0 ] ,  obj . _constructor_args [ 1 ] ,  )	return a tuple with 3 elements: if path is true, path, in not, a string '%s.%s' formated with obj.__class__.__module__,
klass . __new__ = staticmethod ( __new__ )	and obj.__class__.__name__, first element of obj._constructor_args and second element of obj._constructor_args.   klass.__new__ is a static method of the function __new__.
klass . deconstruct = deconstruct	substitute deconstruct for klass.deconstruct.
return klass	return klass.
if not args :	if args is true,
return decorator	return decorator.
return decorator ( * args , ** kwargs )	call the function decorator with 2 arugments: unpacked list args and unpacked dictionary kwargs, return the result.
from functools import wraps , update_wrapper , WRAPPER_ASSIGNMENTS	from functools import wraps, update_wrapper and WRAPPER_ASSIGNMENTS into default name space.
from django . utils import six	from django.utils import six into default name space.
class classonlymethod ( classmethod ) :	derive the class classonlymethod from the classmethod base class.
def __get__ ( self , instance , owner ) :	define the method __get__ with 3 arguments: self, instance and owner.
if instance is not None :	if instance is not None,
raise AttributeError ( 'This method is available only on the view class.' )	raise an AttributeError exception with an argument string 'This method is available only on the view class.'.
return super ( classonlymethod , self ) . __get__ ( instance , owner )	call the method __get__ with 2 arguments: instance and owner, from the base class of the classonlymethod class, return the result.
def method_decorator ( decorator ) :	define the function method_decorator with an argument decorator.
def _dec ( func ) :	define the function _dec with an argument func.
def _wrapper ( self , * args , ** kwargs ) :	define the method _wrapper with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
@ decorator	decorator decorator.
def bound_func ( * args2 , ** kwargs2 ) :	define the function bound_func with 2 arguments: unpacked list args2 and unpacked dictionary kwargs2.
return func . __get__ ( self , type ( self ) ) ( * args2 , ** kwargs2 )	call the method func.__get__ with 2 arguments: self and type of self object, call the result with 2 arguments:
return bound_func ( * args , ** kwargs )	unpacked list args2 and unpacked dictionary kwargs2, return the result.   call the function bound_func with 2 arguments: unpacked list args and unpacked dictionary kwargs, return the result.
@ decorator	decorator decorator.
def dummy ( * args , ** kwargs ) :	define the function dummy with 2 arguments: unpacked list args and unpacked dictionary kwargs.
pass	do nothing.
update_wrapper ( _wrapper , dummy )	call the function update_wrapper with 2 arguments: _wrapper and dummy.
update_wrapper ( _wrapper , func )	call the function update_wrapper with 2 arguments: _wrapper and func.
return _wrapper	return _wrapper.
update_wrapper ( _dec , decorator , assigned = available_attrs ( decorator ) )	call the function update_wrapper with 3 arguments: _dec, decorator and assigned as result of the function available_attrs,
if hasattr ( decorator , '__name__' ) :	called with an argument decorator.   if decorator has an attribute 'process_view',
_dec . __name__ = 'method_decorator(%s)' % decorator . __name__	_dec.__name__ is a string 'method_decorator(%s)' formated with decorator.__name__.
else :	if not,
_dec . __name__ = 'method_decorator(%s)' % decorator . __class__ . __name__	_dec.__name__ is a string 'method_decorator(%s)' formated with decorator.__class__.__name__.
return _dec	return _dec.
def decorator_from_middleware_with_args ( middleware_class ) :	define the function decorator_from_middleware_with_args with an argument middleware_class.
return make_middleware_decorator ( middleware_class )	call the function make_middleware_decorator with an argument middleware_class, return the result.
def decorator_from_middleware ( middleware_class ) :	define the function decorator_from_middleware with an argument middleware_class.
return make_middleware_decorator ( middleware_class ) ( )	call the function make_middleware_decorator with an argument middleware_class, call the result, return the new result.
def available_attrs ( fn ) :	define the function available_attrs with an argument fn.
if six . PY3 :	if six.PY3 is true,
return WRAPPER_ASSIGNMENTS	return WRAPPER_ASSIGNMENTS.
else :	if not,
return tuple ( a for a in WRAPPER_ASSIGNMENTS if hasattr ( fn , a ) )	if fh has an attribute a, for every a in WRAPPER_ASSIGNMENTS, put a into a tuple, return the resulting tuple.
def make_middleware_decorator ( middleware_class ) :	define the function make_middleware_decorator with an argument middleware_class.
def _make_decorator ( * m_args , ** m_kwargs ) :	define the function make_decorator with 2 arguments: unpacked list m_args and unpacked dictionary m_kwargs.
middleware = middleware_class ( * m_args , ** m_kwargs )	call the function middleware_class with 2 arguments: unpacked list m_args and unpacked dictionary m_kwargs,
def _decorator ( view_func ) :	substitute the middleware.   define the function _decorator with an argument view_func.
@ wraps ( view_func , assigned = available_attrs ( view_func ) )	decorator function wraps with 2 arguments: view_func and assigned set to result of the function available_attrs,
def _wrapped_view ( request , * args , ** kwargs ) :	called with an argument view_func.   define the function _wrapped_view with 3 arguments: request, unpacked list args and unpacked dictionary kwargs.
if hasattr ( middleware , 'process_request' ) :	if middleware has an attribute 'process_request',
result = middleware . process_request ( request )	call the method middleware.process_request with an argument request, substitute the result for result.
if result is not None :	if result is not None,
    return result	return result.
if hasattr ( middleware , 'process_view' ) :	if middleware has an attribute 'process_view',
result = middleware . process_view ( request , view_func , args , kwargs )	call the method middleware.process_view with 4 arguments: request, view_func, args and kwargs, substitute the result for result.
if result is not None :	if result is not None,
    return result	return result.
try :	try,
response = view_func ( request , * args , ** kwargs )	call the function view_func with 3 arguments: request, unpacked list args, unpacked dictionary kwargs, substitute the result for response.
except Exception as e :	if Exception, renamed to e, exception is caught,
if hasattr ( middleware , 'process_exception' ) :	  if middleware has an attribute 'process_exception',
    result = middleware . process_exception ( request , e )	call the method middleware.process_exception with 2 arguments: request and e, substitute the result for result.
if result is not None :	if result is not None,
        return result	return result,
raise	raise an exception.
if hasattr ( response , 'render' ) and callable ( response . render ) :	if response has an attribute 'render' and response.render is a callable object,
if hasattr ( middleware , 'process_template_response' ) :	if middleware has an attribute 'process_response',
    response = middleware . process_template_response ( request , response )	call the method middleware.process_template_response with 2 arguments: request and response, substitute the result for response.
if hasattr ( middleware , 'process_response' ) :	if middleware has an attribute 'process_response',
    callback = lambda response : middleware . process_response ( request , response )	callback is an lambda function with an argument response and with return value result of the method middleware.process_response,
response . add_post_render_callback ( callback )	called with 2 arguments: request and response.   call the method response.add_post_render_callback with an argument callback.
else :	if not,
if hasattr ( middleware , 'process_response' ) :	if middleware has an attribute 'process_response',
    return middleware . process_response ( request , response )	call the method middleware.process_response with 2 arguments: request and response, return the result.
return response	return response.
return _wrapped_view	return _wrapped_view.
return _decorator	return _decorator.
return _make_decorator	return _make_decorator.
import inspect	import module inspect.
import warnings	import module warnings.
class RemovedInDjango20Warning ( PendingDeprecationWarning ) :	derive the class RemovedInDjango20Warning from PendingDeprecationWarning base class.
pass	do nothing.
class RemovedInDjango19Warning ( DeprecationWarning ) :	derive the class RemovedInDjango19Warning from DeprecationWarning base class.
pass	do nothing.
RemovedInNextVersionWarning = RemovedInDjango19Warning	substitute RemovedInDjango19Warning for RemovedInNextVersionWarning.
class warn_about_renamed_method ( object ) :	derive the class warn_about_renamed_method from object base class.
def __init__ ( self , class_name , old_method_name , new_method_name , deprecation_warning ) :	deifne the method __init__ with 5 arguments: self, class_name, old_method_name, new_method_name and deprecation_warning.
self . class_name = class_name	substitute class_name for self.class_name.
self . old_method_name = old_method_name	substitute old_method_name for self.old_method_name.
self . new_method_name = new_method_name	substitute new_method_name for new_method_name.
self . deprecation_warning = deprecation_warning	substitute deprecation_warning for self.deprecation_warning.
def __call__ ( self , f ) :	define the method __call__ with 2 arguments: self and f.
def wrapped ( * args , ** kwargs ) :	define the function wrapped with 2 arguments: unpacked list args and unpacked dictionary kwargs.
warnings . warn (  '`%s.%s` is deprecated, use `%s` instead.' %  ( self . class_name , self . old_method_name , self . new_method_name ) ,  self . deprecation_warning , 2 )	call the function warnings.warn with 3 arguments: string '`%s.%s` is deprecated, use `%s` instead.',
return f ( * args , ** kwargs )	formated with 3 elements: self.class_name, self.old_method_name and self.new_method_name, self.deprecation_warning and integer 2.   call the function f with a arguments: unpacked list args and unpacked dictionary kwargs, return the result.
return wrapped	return wrapped.
class RenameMethodsBase ( type ) :	derive the class RenameMethodsBase from type base class.
renamed_methods = ( )	renamed_methods is an tuple.
def __new__ ( cls , name , bases , attrs ) :	define the method __new__ with 4 arguments: cls, name, bases and attrs.
new_class = super ( RenameMethodsBase , cls ) . __new__ ( cls , name , bases , attrs )	call the method __new__ with 4 arguments: cls, name, bases and attrs, from the base class of the class RenameMethodsBase.
for base in inspect . getmro ( new_class ) :	call the method inspect.getmro with an argument new_class, for every base in the result,
class_name = base . __name__	substitute base.__name__ for class_name.
for renamed_method in cls . renamed_methods :	for every renamed_method in cls.renamed_methods,
old_method_name = renamed_method [ 0 ]	substitute first element of renamed_method for old_method_name.
old_method = base . __dict__ . get ( old_method_name )	get the value under the old_method_name key of the base.__dict__ dictionary, substitute it for old_method.
new_method_name = renamed_method [ 1 ]	substitute second element of renamed_method for new_method_name.
new_method = base . __dict__ . get ( new_method_name )	get the value under the new_method_name key of the base.__dict__ dictionary, substitute it for new_method.
deprecation_warning = renamed_method [ 2 ]	substitute third element of renamed_method for deprecation_warning.
wrapper = warn_about_renamed_method ( class_name , * renamed_method )	call the function warn_about_renamed_method with 2 arguments: class_name and unpacked list renamed_method, substitute the result for wrapper.
if not new_method and old_method :	if new_method is false and old_method is true,
warnings . warn (  '`%s.%s` method should be renamed `%s`.' %  ( class_name , old_method_name , new_method_name ) ,  deprecation_warning , 2 )	call the function warnings.warn with 3 arguments: string '`%s.%s` method should be renamed `%s`.',
setattr ( base , new_method_name , old_method )	formated with 3 elements: class_name, old_method_name and new_method_name, deprecation_warning and integer 2.   set new_method_name attribute of the base object to old_method.
setattr ( base , old_method_name , wrapper ( old_method ) )	set old_method_name attribute of the base object to the result of the function wrapper called with an argument old_method.
if not old_method and new_method :	if old_method is false and new_method is true,
setattr ( base , old_method_name , wrapper ( new_method ) )	set old_method_name attribute of the base object to the result of the function wrapper called with an argument new_method.
return new_class	return new_class.
import warnings	import module warnings.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
warnings . warn ( 'django.utils.dictconfig will be removed in Django 1.9.' ,  RemovedInDjango19Warning , stacklevel = 2 )	call the function warnings.warn with 3 arguments: string 'django.utils.dictconfig will be removed in Django 1.9.',
import logging . handlers	RemovedInDjango19Warning and stacklevel set to integer 2.   import module logging.handlers.
import re	import module re.
import sys	import module sys.
import types	import module types.
from django . utils import six	from django.utils import six into default name space.
IDENTIFIER = re . compile ( '^[a-z_][a-z0-9_]*$' , re . I )	compile regex from string '^[a-z_][a-z0-9_]*$' in case insensitive mode, substitute it for IDENTIFIER.
def valid_ident ( s ) :	define the function valid_ident with an argument s.
m = IDENTIFIER . match ( s )	match string s with regex IDENTIFIER, substitute the result for m.
if not m :	if m is false,
raise ValueError ( 'Not a valid Python identifier: %r' % s )	raise an ValueError exception with an argument string 'Not a valid Python identifier: %r' formated with s.
return True	return boolean True.
try :	try,
from logging import _checkLevel	from logging import _checkLevel.
except ImportError :	if ImportError exception is caught,
def _checkLevel ( level ) :	define the function _checkLevel with an argument level.
if isinstance ( level , int ) :	if level is an instance of int type,
rv = level	substitute level for rv.
elif str ( level ) == level :	otherwise if level converted into a string equals level,
if level not in logging . _levelNames :	if level is not contained in logging._levelNames,
raise ValueError ( 'Unknown level: %r' % level )	raise an ValueError exception with an argument string 'Unknown level: %r' formated with level.
rv = logging . _levelNames [ level ]	substitute value under level key of logging._levelNames dictionary for rv.
else :	if not,
raise TypeError ( 'Level not an integer or a '  'valid string: %r' % level )	raise an TypeError exception with an argument string 'Level not an integer or a valid string: %r' formated with level.
return rv	return rv.
class ConvertingDict ( dict ) :	derive the class ConvertingDict from dict base class.
def __getitem__ ( self , key ) :	define the method __getitem__ with 2 arguments: self and key.
value = dict . __getitem__ ( self , key )	call the method dict.__getitem__ with 2 arguments self and key, substitute the result for value.
result = self . configurator . convert ( value )	call the method self.configurator.convert with an argument value, substitute the result for result.
if value is not result :	if value is not contained in result,
self [ key ] = result	substitute result for self dictionary under key key.
if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :	if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
result . parent = self	substitute self for result.parent.
result . key = key	substitute key for result.key.
return result	return result.
def get ( self , key , default = None ) :	define the method get with 3 arguments: self, key and default set to None.
value = dict . get ( self , key , default )	get value under key key of self dictionary, if it doesnt exists return default, substitute the result for value.
result = self . configurator . convert ( value )	call the method self.configurator.convert with an argument value, substitute the result for result.
if value is not result :	if value is not contained in result,
self [ key ] = result	substitute result for value under key key of self dictionary.
if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :	if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
result . parent = self	substitute self for result.parent.
result . key = key	substitute key for result.key.
return result	return result.
def pop ( self , key , default = None ) :	define the method pop with 3 arguments: self, key and default set to None.
value = dict . pop ( self , key , default )	remove value under key key of self dictionary, if it doesnt exists return default, substitute the result for value.
result = self . configurator . convert ( value )	call the method self.configurator.convert with an argument value.
if value is not result :	if value is not contained in result,
if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :	if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
result . parent = self	substitute self for result.parent.
result . key = key	substitute key for result.key.
return result	return result.
class ConvertingList ( list ) :	derive the class ConvertingList from list base class.
def __getitem__ ( self , key ) :	define the method __getitem__ with 2 arguments: self and key.
value = list . __getitem__ ( self , key )	call the method list.__getitem__ with 2 arguments self and key, substitute the result for value.
result = self . configurator . convert ( value )	call the method self.configurator.convert with an arugment value, substitute the result for result.
if value is not result :	if value is not contained in result,
self [ key ] = result	substitute result for value under key key of self dictionary.
if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :	if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
result . parent = self	substitute self for result.parent.
result . key = key	substitute key for result.key.
return result	return result.
def pop ( self , idx = - 1 ) :	define the method pop with 2 arguments: self and idx set to negative integer 1.
value = list . pop ( self , idx )	remove idx-th element from self list.
result = self . configurator . convert ( value )	call the method self.configurator.convert with an argument value, substitute the result for result.
if value is not result :	if value is not contained in result,
if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :	if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
result . parent = self	substitute self for result.parent.
return result	return result.
class ConvertingTuple ( tuple ) :	derive the class ConvertingTuple from tuple base class.
def __getitem__ ( self , key ) :	define the method __getitem__ with 2 arguments: self and key.
value = tuple . __getitem__ ( self , key )	call the method tuple.__getitem__ with 2 arguments: self and key, substitute the result for value.
result = self . configurator . convert ( value )	call the method self.configurator.convert with an argument value, substitute the result for result.
if value is not result :	if value is not contained in result,
if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :	if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
result . parent = self	substitute self for result.parent.
result . key = key	substitute key for result.key.
return result	return result.
class BaseConfigurator ( object ) :	derive the class BaseConfigurator from object base class.
CONVERT_PATTERN = re . compile ( r'^(?P<prefix>[a-z]+)://(?P<suffix>.*)$' )	compile a regex from raw string '^(?P<prefix>[a-z]+)://(?P<suffix>.*)$', substitute it for CONVERT_PATTERN.
\WORD_PATTERN = re . compile ( r'^\\s*(\\w+)\\s*' )\	\compile a regex from raw string '^\\s*(\\w+)\\s*', substitute it for WORD_PATTERN.\
\DOT_PATTERN = re . compile ( r'^\\.\\s*(\\w+)\\s*' )\	\compile a regex from raw string '^\\.\\s*(\\w+)\\s*', substitute it for DOT_PATTERN.\
\INDEX_PATTERN = re . compile ( r'^\\[\\s*(\\w+)\\s*\\]\\s*' )\	\compile a regex from raw string '^\\[\\s*(\\w+)\\s*\\]\\s*', substitute it for INDEX_PATTERN.\
\DIGIT_PATTERN = re . compile ( r'^\\d+$' )\	\compile a regex from raw string '^\\d+$', substitute it for DIGIT_PATTERN.\
value_converters = {  'ext' : 'ext_convert' ,  'cfg' : 'cfg_convert' ,  }	value_converters is a dictionary with 2 entries: 'ext_convert' for 'ext' and 'cfg_convert' for 'cfg'.
importer = __import__	substitute __import__ for importer.
def __init__ ( self , config ) :	define the method __init__ with 2 arguments: self and config.
self . config = ConvertingDict ( config )	self.config is an instance of ConvertingDict, called with an argument config.
self . config . configurator = self	substitute self for self.config.configurator.
def resolve ( self , s ) :	define the method resolve with 2 arguments: self and s.
name = s . split ( '.' )	split s into parts by '.', substitute the result for name.
used = name . pop ( 0 )	remove first element from name, substitute the result for used.
try :	try,
found = self . importer ( used )	call the method self.importer with an argument used, substitute the result for found.
for frag in name :	for every frag in name.
used += '.' + frag	append '.' to frag, append the result to used.
try :	try,
found = getattr ( found , frag )	get frag attribute from found object, substitute it for found.
except AttributeError :	if AttributeError exception is caught,
self . importer ( used )	call the method self.importer with an argument used.
found = getattr ( found , frag )	get frag attribute from found object, substitute it for found.
return found	return found.
except ImportError :	if ImportError exception is caught,
e , tb = sys . exc_info ( ) [ 1 : ]	call the method sys.exc_info, substitute the result without the first element for e and tb.
v = ValueError ( 'Cannot resolve %r: %s' % ( s , e ) )	raise an ValueError exception with an argument string 'Cannot resolve %r: %s', formated with s and e.
v . __cause__ , v . __traceback__ = e , tb	substitute e and tb for v.__cause__ and v.__traceback__.
raise v	raise an v exception.
def ext_convert ( self , value ) :	define the method ext_convert with 2 arguments: self and value.
return self . resolve ( value )	call the method self.resolve with an argument value, return the result.
def cfg_convert ( self , value ) :	define the method cfg_convert with 2 arguments: self and value.
rest = value	substitute value for rest.
m = self . WORD_PATTERN . match ( rest )	match rest string with self.WORD_PATTERN regex, substitute the result for m.
if m is None :	if m is None,
raise ValueError ( 'Unable to convert %r' % value )	raise an ValueError exception with an argument string 'Unable to convert %r' formated with value.
else :	if not,
rest = rest [ m . end ( ) : ]	call the method m.end, slice list rest from previous result as starting index to the end, substitute the result for rest.
d = self . config [ m . groups ( ) [ 0 ] ]	call the method m.groups, use the first element of the result as key for obtaining value from self.config dictionary,
while rest :	substitute it for d.   while rest is true,
m = self . DOT_PATTERN . match ( rest )	match rest string with self.DOT_PATTERN regex, substitute the result for m.
if m :	if m is true,
d = d [ m . groups ( ) [ 0 ] ]	call the method m.groups, use the first element of the result as key for obtaining value from d dictionary,
else :	if not,
m = self . INDEX_PATTERN . match ( rest )	match rest string with self.INDEX_PATTERN regex, substitute the result for m.
if m :	if m is true,
    idx = m . groups ( ) [ 0 ]	call the method m.groups, substitute the first element of the result for idx.
if not self . DIGIT_PATTERN . match ( idx ) :	match rest string with self.DIGIT_PATTERN regex, if it evaluates to false,
        d = d [ idx ]	substitute value under idx key of dictionary d for d.
else :	if not,
        try :	try,
            n = int ( idx )	convert idx to an integer, substitute it or n.
d = d [ n ]	substitute value under n key of dictionary d for d.
except TypeError :	if TypeError exception is caught,
            d = d [ idx ]	substitute value under idx key of dictionary d for d.
if m :	if m is true,
rest = rest [ m . end ( ) : ]	call the method m.end, slice list rest from previous result as starting index to the end, substitute the result for rest.
else :	if not,
raise ValueError ( 'Unable to convert '  '%r at %r' % ( value , rest ) )	raise an ValueError exception with an argument string 'Unable to convert %r at %r' formated with value and rest.
return d	return d.
def convert ( self , value ) :	define the method convert with 2 arguments: self and value.
if not isinstance ( value , ConvertingDict ) and isinstance ( value , dict ) :	if vale is not an instance of ConvertingDict and value is an instance of dict type,
value = ConvertingDict ( value )	value is an instance of ConvertingDict class, created with an argument value.
value . configurator = self	substitute self for value.configurator.
elif not isinstance ( value , ConvertingList ) and isinstance ( value , list ) :	otherwise if vale is not an instance of ConvertingList and value is an instance of list type,
value = ConvertingList ( value )	value is an instance of ConvertingList class, created with an argument value.
value . configurator = self	substitute self for value.configurator.
elif not isinstance ( value , ConvertingTuple ) and isinstance ( value , tuple ) :	otherwise if vale is not an instance of ConvertingTuple and value is an instance of tuple type,
value = ConvertingTuple ( value )	value is an instance of ConvertingTuple class, created with an argument value.
value . configurator = self	substitute self for value.configurator.
elif isinstance ( value , six . string_types ) :	otherwise if vale is an instance of value,
m = self . CONVERT_PATTERN . match ( value )	match value string with regex self.CONVERT_PATTERN, substitute the result for m.
if m :	if m is true,
d = m . groupdict ( )	call the method m.groupdict, substitute the result for d.
prefix = d [ 'prefix' ]	substitute value under the 'prefix' key of dictionary d, substitute it for prefix.
converter = self . value_converters . get ( prefix , None )	remove self.value_converters dictionary element under prefix key, if it exists substitute it for converter, if not, converter is None.
if converter :	if converter is true,
suffix = d [ 'suffix' ]	substitute value under the 'suffix' key of dictionary d, substitute it for suffix.
converter = getattr ( self , converter )	get converter attribute from self object, substitute it for converter.
value = converter ( suffix )	call the function converter with an argument suffix, substitute the result for value.
return value	return value.
def configure_custom ( self , config ) :	define the method configure_custom with 2 arguments: self and config.
c = config . pop ( '()' )	remove config dictionary element under '()' key, substitute it for c.
if not hasattr ( c , '__call__' ) and hasattr ( types , 'ClassType' ) and type ( c ) != types . ClassType :	if c doesnt have an attribute '__call__' and types has an 'ClassType' attribute and type of c is not equal to types.ClassType,
c = self . resolve ( c )	call the method self.resolve with an argument c, substitute the result for c.
props = config . pop ( '.' , None )	remove config dictionary element under '.' key, if it exists substitute it for props, if not, props is None.
kwargs = dict ( ( k , config [ k ] ) for k in config if valid_ident ( k ) )	kwargs is a dictionary with elements: config dictionary element under k key for k, for every k in result of function valid_ident,
result = c ( ** kwargs )	called with an argument k.   call the function c with an argument unpacked dictionary kwargs, substitute the result for result.
if props :	if props is true,
for name , value in props . items ( ) :	for every name and value in items of props dictionary,
setattr ( result , name , value )	set result attribute name to value value.
return result	return result.
def as_tuple ( self , value ) :	define the method as_tuple with 2 arguments: self and value.
if isinstance ( value , list ) :	if valu is an instance of list type,
value = tuple ( value )	convery value into a tuple, substitute it for value.
return value	return value.
class DictConfigurator ( BaseConfigurator ) :	derive the class DictConfigurator from the BaseConfigurator base class.
def configure ( self ) :	define the method configure with an argument self.
config = self . config	substitute self.config for config.
if 'version' not in config :	if string 'version' is not contained in config,
raise ValueError ( 'dictionary doesn't specify a version' )	raise an ValueError exception with an argument string 'dictionary doesn't specify a version'.
if config [ 'version' ] != 1 :	if config dictionary value under 'version' key is not equal to integer 1,
raise ValueError ( 'Unsupported version: %s' % config [ 'version' ] )	raise an ValueError exception with an argument string 'Unsupported version: %s' formated with value under 'version' key of config dictionary.
incremental = config . pop ( 'incremental' , False )	get config dictionary element under 'incremental' key, if it exists substitute it for incremental, if not,
EMPTY_DICT = { }	incremental is boolean False.   EMPTY_DICT is an empty dictionary.
logging . _acquireLock ( )	call the method logging._acquireLock.
try :	try,
if incremental :	if incremental is true,
handlers = config . get ( 'handlers' , EMPTY_DICT )	get config dictionary element under 'handlers' key, if it exists substitute it for handlers, if not, handlers is EMPTY_DICT.
if sys . version_info [ : 2 ] == ( 2 , 7 ) :	if first two elements of sys.version_info equal to integers 2 ant 7, respectively,
for name in handlers :	for every name in handlers,
    if name not in logging . _handlers :	if name is not contained in logging._handlers,
        raise ValueError ( 'No handler found with '  'name %r' % name )	raise an ValueError exception with an argument string 'No handler found with name %r' formated with name.
else :	if not,
        try :	try,
            handler = logging . _handlers [ name ]	substitute value under name key of logging._handlers dictionary for handler.
handler_config = handlers [ name ]	substitute value under name key of handlers dictionary for handler_config.
level = handler_config . get ( 'level' , None )	get handler_config dictionary element under 'level' key, if it exists substitute it for level, if not, level is None.
if level :	if level is true,
                handler . setLevel ( _checkLevel ( level ) )	call the function _checkLevel with an argument level, use the result as an argument for the call to the function handler.setLevel.
except StandardError as e :	if StandardError, renamed to e, exception is caught,
            raise ValueError ( 'Unable to configure handler '  '%r: %s' % ( name , e ) )	raise an ValueError exception with an argument string 'Unable to configure handler %r: %s' formated with name and e.
loggers = config . get ( 'loggers' , EMPTY_DICT )	get config dictionary element under 'loggers' key, if it exists substitute it for loggers, if not, loggers is EMPTY_DICT.
for name in loggers :	for every name in loggers,
try :	try,
    self . configure_logger ( name , loggers [ name ] , True )	call the method self.configure_logger with 3 arguments: name, value under name key of loggers dictionary and boolean True.
except StandardError as e :	if StandardError, renamed to e, exception is caught,
    raise ValueError ( 'Unable to configure logger '  '%r: %s' % ( name , e ) )	raise an ValueError exception with an argument string 'Unable to configure logger %r: %s' formated with name and e.
root = config . get ( 'root' , None )	get config dictionary element under 'root' key, if it exists substitute it for root, if not, root is None.
if root :	if root is true,
try :	try,
    self . configure_root ( root , True )	call the method self.configure_root with 2 arguments: root and boolean True.
except StandardError as e :	if StandardError, renamed to e, exception is caught,
    raise ValueError ( 'Unable to configure root '  'logger: %s' % e )	raise an ValueError exception with an argument string 'Unable to configure root logger: %s' formated with e.
else :	if not,
disable_existing = config . pop ( 'disable_existing_loggers' , True )	remove config dictionary element under 'disable_existing_loggers' key, if it exists substitute it for disable_existing, if not,
logging . _handlers . clear ( )	disable_existing is boolean True.   call the method logging._handler.clear.
del logging . _handlerList [ : ]	delete logging._handlerList list.
formatters = config . get ( 'formatters' , EMPTY_DICT )	get config dictionary element under 'formatters' key, if it exists substitute it for formatters, if not, formatters is EMPTY_DICT.
for name in formatters :	for every name in formatters,
try :	try,
    formatters [ name ] = self . configure_formatter (  formatters [ name ] )	call the method self.configure_filter with an argument value under name key of formatters dictionary,
except StandardError as e :	substitute the result for formatters dictionary value under name key.   if StandardError, renamed to e, exception is caught,
    raise ValueError ( 'Unable to configure '  'formatter %r: %s' % ( name , e ) )	raise an ValueError exception with an argument string 'Unable to configure formatter %r: %s' formated with name and e.
filters = config . get ( 'filters' , EMPTY_DICT )	get config dictionary element under 'filters' key, if it exists substitute it for filters, if not, filters is EMPTY_DICT.
for name in filters :	for every name in filters,
try :	try,
    filters [ name ] = self . configure_filter ( filters [ name ] )	call the method self.configure_filter with an argument value under name key of filters dictionary,
except StandardError as e :	substitute the result for filters dictionary value under name key.   if StandardError, renamed to e, exception is caught,
    raise ValueError ( 'Unable to configure '  'filter %r: %s' % ( name , e ) )	raise an ValueError exception with an argument string 'Unable to configure filter %r: %s' formated with name and e.
handlers = config . get ( 'handlers' , EMPTY_DICT )	get config dictionary element under 'handlers' key, if it exists substitute it for handlers, if not, handlers is EMPTY_DICT.
for name in sorted ( handlers ) :	sort elements of handlers, for every name in result,
try :	try,
    handler = self . configure_handler ( handlers [ name ] )	call the method self.configure_handler with an argument value under name key of handlers dictionary, substitute the result for handler.
handler . name = name	substitute name for handler.name.
handlers [ name ] = handler	substitute handler for value under name key of handlers dictionary.
except StandardError as e :	if StandardError, renamed to e, exception is caught,
    raise ValueError ( 'Unable to configure handler '  '%r: %s' % ( name , e ) )	raise an ValueError exception with an argument string 'Unable to configure handler %r: %s' formated with name and e.
root = logging . root	substitute logging.root for root.
existing = list ( root . manager . loggerDict )	convert root.manager.loggerDict into a list, substitute it for existing.
existing . sort ( )	sort elements of list existing.
child_loggers = [ ]	child_loggers is an empty list.
loggers = config . get ( 'loggers' , EMPTY_DICT )	get config dictionary element under 'loggers' key, if it exists substitute it for loggers, if not, loggers is EMPTY_DICT.
for name in loggers :	for every name in loggers,
if name in existing :	if name is contained in existing,
    i = existing . index ( name )	get the index of first occurrence of name in existing, substitute it for i.
prefixed = name + '.'	append '.' to name, substitute the result for prefixed.
pflen = len ( prefixed )	substitute length of prefixed for pflen.
num_existing = len ( existing )	substitute length of existing for num_existing.
i = i + 1	increment i by integer 1, substitute the result for i.
while ( i < num_existing ) and ( existing [ i ] [ : pflen ] == prefixed ) :	while i is lesser than num_existing and first pflen elements of i-th element of existing equals prefixed,
        child_loggers . append ( existing [ i ] )	append i-th element of existing to child_loggers.
i = i + 1	increment i by integer 1, substitute the result for i.
existing . remove ( name )	remove name from existing.
try :	try,
    self . configure_logger ( name , loggers [ name ] )	call the method self.configure_logger with 2 arguments: name and value under loggers dictionary key name.
except StandardError as e :	if StandardError, renamed to e, exception is caught,
    raise ValueError ( 'Unable to configure logger '  '%r: %s' % ( name , e ) )	raise an ValueError exception with an argument string 'Unable to configure logger %r: %s' formated with name and e.
for log in existing :	for every log in existing,
logger = root . manager . loggerDict [ log ]	get the value under log key of root.manager.loggerDict dictionary, substitute it for logger.
if log in child_loggers :	if log is contained in child_loggers,
    logger . level = logging . NOTSET	substitute logging.NOTSET for logger.level.
logger . handlers = [ ]	logger.handlers is an empty list.
logger . propagate = True	logger.propagate is boolean True.
elif disable_existing :	otherwise if disable_existing is true,
    logger . disabled = True	logger.disabled is boolean True.
root = config . get ( 'root' , None )	get config dictionary element under 'root' key, if it exists substitute it for root, if not, root is None.
if root :	if root is true,
try :	try,
    self . configure_root ( root )	call the method self.configure_root with an argument root.
except StandardError as e :	if StandardError, renamed to e, exception is caught,
    raise ValueError ( 'Unable to configure root '  'logger: %s' % e )	raise an ValueError exception with an argument string ''Unable to configure root logger: %s' formated with e.
finally :	finally perform,
logging . _releaseLock ( )	call the method logging._releaseLock.
def configure_formatter ( self , config ) :	define the method configure_formatter with 2 arguments: self and config.
if '()' in config :	if string '()' is contained in config,
factory = config [ '()' ]	substitute config dictionary value under '()' key for factory.
try :	try,
result = self . configure_custom ( config )	call the method self.configure_custom with an argument config, substitute the result for result.
except TypeError as te :	if TypeError, renamed to te, exception is caught,
raise	raise an exception.
config [ 'fmt' ] = config . pop ( 'format' )	remove config dictionary entry under 'format' key, substitute it for value under 'fmt' key of config dictionary.
config [ '()' ] = factory	substitute factory for value under '()' key of config dictionary.
result = self . configure_custom ( config )	call the method self.configure_custom with an argument config, substitute the result for result.
else :	if not,
fmt = config . get ( 'format' , None )	get config dictionary element under 'format' key, if it exists substitute it for fmt, if not, fmt is None.
dfmt = config . get ( 'datefmt' , None )	get config dictionary element under 'datefmt' key, if it exists substitute it for dfmt, if not, dfmt is None.
result = logging . Formatter ( fmt , dfmt )	call the method logging.Formatter with 2 arguments: fmt and dfmt, substitute the result for result.
return result	return result.
def configure_filter ( self , config ) :	define the method configure_filter with 2 arguments: self and config.
if '()' in config :	if string '()' is contained in config,
result = self . configure_custom ( config )	call the method self.configure_custom with an argument config, substitute the result for result.
else :	if not,
name = config . get ( 'name' , '' )	remove config dictionary element under 'name' key, if it exists substitute it for name, if not, name is an empty string.
result = logging . Filter ( name )	call the method logging.Filter with an argument name, substitute the result for result.
return result	return result.
def add_filters ( self , filterer , filters ) :	define the method add_filters with 3 arguments: self, filterer and filters.
for f in filters :	for every f in filters,
try :	try,
filterer . addFilter ( self . config [ 'filters' ] [ f ] )	get the value under f key of dictionary under 'filters' key of self.config dictionary,
except StandardError as e :	use the result as an argument for the call to the method filterer.addFilter.   if StandardError, renamed to e, exception is caught,
raise ValueError ( 'Unable to add filter %r: %s' % ( f , e ) )	raise an ValueError exception with an argument string 'Unable to add filter %r: %s' formated with f and e.
def configure_handler ( self , config ) :	define the method configure_handler with 2 arguments: self and config.
formatter = config . pop ( 'formatter' , None )	remove config dictionary element under 'formatter' key, if it exists substitute it for formatter, if not, formatter is None.
if formatter :	if formatter is true,
try :	try,
formatter = self . config [ 'formatters' ] [ formatter ]	get the value under formatter key of dictionary under 'formatters' key of self.config dictionary, substitute the result for formatter.
except StandardError as e :	if StandardError, renamed to e, exception is caught,
raise ValueError ( 'Unable to set formatter '  '%r: %s' % ( formatter , e ) )	raise an ValueError exception with an argument string 'Unable to set formatter %r: %s' formated with formatter and e.
level = config . pop ( 'level' , None )	remove config dictionary element under 'level' key, if it exists substitute it for level, if not, level is None.
filters = config . pop ( 'filters' , None )	remove config dictionary element under 'filter' key, if it exists substitute it for filters, if not, filters is None.
if '()' in config :	if string '()' is contained in config,
c = config . pop ( '()' )	remove config dictionary element under '()' key, substitute it for c.
if not hasattr ( c , '__call__' ) and hasattr ( types , 'ClassType' ) and type ( c ) != types . ClassType :	if c doesnt have an attribute '__call__', and types has an attribute 'ClassType', and type of c is not equal to types.ClassType,
c = self . resolve ( c )	call the method self.resolve with an argument c, substitute the result for c.
factory = c	substitute c for factory.
else :	if not,
klass = self . resolve ( config . pop ( 'class' ) )	remove config dictionary element under 'class' key, use it as an argument for the call to the method self.resolve,
if issubclass ( klass , logging . handlers . MemoryHandler ) and 'target' in config :	substitute the result for klass.   if klass is a subclass of logging.handlers.MemoryHandler base class and string 'target' is contained in config,
try :	try,
config [ 'target' ] = self . config [ 'handlers' ] [ config [ 'target' ] ]	get value under 'target' key of config dictionary, use it as a key to get the value from the dictionary,
except StandardError as e :	under the 'handlers' key of self.config dictionary, substitute the result for value under 'target' key of config dictioanry.   if StandardError, renamed to e, exception is caught,
raise ValueError ( 'Unable to set target handler '  '%r: %s' % ( config [ 'target' ] , e ) )	raise an ValueError exception with an argument string 'Unable to set target handler %r: %s',
elif issubclass ( klass , logging . handlers . SMTPHandler ) and 'mailhost' in config :	formated with value under 'target' key of config dictionary and e.   otherwise if klass is a subclass of logging.handlers.SMTPHandler and string 'mailhost' is contained in config,
config [ 'mailhost' ] = self . as_tuple ( config [ 'mailhost' ] )	call the method self.as_tuple with an argument value under 'mailhost' key of config dictionary,
elif issubclass ( klass , logging . handlers . SysLogHandler ) and 'address' in config :	substitute the result for value under 'mailhost' key of config dictionary.   otherwise if klass is subclass of logging.handlers.SysLogHandler class, and string 'address' is contained in config,
config [ 'address' ] = self . as_tuple ( config [ 'address' ] )	call the method self.as_tuple with an argument value under 'address' key of config dictionary,
factory = klass	substitute the result for value under 'address' key of config dictionary.   substitute klass for factory.
kwargs = dict ( ( k , config [ k ] ) for k in config if valid_ident ( k ) )	kwargs is a dictionary created with tuples with 2 elements: k and value under k key of config dictionary,
try :	for every k in config, only if result of the function valid_ident called with an argument k evaluates to true.   try,
result = factory ( ** kwargs )	call the function factory with an argument unpacked dictionary kwargs, substitute the result for result.
except TypeError as te :	if TypeError, renamed to te, exception is caught,
raise	raise an exception.
kwargs [ 'strm' ] = kwargs . pop ( 'stream' )	remove element under 'stream' key of kwargs dictionary, substitute the result for value under 'strm' key of kwargs dictionary.
result = factory ( ** kwargs )	call the function factory with an argument unpacked dictionary kwargs, substitute the result for result.
if formatter :	if formatter is true,
result . setFormatter ( formatter )	call the method result.setFormatter with an argument formatter.
if level is not None :	if level is not None,
result . setLevel ( _checkLevel ( level ) )	call function _checkLevel with an argument level, use the result as an argument for the method result.setLevel.
if filters :	if filters is true,
self . add_filters ( result , filters )	call the method self.add_filters with 2 arguments: result and filters.
return result	return result.
def add_handlers ( self , logger , handlers ) :	define the method add_handlers with 3 arguments: self, logger and handlers.
for h in handlers :	for every h in handlers,
try :	try,
logger . addHandler ( self . config [ 'handlers' ] [ h ] )	call the method logger.addHandler with an argument: h-th element of value under 'handlers' key of self.config dictionary.
except StandardError as e :	if StandardError, renamed to e, exception is caught,
raise ValueError ( 'Unable to add handler %r: %s' % ( h , e ) )	raise an ValueError exception with an argument string 'Unable to add handler %r: %s' formated with h and e.
def common_logger_config ( self , logger , config , incremental = False ) :	define the method common_logger_config with 4 arguments: self, logger, config and incremental set to boolean False.
level = config . get ( 'level' , None )	get value under the 'level' key of the config dictioanry, if it exists substitute it for level, if not level is None.
if level is not None :	if level is not None,
logger . setLevel ( _checkLevel ( level ) )	call the function _checkLevel with an argument level, use the result as an argument for the call to the method logger.setLevel.
if not incremental :	if incremental is true,
for h in logger . handlers [ : ] :	for every h in elements of logger.handlers list,
logger . removeHandler ( h )	call the method logger.removeHandler with an argument h.
handlers = config . get ( 'handlers' , None )	get value under the 'handlers' key of the config dictioanry, if it exists substitute it for handlers, if not handlers is None.
if handlers :	if handlers is true,
self . add_handlers ( logger , handlers )	call the method self.add_handlers with 2 arguments: logger and handlers.
filters = config . get ( 'filters' , None )	get value under the 'filters' key of the config dictioanry, if it exists substitute it for filters, if not filters is None.
if filters :	if filters is true,
self . add_filters ( logger , filters )	call the method self.add_filters with 2 arguments: logger and filters.
def configure_logger ( self , name , config , incremental = False ) :	define the method configure_logger with 4 arguments: self, name, config, incremental set to boolean False.
logger = logging . getLogger ( name )	call the method logging.getLogger with an argument name, substitute the result for logger.
self . common_logger_config ( logger , config , incremental )	call the method self.common_logger_config with 3 arguments: logger, config and incremental.
propagate = config . get ( 'propagate' , None )	get value under the 'propagate' key of the config dictioanry, if it exists substitute it for propagate, if not propagate is None.
if propagate is not None :	if propagate is not None,
logger . propagate = propagate	substitute propagate for logger.propagate.
def configure_root ( self , config , incremental = False ) :	define the method configure_root with 3 arguments: self, config and incremental set to boolean False.
root = logging . getLogger ( )	call the method logging.getLogger, substitute the result for root.
self . common_logger_config ( root , config , incremental )	call the method self.common_logger_config with 3 arguments: root, config and incremental.
dictConfigClass = DictConfigurator	substitute DictConfigurator for dictConfigClass.
def dictConfig ( config ) :	define the function dictConfig with an argument config.
dictConfigClass ( config ) . configure ( )	call the method dictConfigClass with an argument config, call the method configure on the result.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import codecs	import module codecs.
import datetime	import module datetime.
from decimal import Decimal	from decimal import Decimal into default name space.
import locale	import module locale.
from django . utils . functional import Promise	from django.utils.functional import Promise into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . six . moves . urllib . parse import quote	from django.utils.six.moves.urllib.parse import quote into default name space.
class DjangoUnicodeDecodeError ( UnicodeDecodeError ) :	derive the class DjangoUnicodeDecodeError from the base class UnicodeDecodeError.
def __init__ ( self , obj , * args ) :	define the private method __init__, with self instance of this class, obj and list of arbitrary length *args as arguments.
self . obj = obj	assign obj to the obj field of self instance of this class.
UnicodeDecodeError . __init__ ( self , * args )	call the initialization method UnicodeDecodeError.__init__, with self instance of this class and *args as arguments.
def __str__ ( self ) :	define the private method __str__, with self instance of this class as the only argument.
original = UnicodeDecodeError . __str__ ( self )	call the method UnicodeDecodeError.__str__, with self as the argument, substitute the result for original.
return '%s. You passed in %r (%s)' % ( original , self . obj ,  type ( self . obj ) )	in the string '%s. You passed in %r (%s)' replace every %s with original and type of the object self.obj as strings, respectively,
def python_2_unicode_compatible ( klass ) :	and replace %r with self.obj, return the result.   define function python_2_unicode_compatible, with klass as an argument.
if six . PY2 :	if field PY2 of the module six is boolean True,
if '__str__' not in klass . __dict__ :	if string '__str__' is not contained in __dict__ field of klass,
raise ValueError ( '@python_2_unicode_compatible cannot be applied '  'to %s because it doesn't define __str__().' %  klass . __name__ )	raise the exception ValueError, with string as argument, '@python_2_unicode_compatible cannot be applied',
klass . __unicode__ = klass . __str__	to %s because it doesn't define __str__()., replace %s with string value of klass.__name__.   substitute __str__ filed of klass for __unicode__ field of klass.
klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( 'utf-8' )	define lambda function with self class instance as the argument, lambda function body encapsulates the call to the method,
return klass	str.__unicode__().encode('utf-8'), call the lambda function and put the result in the __str__ filed of klass.   return klass.
def smart_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :	define the function smart_text, with s, encoding set to string 'utf-8', strings_only set to False, errors set to 'strict' as arguments.
if isinstance ( s , Promise ) :	if s is instance of a class Promise,
return s	return s.
return force_text ( s , encoding , strings_only , errors )	return the result of the call to the function force_text, with s, encoding, string_only and errors as arguments.
_PROTECTED_TYPES = six . integer_types + ( type ( None ) , float , Decimal ,  datetime . datetime , datetime . date , datetime . time )	_PROTECTED_TYPES is a tuple containing next elements, six.integer_types, type of None, type of float, Decimal, detetime.datetime,
def is_protected_type ( obj ) :	datetime.date and datetime.time.   define the function is_protected_type with obj as the only argument.
return isinstance ( obj , _PROTECTED_TYPES )	check if obj is instance of the object _PROTECTED_TYPES, return the boolean result.
def force_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :	define the function force_text, with s, encoding set to 'utf-8', strings_only set to False, errors set to string 'strict' as arguments.
if isinstance ( s , six . text_type ) :	if s is the instance of the object six.text_type,
return s	return s.
if strings_only and is_protected_type ( s ) :	if the boolean return vale of the call to the function is_protected_type(s) and string_onlys are boolean True,
return s	return s.
try :	try,
if not isinstance ( s , six . string_types ) :	if s is not an instance of the object six/string_types,
if six . PY3 :	if PY3 filed of six is boolean True,
if isinstance ( s , bytes ) :	if s is an instance of object bytes,
s = six . text_type ( s , encoding , errors )	call the function six.text_type with s, encoding and errors as the arguments, substitute the result for s.
else :	if not,
s = six . text_type ( s )	call the function six.text_type with s as an argument, substitute the result for s.
elif hasattr ( s , '__unicode__' ) :	otherwise, if s has an attribute '__unicode__',
s = six . text_type ( s )	call the function six.text_type with s as an argument, substitute result for s.
else :	if not,
s = six . text_type ( bytes ( s ) , encoding , errors )	call the function six.text_type with return value of the function bytes(s), encoding and errors as the arguments,
else :	substitute the result for s.   if not,
s = s . decode ( encoding , errors )	call the method s.decode with encoding and errors as the arguments, substitute the result for s.
except UnicodeDecodeError as e :	if an exception of the type UnicodeDecodeError, renamed to e, is caught,
if not isinstance ( s , Exception ) :	if s is not an instance of the object Exception,
raise DjangoUnicodeDecodeError ( s , * e . args )	raise an exception DjingoUnicodeDecodeError, with s and list of arguments *args from object e, as the arguments.
else :	if not,
s = ' ' . join ( [ force_text ( arg , encoding , strings_only ,  errors ) for arg in s ] )	for every arg in s, call the function force_text with arg, encoding, strings_only and errors as arguments,
return s	join the result in a string separated by whitespaces, substitute it for s.   return s.
def smart_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :	define function smart_bytes with s, encoding set to string 'utf-8', strings_only set to False and errors set to string 'strict', as arguments.
if isinstance ( s , Promise ) :	if s is an instance of an object Promise.
return s	return s.
return force_bytes ( s , encoding , strings_only , errors )	evaluate the function force_bytes, with the arguments s, encoding, strings_only and errors, return the result.
def force_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :	define function force_bytes with s, encoding set to 'utf-8', strings_only set to False and errors set to 'strict' as arguments.
if isinstance ( s , bytes ) :	if s is an instance of an object bytes.
if encoding == 'utf-8' :	if encoding equals to string 'utf-8'.
return s	return s.
else :	if not,
return s . decode ( 'utf-8' , errors ) . encode ( encoding , errors )	evaluate the method s.decode with string 'utf-8' and errors as the arguments,
if strings_only and is_protected_type ( s ) :	on the result call the method encode with the arguments encoding and errors, return the result.   if strings_only and boolean return value of the call to the function is_protected_type for argument s are boolean True,
return s	return s.
if isinstance ( s , six . memoryview ) :	if s is an instance of an object six.memoryview.
return bytes ( s )	evaluate the function bytes with the argument s, and return the result.
if isinstance ( s , Promise ) :	if s is an instance of an object Promise.
return six . text_type ( s ) . encode ( encoding , errors )	return six.text_type(s).encode(encoding, errors).
if not isinstance ( s , six . string_types ) :	if s is not an instance of the object six.string_types,
try :	try,
if six . PY3 :	if PY3 field of six is boolean True,
return six . text_type ( s ) . encode ( encoding )	evaluate the method six.text_type(s), on the result call the method encode with encoding as an argument, return the result.
else :	if not,
return bytes ( s )	evaluate the function bytes with the argument s, and return the result.
except UnicodeEncodeError :	if the UnicodeEncodeError exception is caught,
if isinstance ( s , Exception ) :	if s is an instance of the subclass Exception,
return b' ' . join ( [ force_bytes ( arg , encoding , strings_only ,  errors ) for arg in s ] )	for every arg in s, evaluate the function force_bytes for the arguments arg, encoding, strings_only and errors,
return six . text_type ( s ) . encode ( encoding , errors )	put the results in a list, join the list elements in a string separated by whitespace separator, return the string as the bytes string.   evaluate the method six.text_type(s), on the result call the method encode with the arguments encoding and errors, return the result.
else :	if not,
return s . encode ( encoding , errors )	evaluate the member method of s, encode with the encoding and errors as the arguments, return the result.
if six . PY3 :	if PY3 field of module six is boolean True,
smart_str = smart_text	substitute smart_text for smart_str.
force_str = force_text	substitute force_text for force_str.
else :	if not,
smart_str = smart_bytes	substitute smart_bytes for smart_str.
force_str = force_bytes	substitute force_bytes for force_str.
smart_unicode = smart_text	substitute smart_text for smart_unicode.
force_unicode = force_text	substitute force_text for force_unicode.
def iri_to_uri ( iri ) :	define the function iri_to_uri with iri as an argument.
if iri is None :	if iri is not initialized,
return iri	return iri.
return quote ( force_bytes ( iri ) , safe = b'/#%[]=:;$&()+,!?*@'~' )	call the function quote with return value of the evaluated function force_bytes(iri),
def filepath_to_uri ( path ) :	and with safe set to bytes string '/#%[]=:;$&()+,!?*@'~', return the result.   define function filepath_to_uri with path as the argument.
if path is None :	if path is not initialized,
return path	return path.
try :	try,
encoding = locale . getdefaultlocale ( ) [ 1 ] or 'ascii'	evaluate the function getdefaultlocale from the module locale, if second element of return value exists assign it to encoding,
codecs . lookup ( encoding )	otherwise assign string 'ascii' to encoding.   call the method lookup with the encoding as the argument.
except Exception :	if the Exception exception is caught,
encoding = 'ascii'	substitute string 'ascii' for encoding.
return encoding	return encoding.
DEFAULT_LOCALE_ENCODING = get_system_encoding ( )	evaluate the function get_system_encoding(), substitute the return vale for DEFAULT_LOCALE_ENCODING.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import datetime	import module datetime.
from django . utils . xmlutils import SimplerXMLGenerator	from django.utils.xmlutils import SimplerXMLGenerator into default name space.
from django . utils . encoding import force_text , iri_to_uri	from django.utils.encoding import force_text and iri_to_uri into default name space.
from django . utils import datetime_safe	from django.utils import datetime_safe into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . six import StringIO	from django.utils.six import StringIO into default name space.
from django . utils . six . moves . urllib . parse import urlparse	from django.utils.six.moves.urllib.parse import urlparse into default name space.
from django . utils . timezone import is_aware	from django.utils.timezone import is_aware into default name space.
def rfc2822_date ( date ) :	define the function rfc2822_date with an argument date.
months = ( 'Jan' , 'Feb' , 'Mar' , 'Apr' , 'May' , 'Jun' , 'Jul' , 'Aug' , 'Sep' , 'Oct' , 'Nov' , 'Dec' , )	months is a tuple with 12 elements: strings 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov' and 'Dec'.
days = ( 'Mon' , 'Tue' , 'Wed' , 'Thu' , 'Fri' , 'Sat' , 'Sun' )	days is a tuple with 7 elements: strings 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' and 'Sun'.
date = datetime_safe . new_datetime ( date )	call the method datetime_safe.new_datetime with an argument date, substitute the result for date.
dow = days [ date . weekday ( ) ]	call the method date.weekday, use the result as an key to obtain the value from the days dictionary, substitute it for dow.
month = months [ date . month - 1 ]	decrement date.month by integer 1, use the result as an key to obtain the value from the months dictionary, substitute it for month.
time_str = date . strftime ( '%s, %%d %s %%Y %%H:%%M:%%S ' % ( dow , month ) )	call the function date.strftime with an argument string '%s, %%d %s %%Y %%H:%%M:%%S ' formated with dow and month,
if six . PY2 :	substitute the result for time_str.   if six.PY2 is true,
time_str = time_str . decode ( 'utf-8' )	call the method time_str.decode with an argument string 'utf-8', substitute the result for time_str.
if is_aware ( date ) :	call the function is_aware with an argument date, if it evaluates to true,
offset = date . tzinfo . utcoffset ( date )	call the method date.tzinfo.utcoffset with an argument date, substitute the result for offset.
timezone = ( offset . days * 24 * 60 ) + ( offset . seconds // 60 )	multiply offset.days, integer 24 and integer 60, sum the result with floored result of dividing offset.seconds by integer 60,
hour , minute = divmod ( timezone , 60 )	substitute the result for timezone.   divide timezone by integer 60, substitute the quotient of the division for hour and reminder for minute.
return time_str + '%+03d%02d' % ( hour , minute )	format string '%+03d%02d' with hour and minute, append it to time_str, return the result.
else :	if not,
return time_str + '-0000'	append string '-0000' to time_str, return the result.
def rfc3339_date ( date ) :	define the function rfc3339_date with an argument date.
date = datetime_safe . new_datetime ( date )	call the function datetime_safe.new_datetime with an argument date, substitute the result for date.
time_str = date . strftime ( '%Y-%m-%dT%H:%M:%S' )	call the function date.strftime with an argument string '%Y-%m-%dT%H:%M:%S', substitute the result for time_str.
if six . PY2 :	if six.PY2,
time_str = time_str . decode ( 'utf-8' )	call the method time_str.decode with an argument string 'utf-8', substitute the result for time_str.
if is_aware ( date ) :	call the function is_aware with an argument date, if it evaluates to true,
offset = date . tzinfo . utcoffset ( date )	call the method date.tzinfo.utcoffset with an argument date, substitute the result for offset.
timezone = ( offset . days * 24 * 60 ) + ( offset . seconds // 60 )	multiply offset.days, integer 24 and integer 60, sum the result with floored result of division of offset.seconds,
hour , minute = divmod ( timezone , 60 )	and integer 60, substitute the result for timezone.   divide timezone by integer 60, substitute the quotient of the division for hour and reminder for minute.
return time_str + '%+03d:%02d' % ( hour , minute )	format string '%+03d:%02d' with hour and minute, append it to time_str, return the result.
else :	if not,
return time_str + 'Z'	append 'Z' to time_str, return the result.
def get_tag_uri ( url , date ) :	define the function get_tag_uri with 2 arguments: url and date.
bits = urlparse ( url )	call the method urlparse with an argument url, substitute the result for bits.
d = ''	d is an empty string.
if date is not None :	if date is not None,
d = ',%s' % datetime_safe . new_datetime ( date ) . strftime ( '%Y-%m-%d' )	call the function datetime_safe.new_datetime with an argument date, on the result call the method strftime with an argument,
return 'tag:%s%s:%s/%s' % ( bits . hostname , d , bits . path , bits . fragment )	string '%Y-%m-%d', convert the result into a string and append it to ',', substitute the result for d.   format string 'tag:%s%s:%s/%s' with bits.hostname, d, bits.path and bits.fragment, return it.
class SyndicationFeed ( object ) :	derive the class SyndicationFeed from the object base class.
def __init__ ( self , title , link , description , language = None , author_email = None ,  author_name = None , author_link = None , subtitle = None , categories = None ,  feed_url = None , feed_copyright = None , feed_guid = None , ttl = None , ** kwargs ) :	define the method __init__ with 15 elements: self, title, link, description, language set to None, author_email set to None,
to_unicode = lambda s : force_text ( s , strings_only = True )	author_name set to None, author_link set to None, subtitle set to None, categories set to None, feed_url set to None,   feed_copyright set to None, feed_guid set to None, ttl set to None and unpacked dictionary kwargs.   to_unicode is an lambda function with an argument s, result is the result of the function force_text,
if categories :	called with 2 arguments: s and string_only as boolean True.   if categories is true,
categories = [ force_text ( c ) for c in categories ]	categories is a list containing the results of the function force_text, called with an argument c, for every c in categories.
if ttl is not None :	if ttl is not None,
ttl = force_text ( ttl )	call the function force_text with an argument ttl, substitute the result for ttl.
self . feed = {  'title' : to_unicode ( title ) ,  'link' : iri_to_uri ( link ) ,  'description' : to_unicode ( description ) ,  'language' : to_unicode ( language ) ,  'author_email' : to_unicode ( author_email ) ,  'author_name' : to_unicode ( author_name ) ,  'author_link' : iri_to_uri ( author_link ) ,  'subtitle' : to_unicode ( subtitle ) ,  'categories' : categories or ( ) ,  'feed_url' : iri_to_uri ( feed_url ) ,  'feed_copyright' : to_unicode ( feed_copyright ) ,  'id' : feed_guid or link ,  'ttl' : ttl ,  }	self.feed is an dictionary with 13 initial entries, result of the function to_unicode called with an argument title for 'title',
self . feed . update ( kwargs )	result of the function iri_to_uri called with an argument link for 'link',   result of the function to_unicode called with an argument description for 'description',   result of the function to_unicode called with an argument language for 'language',   result of the function to_unicode called with an author_email description for 'author_email',   result of the function to_unicode called with an argument author_name for 'author_name',   result of the function iri_to_uri called with an argument author_link for 'author_link',   result of the function to_unicode called with an argument subtitle for 'subtitle',   if true, categories is value for 'categories' key, if not, empty tuple is value for 'categories' key,   result of the function iri_to_uri called with an argument feed_url for 'feed_url',   result of the function to_unicode called with an argument feed_copyright for 'feed_copyright',   if true, feed_guid is value for 'id' key, if not, lik is value for 'id' key and ttl for 'ttl'.   update self.feed dictionary with kwargs.
self . items = [ ]	self.items is an empty list.
def add_item ( self , title , link , description , author_email = None ,  author_name = None , author_link = None , pubdate = None , comments = None ,  unique_id = None , unique_id_is_permalink = None , enclosure = None ,  categories = ( ) , item_copyright = None , ttl = None , updateddate = None , ** kwargs ) :	define the method add_item with 17 arguments: self, title, link, description, author_email set to None, author_name set to None,
to_unicode = lambda s : force_text ( s , strings_only = True )	to_unicode is an lambda function with an argument s, result is the result of the function force_text,
if categories :	called with 2 arguments: s and string_only as boolean True.   if categories is true,
categories = [ ( c ) for c in categories ]	categories is a list containing the results of the function to_unicode, called with an argument c, for every c in categories.
if ttl is not None :	if ttl is not None,
ttl = force_text ( ttl )	call the function force_text with an argument ttl, substitute the result for ttl.
item = {  'title' : to_unicode ( title ) ,  'link' : iri_to_uri ( link ) ,  'description' : to_unicode ( description ) ,  'author_email' : to_unicode ( author_email ) ,  'author_name' : to_unicode ( author_name ) ,  'author_link' : iri_to_uri ( author_link ) ,  'pubdate' : pubdate ,  'updateddate' : updateddate ,  'comments' : to_unicode ( comments ) ,  'unique_id' : to_unicode ( unique_id ) ,  'unique_id_is_permalink' : unique_id_is_permalink ,  'enclosure' : enclosure ,  'categories' : categories or ( ) ,  'item_copyright' : to_unicode ( item_copyright ) ,  'ttl' : ttl ,  }	item is a dictionary with 15 initial entries: result of the function to_unicode called with an argument title for 'title',
item . update ( kwargs )	result of the function iri_to_uri called with an argument link for 'link',   result of the function to_unicode called with an argument description for 'description',   result of the function to_unicode called with an argument author_email for 'author_email',   result of the function to_unicode called with an argument author_name for 'author_name',   result of the function iri_to_uri called with an author_link link for 'author_link', pubdate for 'pubdate',   updateddate for 'updateddate', result of the function to_unicode called with an comments author_name for 'comments',   result of the function to_unicode called with an argument unique_id) for 'unique_id)',   unique_id_is_permalink for 'unique_id_is_permalink', enclosure for 'enclosure',    if true, categories is value for 'categories' key, if not, empty tuple is value for 'categories' key,   result of the function to_unicode called with an argument item_copyright for 'item_copyright', ttl for 'ttl'.   update dictionary item with an argument kwargs.
self . items . append ( item )	append item to self.items.
def num_items ( self ) :	define the method num_items with an argument self.
return len ( self . items )	return length of self.items.
def root_attributes ( self ) :	define the method root_attributes with an argument self.
return { }	return an empty dictionary.
def add_root_elements ( self , handler ) :	define the method add_root_elements with 2 arguments self and handler.
pass	do nothing.
def item_attributes ( self , item ) :	define the method item_attributes with 2 arguments self and item.
return { }	return an empty dictionary.
def add_item_elements ( self , handler , item ) :	define the method add_item_elements with 2 arguments, handler self and item.
pass	do nothing.
def write ( self , outfile , encoding ) :	define the method write with 3 arguments self, outfile and encoding.
raise NotImplementedError ( 'subclasses of SyndicationFeed must provide a write() method' )	raise an NotImplementedError with an argument string 'subclasses of SyndicationFeed must provide a write() method'.
def writeString ( self , encoding ) :	define the method writeString with 2 arguments self and encoding.
s = StringIO ( )	s is an instance of StringIO class.
self . write ( s , encoding )	call the method self.write with 2 arguments: s and encoding.
return s . getvalue ( )	call the method s.getvalue, return the result.
def latest_post_date ( self ) :	define the method latest_post_date with an argument self.
latest_date = None	latest_date is None.
date_keys = ( 'updateddate' , 'pubdate' )	date_keys is a tuple with 2 arguments: strings 'updateddate' and 'pubdate'.
for item in self . items :	for every item in self.items,
for date_key in date_keys :	for every date_key in date_keys,
item_date = item . get ( date_key )	get the value under the date_key key of the item dictionary, substitute it for item_date.
if item_date :	if item_date is true,
if latest_date is None or item_date > latest_date :	if latest_date is None or item_date is greater than latest_date,
    latest_date = item_date	substitute item_date for latest_date.
return latest_date or datetime . datetime . now ( )	if latest_date is true, return it, if not, call the method datetime.datetime.now and return the result.
class Enclosure ( object ) :	derive the class Enclosure from the object base class.
def __init__ ( self , url , length , mime_type ) :	define the method __init__ with 4 arguments: self, url, length and mime_type.
self . length , self . mime_type = length , mime_type	substitute length and mime_type for self.length and self.mime_type.
self . url = iri_to_uri ( url )	call the function iri_to_uri with an argument url, substitute the result for self.url.
class RssFeed ( SyndicationFeed ) :	derive the class RssFeed from the SyndicationFeed base class.
mime_type = 'application/rss+xml; charset=utf-8'	mime_type is a string 'application/rss+xml; charset=utf-8'.
def write ( self , outfile , encoding ) :	define the method write with 3 arguments: self, outfile and encoding.
handler = SimplerXMLGenerator ( outfile , encoding )	handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
handler . startDocument ( )	call the method handler.startDocument.
handler . startElement ( 'rss' , self . rss_attributes ( ) )	call the method handler.startElement with 2 arguments: string 'rss' and result of the method self.rss_attributes.
handler . startElement ( 'channel' , self . root_attributes ( ) )	call the method handler.startElement with 2 arguments: string 'channel' and result of the method self.root_attributes.
self . add_root_elements ( handler )	call the method self.add_root_elements with an argument handler.
self . write_items ( handler )	call the method self.write_items with an argument handler.
self . endChannelElement ( handler )	call the method self.endChannelElement with an argument handler.
handler . endElement ( 'rss' )	call the method handler.endElement with an argument string 'rss'.
def rss_attributes ( self ) :	define the method rss_attributes with an argument self.
return { 'version' : self . _version ,  'xmlns:atom' : 'http://www.w3.org/2005/Atom' }	return a dictionary with 2 elements: self._version for 'version' and 'http://www.w3.org/2005/Atom' for 'xmlns:atom'.
def write_items ( self , handler ) :	define the method write_items with 2 arguments: self and handler.
for item in self . items :	for every item in self.items,
handler . startElement ( 'item' , self . item_attributes ( item ) )	call the method handler.startElement with 2 arguments: string 'item' and result of the method self.item_attributes with an argument item.
self . add_item_elements ( handler , item )	call the method self.add_item_elements with 2 arguments: handler and item.
handler . endElement ( 'item' )	call the method handler.endElement with an argument string 'item'.
def add_root_elements ( self , handler ) :	define the method add_root_elements with 2 arguments: self and handler.
handler . addQuickElement ( 'title' , self . feed [ 'title' ] )	call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
handler . addQuickElement ( 'link' , self . feed [ 'link' ] )	call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the self.feed dictionary.
handler . addQuickElement ( 'description' , self . feed [ 'description' ] )	call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the self.feed dictionary.
if self . feed [ 'feed_url' ] is not None :	if value under the 'feed_url' key of the self.feed dictionary is not None,
handler . addQuickElement ( 'atom:link' , None ,  { 'rel' : 'self' , 'href' : self . feed [ 'feed_url' ] } )	call the method handler.addQuickElement with 3 arguments: string 'atom:link', None and dictionary with 2 entries: 'self' for 'rel',
if self . feed [ 'language' ] is not None :	value under the 'feed_url' key of the self.feed dictionary for 'href'.   if value under the 'language' key of the self.feed dictionary is not None,
handler . addQuickElement ( 'language' , self . feed [ 'language' ] )	call the method handler.addQuickElement with 2 arguments: string 'language' and value under the 'language' key of the self.feed dictionary.
for cat in self . feed [ 'categories' ] :	for every cat in value under the 'categories' key of the self.feed dictionary.
handler . addQuickElement ( 'category' , cat )	call the method handler.addQuickElement with 2 arguments: string 'category' and cat.
if self . feed [ 'feed_copyright' ] is not None :	if value under the 'feed_copyright' key of the self.feed dictionary is not None,
handler . addQuickElement ( 'copyright' , self . feed [ 'feed_copyright' ] )	call the method handler.addQuickElement with 2 arguments: string 'copyright' and value under the 'feed_copyright' key of the self.feed dictionary.
handler . addQuickElement ( 'lastBuildDate' , rfc2822_date ( self . latest_post_date ( ) ) )	call the method handler.addQuickElement with 2 arguments: string 'lastBuildDate' and result of the function rfc2822_date,
if self . feed [ 'ttl' ] is not None :	called with an argument result of the method self.latest_post_date.   if value under the 'ttl' key of the self.feed dictionary is not None,
handler . addQuickElement ( 'ttl' , self . feed [ 'ttl' ] )	call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the self.feed dictionary.
def endChannelElement ( self , handler ) :	define the method endChannelElement with 2 arguments: self and handler.
handler . endElement ( 'channel' )	call the method handler.endElement with an argument string 'channel'.
class RssUserland091Feed ( RssFeed ) :	derive the class RssUserland091Feed from the RssFeed base class.
_version = '0.91'	_version is a string '0.91'.
def add_item_elements ( self , handler , item ) :	define the method add_item_elements with 3 arguments: self, handler and item.
handler . addQuickElement ( 'title' , item [ 'title' ] )	call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
handler . addQuickElement ( 'link' , item [ 'link' ] )	call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
if item [ 'description' ] is not None :	if value under the 'description' key of the item dictionary is not None,
handler . addQuickElement ( 'description' , item [ 'description' ] )	call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of item dictionary.
class Rss201rev2Feed ( RssFeed ) :	derive the class Rss201rev2Feed from the RssFeed base class.
_version = '2.0'	_version is a string '2.0'.
def add_item_elements ( self , handler , item ) :	define the method add_item_elements with 3 arguments: self, handler and item.
handler . addQuickElement ( 'title' , item [ 'title' ] )	call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
handler . addQuickElement ( 'link' , item [ 'link' ] )	call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
if item [ 'description' ] is not None :	if value under the 'description' key of the item dictionary is not None,
handler . addQuickElement ( 'description' , item [ 'description' ] )	call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the item dictionary.
if item [ 'author_name' ] and item [ 'author_email' ] :	if values under 'author_name' and 'author_email' keys of the item dictionary are both true,
handler . addQuickElement ( 'author' , '%s (%s)' %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )	call the method handler.addQuickElement with an argument string 'author', '%s (%s)',
elif item [ 'author_email' ] :	formated with values under the 'author_email' and 'author_name' keys of item dictionary.   otherwise if value under the 'author_email' key of the item dictionary is true,
handler . addQuickElement ( 'author' , item [ 'author_email' ] )	call the method handler.addQuickElement with 2 arguments: string 'author' and value under the 'author_email' key of the item dictionary.
elif item [ 'author_name' ] :	otherwise if value under the 'author_name' key of the item dictionary is true,
handler . addQuickElement ( 'dc:creator' , item [ 'author_name' ] , { 'xmlns:dc' : 'http://purl.org/dc/elements/1.1/' } )	call the method handler.addQuickElement with 3 arguments: string 'dc:creator',
if item [ 'pubdate' ] is not None :	value under the 'author_name' key of the item dictionary and dictionary with an entry: 'http://purl.org/dc/elements/1.1/' for 'xmlns:dc'.   if value under the 'pubdate' key of the item dictionary is not None,
handler . addQuickElement ( 'pubDate' , rfc2822_date ( item [ 'pubdate' ] ) )	call the method handler.addQuickElement with 2 arguments: string 'pubDate' and result of the function rfc2822_date,
if item [ 'comments' ] is not None :	called with value under the 'pubdate' key of the item dictionary.   if value under the 'comments' key of the item dictionary is not None,
handler . addQuickElement ( 'comments' , item [ 'comments' ] )	call the method handler.addQuickElement with 2 arguments: string 'comments' and value under the 'comments' key of the item dictionary.
if item [ 'unique_id' ] is not None :	if value under the 'unique_id' key of the item dictionary is not None,
guid_attrs = { }	guid_attrs is an empty dictionary.
if isinstance ( item . get ( 'unique_id_is_permalink' ) , bool ) :	if value object the 'unique_id_is_permalink' key of the item dictionary is an instance of bool type,
guid_attrs [ 'isPermaLink' ] = str (  item [ 'unique_id_is_permalink' ] ) . lower ( )	covert to string value under the 'unique_id_is_permalink' key of the item dictionary, convert it to lowercase,
handler . addQuickElement ( 'guid' , item [ 'unique_id' ] , guid_attrs )	substitute the result for value under the 'isPermaLink' key of the guid_attrs dictionary.   call the method handler.addQuickElement with 3 arguments: string 'guid', value under the 'unique_id' key of the item dictionary,
if item [ 'ttl' ] is not None :	and guid_attrs.   if value under the 'ttl' key of the item dictionary is not None,
handler . addQuickElement ( 'ttl' , item [ 'ttl' ] )	call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the item dictionary.
if item [ 'enclosure' ] is not None :	if value under the 'enclosure' key of the item dictionary is not None,
handler . addQuickElement ( 'enclosure' , '' ,  { 'url' : item [ 'enclosure' ] . url , 'length' : item [ 'enclosure' ] . length ,  'type' : item [ 'enclosure' ] . mime_type } )	call the method handler.addQuickElement with 3 arguments: string 'title', an empty string and a dictionary with 3 entries:
for cat in item [ 'categories' ] :	field url of the value under the 'enclosure' key of the item dictionary for 'url',   field length of the value under the 'enclosure' key of the item dictionary for 'length',   and field mime_type of the value under the 'enclosure' key of the item dictionary for 'type'.   for every cat in value under the 'categories' key of the item dictionary,
handler . addQuickElement ( 'category' , cat )	call the method handler.addQuickElement with 2 arguments: string 'category' and cat.
class Atom1Feed ( SyndicationFeed ) :	derive the class Atom1Feed from the SyndicationFeed base class.
mime_type = 'application/atom+xml; charset=utf-8'	mime_type is a string 'application/atom+xml; charset=utf-8'.
ns = 'http://www.w3.org/2005/Atom'	ns is a string 'http://www.w3.org/2005/Atom'.
def write ( self , outfile , encoding ) :	define the method write with 3 arguments: self, outfile and encoding.
handler = SimplerXMLGenerator ( outfile , encoding )	handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
handler . startDocument ( )	call the method handler.startDocument.
handler . startElement ( 'feed' , self . root_attributes ( ) )	call the method handler.startElement with 2 arguments: string 'feed' and result of the method self.root_attributes.
self . add_root_elements ( handler )	call the method self.add_root_elements with an argument handler.
self . write_items ( handler )	call the method self.write_items with an argument handler.
handler . endElement ( 'feed' )	call the method handler.endElement with an argument string 'feed'.
def root_attributes ( self ) :	define the method root_attributes with an argument self.
if self . feed [ 'language' ] is not None :	if value under the 'language' key of the self.feed dictionary is not None,
return { 'xmlns' : self . ns , 'xml:lang' : self . feed [ 'language' ] }	return a dictionary with 2 entries: value under the 'language' key of the self.feed dictionary for 'xml:lang',
else :	and self.ns for 'xmlns'.   if not,
return { 'xmlns' : self . ns }	return a dictionary with an entry: self.ns for 'xmlns'.
def add_root_elements ( self , handler ) :	define the method add_root_elements with 2 arguments: self and handler.
handler . addQuickElement ( 'title' , self . feed [ 'title' ] )	call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
handler . addQuickElement ( 'link' , '' , { 'rel' : 'alternate' , 'href' : self . feed [ 'link' ] } )	call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
if self . feed [ 'feed_url' ] is not None :	'alternate' for 'rel' and value under the 'link' key of self.feed dictionary for 'href'.   if value under the 'feed_url' key of the self.feed dictionary is not None,
handler . addQuickElement ( 'link' , '' , { 'rel' : 'self' , 'href' : self . feed [ 'feed_url' ] } )	call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
handler . addQuickElement ( 'id' , self . feed [ 'id' ] )	'self' for 'rel' and value under the 'feed_url' key of self.feed dictionary for 'href'.   call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
handler . addQuickElement ( 'updated' , rfc3339_date ( self . latest_post_date ( ) ) )	call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
if self . feed [ 'author_name' ] is not None :	called with an argument result of the method self.latest_post_date.   if value under the 'author_name' key of the self.feed dictionary is not None,
handler . startElement ( 'author' , { } )	call the method handler.startElement with 2 arguments: string 'author' and an empty dictionary.
handler . addQuickElement ( 'name' , self . feed [ 'author_name' ] )	call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the self.feed dictionary.
if self . feed [ 'author_email' ] is not None :	if value under the 'author_email' key of the self.feed dictionary is not None,
handler . addQuickElement ( 'email' , self . feed [ 'author_email' ] )	call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the self.feed dictionary.
if self . feed [ 'author_link' ] is not None :	if value under the 'author_link' key of the self.feed dictionary is not None,
handler . addQuickElement ( 'uri' , self . feed [ 'author_link' ] )	call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the self.feed dictionary.
handler . endElement ( 'author' )	call the method handler.endElement with an argument string 'author'.
if self . feed [ 'subtitle' ] is not None :	if value under the 'subtitle' key of the self.feed dictionary is not None,
handler . addQuickElement ( 'subtitle' , self . feed [ 'subtitle' ] )	call the method handler.addQuickElement with 2 arguments: string 'subtitle' and value under the 'subtitle' key of the self.feed dictionary.
for cat in self . feed [ 'categories' ] :	for every cat in value under the 'categories' key of the self.feed dictionary.
handler . addQuickElement ( 'category' , '' , { 'term' : cat } )	call the method handler.addQuickElement with 3 arguments: string 'category', an empty string and a dictionary with an entry:
if self . feed [ 'feed_copyright' ] is not None :	cat for 'term'.   if value under the 'feed_copyright' key of the self.feed dictionary is not None,
handler . addQuickElement ( 'rights' , self . feed [ 'feed_copyright' ] )	call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'feed_copyright' key of the self.feed dictionary.
def write_items ( self , handler ) :	define the method write_items with 2 arguments: self and handler.
for item in self . items :	for every item in self.items,
handler . startElement ( 'entry' , self . item_attributes ( item ) )	call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
self . add_item_elements ( handler , item )	called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
handler . endElement ( 'entry' )	call the method handler.endElement with an argument string 'entry'.
def add_item_elements ( self , handler , item ) :	define the method add_item_elements with 3 arguments: self, handler and item.
handler . addQuickElement ( 'title' , item [ 'title' ] )	call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
handler . addQuickElement ( 'link' , '' , { 'href' : item [ 'link' ] , 'rel' : 'alternate' } )	call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
if item [ 'pubdate' ] is not None :	value under the 'link' key of item dictionary for 'href' and 'alternate' for 'rel'.   if value under the 'pubdate' key of the item dictionary is not None,
handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )	call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
if item [ 'updateddate' ] is not None :	called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )	call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
if item [ 'author_name' ] is not None :	called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
handler . startElement ( 'author' , { } )	call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
handler . addQuickElement ( 'name' , item [ 'author_name' ] )	call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
if item [ 'author_email' ] is not None :	if value under the 'author_email' key of the item dictionary is not None,
handler . addQuickElement ( 'email' , item [ 'author_email' ] )	call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
if item [ 'author_link' ] is not None :	if value under the 'author_link' key of the item dictionary is not None,
handler . addQuickElement ( 'uri' , item [ 'author_link' ] )	call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
handler . endElement ( 'author' )	call the method handler.endElement with an argument string 'author'.
if item [ 'unique_id' ] is not None :	if value under the 'unique_id' key of the item dictionary is not None,
unique_id = item [ 'unique_id' ]	substitute value under 'unique_id' key of item dictionary for unique_id.
else :	if not,
unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )	call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
handler . addQuickElement ( 'id' , unique_id )	call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
if item [ 'description' ] is not None :	if value under the 'description' key of the item dictionary is not None,
handler . addQuickElement ( 'summary' , item [ 'description' ] , { 'type' : 'html' } )	call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
if item [ 'enclosure' ] is not None :	and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
handler . addQuickElement ( 'link' , '' ,  { 'rel' : 'enclosure' ,  'href' : item [ 'enclosure' ] . url ,  'length' : item [ 'enclosure' ] . length ,  'type' : item [ 'enclosure' ] . mime_type } )	call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
for cat in item [ 'categories' ] :	enclosure for 'rel', field url of value under the 'enclosure' key of item dictionary for 'href',   field length of value under the 'enclosure' key of item dictionary for 'length',   and field mime_type of value under the 'enclosure' key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
handler . addQuickElement ( 'category' , '' , { 'term' : cat } )	call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
if item [ 'item_copyright' ] is not None :	cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
handler . addQuickElement ( 'rights' , item [ 'item_copyright' ] )	call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
DefaultFeed = Rss201rev2Feed	substitute Rss201rev2Feed for DefaultFeed.
from __future__ import absolute_import	from __future__ import absolute_ into default name space.
import decimal	import module decimal.
import datetime	import module datetime.
from importlib import import_module	from importlib import import_module into default name space.
import unicodedata	import module unicodedata.
from django . conf import settings	from django.conf import settings into default name space.
from django . utils import dateformat , numberformat , datetime_safe	from django.utils import dateformat, numberformat and datetime_safe into default name space.
from django . utils . encoding import force_str	from django.utils.encoding import force_str into default name space.
from django . utils . functional import lazy	from django.utils.functional import lazy into default name space.
from django . utils . safestring import mark_safe	from django.utils.safestring import mark_safe into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . translation import get_language , to_locale , check_for_language	from django.utils.translation import get_language, to_locale and check_for_language into default name space.
_format_cache = { }	_format_cache is an empty dictionary.
_format_modules_cache = { }	_format_modules_cache is an empty dictionary.
ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }	ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
def reset_format_cache ( ) :	tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
global _format_cache , _format_modules_cache	use global variables _format_cache and _format_modules_cache.
_format_cache = { }	_format_cache is an empty dictionary.
_format_modules_cache = { }	_format_modules_cache is an empty dictionary.
def iter_format_modules ( lang , format_module_path = None ) :	define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
if not check_for_language ( lang ) :	call the function check_for_language with an argument lang, if it evaluates to false,
return	return nothing.
if format_module_path is None :	if format_module_path is None.
format_module_path = settings . FORMAT_MODULE_PATH	substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
format_locations = [ ]	format_locations is an empty list.
if format_module_path :	if format_module_path is true,
if isinstance ( format_module_path , six . string_types ) :	if format_module_path is an instance of six.string_types,
format_module_path = [ format_module_path ]	format_module_path is a list containing an element format_module_path.
for path in format_module_path :	for every path in format_module_path,
format_locations . append ( path + '.%s' )	concatenate path and string '.%s', append the result to format_module_path.
format_locations . append ( 'django.conf.locale.%s' )	append string 'django.conf.locale.%s' to format_locations.
locale = to_locale ( lang )	call the function to_locale with an argument lang, substitute the result for locale.
locales = [ locale ]	locales is a list with an element locale.
if '_' in locale :	if '_' is contained in locale,
locales . append ( locale . split ( '_' ) [ 0 ] )	split locale by '_', append the first element of the result to locales.
for location in format_locations :	for every location in format_locations,
for loc in locales :	for every loc in locales,
try :	try,
yield import_module ( '%s.formats' % ( location % loc ) )	call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
except ImportError :	yield the result.   if ImportError exception is caught,
pass	do nothing.
def get_format_modules ( lang = None , reverse = False ) :	define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
if lang is None :	if lang is None,
lang = get_language ( )	call the function get_language, substitute the result for lang.
modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )	call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
if reverse :	iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
return list ( reversed ( modules ) )	reverse the order of modules elements, put them into a list, return it.
return modules	return modules.s
def get_format ( format_type , lang = None , use_l10n = None ) :	define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
format_type = force_str ( format_type )	call the function force_str with an argument format_type, substitute the result for format_type.
if use_l10n or ( use_l10n is None and settings . USE_L10N ) :	if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
if lang is None :	if lang is None,
lang = get_language ( )	call the function get_language, substitute the result for lang.
cache_key = ( format_type , lang )	cache_key is a tuple with 2 argumetns: format_type and lang.
try :	try,
cached = _format_cache [ cache_key ]	substitute value under the cache_key key of the _format_cache dictionary for cached.
if cached is not None :	if cached is not None,
return cached	return cached.
else :	if not,
return getattr ( settings , format_type )	get format_type attribute of the settings object, return it.
except KeyError :	if KeyError exception is caught,
for module in get_format_modules ( lang ) :	call the function get_format_modules with an argument lang, for every module in the result,
try :	try,
val = getattr ( module , format_type )	get format_type attribute of module object, substitute the result for val.
for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :	get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
    if iso_input not in val :	for every iso_input in the result,   if iso_input is not contained in val,
        if isinstance ( val , tuple ) :	if val is an instance of tuple,
            val = list ( val )	convert val to an list, substitute it for val.
val . append ( iso_input )	append iso_input to val.
_format_cache [ cache_key ] = val	substitute val for the value under the cache_key key of the _format_cache dictionary.
return val	return val.
except AttributeError :	if AttributeError exception is caught,
pass	do nothing.
_format_cache [ cache_key ] = None	value under the cache_key key of the _format_cache dictionary is None.
return getattr ( settings , format_type )	get format_type attribute of the settings object, return it.
get_format_lazy = lazy ( get_format , six . text_type , list , tuple )	call the function lazy with 4 arguments: get_format, six.text_type, list and tuple, substitute the result for get_format_lazy.
def date_format ( value , format = None , use_l10n = None ) :	define the function date_format with 3 arguments: value, format set to None and use_l10n set to None.
return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )	call the function dateformat.format with 2 arguments: value and result of the function get_format called with 2 arguments:
def time_format ( value , format = None , use_l10n = None ) :	format, if its true, otherwise string 'DATE_FORMAT' and use_l10n as use_l10n, return the result.   define the function time_format with 3 arguments: value, format set to None and use_l10n set to None.
return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )	call the function dateformat.time_format with 2 arguments: value and result of the function get_format called with 2 arguments:
def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :	format, if its true, otherwise string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.   define the function number_format with 4 arguments: value, decimal_pos set to None, use_l10n set to None,
if use_l10n or ( use_l10n is None and settings . USE_L10N ) :	if use_l10n is true, or use_l10n is None and settings.USE_L10N is true,
lang = get_language ( )	call the function get_language, substitute the result for lang.
else :	if not,
lang = None	lang is None.
return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )	call the method numberformat.format with 6 arguments: value, result of the function get_format called with 3 arguments:
def localize ( value , use_l10n = None ) :	string 'DECIMAL_SEPARATOR', lang and use_l10n set to use_l10n, decimal_pos, result of the function get_format called with 3 arguments:   string 'NUMBER_GROUPING', lang and use_l10n as use_l10n, result of the function get_format called with an argument:   string 'THOUSAND_SEPARATOR', lang and use_l10n as use_l10n and force_grouping as force_grouping, return the result.   define the function localize with 2 arguments value and use_l10n set to None.
if isinstance ( value , bool ) :	if value is an instance of bool.
return mark_safe ( six . text_type ( value ) )	call the function six.text_type with an argument value, use the result as an argument for the call to the function mark_safe,
elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :	return the result.   otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
return number_format ( value , use_l10n = use_l10n )	call the function number_format with 2 arguments: value and use_l10 as use_l10n, return the result.
elif isinstance ( value , datetime . datetime ) :	otherwise if value is an instance of datetime.datetime,
return date_format ( value , 'DATETIME_FORMAT' , use_l10n = use_l10n )	call the function date_format with 2 arguments: value, string 'DATETIME_FORMAT' and use_l10n as use_l10n, return the result.
elif isinstance ( value , datetime . date ) :	otherwise if value is an instance of datetime.date,
return date_format ( value , use_l10n = use_l10n )	call the function date_format with 2 arguments: value and use_l10n as use_l10n, return the result.
elif isinstance ( value , datetime . time ) :	otherwise if value is an instance of datetime.time,
return time_format ( value , 'TIME_FORMAT' , use_l10n = use_l10n )	call the function time_format with 3 arguments: value, string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.
else :	if not,
return value	return value.
def localize_input ( value , default = None ) :	define the function localize_input with 2 arguments value and default set to None.
if isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :	otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
return number_format ( value )	call the function number_format with an argument value, return the result.
elif isinstance ( value , datetime . datetime ) :	otherwise if value is an instance of datetime.datetime,
value = datetime_safe . new_datetime ( value )	call the method datetime_safe.new_datetime with an argument value, substitute the result for value.
format = force_str ( default or get_format ( 'DATETIME_INPUT_FORMATS' ) [ 0 ] )	call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
return value . strftime ( format )	get_format called with an argument string 'DATETIME_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
elif isinstance ( value , datetime . date ) :	otherwise if value is an instance of datetime.date,
value = datetime_safe . new_date ( value )	call the method datetime_safe.new_date with an argument value, substitute the result for value.
format = force_str ( default or get_format ( 'DATE_INPUT_FORMATS' ) [ 0 ] )	call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
return value . strftime ( format )	get_format called with an argument string 'DATE_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
elif isinstance ( value , datetime . time ) :	otherwise if value is an instance of datetime.time,
format = force_str ( default or get_format ( 'TIME_INPUT_FORMATS' ) [ 0 ] )	call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
return value . strftime ( format )	get_format called with an argument string 'TIME_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
return value	return value.
def sanitize_separators ( value ) :	define the function sanitize_separators with an argument value.
if settings . USE_L10N and isinstance ( value , six . string_types ) :	if settings.USE_L10N is true and value is an instance of six.string_types,
parts = [ ]	parts is an empty list.
decimal_separator = get_format ( 'DECIMAL_SEPARATOR' )	call the function get_format with an argument string 'DECIMAL_SEPARATOR', substitute the result for decimal_separator.
if decimal_separator in value :	if decimal_separator is contained in value,
value , decimals = value . split ( decimal_separator , 1 )	split value into two parts by decimal_separator, assign the result to value and decimals.
parts . append ( decimals )	append decimals to parts.
if settings . USE_THOUSAND_SEPARATOR :	if settings.USE_THOUSAND_SEPARATOR is true,
thousand_sep = get_format ( 'THOUSAND_SEPARATOR' )	call the function get_format with an argument string 'THOUSAND_SEPARATOR', substitute the result for thousand_sep.
for replacement in set ( [  thousand_sep , unicodedata . normalize ( 'NFKD' , thousand_sep ) ] ) :	call the function unicodedata.normalize with 2 arguments: string 'NFKD' and thousand_sep, put the result and thousand_sep into a set,
value = value . replace ( replacement , '' )	for every replacement in the resulting set,   replace every occurrence of replacement in value for an empty string, substitute the result for value.
parts . append ( value )	append value to parts.
value = '.' . join ( reversed ( parts ) )	reverse order of parts, join them into a string, separated with '.', substitute the result for value.
return value	return value.
import copy	import module copy.
import operator	import module opera.
from functools import wraps	from functools import wraps into default name space.
import sys	import module sys.
import warnings	import module warnings.
from django . utils import six	from django.utils import six into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
from django . utils . six . moves import copyreg	from django.utils.six.moves import copyreg into default name space.
def curry ( _curried_func , * args , ** kwargs ) :	define the function curry with 3 arguments: _curried_func, unpacked list args and unpacked dictionary kwargs.
def _curried ( * moreargs , ** morekwargs ) :	define the function _curried with 2 arguments: unpacked list moreargs and unpacked dictionary morekwargs.
return _curried_func ( * ( args + moreargs ) , ** dict ( kwargs , ** morekwargs ) )	call the function _curried_func with 2 arguments: list moreargs appended to args and unpacked,
return _curried	unpacked dictionary created with elements of morekwargs dictionary through the kwargs mapping, return the result.   return _curried.
def memoize ( func , cache , num_args ) :	define the function memoize with 3 arguments: func, cache and num_args.
warnings . warn ( 'memoize wrapper is deprecated and will be removed in '  'Django 1.9. Use django.utils.lru_cache instead.' ,  RemovedInDjango19Warning , stacklevel = 2 )	call the function warnings.warn with 3 arguments:
@ wraps ( func )	string 'memoize wrapper is deprecated and will be removed in Django 1.9. Use django.utils.lru_cache instead.',   RemovedInDjango19Warning and stacklevel set to integer 2.   decorator function wraps with an argument func.
def wrapper ( * args ) :	define the function wrapper with an argument unpacked list args.
mem_args = args [ : num_args ]	mem_args is a list containing of first num_args elements of args list.
if mem_args in cache :	if mem_args is contained in cache,
return cache [ mem_args ]	get the value under the mem_args key of the cache dictionary, return it.
result = func ( * args )	call the function func with an argument unpacked list args, substitute the result for result.
cache [ mem_args ] = result	substitute result for value under the mem_args key of the cache dictionary.
return result	return result.
return wrapper	return wrapper.
class cached_property ( object ) :	derive the class cached_property from the object base class.
def __init__ ( self , func , name = None ) :	define the method __init__ with 3 arguments: self, func and name set to None.
self . func = func	substitute func for self.func.
self . name = name or func . __name__	if name is true, substitute it for self.name, otherwise substitute func.__name__ for self.name.
def __get__ ( self , instance , type = None ) :	define the method __get__ with 3 arguments: self, instance and name type to None.
if instance is None :	if instance is None,
return self	return self.
res = instance . __dict__ [ self . name ] = self . func ( instance )	call the function self.func with an argument instance, substitute the result for res and value under the self.name key of the instance.__dict__ dictionary.
return res	return res.
class Promise ( object ) :	derive the class Promise from the object base class.
pass	do nothing.
def lazy ( func , * resultclasses ) :	define the function lazy with 2 arguments: func and unpacked list resultclasses.
@ total_ordering	decorator total_ordering,
class __proxy__ ( Promise ) :	derive the class __proxy__ from the Promise base class.
__dispatch = None	__dispatch is None.
def __init__ ( self , args , kw ) :	define the method __init__ with 3 arguments: self, args and kw.
self . __args = args	substitute args for self.__args.
self . __kw = kw	substitute kw for self.__kw.
if self . __dispatch is None :	if self.__dispatch is None.
self . __prepare_class__ ( )	call the method self.__prepare_class__.
def __reduce__ ( self ) :	define the method __reduce__ with an argument self.
return (  _lazy_proxy_unpickle ,  ( func , self . __args , self . __kw ) + resultclasses  )	return a tuple wit 2 elements: _lazy_proxy_unpickle and tuple with 3 elements: func, self.__args, self.__kw and resultclasses.
@ classmethod	classmethod decorator,
def __prepare_class__ ( cls ) :	define the method __prepare_class__ with an argument self.
cls . __dispatch = { }	cls.__dispatch is an empty dictionary.
for resultclass in resultclasses :	for every resultclass in resultclasses,
cls . __dispatch [ resultclass ] = { }	value under the resultclass key of the cls.__dispatch dictionary is an empty dictionary.
for type_ in reversed ( resultclass . mro ( ) ) :	call the method resultclass.mro, reverse the order of elements, for every type_ in the result.
for ( k , v ) in type_ . __dict__ . items ( ) :	for every k and v in result of the call to the method type_.__dict__.items,
        meth = cls . __promise__ ( resultclass , k , v )	call the method cls.__promise__ with 3 arguments: resultclass, k and v, substitute the result for meth.
if hasattr ( cls , k ) :	if cls has an attribute k,
        continue	skip this loop iteration,
setattr ( cls , k , meth )	set k attribute of cls object to meth.
cls . _delegate_bytes = bytes in resultclasses	if bytes is contained in resultclasses, cls._delegate_bytes is boolean True, otherwise it is boolean False.
cls . _delegate_text = six . text_type in resultclasses	if six.text_type is contained in resultclasses, cls._delegate_text is boolean True, otherwise it is boolean False.
assert not ( cls . _delegate_bytes and cls . _delegate_text ) , 'Cannot call lazy() with both bytes and text return types.'	if cls._delegate_bytes and cls._delegate_text are both false, raise an error, with an argument string 'Cannot call lazy() with both bytes and text return types.'.
if cls . _delegate_text :	if cls._delegate_text is true,
if six . PY3 :	if six.PY3 is true,
cls . __str__ = cls . __text_cast	substitute cls.__text_cast for cls.__str__.
else :	if not,
cls . __unicode__ = cls . __text_cast	substitute cls.__text_cast for cls.__text_cast.
elif cls . _delegate_bytes :	otherwise if cls._delegate_bytes is true,
if six . PY3 :	if six.PY3 is true,
cls . __bytes__ = cls . __bytes_cast	substitute cls.__bytes_cast for cls.__bytes__.
else :	if not,
cls . __str__ = cls . __bytes_cast	substitute cls.__bytes_cast for cls.__str__.
@ classmethod	class method decorator,
def __promise__ ( cls , klass , funcname , method ) :	define the method __promise__ with 4 arguments: cls, klass, funcname and method.
def __wrapper__ ( self , * args , ** kw ) :	define the method __wrapper__ with 3 arguments: self, unpacked list args and unpacked dictionary kw.
res = func ( * self . __args , ** self . __kw )	call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, substitute the result for res.
for t in type ( res ) . mro ( ) :	get the type of res, call the method mro on the result, for every t in the result,
if t in self . __dispatch :	if t is contained in self.__dispatch,
    return self . __dispatch [ t ] [ funcname ] ( res , * args , ** kw )	get the value under the funcname key of the t-th elment of self.__dispatch dictionary, call the result with 3 arguments: res,
raise TypeError ( 'Lazy object returned unexpected type.' )	unpacked list args and unpacked dictionary kw, return the result.   raise an TypeError exception with an argument sting 'Lazy object returned unexpected type.'.
if klass not in cls . __dispatch :	if klass is not contained in cls.__dispatch,
cls . __dispatch [ klass ] = { }	value under the klass key of the cls.__dispatch dictionary is an empty dictionary.
cls . __dispatch [ klass ] [ funcname ] = method	substitute method for value under the funcname key of the dictionary under the klass key of the cls.__dispatch dictionary.
return __wrapper__	return __wrapper__.
def __text_cast ( self ) :	define the method __text_cast with an argument self.
return func ( * self . __args , ** self . __kw )	call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, return the result.
def __bytes_cast ( self ) :	define the method __bytes_cast with an argument self.
return bytes ( func ( * self . __args , ** self . __kw ) )	call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw,
def __cast ( self ) :	use the result as an argument for the call to the function bytes, return the result.   define the method __cast with an argument self.
if self . _delegate_bytes :	if self._delegate_bytes is true,
return self . __bytes_cast ( )	call the method self.__bytes_cast, return the result.
elif self . _delegate_text :	otherwise if self._delegate_text is true,
return self . __text_cast ( )	call the method self.__text_cast, return the result.
else :	if not,
return func ( * self . __args , ** self . __kw )	call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, return the result.
def __ne__ ( self , other ) :	define the method __ne__ with 2 arguments: self and other.
if isinstance ( other , Promise ) :	if other is an instance of Promise class,
other = other . __cast ( )	call the method other.__cast, substitute the result for other.
return self . __cast ( ) != other	call the method self.__cast, if the result doesnt equal to other, return boolean True, otherwise return boolean False.
def __eq__ ( self , other ) :	define the method __ne__ with 2 arguments: self and other.
if isinstance ( other , Promise ) :	if other is an instance of Promise class,
other = other . __cast ( )	call the method other.__cast, substitute the result for other.
return self . __cast ( ) == other	call the method self.__cast, if the result equals other, return boolean True, otherwise return boolean False.
def __lt__ ( self , other ) :	define the method __lt__ with 2 arguments: self and other.
if isinstance ( other , Promise ) :	if other is an instance of Promise,
other = other . __cast ( )	call the method other.__cast, substitute the result for other.
return self . __cast ( ) < other	call the method self.__cast, if the result is lesser than other, return boolean True, otherwise return boolean False.
def __hash__ ( self ) :	define the method __hash__ with an argument self.
return hash ( self . __cast ( ) )	call the method self.__cast, return the hash value of the result.
def __mod__ ( self , rhs ) :	define the method __mod__ with 2 arguments: self and rhs.
if self . _delegate_bytes and six . PY2 :	if self._delegate_bytes and six.PY2 are both true,
return bytes ( self ) % rhs	call the function bytes with an argument self, divide the result with rhs and return the reminder of the division.
elif self . _delegate_text :	otherwise if self._delegate_text is true,
return six . text_type ( self ) % rhs	call the function six.text_type with an argument self, divide the result with rhs and return the reminder of the division.
return self . __cast ( ) % rhs	call the function sself.__cast with an argument self, divide the result with rhs and return the reminder of the division.
def __deepcopy__ ( self , memo ) :	define the method __deepcopy__ with 2 arguments: self and memo.
memo [ id ( self ) ] = self	get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
return self	return self.
@ wraps ( func )	decorator function wraps with an argument func.
def __wrapper__ ( * args , ** kw ) :	define the function __wrapper__ with 2 arguments: unpacked list args and unpacked dictionary kw.
return __proxy__ ( args , kw )	call the function __proxy__ with 2 arguments: args and kw, return the result.
return __wrapper__	return __wrapper__.
def _lazy_proxy_unpickle ( func , args , kwargs , * resultclasses ) :	define the function _lazy_proxy_unpickle with 4 arguments: func, args, kwargs and unpacked list resultclasses.
return lazy ( func , * resultclasses ) ( * args , ** kwargs )	call the function lazy with 2 arguments: func and unpacked list resultclasses, call the result with 2 arguments: unpacked list args,
def allow_lazy ( func , * resultclasses ) :	and unpacked dictionary kwargs.   define the function allow_lazy with 2 arguments: func and unpacked list resultclasses.
@ wraps ( func )	decorator function wraps with an argument func.
def wrapper ( * args , ** kwargs ) :	define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwargs.
for arg in list ( args ) + list ( six . itervalues ( kwargs ) ) :	call the function six.itervalues with an argument kwargs, convert the result to a list and append it to a list containing args,
if isinstance ( arg , Promise ) :	for every arg in the result,   if arg is an instance of Promise class,
break	break from the loop execution,
else :	if not,
return func ( * args , ** kwargs )	call the function func with 2 arguments: unpacked list args and unpacked dictionary kwargs.
return lazy ( func , * resultclasses ) ( * args , ** kwargs )	call the function lazy with 2 arguments: func and unpacked list resultclasses, call the result with 2 arguments: unpacked list args,
return wrapper	and unpacked dictionary kwargs, return the result.   return wrapper.
empty = object ( )	empty is an instance of object class.
def new_method_proxy ( func ) :	define the function new_method_proxy with an argument func.
def inner ( self , * args ) :	define the method inner with 2 arguments: self and unpacked list args.
if self . _wrapped is empty :	if self._wrapped is contained in empty,
self . _setup ( )	call the method self._setup.
return func ( self . _wrapped , * args )	call the function func with 2 arguments: self._wrapped and unpacked list args.
return inner	self._wrapped.
class LazyObject ( object ) :	derive the class LazyObject from the object base class.
_wrapped = None	_wrapped is None.
def __init__ ( self ) :	define the method __init__ with an argument self.
self . _wrapped = empty	substitute empty for self._wrapped.
__getattr__ = new_method_proxy ( getattr )	call the function new_method_proxy with an argument getattr, substitute the result for __getattr__.
def __setattr__ ( self , name , value ) :	define the method __setattr__ with 3 arguments: self, name and value.
if name == '_wrapped' :	if name equals string '_wrapped',
self . __dict__ [ '_wrapped' ] = value	substitute value under the '_wrapped' key of the self.__dict__ dictionary.
else :	if not,
if self . _wrapped is empty :	if self._wrapped is empty,
self . _setup ( )	call the method self._setup.
setattr ( self . _wrapped , name , value )	set name attribute of self._wrapped object to value.
def __delattr__ ( self , name ) :	define the method __delattr__ with 2 arguments self and name.
if name == '_wrapped' :	if name equals string '_wrapped',
raise TypeError ( 'can't delete _wrapped.' )	raise an TypeError exception with an argument sting 'can't delete _wrapped.'.
if self . _wrapped is empty :	if self._wrapped is empty,
self . _setup ( )	call the method self._setup.
delattr ( self . _wrapped , name )	delete name attribute from self._wrapped object.
def _setup ( self ) :	define the method _setup with an argument self.
raise NotImplementedError ( 'subclasses of LazyObject must provide a _setup() method' )	raise an NotImplementedError exception with an argument sting 'subclasses of LazyObject must provide a _setup() method'.
def __getstate__ ( self ) :	define the method __getstate__ with an argument self.
if self . _wrapped is empty :	if self._wrapped is empty,
self . _setup ( )	call the method self._setup.
return self . _wrapped . __dict__	return self._wrapped.__dict__.
@ classmethod	classmethod decorator,
def __newobj__ ( cls , * args ) :	define the method __newobj__ with 2 arguments cls and unpacked list args.
return cls . __new__ ( cls , * args )	call the method cls.__new__ with 2 arguments: cls and unpacked list args.
def __reduce_ex__ ( self , proto ) :	define the method __reduce_ex__ with 2 arguments self and proto.
if proto >= 2 :	if proto is greater than or equal to integer 2,
return ( self . __newobj__ , ( self . __class__ , ) , self . __getstate__ ( ) )	return a tuple with 3 elements: self.__newobj__, tuple with an element self.__class__ and result of the method self.__getstate__.
else :	if not,
return ( copyreg . _reconstructor , ( self . __class__ , object , None ) , self . __getstate__ ( ) )	return a tuple with 3 elements: copyreg._reconstructor, tuple with 3 elements: self.__class__, object and None,
def __deepcopy__ ( self , memo ) :	and result of the method self.__getstate__.   define the method __deepcopy__ with 2 arguments self and memo.
if self . _wrapped is empty :	if self._wrapped is empty,
result = type ( self ) ( )	get type of self, call it and substitute the result for result.
memo [ id ( self ) ] = result	get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
return result	return result.
return copy . deepcopy ( self . _wrapped , memo )	call the method copy.deepcopy with 2 arguments: self._wrapped and memo, return the result.
if six . PY3 :	if six.PY3 is true,
__bytes__ = new_method_proxy ( bytes )	call the function new_method_proxy with an argument bytes, substitute the result for __bytes__.
__str__ = new_method_proxy ( str )	call the function new_method_proxy with an argument str, substitute the result for __str__.
__bool__ = new_method_proxy ( bool )	call the function new_method_proxy with an argument bool, substitute the result for __bool__.
else :	if not,
__str__ = new_method_proxy ( str )	call the function new_method_proxy with an argument str, substitute the result for __str__.
__unicode__ = new_method_proxy ( unicode )	call the function new_method_proxy with an argument unicode, substitute the result for __unicode__.
__nonzero__ = new_method_proxy ( bool )	call the function new_method_proxy with an argument bool, substitute the result for __nonzero__.
__dir__ = new_method_proxy ( dir )	call the function new_method_proxy with an argument dir, substitute the result for __dir__.
__class__ = property ( new_method_proxy ( operator . attrgetter ( '__class__' ) ) )	cal the method operator.attrgetter with an argument string '__class__', use the result as an argument for the call to the function,
__eq__ = new_method_proxy ( operator . eq )	new_method_proxy, __class__ is an property object created with previous result as an argument.   call the function new_method_proxy with an argument operator.eq, substitute the result for __eq__.
__ne__ = new_method_proxy ( operator . ne )	call the function new_method_proxy with an argument operator.ne, substitute the result for __ne__.
__hash__ = new_method_proxy ( hash )	call the function new_method_proxy with an argument hash, substitute the result for __hash__.
__getitem__ = new_method_proxy ( operator . getitem )	call the function new_method_proxy with an argument operator.getitem, substitute the result for __getitem__.
__setitem__ = new_method_proxy ( operator . setitem )	call the function new_method_proxy with an argument operator.setitem, substitute the result for __setitem__.
__delitem__ = new_method_proxy ( operator . delitem )	call the function new_method_proxy with an argument operator.delitem, substitute the result for __delitem__.
__len__ = new_method_proxy ( len )	call the function new_method_proxy with an argument len, substitute the result for __len__.
__contains__ = new_method_proxy ( operator . contains )	call the function new_method_proxy with an argument operator.contains, substitute the result for __contains__.
_super = super	substitute super for _super.
class SimpleLazyObject ( LazyObject ) :	derive the class SimpleLazyObject from the LazyObject base class.
def __init__ ( self , func ) :	define the method __init__ with 2 arguments self and func.
self . __dict__ [ '_setupfunc' ] = func	substitute func for value under the '_setupfunc' key of the self.__dict__ dictionary.
_super ( SimpleLazyObject , self ) . __init__ ( )	call the function _super with 2 arguments: class SimpleLazyObject and self, call the method __init__ on the result.
def _setup ( self ) :	define the method _setup with an argument self.
self . _wrapped = self . _setupfunc ( )	call the method self._setupfunc, substitute the result for self._wrapped.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
if self . _wrapped is empty :	if self._wrapped is empty,
repr_attr = self . _setupfunc	substitute self._setupfunc for repr_attr.
else :	if not,
repr_attr = self . _wrapped	substitute self._wrapped for repr_attr.
return '<%s: %r>' % ( type ( self ) . __name__ , repr_attr )	return a string '<%s: %r>', format it with __name__ field of the self class and repr_attr.
def __deepcopy__ ( self , memo ) :	define the method __deepcopy__ with 2 arguments self and memo.
if self . _wrapped is empty :	if self._wrapped is empty,
result = SimpleLazyObject ( self . _setupfunc )	result is an instance of SimpleLazyObject class, created with an argument self._setupfunc.
memo [ id ( self ) ] = result	get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
return result	return result.
return copy . deepcopy ( self . _wrapped , memo )	call the method copy.deepcopy with 2 arguments: self._wrapped and memo, return the result.
class lazy_property ( property ) :	derive the class lazy_property from the property base class.
def __new__ ( cls , fget = None , fset = None , fdel = None , doc = None ) :	define the method __new__ with 5 arguments: cls, fget set to None, fset set to None, fdel set to None and doc set to None.
if fget is not None :	if fget is not None,
@ wraps ( fget )	decorator function wraps with an argument fget.
def fget ( instance , instance_type = None , name = fget . __name__ ) :	define the function fget with 3 arguments: instance, instance_type set to None and name set to fget.__name__.
return getattr ( instance , name ) ( )	get name attribute from the instance object, call it and return the result.
if fset is not None :	if fset is not None,
@ wraps ( fset )	decorator function wraps with an argument fset.
def fset ( instance , value , name = fset . __name__ ) :	define the function fset with 3 arguments: instance, valse to None and name set to fset.__name__.
return getattr ( instance , name ) ( value )	get name attribute from the instance object, call it with an argument value and return the result.
if fdel is not None :	if fdel is not None,
@ wraps ( fdel )	decorator function wraps with an argument fdel.
def fdel ( instance , name = fdel . __name__ ) :	define the function fdel with 2 arguments: instance and name set to fdel.__name__.
return getattr ( instance , name ) ( )	get name attribute from the instance object, call it and return the result.
return property ( fget , fset , fdel , doc )	return an property object with getter function fget, setter function fset, destructor fdel and documentation string doc.
def partition ( predicate , values ) :	define the function partition with 2 arguments: predicate and values.
results = ( [ ] , [ ] )	results is a tuple with 2 elements, 2 empty lists.
for item in values :	for every item in values,
results [ predicate ( item ) ] . append ( item )	call the function predicate with an argument item, use it as a key to get results dictionary value, append item to it.
return results	return results.
if sys . version_info >= ( 2 , 7 , 2 ) :	if sys.version_info is greater than or equal to a tuple with 3 elements: integers 2, 7 and 2, respectively,
from functools import total_ordering	from functools import total_ordering.
else :	if not,
def total_ordering ( cls ) :	define the function total_ordering with an argument cls.
convert = {  '__lt__' : [ ( '__gt__' , lambda self , other : not ( self < other or self == other ) ) ,  ( '__le__' , lambda self , other : self < other or self == other ) ,  ( '__ge__' , lambda self , other : not self < other ) ] ,  '__le__' : [ ( '__ge__' , lambda self , other : not self <= other or self == other ) ,  ( '__lt__' , lambda self , other : self <= other and not self == other ) ,  ( '__gt__' , lambda self , other : not self <= other ) ] ,  '__gt__' : [ ( '__lt__' , lambda self , other : not ( self > other or self == other ) ) ,  ( '__ge__' , lambda self , other : self > other or self == other ) ,  ( '__le__' , lambda self , other : not self > other ) ] ,  '__ge__' : [ ( '__le__' , lambda self , other : ( not self >= other ) or self == other ) ,  ( '__gt__' , lambda self , other : self >= other and not self == other ) ,  ( '__lt__' , lambda self , other : not self >= other ) ]  }	convert is a dictionary with 4 initial entries: list with 3 tuples: tuple with 2 elements: string '__gt__',
roots = set ( dir ( cls ) ) & set ( convert )	and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than other or self is equal to other,   tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is lesser than other or self is equal to other,   tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than other, for '__lt__',   list with 3 tuples: tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than or equal to other,   or self is equal to other, tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is lesser than or equal to other,   or self is not equal to other, tuple with 2 elements: string '__gt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than or equal to other, for '__le__',   list with 3 tuples: tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than other or self is equal to other,   tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is greater than other or self is equal to other,   tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than other, for '__gt__',   and list with 3 tuples: tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is not greater than or is not equal to other,   or self is equal to other, tuple with 2 elements: string '__gt__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is greater than or not equal to other,   or self is not equal to other, tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than or equal to other, for '__ge__',   convert cls to a dictionary, convert the result into a set and convert convert into a set, roots is a set of differences of the two previous sets.
if not roots :	if roots is false,
raise ValueError ( 'must define at least one ordering operation: < > <= >=' )	raise an ValueError exception with an argument string 'must define at least one ordering operation: < > <= >='.
root = max ( roots )	get maximal element from roots and substitute it for root.
for opname , opfunc in convert [ root ] :	get the value under the root key of the convert dictionary, for every opname and opfunc in the result,
if opname not in roots :	if opname is not contained in roots,
opfunc . __name__ = opname	substitute opname for opfunc.__name__.
opfunc . __doc__ = getattr ( int , opname ) . __doc__	get opname attribute from int object, substitute its field __doc__ for opfunc.__doc__.
setattr ( cls , opname , opfunc )	set opname attribute of cls object to opfunc.
return cls	return cls.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import re	import module re.
import sys	import module sys.
from django . utils . encoding import force_text , force_str	from django.utils.encoding import force_text and force_str into default name space.
from django . utils . functional import allow_lazy	from django.utils.functional import allow_lazy into default name space.
from django . utils . safestring import SafeData , mark_safe	from django.utils.safestring import SafeData and mark_safe into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . six . moves . urllib . parse import quote , unquote , urlsplit , urlunsplit	from django.utils.six.moves.urllib.parse import quote, unquote, urlsplit and urlunsplit into default name space.
from django . utils . text import normalize_newlines	from django.utils.text import normalize_newlines into default name space.
from . html_parser import HTMLParser , HTMLParseError	from .html_parser import HTMLParser and HTMLParseError into default name space.
\unencoded_ampersands_re = re . compile ( r'&(?!(\\w+|#\\d+);)' )\	\call the function re.compile with raw string '&(?!(\\w+|#\\d+);)', substitute the result for unencoded_ampersands_re.\
\word_split_re = re . compile ( r'(\\s+)' )\	\call the function re.compile with raw string '(\\s+)', substitute the result for word_split_re.\
\simple_url_re = re . compile ( r'^https?://\\[?\\w' , re . IGNORECASE )\	\call the function re.compile with 2 arguments: raw string '^https?://\\[?\\w' and re.IGNORECASE, substitute the result for simple_url_re.\
\simple_url_2_re = re . compile ( r'^www\\.|^(?!http)\\w[^@]+\\.(com|edu|gov|int|mil|net|org)($|/.*)$' , re . IGNORECASE )\	\call the function re.compile with 2 arguments: raw string '^www\\.|^(?!http)\\w[^@]+\\.(com|edu|gov|int|mil|net|org)($|/.*)$',\
\simple_email_re = re . compile ( r'^\\S+@\\S+\\.\\S+$' )\	\and re.IGNORECASE, substitute the result for simple_url_re.   call the function re.compile with raw string '&(?!(\\w+|#\\d+);)', substitute the result for simple_email_re.\
\link_target_attribute_re = re . compile ( r'(<a [^>]*?)target=[^\\s>]+' )\	\call the function re.compile with raw string '(<a [^>]*?)target=[^\\s>]+', substitute the result for link_target_attribute_re.\
\html_gunk_re = re . compile ( r'(?:<br clear='all'>|<i><\\/i>|<b><\\/b>|<em><\\/em>|<strong><\\/strong>|<\\/?smallcaps>|<\\/?uppercase>)' , re . IGNORECASE )\	call the function re.compile with 2 arguments:
\hard_coded_bullets_re = re . compile ( r'((?:<p>(?:%s).*?[a-zA-Z].*?</p>\\s*)+)' % '|' . join ( re . escape ( x ) for x in DOTS ) , re . DOTALL )\	\raw string '(?:<br clear='all'>|<i><\\/i>|<b><\\/b>|<em><\\/em>|<strong><\\/strong>|<\\/?smallcaps>|<\\/?uppercase>)' and re.IGNORECASE,   substitute the result for html_gunk_re.   call the function re.compile with 2 arguments: raw string '((?:<p>(?:%s).*?[a-zA-Z].*?</p>\\s*)+)',\
\trailing_empty_content_re = re . compile ( r'(?:<p>(?:&nbsp;|\\s|<br \\/>)*?</p>\\s*)+\\Z' )\	\formated with string created by joining elements of result of the function re.escape with an argument x, with separator '|',   for every x in DOTS, and re.DOTALL, substitute the result for hard_coded_bullets_re.   call the function re.compile with raw string '(?:<p>(?:&nbsp;|\\s|<br \\/>)*?</p>\\s*)+\\Z', substitute the result for trailing_empty_content_re.\
def escape ( text ) :	define the function escape with an argument text.
def escapejs ( value ) :	for integer representation of z converted into a string.   define the function escapejs with an argument value.
return mark_safe ( force_text ( value ) . translate ( _js_escapes ) )	call the function force_text with an argument value, call the method translate on the result, with an argument _js_escapes,
escapejs = allow_lazy ( escapejs , six . text_type )	use the result as an argument for the call to the mark_safe function, return the result.   call the function allow_lazy with 2 arguments: escapejs, six.text_type, substitute the result for escapejs.
def conditional_escape ( text ) :	define the function conditional_escape with an argument text.
if hasattr ( text , '__html__' ) :	if text has an '__html__' attribute,
return text . __html__ ( )	call the method text.__html__, return the result.
else :	if not,
return escape ( text )	call the function escape with an argument text, return the result.
def format_html ( format_string , * args , ** kwargs ) :	define the function format_html with 3 arguments: format_string, unpacked list args and unpacked dictionary kwargs.
args_safe = map ( conditional_escape , args )	map elements from args through the function conditional_escape, substitute the result for args_safe.
kwargs_safe = dict ( ( k , conditional_escape ( v ) ) for ( k , v ) in six . iteritems ( kwargs ) )	kwargs_safe is a dictionary created for every k and v in result of the function six.iteritems called with an argument kwargs,
return mark_safe ( format_string . format ( * args_safe , ** kwargs_safe ) )	with value result of the conditional_escape function called with an argument v for key k.   call the method format_string.format with 2 arguments: unpacked list args_safe and unpacked dictionary kwargs_safe,
def format_html_join ( sep , format_string , args_generator ) :	use the result as an argument for the call to the function mark_safe, return the result.   define the function format_html_join with 3 arguments: sep, format_string and args_generator.
return mark_safe ( conditional_escape ( sep ) . join (  format_html ( format_string , * tuple ( args ) )  for args in args_generator ) )	join results of format_html called with 2 arguments: format_string and tuple with an element args, into a string,
def linebreaks ( value , autoescape = False ) :	separated with result of the function conditional_escape with an argument sep, for every args in args_generator,   use the result as an argument for the call to the function mark_safe, return the result.   define the function linebreaks with 2 arguments: value and autoescape set to boolean False.
value = normalize_newlines ( value )	call the function normalize_newlines with an argument value, substitute the result for value.
\paras = re . split ( '\\n{2,}' , value )\	\call the method re.split with 2 arguments: string '\\n{2,}' and value, substitute the result for paras.\
if autoescape :	if autoescape is true,
\paras = [ '<p>%s</p>' % escape ( p ) . replace ( '\\n' , '<br />' ) for p in paras ]\	\call the function escape with an argument p, replace every occurrence of '\\n' in the result for '<br />',\
else :	format the string  '<p>%s</p>' with the result, for every p in paras, substitute list of results for paras.   if not,
\paras = [ '<p>%s</p>' % p . replace ( '\\n' , '<br />' ) for p in paras ]\	\replace every occurrence of '\\n' in p for '<br />',\
\return '\\n\\n' . join ( paras )\	\format the string  '<p>%s</p>' with the result, for every p in paras, substitute list of results for paras.   join elements of paras into a string separated with '\\n\\n', return the result.\
linebreaks = allow_lazy ( linebreaks , six . text_type )	call the function allow_lazy with 2 arguments: linebreaks, six.text_type, substitute the result for linebreaks.
class MLStripper ( HTMLParser ) :	derive the class MLStripper from the HTMLParser base class.
def __init__ ( self ) :	define the method __init__ with an argument self.
if sys . version_info [ : 2 ] == ( 3 , 2 ) :	if fist and second element of sys.version_info equals to integer 3 and 2, respectively,
HTMLParser . __init__ ( self , strict = False )	call the method HTMLParser.__init__ with 2 arguments: self and strict set to boolean False.
else :	if not,
HTMLParser . __init__ ( self )	call the method HTMLParser.__init__ with an argument self.
self . reset ( )	call the method self.reset.
self . fed = [ ]	self.fed is an empty list.
def handle_data ( self , d ) :	define the method handle_data with 2 arguments self and d.
self . fed . append ( d )	append d to self.fed.
def handle_entityref ( self , name ) :	define the method handle_entityref with 2 arguments self and name.
self . fed . append ( '&%s;' % name )	format string '&%s;' with name, append it to self.fed.
def handle_charref ( self , name ) :	define the method handle_charref with 2 arguments self and name.
self . fed . append ( '&#%s;' % name )	format string '&#%s;' with name, append it to self.fed.
def get_data ( self ) :	define the method get_data with an argument self.
return '' . join ( self . fed )	join elements of self.fed into a string, return the result.
def _strip_once ( value ) :	define the function _strip_once with an argument value.
s = MLStripper ( )	s is an instance of MLStripper class.
try :	try,
s . feed ( value )	call the method s.feed with an argument value.
except HTMLParseError :	if HTMLParseError exception is caught,
return value	return value.
try :	try,
s . close ( )	close file descriptor s.
except ( HTMLParseError , UnboundLocalError ) :	if HTMLParseError or UnboundLocalError exceptions are caught,
return s . get_data ( ) + s . rawdata	sum the result of the method s.get_data and s.rawdata, return the result.
else :	if not,
return s . get_data ( )	call the method s.get_data, return the result.
def strip_tags ( value ) :	define the function strip_tags with an argument value.
while '<' in value and '>' in value :	while '<' is contained in value and '>' is contained in value,
new_value = _strip_once ( value )	call the function _strip_once with an argument value, substitute the result for new_value.
if new_value == value :	if new_value equals value,
break	break from the loop execution.
value = new_value	substitute new_value for value.
return value	return value.
strip_tags = allow_lazy ( strip_tags )	call the function allow_lazy with an argument strip_tags, substitute the result for strip_tags.
def remove_tags ( html , tags ) :	define the function remove_tags with 2 arguments: html and tags.
tags = [ re . escape ( tag ) for tag in tags . split ( ) ]	tags is a list containing results of the function re.escape with an argument tag, for every tag in tags split into words.
tags_re = '(%s)' % '|' . join ( tags )	join elements of tags into a string, separated with '|', format string '(%s)' with it, substitute the result for tags_re.
\starttag_re = re . compile ( r'<%s(/?>|(\\s+[^>]*>))' % tags_re , re . U )\	\call the function re.compile with 2 arguments: raw string '<%s(/?>|(\\s+[^>]*>))' formated with tags_re and re.U,\
endtag_re = re . compile ( '</%s>' % tags_re )	substitute the result for starttag_re.   call the function re.compile with an argument string '</%s>' formated with tags_re, substitute the result for endtag_re.
html = starttag_re . sub ( '' , html )	call the function starttag_re.sub with 2 arguments: an empty string and html, substitute the result for html.
html = endtag_re . sub ( '' , html )	call the function endtag_re.sub with 2 arguments: an empty string and html, substitute the result for html.
return html	return html.
remove_tags = allow_lazy ( remove_tags , six . text_type )	call the function allow_lazy with 2 arguments: remove_tags, six.text_type, substitute the result for remove_tags.
def strip_spaces_between_tags ( value ) :	define the function strip_spaces_between_tags with an argument value.
\return re . sub ( r'>\\s+<' , '><' , force_text ( value ) )\	\call the method re.sub with 3 arguments: raw string '>\\s+<', string '><' and result of the function force_text,\
strip_spaces_between_tags = allow_lazy ( strip_spaces_between_tags , six . text_type )	called with an argument value, return the result.   call the function allow_lazy with 2 arguments: strip_spaces_between_tags, six.text_type, substitute the result for strip_spaces_between_tags.
def strip_entities ( value ) :	define the function strip_entities with an argument value.
\return re . sub ( r'&(?:\\w+|#\\d+);' , '' , force_text ( value ) )\	\call the method re.sub with 3 arguments: raw string '&(?:\\w+|#\\d+);', empty string and result of the function force_text,\
strip_entities = allow_lazy ( strip_entities , six . text_type )	called with an argument value, return the result.   call the function allow_lazy with 2 arguments: strip_entities, six.text_type, substitute the result for strip_entities.
def smart_urlquote ( url ) :	define the function smart_urlquote with an argument url.
try :	try,
scheme , netloc , path , query , fragment = urlsplit ( url )	call the function urlsplit with an argument url, assign the result to scheme, netloc, path, query and fragment, respectively.
try :	try,
netloc = netloc . encode ( 'idna' ) . decode ( 'ascii' )	call the method netloc.encode with an argument string 'idna', call the method decode on the result with an argument 'ascii',
except UnicodeError :	substitute the result for netloc.   if UnicodeError exception is caught,
pass	do nothing.
else :	if not,
url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )	call the function urlunsplit with an argument tuple with 4 elements: scheme, netloc, path, query and fragment, substitute the result for url.
except ValueError :	if ValueError exception is caught,
pass	do nothing.
url = unquote ( force_str ( url ) )	call the function force_str with an argument url, use the result as an argument for the call to the function unquote, substitute the result for url.
\url = quote ( url , safe = b'!*\\'();:@&=+$,/?#[]~' )\	\call the function quote with 2 arguments: url and safe as bytes string '!*\\'();:@&=+$,/?#[]~', substitute the result for url.\
return force_text ( url )	call the function force_text with an argument url, return the result.
def urlize ( text , trim_url_limit = None , nofollow = False , autoescape = False ) :	define the function urlize with 4 arguments: text, trim_url_limit set to None, nofollow set to boolean False,
def trim_url ( x , limit = trim_url_limit ) :	define the function trim_url with 2 arguments: x and limit set to trim_url_limit.
if limit is None or len ( x ) <= limit :	if limit is None or length of x is lesser than or equal to limit,
return x	return x.
return '%s...' % x [ : max ( 0 , limit - 3 ) ]	return a string '%s...' formated with elements of x up to the index equal to the maximum value between integer 0 and 3 subtracted from limit.
safe_input = isinstance ( text , SafeData )	if text is an instance of SafeData, safe_input is boolean True, otherwise is boolean False.
words = word_split_re . split ( force_text ( text ) )	call the function force_text with an argument text, split by it word_split_re, substitute it for words.
for i , word in enumerate ( words ) :	for every i and word in enumerated iterable words,
if '.' in word or '@' in word or ':' in word :	if '.' is contained in words or '@' is contained in word or ':' is contained in word,
lead , middle , trail = '' , word , ''	substitute empty string, word an empty string for lead, middle and trail, respectively.
for punctuation in TRAILING_PUNCTUATION :	for every punctuation in TRAILING_PUNCTUATION,
if middle . endswith ( punctuation ) :	if middle ends with punctuation,
middle = middle [ : - len ( punctuation ) ]	substitute elements of middle from the beginning to the negative length of punctuation, for middle.
trail = punctuation + trail	sum punctuation and trail, substitute the result for trail.
for opening , closing in WRAPPING_PUNCTUATION :	for every opening and closing in WRAPPING_PUNCTUATION,
if middle . startswith ( opening ) :	if middle starts with opening,
middle = middle [ len ( opening ) : ]	substitute elements of middle from length of opening index to the end, for middle.
lead = lead + opening	sum lead and opening, substitute the result for lead.
if ( middle . endswith ( closing )  and middle . count ( closing ) == middle . count ( opening ) + 1 ) :	if middle ends with closing and count of occurrence of closing in middle equals count of occurrence of opening in middle incremented by one,
middle = middle [ : - len ( closing ) ]	substitute elements of middle from the beginning to the negative length of closing, for middle.
trail = closing + trail	sum trail and closing, substitute the result for lead.
url = None	url is None.
if simple_url_re . match ( middle ) :	call the method simple_url_re.match with an argument middle, if it evaluates to true,
url = smart_urlquote ( middle )	call the function smart_urlquote with an argument middle, substitute the result for url.
elif simple_url_2_re . match ( middle ) :	otherwise if call the method simple_url_2_re.match with an argument middle evaluates to true,
url = smart_urlquote ( 'http://%s' % middle )	call the function smart_urlquote with an argument string 'http://%s' formated with an argument middle, substitute the result for url.
elif ':' not in middle and simple_email_re . match ( middle ) :	otherwise if ':' is not contained in middle and result of the function simple_email_re.match called with an argument middle,
local , domain = middle . rsplit ( '@' , 1 )	evaluates to true,   split middle into two parts from the right by '@' character, assign the resulting parts to local and domain.
try :	try,
domain = domain . encode ( 'idna' ) . decode ( 'ascii' )	call the method domain.encode with an argument string 'idna', call the method decode on the result with an argument string 'ascii',
except UnicodeError :	substitute the result for domain.   if UnicodeError exception is caught,
continue	skip this loop iteration.
url = 'mailto:%s@%s' % ( local , domain )	url is a string 'mailto:%s@%s' formated with local and domain.
nofollow_attr = ''	nofollow_attr is an empty string.
if url :	if url is true,
trimmed = trim_url ( middle )	call the function trim_url with an argument middle, substitute the result for trimmed.
if autoescape and not safe_input :	if autoescape is true and safe_input is false,
lead , trail = escape ( lead ) , escape ( trail )	call the function escape with an argument lead, substitute the result for lead, call the function escape with an argument trail,
url , trimmed = escape ( url ) , escape ( trimmed )	substitute the result for trail.   call the function escape with an argument url, substitute the result for url, call the function escape with an argument trimmed,
middle = '<a href='%s'%s>%s</a>' % ( url , nofollow_attr , trimmed )	substitute the result for trimmed.   middle is a string '<a href='%s'%s>%s</a>' formated with url, nofollow_attr and trimmed.
words [ i ] = mark_safe ( '%s%s%s' % ( lead , middle , trail ) )	format string '<a href='%s'%s>%s</a>' with lead, middle and trail, use it as an argument for the call to the function mark_safe,
else :	substitute the result for i-th element of words.   if not,
if safe_input :	if safe_input is true,
words [ i ] = mark_safe ( word )	call the function mark_safe with an argument word, substitute the result for i-th element of words.
elif autoescape :	otherwise if autoescape is true,
words [ i ] = escape ( word )	call the function escape with an argument word, substitute the result for i-th element of words.
elif safe_input :	otherwise if safe_input is true,
words [ i ] = mark_safe ( word )	call the function mark_safe with an argument word, substitute the result for i-th element of words.
elif autoescape :	otherwise if autoescape is true,
words [ i ] = escape ( word )	call the function escape with an argument word, substitute the result for i-th element of words.
return '' . join ( words )	join elements of words into a string, return it.
urlize = allow_lazy ( urlize , six . text_type )	call the function allow_lazy with 2 arguments: urlize, six.text_type, substitute the result for urlize.
def avoid_wrapping ( value ) :	define the function avoid_wrapping with an argument value.
\return value . replace ( ' ' , '\\xa0' )\	\replace every occurrence of ' ' in value for '\\xa0', return the result.\
from django . utils . six . moves import html_parser as _html_parser	from django.utils.six.moves import html_parser as _html_parse into default name space.
import re	import module re.
import sys	import module sys.
current_version = sys . version_info	substitute version_info from module sys for surrent_version.
use_workaround = (  ( current_version < ( 2 , 7 , 3 ) ) or  ( current_version >= ( 3 , 0 ) and current_version < ( 3 , 2 , 3 ) )  )	set use_workaround to boolean True if current_version tuple elements are smaller than the tuple (2,7,3), respectively,
HTMLParseError = _html_parser . HTMLParseError	or if current_version is greater than (3,0), but smaller than (3,2,3), otherwise set use_workaround to boolean False.   substitute HTMLParseError from the module _html_parser for HTMLParseError.
if not use_workaround :	if use_workaround is boolean False,
if current_version >= ( 3 , 4 ) :	if tuple current_version elements are greater or equal to (3, 4), respectively,
class HTMLParser ( _html_parser . HTMLParser ) :	derive the class HTMLParser from the base class HTMLParser located in the module _html_parser.
def __init__ ( self , convert_charrefs = False , ** kwargs ) :	define the initialization method __init__, with self instance of this class, convert_charrefs set to boolean False,
_html_parser . HTMLParser . __init__ ( self , convert_charrefs = convert_charrefs , ** kwargs )	and dictionary of arbitrary length **kwargs as arguments.   call the initialization method for the base class, _html_parser.HTMLParser.__init__ with self,
else :	convert_charrefs set to convert_charrefs and dictionary **kwargs as the arguments.   if not,
HTMLParser = _html_parser . HTMLParser	substitute HTMLParser from the module _html_parser for HTMLParser.
else :	if not,
\tagfind = re . compile ( '([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\\s|/(?!>))*' )\	\compile a regular expression pattern string '([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\\s|/(?!>))*' into a regular expression object and assign it to tagfind.\
class HTMLParser ( _html_parser . HTMLParser ) :	derive the class HTMLParser from the base class HTMLParser located in the module _html_parser.
def __init__ ( self ) :	define initialization method __init__ with self instance of the class as an argument.
_html_parser . HTMLParser . __init__ ( self )	call the initialization method _html_parser.HTMLParser.__init__(self) for the base class.
self . cdata_tag = None	set field cdata_tag for this class instance to None.
def set_cdata_mode ( self , tag ) :	define method set_cdata_mode, with self class instance and tag as the arguments.
try :	try,
self . interesting = _html_parser . interesting_cdata	set field interesting for this class instance to interesting_cdata from module _html_parser.
except AttributeError :	if AttributeError exception is caught,
\self . interesting = re . compile ( r'</\\s*%s\\s*>' % tag . lower ( ) , re . I )\	\replace '%s' in the string '</\\s*%s\\s*>' with the result of the function call tag.lower(),\
self . cdata_tag = tag . lower ( )	use it and the re.I as the input arguments for function re.compile, put the result in the self.interesting.   evaluate function tag.lower, without the arguments, put the result in the self.cdata_tag.
def clear_cdata_mode ( self ) :	define method clear_cdata_mode, with self class instance as an argument.
self . interesting = _html_parser . interesting_normal	substitute _html_parser.interesting_normal for self.interesting.
self . cdata_tag = None	set self.cdata_tag to None.
def parse_starttag ( self , i ) :	define method parse_starttag with self class instance and i as the arguments.
self . __starttag_text = None	set self.__starttag_text to None.
endpos = self . check_for_whole_start_tag ( i )	call the method self.check_for_whole_start_tag with i as an argument, substitute result for the endpos.
if endpos < 0 :	if endpos is lesser than zero,
return endpos	return endpos.
rawdata = self . rawdata	substitute self.rawdata for rawdata.
self . __starttag_text = rawdata [ i : endpos ]	slice the list from the i-th to the endpos-th element, substitute it for self.__starttag_text.
attrs = [ ]	attrs is a empty list.
match = tagfind . match ( rawdata , i + 1 )	match the rawdata from the position i+1, with tagfind pattern, assign the result to the match.
assert match , 'unexpected call to parse_starttag()'	if match evaluates to False throw an exception with the string message 'unexpected call to parse_starttag()'.
k = match . end ( )	find the ending position of the regular expression match of the object match, substitute the result for k.
self . lasttag = tag = match . group ( 1 ) . lower ( )	find the first subgroup of the matched string from the match object, convert it to lowercase, substitute it for tag and self.lasttag.
while k < endpos :	as long k is smaller than endpos,
m = _html_parser . attrfind . match ( rawdata , k )	match the rawdata from the position k, with attrfind pattern, assign the result to the m.
if not m :	if m is not False, None is considered False,
break	breaks from the smallest enclosing loop.
attrname , rest , attrvalue = m . group ( 1 , 2 , 3 )	find the first, second and third subgroup of the m regular expression match, assign the result to the attrname, rest and attrvalue, respectively.
if not rest :	if rest is not False, None is considered False,
attrvalue = None	set attrvalue to None.
attrvalue = attrvalue [ 1 : - 1 ]	remove first and last character from the attrvalue, substitute it for attrvalue.
if attrvalue :	if attrvalue is not an empty string,
attrvalue = self . unescape ( attrvalue )	call the method unescape with attrvalue as the argument on the self class instance, substitute the result for attrvalue.
attrs . append ( ( attrname . lower ( ) , attrvalue ) )	form the tuple from the attrname converted to lowercase and attrvalue, append it to the end of attrs.
k = m . end ( )	find the ending position of the regular expression match of the object match, substitute the result for k.
end = rawdata [ k : endpos ] . strip ( )	slice the rawdata string from the k-th to the endpos-th index, remove the whitespaces from the start and the end of the string, substitute it for end.
if end not in ( '>' , '/>' ) :	if end is not a '>' or '/>' character,
lineno , offset = self . getpos ( )	evaluate the self.getpos() and assign the result to the lineno and offset respectfully.
\if '\\n' in self . __starttag_text :\	if self.__stattag_text contains newline character,
\lineno = lineno + self . __starttag_text . count ( '\\n' )\	increment the lineno by the count of the newlines in self.__starttag_text.
\offset = ( len ( self . __starttag_text )  - self . __starttag_text . rfind ( '\\n' ) )\	find the last index of newline occurrence in self.__starttag_text, subtract it from total length of self.__starttag_text,
else :	substitute the result for offset.   if not,
offset = offset + len ( self . __starttag_text )	increment the offset by the length of self.__starttag_text.
self . error ( 'junk characters in start tag: %r'  % ( rawdata [ k : endpos ] [ : 20 ] , ) )	slice the rawdata from k to endpos, then take the first 20 elements of the previous slice,
if end . endswith ( '/>' ) :	with it replace %r in the string 'junk characters in start tag: %r',   call the method self.error with the resulting string as an argument.   if string end ends with string '/>',
self . handle_startendtag ( tag , attrs )	call the method self.handle_startendtag with tag and attrs as the arguments.
else :	if not,
self . handle_starttag ( tag , attrs )	call the method self.handle_starttag, with tag and attrs as the arguments.
if tag in self . CDATA_CONTENT_ELEMENTS :	if tag is contained in self.CDATA_CONTENT_ELEMENTS,
self . set_cdata_mode ( tag )	call the method self.set_cdata_mode with tag as the argument.
return endpos	return endpos.
def parse_endtag ( self , i ) :	define the method parse_endtag with self class instance and i as the arguments.
rawdata = self . rawdata	substitute self.rawdata for rawdata.
assert rawdata [ i : i + 2 ] == '</' , 'unexpected call to parse_endtag'	take two characters from the i-th element of rawdata, if they are not equal to the string '</',
match = _html_parser . endendtag . search ( rawdata , i + 1 )	throw an exception with string 'unexpected call to parse_endtag' as the message.   search anywhere in the rawdata string starting from the (i+1)-th element for the _html_parser.endendeag, replace the result for match.
if not match :	if there is no match,
return - 1	return integer -1.
j = match . end ( )	find the ending position of the regular expression match of the object match, substitute the result for j.
match = _html_parser . endtagfind . match ( rawdata , i )	match the rawdata from the position i, with _html_parser.endtagfind pattern, assign the result to the match.
if not match :	if there is no match,
if self . cdata_tag is not None :	if self.cdata_tag is not None,
self . handle_data ( rawdata [ i : j ] )	slice the rawdata to obtain substring from i-th to j-th element, use it as the argument for the method call to the self.handle_data.
return j	return j.
self . error ( 'bad end tag: %r' % ( rawdata [ i : j ] , ) )	slice the rawdata from i-th to the j-th element, replace with it '%r' in the string 'bad end tag: %r', use it to call the method self.error.
tag = match . group ( 1 ) . strip ( )	find the first subgroup of the matched string from the match object, strip the whitespaces from the begging and end, replace it for tag.
if self . cdata_tag is not None :	if self.cdata_tag is not None,
if tag . lower ( ) != self . cdata_tag :	convert tag to lowercase if it is not equal to self.cdata_tag,
self . handle_data ( rawdata [ i : j ] )	slice the rawdata to obtain substring from i-th to j-th element, use it as the argument for the method call to the self.handle_data.
return j	return j.
self . handle_endtag ( tag . lower ( ) )	convert tag to lowercase, use it as the argument for the call to the method self.handle_endtag.
self . clear_cdata_mode ( )	call the method self.clear_cdata_mode.
return j	return j.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import base64	import module base64.
import calendar	import module calendar.
import datetime	import module datetime.
import re	import module re.
import sys	import module sys.
from binascii import Error as BinasciiError	from binascii import Error as BinasciiError into default name space.
from email . utils import formatdate	from email.utils import formatdate into default name space.
from django . utils . datastructures import MultiValueDict	from django.utils.datastructures import MultiValueDict into default name space.
from django . utils . encoding import force_str , force_text	from django.utils.encoding import force_str and force_text into default name space.
from django . utils . functional import allow_lazy	from django.utils.functional import allow_lazy into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . six . moves . urllib . parse import (  quote , quote_plus , unquote , unquote_plus , urlparse ,  urlencode as original_urlencode )	from django.utils.six.moves.urllib.parse import quote, quote_plus, unquote, unquote_plus, urlparse, urlencode as original_urlencode.
MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec' . split ( )	MONTHS is a list with 12 elements: strings 'jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', and 'dec'.
\__D = r'(?P<day>\\d{2})'\	\__D is a raw string '(?P<day>\\d{2})'.\
\__D2 = r'(?P<day>[ \\d]\\d)'\	\__D2 is a raw string '(?P<day>[ \\d]\\d)'.\
\__M = r'(?P<mon>\\w{3})'\	\__M is a raw string '(?P<mon>\\w{3})'.\
\__Y = r'(?P<year>\\d{4})'\	\__Y is a raw string '(?P<year>\\d{4})'.\
\__Y2 = r'(?P<year>\\d{2})'\	\__Y2 is a raw string '(?P<year>\\d{2})'.\
\__T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'\	\__T is a raw string '(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'.\
\RFC1123_DATE = re . compile ( r'^\\w{3}, %s %s %s %s GMT$' % ( __D , __M , __Y , __T ) )\	\call the function re.compile with an argument raw string '^\\w{3}, %s %s %s %s GMT$' formated with __D, __M, __Y and __T,\
\RFC850_DATE = re . compile ( r'^\\w{6,9}, %s-%s-%s %s GMT$' % ( __D , __M , __Y2 , __T ) )\	\substitute the result for RFC1123_DATE.   call the function re.compile with an argument raw string '^\\w{6,9}, %s-%s-%s %s GMT$' formated with __D, __M, __Y2 and __T,\
\ASCTIME_DATE = re . compile ( r'^\\w{3} %s %s %s %s$' % ( __M , __D2 , __T , __Y ) )\	\substitute the result for RFC850_DATE.   call the function re.compile with an argument raw string '^\\w{3} %s %s %s %s$' formated with __M, __D2, __T and __Y,\
def urlquote ( url , safe = '/' ) :	substitute the result for ASCTIME_DATE.   define the function urlquote with 2 arguments: url and safe set to '/'.
return force_text ( quote ( force_str ( url ) , force_str ( safe ) ) )	call the function quote with 2 arguments: result of the function force_str called with an argument url,
urlquote = allow_lazy ( urlquote , six . text_type )	and result of the function force_str called with an argument safe,   use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlquote and six.text_type, substitute the result for urlquote.
def urlquote_plus ( url , safe = '' ) :	define the function urlquote_plus with 2 arguments: url and safe set to an empty string.
return force_text ( quote_plus ( force_str ( url ) , force_str ( safe ) ) )	call the function quote_plus with 2 arguments: result of the function force_str called with an argument url,
urlquote_plus = allow_lazy ( urlquote_plus , six . text_type )	and result of the function force_str called with an argument safe,   use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlquote_plus and six.text_type, substitute the result for urlquote_plus.
def urlunquote ( quoted_url ) :	define the function urlunquote with an argument quoted_url.
return force_text ( unquote ( force_str ( quoted_url ) ) )	call the function force_str with an argument quoted_url, use the result as an argument for the call to the function unquote,
urlunquote = allow_lazy ( urlunquote , six . text_type )	use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlunquote and six.text_type, substitute the result for urlunquote.
def urlunquote_plus ( quoted_url ) :	define the function urlunquote with an argument quoted_url.
return force_text ( unquote_plus ( force_str ( quoted_url ) ) )	call the function force_str with an argument quoted_url, use the result as an argument for the call to the function unquote_plus,
urlunquote_plus = allow_lazy ( urlunquote_plus , six . text_type )	use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlunquote_plus and six.text_type, substitute the result for urlunquote_plus.
def urlencode ( query , doseq = 0 ) :	define the function urlencode with 2 arguments query and doseq set to integer 0.
if isinstance ( query , MultiValueDict ) :	if query is an instance of MultiValueDict class,
query = query . lists ( )	call the method query.lists, substitute the result for query.
elif hasattr ( query , 'items' ) :	otherwise if query has an attribute 'items',
query = query . items ( )	call the method query.items, substitute the result for query.
return original_urlencode (  [ ( force_str ( k ) ,  [ force_str ( i ) for i in v ] if isinstance ( v , ( list , tuple ) ) else force_str ( v ) )  for k , v in query ] ,  doseq )	call the function original_urlencode with 2 arguments: list with 2 elements: result of the function force_str with an argument k,
def cookie_date ( epoch_seconds = None ) :	and list with results of the function force_str with an argument i, for every i in v, only if v is a list or a tuple,   otherwise second element is result of the function force_str with an argument v, for every k and v in query,   and doseq, return the result.   define the function cookie_date with an argument epoch_seconds set to None.
rfcdate = formatdate ( epoch_seconds )	call the function formatdate with an argument epoch_seconds, substitute the result for rfcdate.
return '%s-%s-%s GMT' % ( rfcdate [ : 7 ] , rfcdate [ 8 : 11 ] , rfcdate [ 12 : 25 ] )	return a string '%s-%s-%s GMT', formated with: first 7 elements of rfcdate, elements of rfcdate from 8-th to the 11-th index,
def http_date ( epoch_seconds = None ) :	and elements of rfcdate from 12-th to the 25-th index.   define the function http_date with an argument epoch_seconds set to None.
return formatdate ( epoch_seconds , usegmt = True )	call the function formatdate with 2 arguments: epoch_seconds and usegmt set to boolean True, return the result.
def parse_http_date ( date ) :	define the function parse_http_date with an argument date.
for regex in RFC1123_DATE , RFC850_DATE , ASCTIME_DATE :	for every regex in tuple with 3 elements: RFC1123_DATE, RFC850_DATE and ASCTIME_DATE,
m = regex . match ( date )	call the method regex.match with an argument date, substitute the result for m.
if m is not None :	if m is not None,
break	break from the loop execution.
else :	if not,
raise ValueError ( '%r is not in a valid HTTP date format' % date )	raise an ValueError exception with an argument string '%r is not in a valid HTTP date format' formated with date.
try :	try,
year = int ( m . group ( 'year' ) )	call the method m.group with an argument string 'year', convert the result into a string, substitute it for year.
if year < 100 :	if year is lesser than integer 100,
if year < 70 :	if year is lesser than integer 70,
year += 2000	increment year by integer 2000.
else :	if not,
year += 1900	increment year by integer 1900.
month = MONTHS . index ( m . group ( 'mon' ) . lower ( ) ) + 1	call the method m.group with an argument string 'mon', convert the result to lowercase, use it as an argument for the call to the,
day = int ( m . group ( 'day' ) )	method MONTHS.index, increment the result by integer 1, substitute it for month.   call the method m.group with an argument string 'fay', convert the result into a string, substitute it for day.
hour = int ( m . group ( 'hour' ) )	call the method m.group with an argument string 'hour', convert the result into a string, substitute it for hour.
min = int ( m . group ( 'min' ) )	call the method m.group with an argument string 'min', convert the result into a string, substitute it for min.
sec = int ( m . group ( 'sec' ) )	call the method m.group with an argument string 'sec', convert the result into a string, substitute it for sec.
result = datetime . datetime ( year , month , day , hour , min , sec )	call the method MONTHS.index with 6 arguments: year, month, day, hour, min and sec, substitute the result for result.
return calendar . timegm ( result . utctimetuple ( ) )	call the method result.utctimetuple, use the result as an argument for the call to the method calendar.timegm, return the result.
except Exception :	if Exception exception is caught.
six . reraise ( ValueError , ValueError ( '%r is not a valid date' % date ) , sys . exc_info ( ) [ 2 ] )	call the function six.reraise with 3 arguments: ValueError, instance of a class ValueError, created with an argument string,
def parse_http_date_safe ( date ) :	%r is not a valid date formated with date and third element of the result of the function sys.exc_info.   define the function parse_http_date_safe an argument date.
try :	try,
return parse_http_date ( date )	call the function parse_http_date with an argument date, return the result.
except Exception :	if Exception exception is caught.
pass	do nothing.
def base36_to_int ( s ) :	define the functionbase36_to_int with an argument s.
if len ( s ) > 13 :	if length of s is greater than integer 13,
raise ValueError ( 'Base36 input too large' )	raise an ValueError exception with an argument string 'Base36 input too large'.
value = int ( s , 36 )	convert s to integer of base 36, substitute it for value.
if six . PY2 and value > sys . maxint :	if six.PY2 is true and value is greater than sys.maxint,
raise ValueError ( 'Base36 input too large' )	raise an ValueError exception with an argument string 'Base36 input too large'.
return value	return value.
def int_to_base36 ( i ) :	define the function int_to_base36 with an argument i.
digits = '0123456789abcdefghijklmnopqrstuvwxyz'	digits is a string '0123456789abcdefghijklmnopqrstuvwxyz'.
factor = 0	factor is integer 0.
if i < 0 :	if i is smaller than integer 0,
raise ValueError ( 'Negative base36 conversion input.' )	raise an ValueError exception with an argument string 'Negative base36 conversion input.'.
if six . PY2 :	if six.PY2 is true,
if not isinstance ( i , six . integer_types ) :	if i is not an instance of six.integer_types class,
raise TypeError ( 'Non-integer base36 conversion input.' )	raise an TypeError exception with an argument string 'Non-integer base36 conversion input.'.
if i > sys . maxint :	if i is greater than sys.maxint,
raise ValueError ( 'Base36 conversion input too large.' )	raise an ValueError exception with an argument string 'Base36 conversion input too large.'.
while True :	endless loop,
factor += 1	increment factor by one.
if i < 36 ** factor :	bring integer 36 to the power of factor, if i is smaller than the result,
factor -= 1	decrement factor by one.
break	break from the loop execution.
base36 = [ ]	base36 is an empty list.
while factor >= 0 :	while factor is greater or equal to integer 0,
j = 36 ** factor	bring integer 36 to the power of factor, substitute the result for j.
base36 . append ( digits [ i // j ] )	floor the division of i by j, use it an an index to get the element of the digits list, append the result for base36.
i = i % j	i is the reminder of the division of i by j.
factor -= 1	decrement factor by one.
return '' . join ( base36 )	join elements of base36 into a string, return it.
def urlsafe_base64_encode ( s ) :	define the function urlsafe_base64_encode with an argument s.
\return base64 . urlsafe_b64encode ( s ) . rstrip ( b'\\n=' )\	\call the method base64.urlsafe_b64encode with an argument s, strip the result of the bytes string '\\n=' from the right, return it.\
def urlsafe_base64_decode ( s ) :	define the function urlsafe_base64_decode with an argument s.
s = s . encode ( 'utf-8' )	call the method s.encode with an argument string 'utf-8', substitute the result for s.
try :	try,
return base64 . urlsafe_b64decode ( s . ljust ( len ( s ) + len ( s ) % 4 , b'=' ) )	left justify string s in a field of width equal to the sum of length of s and reminder of the division of length of s by integer 4,
except ( LookupError , BinasciiError ) as e :	pad the rest of the field with bytes string '=', use the result as an argument for the call to the method base64.urlsafe_b64decode,   return the result.   if LookupError or BinasciiError, renamed to e, exceptions are caught.
raise ValueError ( e )	raise an ValueError exception with an argument e.
def parse_etags ( etag_str ) :	define the function parse_etags with an argument etag_str.
etags = ETAG_MATCH . findall ( etag_str )	call the method ETAG_MATCH.findall with an argument etag_str, substitute the result for etags.
if not etags :	if etags is false,
return [ etag_str ]	return a list with an element etag_str.
etags = [ e . encode ( 'ascii' ) . decode ( 'unicode_escape' ) for e in etags ]	for every e in etags call the method e.encode with an argument string 'ascii', call the method decode on the result with an argument,
return etags	string 'unicode_escape', substitute the list of results for etags.   return etags.
def quote_etag ( etag ) :	define the function quote_etag with an argument etag.
p1 , p2 = urlparse ( url1 ) , urlparse ( url2 )	substitute result of the function urlparse with an argument ur1 for p1 and result of the function urlparse with an argument ur2 for p2.
try :	try,
return ( p1 . scheme , p1 . hostname , p1 . port ) == ( p2 . scheme , p2 . hostname , p2 . port )	if p2.scheme, p2.hostname and p2.port equals p1.scheme, p1.hostname and p1.port, respectively, return boolean True, otherwise return boolean False.
except ValueError :	if ValueError exception is caught.
return False	return boolean False.
def is_safe_url ( url , host = None ) :	define the function is_safe_url with 2 arguments url and host set to None.
if not url :	if url is false,
return False	return boolean False.
\url = url . replace ( '\\\\' , '/' )\	\replace every occurrence of '\\\\' in url with '/'.\
if url . startswith ( '///' ) :	if url starts with '///',
return False	return boolean False.
url_info = urlparse ( url )	call the function urlparse with an argument url, substitute the result for url_info.
if not url_info . netloc and url_info . scheme :	if url_info.netloc is false and url_info.scheme is true,
return False	return boolean False.
return ( ( not url_info . netloc or url_info . netloc == host ) and  ( not url_info . scheme or url_info . scheme in [ 'http' , 'https' ] ) )	if url_info.netloc is false or url_info.netloc equals host, and if url_info.scheme is false or url_info.scheme equals,
import warnings	import module warnings.
import sys	import module sys.
from django . utils import six	from django.utils import six into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
warnings . warn ( 'django.utils.importlib will be removed in Django 1.9.' ,  RemovedInDjango19Warning , stacklevel = 2 )	call the function warnings.warn with 3 arguments: string 'django.utils.importlib will be removed in Django 1.9.',
def _resolve_name ( name , package , level ) :	RemovedInDjango19Warning and stacklevel set to integer 2.   define the function _resolve_name with 3 arguments: name, package and level.
if not hasattr ( package , 'rindex' ) :	if package doesnt have an 'rindex' attribute,
dot = len ( package )	substitute length of package for dot.
for x in range ( level , 1 , - 1 ) :	for every x is the range of integers from level to the integer 2, in the reversed order,
try :	try,
dot = package . rindex ( '.' , 0 , dot )	call the method package.rindex with 3 arguments: string '.', integer 0 and dot, substitute the result for dot.
except ValueError :	if ValueError exception is caught,
raise ValueError ( 'attempted relative import beyond top-level package' )	raise an ValueError with an argument string 'attempted relative import beyond top-level package'.
return '%s.%s' % ( package [ : dot ] , name )	return a string '%s.%s' formated with first dot package elements and name.
if six . PY3 :	if six.PY3 is true,
from importlib import import_module	from importlib import import_module.
else :	if not,
def import_module ( name , package = None ) :	define the function import_module with 3 arguments: name and package set to None.
if name . startswith ( '.' ) :	if name starts with an string '.',
if not package :	if package is false,
raise TypeError ( 'relative imports require the 'package' argument' )	raise an TypeError with an argument string 'relative imports require the 'package' argument'.
level = 0	level is an integer 0.
for character in name :	for every character in name,
if character != '.' :	if character is not equal to a string '.',
break	break from the loop execution.
level += 1	increment level by one.
name = _resolve_name ( name [ level : ] , package , level )	call the function _resolve_name with 3 arguments: name list elements from the level index to the end, package and level,
__import__ ( name )	substitute the result for name.   call the function __import__ with an argument name.
return sys . modules [ name ]	return sys.modules dictionary value under the name key.
from django . core . exceptions import ValidationError	from django.core.exceptions import ValidationError into default name space.
from django . utils . translation import ugettext_lazy as _	from django.utils.translation import ugettext_lazy as _ into default name space.
from django . utils . six . moves import xrange	from django.utils.six.moves import xrange into default name space.
def clean_ipv6_address ( ip_str , unpack_ipv4 = False ,  error_message = _ ( 'This is not a valid IPv6 address.' ) ) :	define the function clean_ipv6_address with 3 arguments: ip_str, unpack_ipv4 set to boolean False and error_message,
best_doublecolon_start = - 1	best_doublecolon_start is an integer -1.
best_doublecolon_len = 0	best_doublecolon_len is an integer 0.
doublecolon_start = - 1	doublecolon_start is an integer -1.
doublecolon_len = 0	doublecolon_len is an integer 0.
if not is_valid_ipv6_address ( ip_str ) :	call he function is_valid_ipv6_address with an argument ip_str, if it evaluates to false,
raise ValidationError ( error_message , code = 'invalid' )	raise an ValidationError exception with 2 arguments: error_message and code as a string 'invalid'.
ip_str = _explode_shorthand_ip_string ( ip_str )	call the function _explode_shorthand_ip_string with an argument ip_str, substitute the result for ip_str.
ip_str = _sanitize_ipv4_mapping ( ip_str )	call the function _explode_shorthand_ip_string with an argument ip_str, substitute the result for ip_str.
if unpack_ipv4 :	if unpack_ipv4 is true,
ipv4_unpacked = _unpack_ipv4 ( ip_str )	call the function _unpack_ipv4 with an argument ip_str, substitute the result for ipv4_unpacked.
if ipv4_unpacked :	if ipv4_unpacked is true,
return ipv4_unpacked	return ipv4_unpacked.
hextets = ip_str . split ( ':' )	split ip_str by ':', substitute the result for hextets.
for index in range ( len ( hextets ) ) :	for every index in range of integers from 0 to length of hextets, not included,
hextets [ index ] = hextets [ index ] . lstrip ( '0' )	get the value under the index key of the hextets dictionary, remove the leading '0' characters,
if not hextets [ index ] :	substitute the result for value under the index key of the hextets dictionary.   get the value under the index key of the hextets dictionary, if it is false,
hextets [ index ] = '0'	value under the index key of the hextets dictionary is a string '0'.
if hextets [ index ] == '0' :	if value under the index key of the hextets dictionary equals to string '0',
doublecolon_len += 1	increment doublecolon_len by integer 1,
if doublecolon_start == - 1 :	if doublecolon_start equals integer -1,
doublecolon_start = index	substitute index for doublecolon_start.
if doublecolon_len > best_doublecolon_len :	if doublecolon_len is greater than best_doublecolon_len,
best_doublecolon_len = doublecolon_len	substitute doublecolon_len for best_doublecolon_len.
best_doublecolon_start = doublecolon_start	substitute doublecolon_start for best_doublecolon_start.
else :	if not,
doublecolon_len = 0	doublecolon_len is integer 0.
doublecolon_start = - 1	doublecolon_start is integer -1.
if best_doublecolon_len > 1 :	if best_doublecolon_len is greater than integer 1,
best_doublecolon_end = ( best_doublecolon_start +  best_doublecolon_len )	sum best_doublecolon_start and best_doublecolon_len, substitute the result for best_doublecolon_end,
if best_doublecolon_end == len ( hextets ) :	if best_doublecolon_end equals length of hextets,
hextets += [ '' ]	append an empty string to list hextets.
hextets [ best_doublecolon_start : best_doublecolon_end ] = [ '' ] 	replace hextets list from the best_doublecolon_start index to best_doublecolon_end index with an empty string.
if best_doublecolon_start == 0 :	if best_doublecolon_start equals integer 0,
hextets = [ '' ] + hextets	prepend an empty string to hextets list.
result = ':' . join ( hextets )	join elements of hextets into a string, separated with ':', substitute it for result.
return result . lower ( )	convert result to lowercase and return it.
def _sanitize_ipv4_mapping ( ip_str ) :	define the function _sanitize_ipv4_mapping with an argument ip_str.
if not ip_str . lower ( ) . startswith ( '0000:0000:0000:0000:0000:ffff:' ) :	convert ip_str to lowercase, if it doesnt start with a string '0000:0000:0000:0000:0000:ffff:',
return ip_str	return ip_str.
hextets = ip_str . split ( ':' )	split ip_str into parts by ':', substitute the result for hextets.
if '.' in hextets [ - 1 ] :	if '.' is contained in last elements of hextets,
return ip_str	return ip_str.
ipv4_address = '%d.%d.%d.%d' % (  int ( hextets [ 6 ] [ 0 : 2 ] , 16 ) ,  int ( hextets [ 6 ] [ 2 : 4 ] , 16 ) ,  int ( hextets [ 7 ] [ 0 : 2 ] , 16 ) ,  int ( hextets [ 7 ] [ 2 : 4 ] , 16 ) ,  )	ipv4_address is a string '%d.%d.%d.%d' formated with first 2 elements of seventh element of hextets converted into hexadecimal number,
result = ':' . join ( hextets [ 0 : 6 ] )	second 2 elements of seventh element of hextets converted into hexadecimal number,   first 2 elements of eight element of hextets converted into hexadecimal number,   second 2 elements of eight element of hextets converted into hexadecimal number.   join first 5 elements of hextets into a string, separated by ':', substitute the result for result.
result += ':' + ipv4_address	append ':' and ipv4_address to result.
return result	return result.
def _unpack_ipv4 ( ip_str ) :	define the function _unpack_ipv4 with an argument ip_str.
if not ip_str . lower ( ) . startswith ( '0000:0000:0000:0000:0000:ffff:' ) :	convert ip_str to lowercase, if it doesnt start with a string '0000:0000:0000:0000:0000:ffff:',
return None	return None.
return ip_str . rsplit ( ':' , 1 ) [ 1 ]	split ip_str into 2 parts from right, return second element of the result.
def is_valid_ipv6_address ( ip_str ) :	define the function is_valid_ipv6_address with an argument ip_str.
from django . core . validators import validate_ipv4_address	from django.core.validators import validate_ipv4_address.
if ':' not in ip_str :	if ':' is not contained in ip_str.
return False	return boolean False.
if ip_str . count ( '::' ) > 1 :	if count of occurrence of '::' in ip_str is greater than integer 1,
return False	return boolean False.
if ':::' in ip_str :	if string ':::' is contained in ip_str,
return False	return boolean False.
if ( ( ip_str . startswith ( ':' ) and not ip_str . startswith ( '::' ) ) or  ( ip_str . endswith ( ':' ) and not ip_str . endswith ( '::' ) ) ) :	if ip_str starts with ':, but it doesnt starts with '::', or if ip_str ends with ':, but it doesnt ends with '::',
return False	return boolean False.
if ip_str . count ( ':' ) > 7 :	if count of occurrence of ':' in ip_str is greater than integer 7,
return False	return boolean False.
if '::' not in ip_str and ip_str . count ( ':' ) != 7 :	if '::' is not contained in ip_str and number of occurrences of ':' in ip_str is not equal to integer 7,
if ip_str . count ( '.' ) != 3 :	if count of occurrence of '.' in ip_str is not equal to integer 3,
return False	return boolean False.
ip_str = _explode_shorthand_ip_string ( ip_str )	call the function _explode_shorthand_ip_string with an argument ip_str, substitute the result for ip_str.
for hextet in ip_str . split ( ':' ) :	split ip_str into parts by ':', for every hextet in the result,
if hextet . count ( '.' ) == 3 :	if count of occurrence of '.' in ip_str is equal to integer 3,
if not ip_str . split ( ':' ) [ - 1 ] == hextet :	split ip_str by ':', if last element of the result is not equal to hextet.
return False	return boolean False.
try :	try,
validate_ipv4_address ( hextet )	call the function validate_ipv4_address with an argument hextet.
except ValidationError :	if ValidationError exception is caught,
return False	return boolean False.
else :	if not,
try :	try,
if int ( hextet , 16 ) < 0x0 or int ( hextet , 16 ) > 0xFFFF :	if hextet converted to hexadecimal number is smaller than hexadecimal 0, or hextet converted to hexadecimal number is smaller than hexadecimal FFFF,
return False	return boolean False.
except ValueError :	if ValueError exception is caught.
return False	return boolean False.
return True	return boolean True.
def _explode_shorthand_ip_string ( ip_str ) :	define the function _explode_shorthand_ip_string with an argument ip_str.
if not _is_shorthand_ip ( ip_str ) :	call the function _is_shorthand_ip with an argument ip_str, if it evaluates to false,
return ip_str	return ip_str.
new_ip = [ ]	new_ip is an empty list,
hextet = ip_str . split ( '::' )	split ip_str by '::', substitute it for hextet.
if '.' in ip_str . split ( ':' ) [ - 1 ] :	split ip_str into parts by ':', if '.' is contained in the last element of the result,
fill_to = 7	fill_to is an integer 7.
else :	if not,
fill_to = 8	fill_to is an integer 8.
if len ( hextet ) > 1 :	if length of hextet is greater than integer 1,
sep = len ( hextet [ 0 ] . split ( ':' ) ) + len ( hextet [ 1 ] . split ( ':' ) )	split first and second element of hextet into parts by ':', sum their lengths, substitute the result for sep.
new_ip = hextet [ 0 ] . split ( ':' )	split first element of hextet into parts by ':', append them to new_ip.
for __ in xrange ( fill_to - sep ) :	for every __ in range of integers from 0 up to sep subtracted from fill_to,
new_ip . append ( '0000' )	append string '0000' to new_ip.
new_ip += hextet [ 1 ] . split ( ':' )	split second element of hextet into parts by ':', append them to new_ip.
else :	if not,
new_ip = ip_str . split ( ':' )	split ip_str into parts by ':', substitute the result for new_ip.
ret_ip = [ ]	ret_ip is an empty list.
for hextet in new_ip :	for every hextet in new_ip,
ret_ip . append ( ( '0' * ( 4 - len ( hextet ) ) + hextet ) . lower ( ) )	subtract length of hextet from 4, create a string with previous result number of character '0', append hextet to it,
return ':' . join ( ret_ip )	convert the result into a lowercase, append it to ret_ip.   join elements of ret_ip into a string separated with ':', return it.
def _is_shorthand_ip ( ip_str ) :	define the function _is_shorthand_ip with an argument ip_str.
if ip_str . count ( '::' ) == 1 :	if count of occurrence of '::' in ip_str equals integer 1,
return True	return boolean True.
if any ( len ( x ) < 4 for x in ip_str . split ( ':' ) ) :	split ip_str into parts by ':', for every x in the result, calculate length of x, if any is smaller than integer 4,
return True	return boolean True.
return False	return boolean False.
def is_iterable ( x ) :	define the function is_iterable with an argument x.
try :	try,
iter ( x )	create an iterator out of x.
except TypeError :	if TypeError exception is caught,
return False	return boolean False.
else :	if not,
return True	return boolean True.
import re	import module re.
class Tok ( object ) :	derive the class Tok from the object base class.
num = 0	num is an integer 0.
def __init__ ( self , name , regex , next = None ) :	define the method __init__ with 4 arguments: self, name, regex and next set to None.
self . id = Tok . num	substitute Tok.num for self.id.
Tok . num += 1	increment Tok.num with an integer 1.
self . name = name	substitute name for self.name.
self . regex = regex	substitute regex for self.regex.
self . next = next	substitute next for self.next.
def literals ( choices , prefix = '' , suffix = '' ) :	define the function literals with 3 arguments: choices, prefix set to an empty string and suffix set to an empty string.
return '|' . join ( prefix + re . escape ( c ) + suffix for c in choices . split ( ) )	for every c in choices split into words, concatenate prefix, result of the function re.escape with an argument c and suffix,
class Lexer ( object ) :	and join the results into a string, separated with '|' character, return the result.   derive the class Lexer from the object base class.
def __init__ ( self , states , first ) :	define the method __init__ with 3 arguments self, states and first.
self . regexes = { }	self.regexes is an empty dictionary.
self . toks = { }	self.tokens is an empty dictionary.
for state , rules in states . items ( ) :	call the method states.items, for every state and rules in the result,
parts = [ ]	parts is an empty list.
for tok in rules :	for every tok in rules,
groupid = 't%d' % tok . id	groupid is a string 't%d' formated with tok.id.
self . toks [ groupid ] = tok	substitute tok for value under the groupid key of the self.toks dictionary.
parts . append ( '(?P<%s>%s)' % ( groupid , tok . regex ) )	format a string '(?P<%s>%s)' with groupid and tok.regex, append it to the parts.
self . regexes [ state ] = re . compile ( '|' . join ( parts ) , re . MULTILINE | re . VERBOSE )	call the function re.compile with 2 arguments: elements of parts joined into a string, separated with '|',
self . state = first	and result of bitwise OR performed on 2 operands: re.MULTILINE and re.VERBOSE,   substitute the result for value under the state key of the self.regexes dictionary.   substitute first for self.state.
def lex ( self , text ) :	define the method lex with 2 arguments self and text.
end = len ( text )	substitute length of text for end.
state = self . state	substitute self.state for state.
regexes = self . regexes	substitute self.regexes for regexes.
toks = self . toks	substitute self.toks for toks.
start = 0	start is an integer 0.
while start < end :	while start is lesser than end.
for match in regexes [ state ] . finditer ( text , start ) :	get the value under the state key of the regexes dictionary, call the method finditer on the result with 2 arguments: text and start,
name = match . lastgroup	for every match in the result,   substitute match.lastgroup for name.
tok = toks [ name ]	substitute value under the name key of the toks dictionary for tok.
toktext = match . group ( name )	call the method match.group with an arugument name, substitute the result for toktext.
start += len ( toktext )	increment start by length of toktext.
yield ( tok . name , toktext )	yield a tuple with 2 elements: tok.name and toktext.
if tok . next :	if tok.next is true,
state = tok . next	substitute tok.next for state.
break	break from the loop execution.
self . state = state	substitute state for self.state.
class JsLexer ( Lexer ) :	derive the class JsLexer from the Lexer base class.
both_after = [  Tok ( 'other' , r'.' ) ,  ]	both_after is an list with an element instance of Tok class, created with 2 arguments: string 'other' and raw string '.'.
\states = {   'div' : both_before + [  Tok ( 'punct' , literals ( '/= /' ) , next = 'reg' ) ,  ] + both_after ,    'reg' : both_before + [  Tok ( 'regex' ,  r'''                     /                       # opening slash                     # First character is..                     (   [^*\\\\/[]            # anything but * \\ / or [                     |   \\\\.                 # or an escape sequence                     |   \\[                  # or a class, which has                             (   [^\\]\\\\]     #   anything but \\ or ]                             |   \\\\.         #   or an escape sequence                             )*              #   many times                         \\]                     )                     # Following characters are same, except for excluding a star                     (   [^\\\\/[]             # anything but \\ / or [                     |   \\\\.                 # or an escape sequence                     |   \\[                  # or a class, which has                             (   [^\\]\\\\]     #   anything but \\ or ]                             |   \\\\.         #   or an escape sequence                             )*              #   many times                         \\]                     )*                      # many times                     /                       # closing slash                     [a-zA-Z0-9]*            # trailing flags                 ''' , next = 'div' ) ,  ] + both_after ,  }\	states is a dictionary with 2 arguments: appended list with an element instance of a class Tok, created with 3 arguments: 'punct',
def __init__ ( self ) :	\result of the function literals called with an argument string '/= /' and next as a string 'reg', to the both_before,   appended both_after to the previous result, for 'div' and appended list with an element instance of a class Tok,   created with 3 arguments: string 'regex',   raw string '/([^*\\\\/[]|\\\\.|\\[(   [^\\]\\\\]|   \\\\.)*\\])(   [^\\\\/[]|   \\\\.|   \\[(   [^\\]\\\\]|   \\\\.)*\\])*/[a-zA-Z0-9]*',   and next as a string 'div', to the both_before, appended both_after to the previous result for 'div'.   define the method __init__ with an argument self.\
super ( JsLexer , self ) . __init__ ( self . states , 'reg' )	call the method __init__ with 2 arguments: self.states and string 'reg' from the base class of the class JsLexer.
def prepare_js_for_gettext ( js ) :	define the function prepare_js_for_gettext with an argument js.
def escape_quotes ( m ) :	define the function escape_quotes with an argument m.
s = m . group ( 0 )	call the method m.group with an argument integer 0, substitute the result for s.
else :	if not,
return s	return s.
lexer = JsLexer ( )	lexer is an instance of JsLexer class.
c = [ ]	c is an empty list.
for name , tok in lexer . lex ( js ) :	call the method lexer.lex with an arguments js, for every name and tok in the result,
if name == 'regex' :	if name equals a string 'regex',
elif name == 'string' :	otherwise if name starts with a string 'string',
\guts = re . sub ( r'\\\\.|.' , escape_quotes , tok [ 1 : - 1 ] )\	\call the function re.sub with 3 arguments: raw string '\\\\.|.', escape_quotes and tok without the first and last element,\
elif name == 'id' :	otherwise if name equals a string 'id'.
\tok = tok . replace ( '\\\\' , 'U' )\	\replace every occurrence of '\\\\' in tok with 'U', substitute the result for tok.\
c . append ( tok )	append tok to c.
return '' . join ( c )	join elements of c into a string, return it.
import logging	import module logging.
import sys	import module sys.
import warnings	import module warnings.
from django . conf import settings	from django.conf import settings into default name space.
from django . core import mail	from django.core import mail into default name space.
from django . core . mail import get_connection	from django.core.mail import get_connection into default name space.
from django . utils . deprecation import RemovedInNextVersionWarning	from django.utils.deprecation import RemovedInNextVersionWarning into default name space.
from django . utils . module_loading import import_string	from django.utils.module_loading import import_string into default name space.
from django . views . debug import ExceptionReporter , get_exception_reporter_filter	from django.views.debug import ExceptionReporter and get_exception_reporter_filter into default name space.
from logging import NullHandler	from logging import NullHandler.
from logging . config import dictConfig	from logging.config import dictConfig.
getLogger = logging . getLogger	substitute logging.getLogger for getLogger.
DEFAULT_LOGGING = {  'version' : 1 ,  'disable_existing_loggers' : False ,  'filters' : {  'require_debug_false' : {  '()' : 'django.utils.log.RequireDebugFalse' ,  } ,  'require_debug_true' : {  '()' : 'django.utils.log.RequireDebugTrue' ,  } ,  } ,  'handlers' : {  'console' : {  'level' : 'INFO' ,  'filters' : [ 'require_debug_true' ] ,  'class' : 'logging.StreamHandler' ,  } ,  'null' : {  'class' : 'logging.NullHandler' ,  } ,  'mail_admins' : {  'level' : 'ERROR' ,  'filters' : [ 'require_debug_false' ] ,  'class' : 'django.utils.log.AdminEmailHandler'  }  } ,  'loggers' : {  'django' : {  'handlers' : [ 'console' ] ,  } ,  'django.request' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'django.security' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'py.warnings' : {  'handlers' : [ 'console' ] ,  } ,  }  }	DEFAULT_LOGGING is a dictionary with 5 initial entries: 1 for 'version', False for 'disable_existing_loggers',
def configure_logging ( logging_config , logging_settings ) :	and 3 additional pairs of dictionaries for string.   define the function configure_logging with 2 arguments: logging_config and logging_settings.
if not sys . warnoptions :	if sys.warnoptions is false,
logging . captureWarnings ( True )	call the method logging.captureWarnings with an argument boolean True.
warnings . simplefilter ( 'default' , RemovedInNextVersionWarning )	call the function warnings.simplefilter with 2 arguments: string 'default' and RemovedInNextVersionWarning.
if logging_config :	if logging_config is true,
logging_config_func = import_string ( logging_config )	call the function import_string with an argument logging_config, substitute the result for logging_config_func.
logging_config_func ( DEFAULT_LOGGING )	call the function logging_config_func with an argument DEFAULT_LOGGING.
if logging_settings :	if logging_settings is true,
logging_config_func ( logging_settings )	call the function logging_config_func with an argument logging_settings.
class AdminEmailHandler ( logging . Handler ) :	derive the class AdminEmailHandler from logging.Handler base class.
def __init__ ( self , include_html = False , email_backend = None ) :	define the method __init__ with 3 arguments: self, include_html set to boolean False and email_backend set to None.
logging . Handler . __init__ ( self )	call the method logging.Handler.__init__ with an argument self.
self . include_html = include_html	substitute include_html for self.include_html.
self . email_backend = email_backend	substitute email_backend for self.email_backend.
def emit ( self , record ) :	define the method emit with 2 arguments: self and record.
try :	try,
request = record . request	substitute record.request for request.
subject = '%s (%s IP): %s' % (  record . levelname ,  ( 'internal' if request . META . get ( 'REMOTE_ADDR' ) in settings . INTERNAL_IPS  else 'EXTERNAL' ) ,  record . getMessage ( )  )	subject is an string '%s (%s IP): %s', formated with record.levelname, string 'internal' if value under the 'REMOTE_ADDR' key,
filter = get_exception_reporter_filter ( request )	of the request.META dictionary is contained in settings.INTERNAL_IPS, otherwise use string 'EXTERNAL',   and result of the method record.getMessage.   call the function get_exception_reporter_filter with an argument request, substitute the result for filter.
\request_repr = '\\n{0}' . format ( filter . get_request_repr ( request ) )\	\call the method filter.get_request_repr with an argument request, format string '\\n{0}' with the result, substitute the result for request_repr.\
except Exception :	if Exception exception is caught,
subject = '%s: %s' % (  record . levelname ,  record . getMessage ( )  )	subject is an string '%s: %s' formated with record.levelname and result of the method record.getMessage, respectively.
request = None	request is None.
request_repr = 'unavailable'	request_repr is a string 'unavailable'.
subject = self . format_subject ( subject )	call the function self.format_subject with an argument subject, substitute the result for subject.
if record . exc_info :	if record.exc_info is true,
exc_info = record . exc_info	substitute record.exc_info for exc_info.
else :	if not,
exc_info = ( None , record . getMessage ( ) , None )	exc_info is an tuple with 3 elements: None, result of method record.getMessage and None.
\message = '%s\\n\\nRequest repr(): %s' % ( self . format ( record ) , request_repr )\	\message is an string '%s\\n\\nRequest repr(): %s'  formated with the result of the metod self.format with an argument record,\
reporter = ExceptionReporter ( request , is_email = True , * exc_info )	and request_repr, respectively.   reporter is an instance of ExceptionReporter class, created with 3 arguments: request, is_email as boolean True,
html_message = reporter . get_traceback_html ( ) if self . include_html else None	unpacked list exc_info.   if self.include_html is true, call the method reporter.get_traceback_html and substitute the result for html_message,
mail . mail_admins ( subject , message , fail_silently = True ,  html_message = html_message ,  connection = self . connection ( ) )	otherwise html_message is None.   call the method mail.mail_admins with 5 arguments: subject, message, fail_silently as boolean True, tml_message as html_message,
def connection ( self ) :	and connection as the result of the method self.connection.   define the connection with an argument self.
return get_connection ( backend = self . email_backend , fail_silently = True )	call the function get_connection with 2 arguments: backend set to self.email_backend and fail_silently set to boolean True.
def format_subject ( self , subject ) :	define the method format_subject with 2 arguments: self and subject.
\formatted_subject = subject . replace ( '\\n' , '\\\\n' ) . replace ( '\\r' , '\\\\r' )\	\replace every occurrence of '\\n' in subject with '\\\\n' and replace every occurrence of '\\r' in subject with '\\\\r',\
return formatted_subject [ : 989 ]	substitute the result for formatted_subject.   return first 989 elements of formatted_subject.
class CallbackFilter ( logging . Filter ) :	derive the class CallbackFilter from logging.Filter base class.
def __init__ ( self , callback ) :	define the method __init__ with 2 arguments: self and callback.
self . callback = callback	substitute callback for self.callback.
def filter ( self , record ) :	define the method filter with 2 arguments: self and record.
if self . callback ( record ) :	call the method self.callback with an argument record, if the result evaluates to true,
return 1	return integer 1.
return 0	return integer 0.
class RequireDebugFalse ( logging . Filter ) :	derive the class RequireDebugFalse from logging.Filter base class.
def filter ( self , record ) :	define the method filter with 2 arguments: self and record.
return not settings . DEBUG	if settings.DEBUG is true, return boolean False, otherwise return boolean True.
class RequireDebugTrue ( logging . Filter ) :	derive the class RequireDebugTrue from logging.Filter base class.
def filter ( self , record ) :	define the method filter with 2 arguments: self and record.
return settings . DEBUG	return settings.DEBUG.
try :	try,
from functools import lru_cache	from functools import lru_cache.
except ImportError :	if ImportError exception is caught.
from collections import namedtuple	from collections import namedtuple.
from functools import update_wrapper	from functools import update_wrapper.
from threading import RLock	from threading import RLock.
_CacheInfo = namedtuple ( 'CacheInfo' , [ 'hits' , 'misses' , 'maxsize' , 'currsize' ] )	_CacheInfo is an instance of namedtuple class created with 2 arguments: string 'CacheInfo' and a list with 4 elements: string 'hits',
class _HashedSeq ( list ) :	misses, 'maxsize' and 'currsize'.   derive class _HashedSeq from list base class.
__slots__ = 'hashvalue'	__slots__ is a string 'hashvalue'.
def __init__ ( self , tup , hash = hash ) :	define the method __init__ with 3 arguments: self, tup and hash set to hash.
self [ : ] = tup	substitute tup for elements of self.
self . hashvalue = hash ( tup )	get the hash value of the tup, substitute it for self.hashvalue.
def __hash__ ( self ) :	define the method __hash__ with an argument self.
return self . hashvalue	return self.hashvalue.
def _make_key ( args , kwds , typed ,  kwd_mark = ( object ( ) , ) ,  fasttypes = { int , str , frozenset , type ( None ) } ,  sorted = sorted , tuple = tuple , type = type , len = len ) :	define the function _make_key with 9 arguments: args, kwds, typed, kwd_mark as a tuple with an element result of the function object,
key = args	substitute args for key.
if kwds :	if kwds is true,
sorted_items = sorted ( kwds . items ( ) )	sort elements of kwds, substitute the result for sorted_items.
key += kwd_mark	increment key by kwd_mark.
for item in sorted_items :	for every item in sorted_items,
key += item	increment key by item.
if typed :	if typed is true,
key += tuple ( type ( v ) for v in args )	create a tuple out of types of v, for every v in args, extend key tuple with the result.
if kwds :	if kwds is true,
key += tuple ( type ( v ) for k , v in sorted_items )	create a tuple out of types of v, for every k and v in sorted_items, extend key tuple with the result.
elif len ( key ) == 1 and type ( key [ 0 ] ) in fasttypes :	otherwise if length of key equals integer 1 and type of first element of key is contained in fasttypes,
return key [ 0 ]	return first element of key.
return _HashedSeq ( key )	return instance of _HashedSeq class, created with an argument key.
def lru_cache ( maxsize = 100 , typed = False ) :	define the function lru_cache with 2 arguments maxsize set to integer 100 and typed set to boolean False.
def decorating_function ( user_function ) :	define the function decorating_function with an argument user_function.
cache = dict ( )	cache is an empty dictionary.
stats = [ 0 , 0 ]	stats is an list with 2 elements: 2 integers 0.
HITS , MISSES = 0 , 1	HITS and MISSES are integer 0 and 1, respectively.
make_key = _make_key	substitute _make_key for make_key.
cache_get = cache . get	substitute cache.get for cache_get.
_len = len	substitute len for _len.
lock = RLock ( )	lock is an instance of RLock class.
root = [ ]	root is an empty list.
root [ : ] = [ root , root , None , None ]	root is a list with elements: root, root, None and None.
nonlocal_root = [ root ]	nonlocal_root is an list with an element root.
PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3	substitute integers 0, 1, 2 and 3 for PREV, NEXT, KEY and RESULT, respectivley.
if maxsize == 0 :	if maxsize equals integer 0,
def wrapper ( * args , ** kwds ) :	define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  result = user_function ( * args , ** kwds )	call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
stats [ MISSES ] += 1	increment stats dictionary value under the MISSES key by integer 1.
return result	return result.
elif maxsize is None :	otherwise if maxsize is None,
def wrapper ( * args , ** kwds ) :	define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  key = make_key ( args , kwds , typed )	call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key.
result = cache_get ( key , root )	call the function cache_get with 2 arguments: key and root, substitute the result for result.
if result is not root :	if result is not root,
    stats [ HITS ] += 1	increment stats dictionary value under the HITS key by integer 1.
return result	return result.
result = user_function ( * args , ** kwds )	call the function user_function with 2 arguments unpacked list args and unpacked dictionary kwds, substitute the result for result.
cache [ key ] = result	substitute result for cache dictionary value under the key key.
stats [ MISSES ] += 1	increment stats dictionary value under the MISSES key by integer 1.
return result	return result.
else :	if not,
def wrapper ( * args , ** kwds ) :	define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  key = make_key ( args , kwds , typed ) if kwds or typed else args	if kwds is true or typed is true, call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key,
with lock :	otherwise substitute args for key.   with lock,
    link = cache_get ( key )	call the function cache_get with an argument key, substitute the result for link.
if link is not None :	if link is not None,
          root , = nonlocal_root	substitute nonlocal_root for a tuple with an element root.
link_prev , link_next , key , result = link	substitute link for link_prev, link_next, key and result, respectively.
link_prev [ NEXT ] = link_next	substitute link_next for value under the NEXT key of the link_prev dictionary.
link_next [ PREV ] = link_prev	substitute link_prev for value under the PREV key of the link_next dictionary.
last = root [ PREV ]	substitute value under the PREV key of the root dictionary for last.
last [ NEXT ] = root [ PREV ] = link	substitute link for values under the NEXT key of the last dictionary and PREV key of the root dictionary.
link [ PREV ] = last	substitute last for value under the PREV key of the link dictionary.
link [ NEXT ] = root	substitute root for value under the NEXT key of the link dictionary.
stats [ HITS ] += 1	increment stats dictionary value under the HITS key by integer 1.
return result	return result.
result = user_function ( * args , ** kwds )	call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
with lock :	with lock,
    root , = nonlocal_root	substitute nonlocal_root for tuple root.
if key in cache :	if key is contained in cache,
            pass	do nothing.
elif _len ( cache ) >= maxsize :	otherwise if result of the call to the function _len with an argument cache is greater than or equal to maxsize,
          oldroot = root	substitute root for oldroot.
oldroot [ KEY ] = key	substitute key for value under the KEY key of the oldroot dictionary.
oldroot [ RESULT ] = result	substitute result for value under the RESULT key of the oldroot dictionary.
root = nonlocal_root [ 0 ] = oldroot [ NEXT ]	substitute value under the NEXT key of the oldroot dictionary for root and first element of nonlocal_root.
oldkey = root [ KEY ]	  substitute value under the KEY key of the root dictionary for oldkey.
oldvalue = root [ RESULT ]	  substitute value under the RESULT key of the root dictionary for oldvalue.
root [ KEY ] = root [ RESULT ] = None	root dictionary values under the KEY and RESULT keys are both None.
del cache [ oldkey ]	delete entry under the oldkey key of the cache dictionary.
cache [ key ] = oldroot	substitute oldroot for value under the key key of the cache dictionary.
else :	if not,
          last = root [ PREV ]	  substitute value under the PREV key of the root dictionary for last.
link = [ last , root , key , result ]	link is a list with 4 elements: last, root, key and result.
last [ NEXT ] = root [ PREV ] = cache [ key ] = link	substitute link for value under the NEXT key of the last dictionary, for value under the PREV key of the root dictionary,
stats [ MISSES ] += 1	for value under the key key of the cache dictionary.   increment stats dictionary value under the MISSES key by integer 1.
return result	return result.
def cache_info ( ) :	define the function cache_info.
with lock :	with lock,
return _CacheInfo ( stats [ HITS ] , stats [ MISSES ] , maxsize , len ( cache ) )	return an instance of _CacheInfo class, created with 4 arguments: value under the HITS key of the stats dictionary,
def cache_clear ( ) :	value under the MISSES key of the stats dictionary, maxsize and length of cache.   define the function cache_clear.
with lock :	with lock,
cache . clear ( )	call the method cache.clear.
root = nonlocal_root [ 0 ]	substitute first element of nonlocal_root for root.
root [ : ] = [ root , root , None , None ]	root is an list with 4 elements: root, root, None and None.
stats [ : ] = [ 0 , 0 ]	stats is a list with 2 elements: 2 integers 0.
wrapper . __wrapped__ = user_function	substitute user_function for wrapper.__wrapped__.
wrapper . cache_info = cache_info	substitute cache_info for wrapper.cache_info.
wrapper . cache_clear = cache_clear	substitute cache_clear for wrapper.cache_clear.
return update_wrapper ( wrapper , user_function )	call the function update_wrapper with 2 arguments: wrapper and user_function, return the result.
return decorating_function	return decorating_function.
from __future__ import absolute_import	from __future__ import absolute_import into default name space.
import copy	import module copy.
from importlib import import_module	from importlib import import_module into default name space.
import os	import module os.
import sys	import module sys.
import warnings	import module warnings.
from django . core . exceptions import ImproperlyConfigured	from django.core.exceptions import ImproperlyConfigured into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
def import_string ( dotted_path ) :	define the function import_string with an argument dotted_path.
try :	try,
module_path , class_name = dotted_path . rsplit ( '.' , 1 )	split dotted_path into two parts from the right at the '.' character, assign the result to module_path and class_name, respectively.
except ValueError :	if ValueError exception is caught,
msg = '%s doesn't look like a module path' % dotted_path	msg is a string '%s doesn't look like a module path' formated with dotted_path.
six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )	call the function six.reraise with 3 arguments: ImportError, instance of ImportError class created with an argument msg,
module = import_module ( module_path )	and third element of result of the function sys.exc_info.   call the function import_module with an argument module_path, substitute the result for module.
try :	try,
return getattr ( module , class_name )	get attribute class_name form the module object, return it.
except AttributeError :	if AttributeError exception is caught,
msg = 'Module '%s' does not define a '%s' attribute/class' % (  dotted_path , class_name )	msg is a string 'Module '%s' does not define a '%s' attribute/class' formated with dotted_path and class_name, respectively.
six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )	call the function six.reraise with 3 arguments: ImportError, instance of ImportError class created with an argument msg,
def import_by_path ( dotted_path , error_prefix = '' ) :	and third element of result of the function sys.exc_info.   define the function import_by_path with 2 arguments dotted_path and error_prefix set to an empty string..
warnings . warn (  'import_by_path() has been deprecated. Use import_string() instead.' ,  RemovedInDjango19Warning , stacklevel = 2 )	call the function warnings.warn with 3 arguments: string 'import_by_path() has been deprecated. Use import_string() instead.',
try :	RemovedInDjango19Warning and stacklevel as integer 2.   try,
attr = import_string ( dotted_path )	call the function import_string with an argument dotted_path, substitute the result for attr.
except ImportError as e :	if ImportError, renamed to e, exception is caught,
six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) ,  sys . exc_info ( ) [ 2 ] )	call the function six.reraise with 3 arguments: ImproperlyConfigured, instance of ImproperlyConfigured class created with msg,
return attr	and third element of the function sys.exc_info result.   return attr.
def autodiscover_modules ( * args , ** kwargs ) :	define the function autodiscover_modules with 2 arguments unpacked list args and unpacked dictionary kwargs.
from django . apps import apps	from django.apps import apps.
register_to = kwargs . get ( 'register_to' )	get value under the 'register_to' key of the kwargs dictionary, substitute it for register_to.
for app_config in apps . get_app_configs ( ) :	call the method apps.get_app_configs, for every app_config in the result,
try :	try,
if register_to :	if register_to is true,
before_import_registry = copy . copy ( register_to . _registry )	call the method copy.copy with an argument register_to._registry, substitute the result for before_import_registry.
for module_to_search in args :	for every module_to_search in args,
import_module ( '%s.%s' % ( app_config . name , module_to_search ) )	call the function import_module with an argument string '%s.%s', where '%s' is replaced with app_config.name and module_to_search.
except :	  is exception is caught,
if register_to :	if register_to is true,
register_to . _registry = before_import_registry	substitute before_import_registry for register_to._registry.
if module_has_submodule ( app_config . module , module_to_search ) :	if call to the function module_has_submodule with 2 arguments: app_config.module and module_to_search evaluates to true,
raise	raise an exception,
if sys . version_info [ : 2 ] >= ( 3 , 3 ) :	if first and second element of sys.version_info are both equal to integer 3,
if sys . version_info [ : 2 ] >= ( 3 , 4 ) :	if first and second element of sys.version_info are equal to integers 3 and 4, respectively,
from importlib . util import find_spec as importlib_find	from importlib.util import find_spec as importlib_find.
else :	if not,
from importlib import find_loader as importlib_find	from importlib import find_loader as importlib_find.
def module_has_submodule ( package , module_name ) :	define the function module_has_submodule with 2 arguments: package and module_name.
try :	try,
package_name = package . __name__	substitute package.__name__ for package_name.
package_path = package . __path__	substitute package.__path__ for package_path.
except AttributeError :	if AttributeError exception is caught,
return False	return boolean False.
full_module_name = package_name + '.' + module_name	concatenate package_name, string '.' and module_name, substitute it for full_module_name.
return importlib_find ( full_module_name , package_path ) is not None	call the function importlib_find with 2 arguments: full_module_name and package_path, if the result is not None, return boolean True,
else :	otherwise return boolean False.   if not,
import imp	import imp.
def module_has_submodule ( package , module_name ) :	define the function module_has_submodule with 2 arguments: package and module_name.
name = '.' . join ( [ package . __name__ , module_name ] )	join package.__name__ and module_name into a string separated with '.', substitute it for name.
try :	try,
return sys . modules [ name ] is not None	if value under the name key of the sys.modules dictionary is not None, return boolean True, otherwise return boolean False.
except KeyError :	if KeyError exception is caught,
pass	do nothing.
try :	try,
package_path = package . __path__	substitute package.__path__ for package_path.
except AttributeError :	if AttributeError exception is caught,
return False	return boolean False.
for finder in sys . meta_path :	for every finder in sys.meta_path,
if finder . find_module ( name , package_path ) :	if call to the method finder.find_module with 2 arguments: name and package_path evaluates to true,
return True	return boolean True.
for entry in package_path :	for every entry in package_path,
try :	try,
finder = sys . path_importer_cache [ entry ]	substitute the value under the entry key of the sys.path_importer_cache dictionary for finder.
if finder is None :	if finder is None,
  try :	try,
    file_ , _ , _ = imp . find_module ( module_name , [ entry ] )	call the method imp.find_module with 2 arguments: module_name and list containing element entry, assign the result to file_, _,
if file_ :	and _, respectively.   if file_ is true,
        file_ . close ( )	close file_ file descriptor.
return True	return boolean True.
except ImportError :	if ImportError exception is caught,
    continue	skip this loop iteration,
elif finder . find_module ( name ) :	otherwise if call to the method finder.find_module with an argument name evaluates to true,
return True	return boolean True.
else :	if not,
continue	skip this loop iteration,
except KeyError :	if KeyError exception is caught,
for hook in sys . path_hooks :	for every hook in sys.path_hooks,
try :	try,
    finder = hook ( entry )	call the function hook with an argument entry, substitute the result for finder.
if finder . find_module ( name ) :	if call to the method finder.find_module with an argument name evaluates to true,
        return True	return boolean True.
else :	if not,
          break	break from the loop execution,
except ImportError :	if ImportError exception is caught,
      continue	skip this loop iteration,
else :	if not,
  if os . path . isdir ( entry ) :	if entry is a directory,
    try :	try,
        file_ , _ , _ = imp . find_module ( module_name , [ entry ] )	call the method imp.find_module with 2 arguments: module_name and list containing element entry, assign the result to file_, _,
if file_ :	and _, respectively.   if file_ is true,
            file_ . close ( )	close file_ file descriptor.
return True	return boolean True.
except ImportError :	if ImportError exception is caught,
        pass	do nothing.
else :	if not,
return False	return boolean False.
from django . conf import settings	from django.conf import settings into default name space.
from django . utils . safestring import mark_safe	from django.utils.safestring import mark_safe into default name space.
from django . utils import six	from django.utils import six into default name space.
def format ( number , decimal_sep , decimal_pos = None , grouping = 0 , thousand_sep = '' ,  force_grouping = False ) :	define the function format with 6 arguments: number, decimal_sep, decimal_pos set to None, grouping set to integer 0,
use_grouping = settings . USE_L10N and settings . USE_THOUSAND_SEPARATOR	if settings.USE_L10N is true, substitute settings.USE_THOUSAND_SEPARATOR for use_grouping,
use_grouping = use_grouping or force_grouping	otherwise substitute settings.USE_L10N for use_grouping.   if use_grouping is true substitute it for use_grouping, otherwise substitute force_grouping for use_grouping.
use_grouping = use_grouping and grouping > 0	if use_grouping is true and grouping is greater than integer 0, use_grouping is boolean True, otherwise it is boolean False.
if isinstance ( number , int ) and not use_grouping and not decimal_pos :	if number is an integer and use_grouping is false and decimal_pos is false,
return mark_safe ( six . text_type ( number ) )	call the function six.text_type with an argument number, use the result as an argument for the call to the function mark_safe,
sign = ''	return the result.   sign is an empty string.
str_number = six . text_type ( number )	call the function six.text_type with an argument number, substitute the result for str_number.
if str_number [ 0 ] == '-' :	if first element of str_number equals a string '-'.
sign = '-'	sign is a string '-'.
str_number = str_number [ 1 : ]	remove the first element from str_number.
if '.' in str_number :	if '.' is not contained in str_number,
int_part , dec_part = str_number . split ( '.' )	split str_number by '.', substitute the result for int_part and dec_part, respectively.
if decimal_pos is not None :	if decimal_pos is not None,
dec_part = dec_part [ : decimal_pos ]	substitute first decimal_pos elements of dec_part for dec_part.
else :	if not,
int_part , dec_part = str_number , ''	substitute str_number and an empty string for int_part and dec_part.
if decimal_pos is not None :	if decimal_pos is not None
dec_part = dec_part + ( '0' * ( decimal_pos - len ( dec_part ) ) )	subtract length of dec_part from decimal_pos, multiply the number of character '0' by the result,
if dec_part :	append the resulting string to dec_part, substitute it for dec_part.   if dec_part is true,
dec_part = decimal_sep + dec_part	add decimal_sep and dec_part, substitute the result for dec_part.
if use_grouping :	if use_grouping is true,
int_part_gd = ''	int_part_gd is an empty string.
for cnt , digit in enumerate ( int_part [ : : - 1 ] ) :	for every cnt and digit in enumerated list int_part with reversed ordering of elements,
if cnt and not cnt % grouping :	if cnt is true and remained of dividing cnt with grouping is zero,
int_part_gd += thousand_sep	increment int_part_gd by thousand_sep.
int_part_gd += digit	append digit to int_part_gd.
int_part = int_part_gd [ : : - 1 ]	invert the ordering of elements of int_part_gd, substitute it for int_part.
return sign + int_part + dec_part	sum sign, int_part and dec_part, return the result.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . six . moves import zip	from django.utils.six.moves import zip into default name space.
ESCAPE_MAPPINGS = {  'A' : None ,  'b' : None ,  'B' : None ,  'd' : '0' ,  'D' : 'x' ,  's' : ' ' ,  'S' : 'x' ,  'w' : 'x' ,  'W' : '!' ,  'Z' : None ,  }	ESCAPE_MAPPINGS is an dictionary with 10 initial entries: None for 'A', None for 'b', None for 'B', '0' for 'd', 'x' for 'D',
class Choice ( list ) :	' ' for 's', 'x' for 'S', 'x' for 'W', '!' for 'W' and None for 'Z'.   derive the class Choice from list base class.
class Group ( list ) :	derive the class Group from list base class.
class NonCapture ( list ) :	derive the class NonCapture from list base class.
def normalize ( pattern ) :	define the function normalize with an argument pattern.
result = [ ]	result is an empty list.
non_capturing_groups = [ ]	non_capturing_groups is an empty list.
consume_next = True	consume_next is boolean True.
pattern_iter = next_char ( iter ( pattern ) )	call the function next_char with an argument iterator pattern, substitute the result for pattern_iter.
num_args = 0	num_args is an integer 0.
try :	try,
ch , escaped = next ( pattern_iter )	get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
except StopIteration :	if StopIteration exception,
return [ ( '' , [ ] ) ]	return a list with an element tuple with 2 elements: an empty string and an empty list.
try :	try,
while True :	endless loop,
if escaped :	if escaped is true,
result . append ( ch )	append ch to result.
elif ch == '.' :	otherwise if ch equals a string '.',
result . append ( '.' )	append string '.' to result.
elif ch == '|' :	otherwise if ch equals a string '|',
raise NotImplementedError ( 'Awaiting Implementation' )	raise an NotImplementedError exception with an argument string 'Awaiting Implementation'.
elif ch == '^' :	otherwise if ch equals a string '^',
pass	do nothing.
elif ch == '$' :	otherwise if ch equals a string '$',
break	skip this loop iteration.
elif ch == ')' :	otherwise if ch equals a string ')',
  start = non_capturing_groups . pop ( )	remove first element from non_capturing_groups, substitute it for start.
inner = NonCapture ( result [ start : ] )	inner is an instance of NonCapture, created with elements of result from start index to the end.
result = result [ : start ] + [ inner ]	append list with element inner to list containing first start elements of result, substitute it for result.
elif ch == '[' :	otherwise if ch equals a string '[',
ch , escaped = next ( pattern_iter )	get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
result . append ( ch )	append ch to result.
ch , escaped = next ( pattern_iter )	get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
while escaped or ch != ']' :	while escaped is true or ch is not equal to a string ']',
ch , escaped = next ( pattern_iter )	get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
elif ch == '(' :	otherwise if ch equals a string '(',
ch , escaped = next ( pattern_iter )	get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
if ch != '?' or escaped :	if ch is not equal to a sring '?' or escaped is true,
  name = '_%d' % num_args	name is a string '_%d' formated with num_args.
num_args += 1	increment num_args by one.
result . append ( Group ( ( ( '%%(%s)s' % name ) , name ) ) )	instantiate a class Group with 2 arguments: string '%%(%s)s' formated with name, and name, append it to result.
walk_to_end ( ch , pattern_iter )	call the function walk_to_end with 2 arguments: ch and pattern_iter.
else :	if not,
ch , escaped = next ( pattern_iter )	get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
if ch in 'iLmsu#' :	if ch is contained in string 'iLmsu#',
      walk_to_end ( ch , pattern_iter )	call the function walk_to_end with 2 arguments: ch and pattern_iter.
elif ch == ':' :	otherwise if ch equals a string ':',
      non_capturing_groups . append ( len ( result ) )	append length of result to non_capturing_groups.
elif ch != 'P' :	otherwise if ch equals a string 'P',
else :	if not,
    ch , escaped = next ( pattern_iter )	get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
if ch not in ( '<' , '=' ) :	if ch is not equal to string '<' or string '=',
if ch == '<' :	if ch equals a string '<',
        terminal_char = '>'	terminal_char is an string '>'.
else :	if not,
        terminal_char = ')'	terminal_char is an string ')'.
name = [ ]	name is an empty list.
ch , escaped = next ( pattern_iter )	get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
while ch != terminal_char :	while ch is not equal to terminal_char,
        name . append ( ch )	append ch to result.
ch , escaped = next ( pattern_iter )	get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
param = '' . join ( name )	join elements of name into a string, substitute it for param.
if terminal_char != ')' :	  if terminal_char is not equal to string ')',
        result . append ( Group ( ( ( '%%(%s)s' % param ) , param ) ) )	instantiate a class Group with 2 arguments: string '%%(%s)s' formated with param, and param, append it to result.
walk_to_end ( ch , pattern_iter )	call the function walk_to_end with 2 arguments: ch and pattern_iter.
else :	if not,
        result . append ( Group ( ( ( '%%(%s)s' % param ) , None ) ) )	instantiate a class Group with 2 arguments: string '%%(%s)s' formated with param, and None, append it to result.
elif ch in '*?+{' :	otherwise if ch is contained in string '*?+{',
count , ch = get_quantifier ( ch , pattern_iter )	call the function get_quantifier with 2 arguments: ch and pattern_iter, substitute the result for count and ch, respectively.
if ch :	if ch is true,
    consume_next = False	consume_next is boolean False.
if count == 0 :	if count is equal to integer 0.
if contains ( result [ - 1 ] , Group ) :	if call to the function contains with 2 arguments: last element of result and Group, evaluates to true,
          result [ - 1 ] = Choice ( [ None , result [ - 1 ] ] )	last element of result is an instance of Choice class, created with an argument list with 2 elements: None and last element of result.
else :	if not,
    result . pop ( )	remove the first element from result.
elif count > 1 :	otherwise if count is greater than integer 1,
result . extend ( [ result [ - 1 ] ] * ( count - 1 ) )	create a list with count decremented by 1 number of last element of result elements, extend list result with it.
else :	if not,
result . append ( ch )	append ch to result.
if consume_next :	if consume_next is true,
ch , escaped = next ( pattern_iter )	get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
else :	if not,
consume_next = True	consume_next is boolean True.
except StopIteration :	if StopIteration exception,
pass	do nothing.
except NotImplementedError :	if NotImplementedError exception,
return [ ( '' , [ ] ) ]	return a list with an element tuple with 2 elements: an empty string and an empty list.
return list ( zip ( * flatten_result ( result ) ) )	call the function flatten_result with an argument result, unpack the resulting list and zip it in the list of tuples, return the result.
def next_char ( input_iter ) :	define the function next_char with an argument input_iter.
for ch in input_iter :	for every ch in input_iter,
\if ch != '\\\\' :\	\if ch is not equal to string '\\\\'.\
yield ch , False	yield ch and boolean False.
continue	skip this loop iteration.
ch = next ( input_iter )	get the next element of the iterable pattern_iter, assign the result for ch.
representative = ESCAPE_MAPPINGS . get ( ch , ch )	get the value under ch key of the ESCAPE_MAPPINGS dictionary, if it exists substitute it for representative, if not substitute ch for representative.
if representative is None :	if representative is None,
continue	skip this loop iteration.
yield representative , True	yield representative and boolean True.
def walk_to_end ( ch , input_iter ) :	define the function walk_to_end with 2 arguments ch and input_iter.
if ch == '(' :	if ch equal a string '(',
nesting = 1	nesting is integer 1.
else :	if not,
nesting = 0	nesting is integer 0.
for ch , escaped in input_iter :	for every ch and escaped in input_iter,
if escaped :	if escaped is true,
continue	skip this loop iteration.
elif ch == '(' :	otherwise if ch equals a string '(',
nesting += 1	increment nesting by one.
elif ch == ')' :	otherwise if ch equals a string ')',
if not nesting :	if nesting is false,
return	return nothing.
nesting -= 1	decrement nesting by one.
def get_quantifier ( ch , input_iter ) :	define the function get_quantifier with 2 arguments ch and input_iter.
if ch in '*?+' :	if ch is contained in string '*?+',
try :	try,
ch2 , escaped = next ( input_iter )	get the next element of the iterable pattern_iter, assign the result for ch2 and escaped, respectively.
except StopIteration :	if StopIteration exception,
ch2 = None	ch2 is None.
if ch2 == '?' :	if ch2 equals string '?',
ch2 = None	ch2 is None.
if ch == '+' :	if ch equals string '+',
return 1 , ch2	return integer 1 and ch2.
return 0 , ch2	return integer 0 and ch2.
quant = [ ]	quant is an empty list.
while ch != '}' :	while ch is not equal to a string '}',
ch , escaped = next ( input_iter )	get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
quant . append ( ch )	append ch to quant.
quant = quant [ : - 1 ]	remove last element for quant.
values = '' . join ( quant ) . split ( ',' )	join elements of quant into a string, split it by string ',', substitute the result for values.
try :	try,
ch , escaped = next ( input_iter )	get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
except StopIteration :	if StopIteration exception,
ch = None	ch is None.
if ch == '?' :	if ch equals a string '?',
ch = None	ch is None.
return int ( values [ 0 ] ) , ch	convert first element of values into a integer, return the result and ch.
def contains ( source , inst ) :	define the function contains with 2 arguments source and inst.
if isinstance ( source , inst ) :	if source is an instance of inst class,
return True	return boolean True.
if isinstance ( source , NonCapture ) :	if source is an instance of NonCapture class,
for elt in source :	for every elt in source,
if contains ( elt , inst ) :	call the function contains with 2 arguments: elt and inst, if it evaluates to true,
return True	return boolean True.
return False	return boolean False.
def flatten_result ( source ) :	define the function flatten_result with an argument source.
if source is None :	if source is None,
return [ '' ] , [ [ ] ]	return a list containing an empty string and a list containing an empty list.
if isinstance ( source , Group ) :	if source is an instance of Group class,
if source [ 1 ] is None :	if second element of source is None,
params = [ ]	params is an empty list,
else :	if not,
params = [ source [ 1 ] ]	params is a list with second element of source as a element.
return [ source [ 0 ] ] , [ params ]	return a list containing first element of source and a list containing params.
result = [ '' ]	result is a list containing an empty string.
result_args = [ [ ] ]	result_args is a list containing an empty list.
pos = last = 0	pos and last are integer 0.
for pos , elt in enumerate ( source ) :	for every pos and elt in enumerated iterable source,
if isinstance ( elt , six . string_types ) :	if elt is an instance of six.string_types class,
continue	skip this loop iteration.
piece = '' . join ( source [ last : pos ] )	join source list elements from last till pos indexes into a string, substitute the result for piece.
if isinstance ( elt , Group ) :	if elt is an instance of Group class,
piece += elt [ 0 ]	increment piece by firs element of elt.
param = elt [ 1 ]	substitute second element of elt for param.
else :	if not,
param = None	param is None.
last = pos + 1	increment pos by one, substitute the result for last.
for i in range ( len ( result ) ) :	for every i in range of integers from 0 to length of result, not included,
result [ i ] += piece	increment i-th element of result by piece.
if param :	if param is true,
result_args [ i ] . append ( param )	append param to i-th element of result_args.
if isinstance ( elt , ( Choice , NonCapture ) ) :	if elt is an instance of Choice or NonCapture classes,
if isinstance ( elt , NonCapture ) :	if elt is an instance of NonCapture class,
elt = [ elt ]	elt is an list with an element elt.
inner_result , inner_args = [ ] , [ ]	inner_result and inner_args are empty lists.
for item in elt :	for every item in elt,
res , args = flatten_result ( item )	call the function flatten_result with an argument item, assign the result to res and args, respectively.
inner_result . extend ( res )	extend list inner_result with res.
inner_args . extend ( args )	extend list inner_args with args.
new_result = [ ]	new_result is an empty list.
new_args = [ ]	new_args is an empty list.
for item , args in zip ( result , result_args ) :	zip elements of result and result_args into a list of tuples, for every item and args in the result,
for i_item , i_args in zip ( inner_result , inner_args ) :	zip elements of inner_result and inner_args into a list of tuples, for every i_item and i_args in the result,
new_result . append ( item + i_item )	sum item and i_item together, append the result to new_result.
new_args . append ( args [ : ] + i_args )	append i_args to args, append new_args with the result.
result = new_result	substitute new_result for result.
result_args = new_args	substitute new_args for result_args.
if pos >= last :	if pos is greater than or equal to last,
piece = '' . join ( source [ last : ] )	join elements of list source from index last to the end into a string, substitute it for piece.
for i in range ( len ( result ) ) :	for every i in range of integers from 0 to length of result, not included,
result [ i ] += piece	increment i-th element of result by piece.
return result , result_args	return result and result_args.
from django . utils . functional import curry , Promise	from django.utils.functional import curry and Promise into default name space.
from django . utils import six	from django.utils import six into default name space.
class EscapeData ( object ) :	derive the class EscapeData from object base class.
pass	do nothing.
class EscapeBytes ( bytes , EscapeData ) :	derive the class EscapeBytes from bytes and EscapeData base classes.
pass	do nothing.
class EscapeText ( six . text_type , EscapeData ) :	derive the class EscapeText from six.text_type and EscapeData base classes.
pass	do nothing.
if six . PY3 :	if six.PY3 is true,
EscapeString = EscapeText	substitute EscapeText for EscapeString.
else :	if not,
EscapeString = EscapeBytes	substitute EscapeBytes for EscapeString.
EscapeUnicode = EscapeText	substitute EscapeText for EscapeUnicode.
class SafeData ( object ) :	derive the class SafeData from object base class.
def __html__ ( self ) :	define the method __html__ with an argument self.
return self	return self.
class SafeBytes ( bytes , SafeData ) :	derive the class SafeBytes from bytes and SafeData base classes.
def __add__ ( self , rhs ) :	define the method __add__ with 2 arguments self and rhs.
t = super ( SafeBytes , self ) . __add__ ( rhs )	call the __add__ method with an arguments rhs from the base class of the class SafeBytes, substitute the result for t.
if isinstance ( rhs , SafeText ) :	if rhs is an instance of SafeText,
return SafeText ( t )	return an instance of SafeText, created with an argument t.
elif isinstance ( rhs , SafeBytes ) :	otherwise if rhs is an instance of SafeBytes,
return SafeBytes ( t )	return an instance of SafeBytes, created with an argument t.
return t	return t.
def _proxy_method ( self , * args , ** kwargs ) :	define the method _proxy_method with 3 arguments self, unpacked list args and unpacked dictionary kwargs.
method = kwargs . pop ( 'method' )	remove kwargs dictionary element under the 'method' key, substitute it for method.
data = method ( self , * args , ** kwargs )	call the function method with 3 arguments: self, unpacked list args and unpacked dictionary kwargs, substitute the result for data.
if isinstance ( data , bytes ) :	if data is an instance of bytes,
return SafeBytes ( data )	return an instance of SafeBytes, created with an argument data.
else :	if not,
return SafeText ( data )	return an instance of SafeText, created with an argument data.
decode = curry ( _proxy_method , method = bytes . decode )	call the function curry with 2 arguments: _proxy_method and method set to bytes.decode, substitute the result for decode.
class SafeText ( six . text_type , SafeData ) :	derive the class SafeText from six.text_type and SafeData base classes.
def __add__ ( self , rhs ) :	define the method __add__ with 2 arguments self and rhs.
t = super ( SafeText , self ) . __add__ ( rhs )	call the __add__ method with an arguments rhs from the base class of the class SafeText, substitute the result for t.
if isinstance ( rhs , SafeData ) :	if rhs is an instance of SafeData.
return SafeText ( t )	return an instance of SafeText, created with an argument t.
return t	return t.
def _proxy_method ( self , * args , ** kwargs ) :	define the method _proxy_method with 3 arguments self, unpacked list args and unpacked dictionary kwargs.
method = kwargs . pop ( 'method' )	remove kwargs dictionary element under the 'method' key, substitute it for method.
data = method ( self , * args , ** kwargs )	call the function method with 3 arguments: self, unpacked list args and unpacked dictionary kwargs, substitute the result for data.
if isinstance ( data , bytes ) :	if data is an instance of bytes.
return SafeBytes ( data )	return an instance of SafeBytes, created with an argument data.
else :	if not,
return SafeText ( data )	return an instance of SafeText, created with an argument data.
encode = curry ( _proxy_method , method = six . text_type . encode )	call the function curry with 2 arguments: _proxy_method and method set to six.text_type.encode, substitute the result for encode.
if six . PY3 :	if six.PY3 is true,
SafeString = SafeText	substitute SafeText for SafeString.
else :	if not,
SafeString = SafeBytes	substitute SafeBytes for SafeString.
SafeUnicode = SafeText	substitute SafeText for SafeUnicode.
def mark_safe ( s ) :	define the function mark_safe with an argument s.
if isinstance ( s , SafeData ) :	if s is an instance of SafeData.
return s	return s.
if isinstance ( s , bytes ) or ( isinstance ( s , Promise ) and s . _delegate_bytes ) :	if s is an instance of bytes or Promise and s._delegate_bytes is true,
return SafeBytes ( s )	return an instance of SafeBytes, created with an argument s.
if isinstance ( s , ( six . text_type , Promise ) ) :	if s is an instance of six.text_type or Promise,
return SafeText ( s )	return an instance of SafeText, created with an argument s.
return SafeString ( str ( s ) )	return an instance of SafeText, created with an argument s converted into a string.
def mark_for_escaping ( s ) :	define the function mark_for_escaping with an argument s.
if isinstance ( s , ( SafeData , EscapeData ) ) :	if s is an instance of SafeData or EscapeData,
return s	return s.
if isinstance ( s , bytes ) or ( isinstance ( s , Promise ) and s . _delegate_bytes ) :	if s is an instance of bytes or Promise and s._delegate_bytes is true,
return EscapeBytes ( s )	return an instance of EscapeBytes, created with an argument s.
if isinstance ( s , ( six . text_type , Promise ) ) :	if s is an instance of six.text_type or Promise,
return EscapeText ( s )	return an instance of EscapeText, created with an argument s.
return EscapeBytes ( bytes ( s ) )	return an instance of EscapeBytes, created with an argument, reuslt of the call to the function bytes with an argument s.
import operator	import module opera.
import sys	import module sys.
import types	import module types.
__author__ = 'Benjamin Peterson <benjamin@python.org>'	__author__ is a string 'Benjamin Peterson <benjamin@python.org>'.
__version__ = '1.6.1'	__version__ is a string '1.6.1'.
PY2 = sys . version_info [ 0 ] == 2	if first element of sys.version_info equals integer 2, PY2 is boolean True, otherwise it is boolean False.
PY3 = sys . version_info [ 0 ] == 3	if first element of sys.version_info equals integer 3, PY3 is boolean True, otherwise it is boolean False.
if PY3 :	if PY3 is true,
string_types = str ,	substitute str for string_types.
integer_types = int ,	substitute int for integer_types.
class_types = type ,	substitute type for class_types.
text_type = str	substitute str for text_type.
binary_type = bytes	substitute bytes for binary_type.
MAXSIZE = sys . maxsize	substitute sys.maxsize for MAXSIZE.
else :	if not,
string_types = basestring ,	substitute basestring for string_types.
integer_types = ( int , long )	integer_types is a tuple with 2 elements int and long.
class_types = ( type , types . ClassType )	class_types is a tuple with 2 elements: type and types.ClassType.
text_type = unicode	substitute unicode for text_type.
binary_type = str	substitute str for binary_type.
if sys . platform . startswith ( 'java' ) :	if sys.platform starts with string 'java',
MAXSIZE = int ( ( 1 << 31 ) - 1 )	bitwise shift integer 1 to the left by 31 spaces, substitute integer 1 from the result, convert the result to a integer, substitute it for MAXSIZE.
else :	if not,
class X ( object ) :	derive class X from the object base class.
def __len__ ( self ) :	define the method __len__ with an argument self.
return 1 << 31	bitwise shift integer 1 to the left by 31 spaces, return the result.
try :	try
len ( X ( ) )	instantiate class X, get its length.
except OverflowError :	if OverflowError exception is caught,
MAXSIZE = int ( ( 1 << 31 ) - 1 )	bitwise shift integer 1 to the left by 31 spaces, substitute integer 1 from the result, convert the result to a integer, substitute it for MAXSIZE.
else :	if not,
MAXSIZE = int ( ( 1 << 63 ) - 1 )	bitwise shift integer 1 to the left by 63 spaces, substitute integer 1 from the result, convert the result to a integer, substitute it for MAXSIZE.
del X	delete X.
def _add_doc ( func , doc ) :	define the function _add_doc with 2 arguments: func and doc.
func . __doc__ = doc	substitute doc for func.__doc__.
def _import_module ( name ) :	define the function _import_module with an argument name.
__import__ ( name )	call the function __import__ with an argument name.
return sys . modules [ name ]	return value under the name key of the sys.modules dictionary.
class _LazyDescr ( object ) :	derive class _LazyDescr from the object base class.
def __init__ ( self , name ) :	define the method __init__ with 2 arguments: self and name.
self . name = name	substitute name for self.name.
def __get__ ( self , obj , tp ) :	define the method __get__ with 3 arguments: self, obj and tp.
try :	try,
result = self . _resolve ( )	call the method self._resolve, substitute the result for result.
except ImportError :	if ImportError exception is caught,
raise AttributeError ( '%s could not be imported ' % self . name )	raise an AttributeError with an argument string '%s could not be imported ', formated with self.name.
setattr ( obj , self . name , result )	set self.name attribute of the obj object to result.
delattr ( obj . __class__ , self . name )	delete self.name attribute from the obj.__class__ object.
return result	return result.
class MovedModule ( _LazyDescr ) :	derive class MovedModule from the _LazyDescr base class.
def __init__ ( self , name , old , new = None ) :	define the method __init__ with 4 arguments: self, name, old and new set to None.
super ( MovedModule , self ) . __init__ ( name )	call the __init__ method with an argument name from the base class of the MovedModule class.
if PY3 :	if PY3 is true,
if new is None :	if new is None,
new = name	substitute name for new.
self . mod = new	substitute new for self.mod.
else :	if not,
self . mod = old	substitute old for self.mod.
def _resolve ( self ) :	define the method _resolve with an argument self.
return _import_module ( self . mod )	call the function _import_module with an argument self.mod, return the result.
def __getattr__ ( self , attr ) :	define the method __getattr__ with 2 arguments: self and attr set to None.
if ( attr in ( '__file__' , '__name__' , '__path__' ) and  self . mod not in sys . modules ) :	if attr equals any of the strings '__file__', '__name__' or '__path__' and self.mod is not contained in sys.modules,
raise AttributeError ( attr )	raise an AttributeError with an argument attr.
try :	try,
_module = self . _resolve ( )	call the method self._resolve, substitute the result for _module.
except ImportError :	if ImportError exception is caught,
raise AttributeError ( attr )	raise an AttributeError with an argument attr.
value = getattr ( _module , attr )	get attr attribute from the _module object, substitute it for value.
setattr ( self , attr , value )	set attr attribute of the self object to value.
return value	return value.
class _LazyModule ( types . ModuleType ) :	derive class _LazyModule from the types.ModuleType base class.
def __init__ ( self , name ) :	define the method __init__ with 2 arguments: self and name.
super ( _LazyModule , self ) . __init__ ( name )	call the method __init__ with an argument name form the base class of the class _LazyModule.
self . __doc__ = self . __class__ . __doc__	substitute self.__class__.__doc__ for self.__doc__.
def __dir__ ( self ) :	define the method __dir__ with an argument self.
attrs = [ '__doc__' , '__name__' ]	attrs is a list with 2 elements: strings '__doc__' and '__name__'.
attrs += [ attr . name for attr in self . _moved_attributes ]	append attr.name to attrs for every attr in self._moved_attributes.
return attrs	return attrs.
_moved_attributes = [ ]	_moved_attributes is an empty list.
class MovedAttribute ( _LazyDescr ) :	derive class MovedAttribute from the _LazyDescr base class.
def __init__ ( self , name , old_mod , new_mod , old_attr = None , new_attr = None ) :	define the method __init__ with 6 arguments: self, name, old_mod, new_mod, old_attr set to None, new_attr set to None.
super ( MovedAttribute , self ) . __init__ ( name )	call the method __init__ with an argument name form the base class of the class MovedAttribute.
if PY3 :	if PY3 is true,
if new_mod is None :	if new_mod is None,
new_mod = name	substitute name for new_mod.
self . mod = new_mod	substitute new_mod for self.mod.
if new_attr is None :	if new_attr is None,
if old_attr is None :	if old_attr is None,
new_attr = name	substitute name for new_attr.
else :	if not,
new_attr = old_attr	substitute old_attr for new_attr.
self . attr = new_attr	substitute new_attr for self.attr.
else :	if not,
self . mod = old_mod	substitute old_mod for self.mod.
if old_attr is None :	if old_attr is None,
old_attr = name	substitute name for old_attr.
self . attr = old_attr	substitute old_attr for self.attr.
def _resolve ( self ) :	define the method _resolve with an argument self.
module = _import_module ( self . mod )	call the function _import_module with an argument self.mod, substitute the result for module.
return getattr ( module , self . attr )	gett self.attr from the module object, return it.
class _MovedItems ( _LazyModule ) :	derive class _MovedItems from the _LazyModule base class.
_moved_attributes = [  MovedAttribute ( 'cStringIO' , 'cStringIO' , 'io' , 'StringIO' ) ,  MovedAttribute ( 'filter' , 'itertools' , 'builtins' , 'ifilter' , 'filter' ) ,  MovedAttribute ( 'filterfalse' , 'itertools' , 'itertools' , 'ifilterfalse' , 'filterfalse' ) ,  MovedAttribute ( 'input' , '__builtin__' , 'builtins' , 'raw_input' , 'input' ) ,  MovedAttribute ( 'map' , 'itertools' , 'builtins' , 'imap' , 'map' ) ,  MovedAttribute ( 'range' , '__builtin__' , 'builtins' , 'xrange' , 'range' ) ,  MovedAttribute ( 'reload_module' , '__builtin__' , 'imp' , 'reload' ) ,  MovedAttribute ( 'reduce' , '__builtin__' , 'functools' ) ,  MovedAttribute ( 'StringIO' , 'StringIO' , 'io' ) ,  MovedAttribute ( 'UserString' , 'UserString' , 'collections' ) ,  MovedAttribute ( 'xrange' , '__builtin__' , 'builtins' , 'xrange' , 'range' ) ,  MovedAttribute ( 'zip' , 'itertools' , 'builtins' , 'izip' , 'zip' ) ,  MovedAttribute ( 'zip_longest' , 'itertools' , 'itertools' , 'izip_longest' , 'zip_longest' ) ,   MovedModule ( 'builtins' , '__builtin__' ) ,  MovedModule ( 'configparser' , 'ConfigParser' ) ,  MovedModule ( 'copyreg' , 'copy_reg' ) ,  MovedModule ( 'dbm_gnu' , 'gdbm' , 'dbm.gnu' ) ,  MovedModule ( 'http_cookiejar' , 'cookielib' , 'http.cookiejar' ) ,  MovedModule ( 'http_cookies' , 'Cookie' , 'http.cookies' ) ,  MovedModule ( 'html_entities' , 'htmlentitydefs' , 'html.entities' ) ,  MovedModule ( 'html_parser' , 'HTMLParser' , 'html.parser' ) ,  MovedModule ( 'http_client' , 'httplib' , 'http.client' ) ,  MovedModule ( 'email_mime_multipart' , 'email.MIMEMultipart' , 'email.mime.multipart' ) ,  MovedModule ( 'email_mime_text' , 'email.MIMEText' , 'email.mime.text' ) ,  MovedModule ( 'email_mime_base' , 'email.MIMEBase' , 'email.mime.base' ) ,  MovedModule ( 'BaseHTTPServer' , 'BaseHTTPServer' , 'http.server' ) ,  MovedModule ( 'CGIHTTPServer' , 'CGIHTTPServer' , 'http.server' ) ,  MovedModule ( 'SimpleHTTPServer' , 'SimpleHTTPServer' , 'http.server' ) ,  MovedModule ( 'cPickle' , 'cPickle' , 'pickle' ) ,  MovedModule ( 'queue' , 'Queue' ) ,  MovedModule ( 'reprlib' , 'repr' ) ,  MovedModule ( 'socketserver' , 'SocketServer' ) ,  MovedModule ( '_thread' , 'thread' , '_thread' ) ,  MovedModule ( 'tkinter' , 'Tkinter' ) ,  MovedModule ( 'tkinter_dialog' , 'Dialog' , 'tkinter.dialog' ) ,  MovedModule ( 'tkinter_filedialog' , 'FileDialog' , 'tkinter.filedialog' ) ,  MovedModule ( 'tkinter_scrolledtext' , 'ScrolledText' , 'tkinter.scrolledtext' ) ,  MovedModule ( 'tkinter_simpledialog' , 'SimpleDialog' , 'tkinter.simpledialog' ) ,  MovedModule ( 'tkinter_tix' , 'Tix' , 'tkinter.tix' ) ,  MovedModule ( 'tkinter_ttk' , 'ttk' , 'tkinter.ttk' ) ,  MovedModule ( 'tkinter_constants' , 'Tkconstants' , 'tkinter.constants' ) ,  MovedModule ( 'tkinter_dnd' , 'Tkdnd' , 'tkinter.dnd' ) ,  MovedModule ( 'tkinter_colorchooser' , 'tkColorChooser' ,  'tkinter.colorchooser' ) ,  MovedModule ( 'tkinter_commondialog' , 'tkCommonDialog' ,  'tkinter.commondialog' ) ,  MovedModule ( 'tkinter_tkfiledialog' , 'tkFileDialog' , 'tkinter.filedialog' ) ,  MovedModule ( 'tkinter_font' , 'tkFont' , 'tkinter.font' ) ,  MovedModule ( 'tkinter_messagebox' , 'tkMessageBox' , 'tkinter.messagebox' ) ,  MovedModule ( 'tkinter_tksimpledialog' , 'tkSimpleDialog' ,  'tkinter.simpledialog' ) ,  MovedModule ( 'urllib_parse' , __name__ + '.moves.urllib_parse' , 'urllib.parse' ) ,  MovedModule ( 'urllib_error' , __name__ + '.moves.urllib_error' , 'urllib.error' ) ,  MovedModule ( 'urllib' , __name__ + '.moves.urllib' , __name__ + '.moves.urllib' ) ,  MovedModule ( 'urllib_robotparser' , 'robotparser' , 'urllib.robotparser' ) ,  MovedModule ( 'xmlrpc_client' , 'xmlrpclib' , 'xmlrpc.client' ) ,  MovedModule ( 'xmlrpc_server' , 'xmlrpclib' , 'xmlrpc.server' ) ,  MovedModule ( 'winreg' , '_winreg' ) ,  ]	_moved_attributes is a list with 55 initial elements, 13 of them are the results of the call to the function MovedAttribute,
for attr in _moved_attributes :	with different 3 string arguments, the others are results of the call to the function MovedModule called with 3 string arguments.   for every attr in _moved_attributes,
setattr ( _MovedItems , attr . name , attr )	set attr.name attribute of the _MovedItemst object to attr.
if isinstance ( attr , MovedModule ) :	if attr is an instance of MovedModule.
sys . modules [ __name__ + '.moves.' + attr . name ] = attr	concatenate __name__, string '.moves' and attr.name together, use it as an key to get the value from the sys.modules dictionary,
del attr	substitute attr for the obtained value.   delete attr.
_MovedItems . _moved_attributes = _moved_attributes	substitute _moved_attributes for _MovedItems._moved_attributes.
moves = sys . modules [ __name__ + '.moves' ] = _MovedItems ( __name__ + '.moves' )	append string '.moves' to __name__, use it as an argument to instantiate _MovedItems class, assign it to moves,
class Module_six_moves_urllib_parse ( _LazyModule ) :	and to value under the '.moves' appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib_parse from the _LazyModule base class.
_urllib_parse_moved_attributes = [  MovedAttribute ( 'ParseResult' , 'urlparse' , 'urllib.parse' ) ,  MovedAttribute ( 'SplitResult' , 'urlparse' , 'urllib.parse' ) ,  MovedAttribute ( 'parse_qs' , 'urlparse' , 'urllib.parse' ) ,  MovedAttribute ( 'parse_qsl' , 'urlparse' , 'urllib.parse' ) ,  MovedAttribute ( 'urldefrag' , 'urlparse' , 'urllib.parse' ) ,  MovedAttribute ( 'urljoin' , 'urlparse' , 'urllib.parse' ) ,  MovedAttribute ( 'urlparse' , 'urlparse' , 'urllib.parse' ) ,  MovedAttribute ( 'urlsplit' , 'urlparse' , 'urllib.parse' ) ,  MovedAttribute ( 'urlunparse' , 'urlparse' , 'urllib.parse' ) ,  MovedAttribute ( 'urlunsplit' , 'urlparse' , 'urllib.parse' ) ,  MovedAttribute ( 'quote' , 'urllib' , 'urllib.parse' ) ,  MovedAttribute ( 'quote_plus' , 'urllib' , 'urllib.parse' ) ,  MovedAttribute ( 'unquote' , 'urllib' , 'urllib.parse' ) ,  MovedAttribute ( 'unquote_plus' , 'urllib' , 'urllib.parse' ) ,  MovedAttribute ( 'urlencode' , 'urllib' , 'urllib.parse' ) ,  MovedAttribute ( 'splitquery' , 'urllib' , 'urllib.parse' ) ,  ]	_urllib_parse_moved_attributes is a list with 16 elemetns, all of them are the results of the call to the function MovedAttribute with different 3 string arguments.
for attr in _urllib_parse_moved_attributes :	for every attr in _urllib_parse_moved_attributes,
setattr ( Module_six_moves_urllib_parse , attr . name , attr )	set attr.name attribute of the Module_six_moves_urllib_parse object to attr.
del attr	delete attr.
Module_six_moves_urllib_parse . _moved_attributes = _urllib_parse_moved_attributes	substitute _urllib_parse_moved_attributes for Module_six_moves_urllib_parse._moved_attributes.
sys . modules [ __name__ + '.moves.urllib_parse' ] = sys . modules [ __name__ + '.moves.urllib.parse' ] = Module_six_moves_urllib_parse ( __name__ + '.moves.urllib_parse' )	call the method Module_six_moves_urllib_request with an argument: string '.moves.urllib_parse' appended to __name__,
class Module_six_moves_urllib_error ( _LazyModule ) :	assign the result to the value under the string '.moves.urllib_parse' appended to __name__ key of the sys.modules dictionary,   and to the value under the string '.moves.urllib.parse' appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib_error from the _LazyModule base class.
_urllib_error_moved_attributes = [  MovedAttribute ( 'URLError' , 'urllib2' , 'urllib.error' ) ,  MovedAttribute ( 'HTTPError' , 'urllib2' , 'urllib.error' ) ,  MovedAttribute ( 'ContentTooShortError' , 'urllib' , 'urllib.error' ) ,  ]	_urllib_error_moved_attributes is a list with 3 elements: result of the call to the function MovedAttribute with 3 arguments:
for attr in _urllib_error_moved_attributes :	strings 'URLError', 'urllib2', 'urllib.error', result of the call to the function MovedAttribute with 3 arguments:   strings 'HTTPError', 'urllib2', 'urllib.error' and result of the call to the function MovedAttribute with 3 arguments:   strings 'ContentTooShortError', 'urllib', 'urllib.error'.   for every attr in _urllib_error_moved_attributes,
setattr ( Module_six_moves_urllib_error , attr . name , attr )	set attr.name attribute of the Module_six_moves_urllib_error object to attr.
del attr	delete attr.
Module_six_moves_urllib_error . _moved_attributes = _urllib_error_moved_attributes	substitute _urllib_error_moved_attributes for Module_six_moves_urllib_error._moved_attributes.
sys . modules [ __name__ + '.moves.urllib_error' ] = sys . modules [ __name__ + '.moves.urllib.error' ] = Module_six_moves_urllib_error ( __name__ + '.moves.urllib.error' )	call the method Module_six_moves_urllib_request with an argument: string '.moves.urllib.error' appended to __name__,
class Module_six_moves_urllib_request ( _LazyModule ) :	assign the result to the value under the string '.moves.urllib_error' appended to __name__ key of the sys.modules dictionary,   and to the value under the string '.moves.urllib.error' appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib_request from the _LazyModule base class.
_urllib_request_moved_attributes = [  MovedAttribute ( 'urlopen' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'install_opener' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'build_opener' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'pathname2url' , 'urllib' , 'urllib.request' ) ,  MovedAttribute ( 'url2pathname' , 'urllib' , 'urllib.request' ) ,  MovedAttribute ( 'getproxies' , 'urllib' , 'urllib.request' ) ,  MovedAttribute ( 'Request' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'OpenerDirector' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'HTTPDefaultErrorHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'HTTPRedirectHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'HTTPCookieProcessor' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'ProxyHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'BaseHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'HTTPPasswordMgr' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'HTTPPasswordMgrWithDefaultRealm' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'AbstractBasicAuthHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'HTTPBasicAuthHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'ProxyBasicAuthHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'AbstractDigestAuthHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'HTTPDigestAuthHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'ProxyDigestAuthHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'HTTPHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'HTTPSHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'FileHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'FTPHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'CacheFTPHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'UnknownHandler' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'HTTPErrorProcessor' , 'urllib2' , 'urllib.request' ) ,  MovedAttribute ( 'urlretrieve' , 'urllib' , 'urllib.request' ) ,  MovedAttribute ( 'urlcleanup' , 'urllib' , 'urllib.request' ) ,  MovedAttribute ( 'URLopener' , 'urllib' , 'urllib.request' ) ,  MovedAttribute ( 'FancyURLopener' , 'urllib' , 'urllib.request' ) ,  MovedAttribute ( 'proxy_bypass' , 'urllib' , 'urllib.request' ) ,  ]	_urllib_request_moved_attributes is an list with 33 elements, all of them are the results of the call to the function MovedAttribute with 3 different string arguments.
for attr in _urllib_request_moved_attributes :	for every attr in _urllib_request_moved_attributes,
setattr ( Module_six_moves_urllib_request , attr . name , attr )	set attr.name attribute of the Module_six_moves_urllib_request object to attr.
del attr	delete attr.
Module_six_moves_urllib_request . _moved_attributes = _urllib_request_moved_attributes	substitute _urllib_request_moved_attributes for Module_six_moves_urllib_request._moved_attributes.
sys . modules [ __name__ + '.moves.urllib_request' ] = sys . modules [ __name__ + '.moves.urllib.request' ] = Module_six_moves_urllib_request ( __name__ + '.moves.urllib.request' )	call the method Module_six_moves_urllib_request with an argument: string '.moves.urllib.request' appended to __name__,
class Module_six_moves_urllib_response ( _LazyModule ) :	assign the result to the value under the string '.moves.urllib_request' appended to __name__ key of the sys.modules dictionary,   and to the value under the string '.moves.urllib.request' appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib_response from the _LazyModule base class.
_urllib_response_moved_attributes = [  MovedAttribute ( 'addbase' , 'urllib' , 'urllib.response' ) ,  MovedAttribute ( 'addclosehook' , 'urllib' , 'urllib.response' ) ,  MovedAttribute ( 'addinfo' , 'urllib' , 'urllib.response' ) ,  MovedAttribute ( 'addinfourl' , 'urllib' , 'urllib.response' ) ,  ]	_urllib_response_moved_attributes is a list with 4 elements: result of the function MovedAttribute, called with 3 arguments:
for attr in _urllib_response_moved_attributes :	strings 'addbase', 'urllib' and 'urllib.response', result of the function MovedAttribute, called with 3 arguments:   strings 'addclosehook', 'urllib', 'urllib.response', result of the function MovedAttribute, called with 3 arguments:   strings 'addinfo', 'urllib', 'urllib.response' and result of the function MovedAttribute, called with 3 arguments:   strings 'addinfourl', 'urllib', 'urllib.response'.   for every attr in _urllib_response_moved_attributes,
setattr ( Module_six_moves_urllib_response , attr . name , attr )	set attr.name attribute of Module_six_moves_urllib_response object to attr.
del attr	delete attr.
Module_six_moves_urllib_response . _moved_attributes = _urllib_response_moved_attributes	substitute _urllib_response_moved_attributes for Module_six_moves_urllib_response._moved_attributes.
sys . modules [ __name__ + '.moves.urllib_response' ] = sys . modules [ __name__ + '.moves.urllib.response' ] = Module_six_moves_urllib_response ( __name__ + '.moves.urllib.response' )	instantiate class Module_six_moves_urllib_response with an argument, string '.moves.urllib.response' appended to __name__,
class Module_six_moves_urllib_robotparser ( _LazyModule ) :	assign it to value under the string '.moves.urllib_response' appended to __name__ key of the sys.modules dictionary,   and to value under the string '.moves.urllib.response' appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib_robotparser from the _LazyModule base class.
_urllib_robotparser_moved_attributes = [  MovedAttribute ( 'RobotFileParser' , 'robotparser' , 'urllib.robotparser' ) ,  ]	_urllib_robotparser_moved_attributes is a list containing an instance of MovedAttribute class, created with 3 argument: strings,
for attr in _urllib_robotparser_moved_attributes :	RobotFileParser, 'robotparser', 'urllib.robotparser'.   for every attr in _urllib_robotparser_moved_attributes,
setattr ( Module_six_moves_urllib_robotparser , attr . name , attr )	set attr.name attribute of Module_six_moves_urllib_robotparser object to attr.
del attr	delete attr.
Module_six_moves_urllib_robotparser . _moved_attributes = _urllib_robotparser_moved_attributes	substitute _urllib_robotparser_moved_attributes for Module_six_moves_urllib_robotparser._moved_attributes.
sys . modules [ __name__ + '.moves.urllib_robotparser' ] = sys . modules [ __name__ + '.moves.urllib.robotparser' ] = Module_six_moves_urllib_robotparser ( __name__ + '.moves.urllib.robotparser' )	instantiate class Module_six_moves_urllib_robotparser with an argument, string '.moves.urllib.robotparser' appended to __name__,
class Module_six_moves_urllib ( types . ModuleType ) :	assign it to value under the string '.moves.urllib_robotparser' appended to __name__ key of the sys.modules dictionary,   and to value under the string '.moves.urllib.robotparser' appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib from the types.ModuleType base class.
parse = sys . modules [ __name__ + '.moves.urllib_parse' ]	append string '.moves.urllib_parse' to __name__, use it as an key to get the value from the sys.modules dictionary, substitute it for parse.
error = sys . modules [ __name__ + '.moves.urllib_error' ]	append string '.moves.urllib_error' to __name__, use it as an key to get the value from the sys.modules dictionary, substitute it for error.
request = sys . modules [ __name__ + '.moves.urllib_request' ]	append string '.moves.urllib_request' to __name__, use it as an key to get the value from the sys.modules dictionary, substitute it for request.
response = sys . modules [ __name__ + '.moves.urllib_response' ]	append string '.moves.urllib_response' to __name__, use it as an key to get the value from the sys.modules dictionary, substitute it for response.
robotparser = sys . modules [ __name__ + '.moves.urllib_robotparser' ]	append string '.moves.urllib_robotparser' to __name__, use it as an key to get the value from the sys.modules dictionary, substitute it for robotparser.
def __dir__ ( self ) :	define the method __dir__ with an argument self.
return [ 'parse' , 'error' , 'request' , 'response' , 'robotparser' ]	return a list with 5 elements: strings 'parse', 'error', 'request', 'response' and 'robotparser'.
sys . modules [ __name__ + '.moves.urllib' ] = Module_six_moves_urllib ( __name__ + '.moves.urllib' )	instantiate class Module_six_moves_urllib with an argument, string '.moves.urllib' appended to __name__,
def add_move ( move ) :	substitute it for value under the string '.moves.urllib' appended to __name__ key of the sys.modules dictionary.   define the function add_move with an argument move.
setattr ( _MovedItems , move . name , move )	set move.name attribute of the _MovedItems to move.
def remove_move ( name ) :	define the function remove_move with an argument name.
try :	try,
delattr ( _MovedItems , name )	delete name attribute of the _MovedItems object.
except AttributeError :	if AttributeError exception is caught,
try :	try,
del moves . __dict__ [ name ]	delete entry under the name key of the moves.__dict__ dictionary.
except KeyError :	if NameError exception is caught,
raise AttributeError ( 'no such move, %r' % ( name , ) )	raise an AttributeError with an argument string 'no such move, %r', formated with a tuple with an element name.
if PY3 :	if PY3 is true,
_meth_func = '__func__'	_meth_func is a string '__func__'.
_meth_self = '__self__'	_meth_self is a string '__self__'.
_func_closure = '__closure__'	_func_closure is a string '__closure__'.
_func_code = '__code__'	_func_code is a string '__code__'.
_func_defaults = '__defaults__'	_func_defaults is a string '__defaults__'.
_func_globals = '__globals__'	_func_globals is a string '__globals__'.
_iterkeys = 'keys'	_iterkeys is a string 'keys'.
_itervalues = 'values'	_itervalues is a string 'values'.
_iteritems = 'items'	_iteritems is a string 'items'.
_iterlists = 'lists'	_iterlists is a string 'lists'.
else :	if not,
_meth_func = 'im_func'	_meth_func is a string 'im_func'.
_meth_self = 'im_self'	_meth_self is a string 'im_self'.
_func_closure = 'func_closure'	_func_closure is a string 'func_closure'.
_func_code = 'func_code'	_func_code is a string 'func_code'.
_func_defaults = 'func_defaults'	_func_defaults is a string 'func_defaults'.
_func_globals = 'func_globals'	_func_globals is a string 'func_globals'.
_iterkeys = 'iterkeys'	_iterkeys is a string 'iterkeys'.
_itervalues = 'itervalues'	_iterkeys is a string 'iterkeys'.
_iteritems = 'iteritems'	_iteritems is a string 'iteritems'.
_iterlists = 'iterlists'	_iterlists is a string 'iterlists'.
try :	try,
advance_iterator = next	substitute next for advance_iterator.
except NameError :	if NameError exception is caught,
def advance_iterator ( it ) :	define the function advance_iterator with an argument it.
return it . next ( )	return next element of the iterable it.
next = advance_iterator	substitute klass.__dict__ for next.
try :	try,
callable = callable	substitute callable for callable.
except NameError :	if NameError exception is caught,
def callable ( obj ) :	define the function callable with an argument obj.
return any ( '__call__' in klass . __dict__ for klass in type ( obj ) . __mro__ )	if '__call__' is contained in klass.__dict__ for any klass in __mro__ field of the obj class, return boolean True, otherwise return False.
if PY3 :	if PY3 is true,
def get_unbound_function ( unbound ) :	define the function get_unbound_function with an argument unbound.
return unbound	return unbound.
create_bound_method = types . MethodType	substitute Iterator for create_bound_method.
Iterator = object	substitute object for Iterator.
else :	if not,
def get_unbound_function ( unbound ) :	define the function get_unbound_function with an argument unbound.
return unbound . im_func	return unbound.im_func.
def create_bound_method ( func , obj ) :	define the function create_bound_function with 2 arguments: func and obj.
return types . MethodType ( func , obj , obj . __class__ )	call the method types.MethodType with 3 arguments: func, obj and obj.__class__, return the result.
class Iterator ( object ) :	derive the class Iterator from the base class object.
def next ( self ) :	define the method next with an argument self.
return type ( self ) . __next__ ( self )	call the function type with an argument self, on the result call the method __next__ with an argument self, return the result.
callable = callable	substitute callable for callable.
_add_doc ( get_unbound_function ,  '''Get the function out of a possibly unbound function''' )	call the function _add_doc with 2 arguments: get_unbound_function and string '''Get the function out of a possibly unbound function'''.
get_method_function = operator . attrgetter ( _meth_func )	call the method operator.attrgetter with an argument _meth_func, substitute the result for get_method_function.
get_method_self = operator . attrgetter ( _meth_self )	call the method operator.attrgetter with an argument _meth_self, substitute the result for get_method_self.
get_function_closure = operator . attrgetter ( _func_closure )	call the method operator.attrgetter with an argument _func_closure, substitute the result for get_method_closure.
get_function_code = operator . attrgetter ( _func_code )	call the method operator.attrgetter with an argument _func_code, substitute the result for get_method_code.
get_function_defaults = operator . attrgetter ( _func_defaults )	call the method operator.attrgetter with an argument _func_defaults, substitute the result for get_method_defaults.
get_function_globals = operator . attrgetter ( _func_globals )	call the method operator.attrgetter with an argument _func_globals, substitute the result for get_method_globals.
def iterkeys ( d , ** kw ) :	define the function iterkeys with 2 arguments: d and unpacked dictionary  kw.
return iter ( getattr ( d , _iterkeys ) ( ** kw ) )	get _iterkeys attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
def itervalues ( d , ** kw ) :	return it.   define the function itervalues with 2 arguments: d and unpacked dictionary  kw.
return iter ( getattr ( d , _itervalues ) ( ** kw ) )	get _itervalues attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
def iteritems ( d , ** kw ) :	return it.   define the function iteritems with 2 arguments: d and unpacked dictionary  kw.
return iter ( getattr ( d , _iteritems ) ( ** kw ) )	get _iteritems attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
def iterlists ( d , ** kw ) :	return it.   define the function iterlists with 2 arguments: d and unpacked dictionary  kw.
return iter ( getattr ( d , _iterlists ) ( ** kw ) )	get _iterlists attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
if PY3 :	return it.   if PY3 is true,
def b ( s ) :	define the function b with an argument s.
return s . encode ( 'latin-1' )	call the method e.encode with an argument string 'latin-1'.
def u ( s ) :	define the function u with an argument s.
return s	return s.
unichr = chr	substitute chr for unichr.
if sys . version_info [ 1 ] <= 1 :	if second element of sys.version_info is smaller than or equal to integer 1,
def int2byte ( i ) :	define the function int2byte with an argument i.
return bytes ( ( i , ) )	call the function bytes with an argument tuple with an element i, return the result.
else :	if not,
int2byte = operator . methodcaller ( 'to_bytes' , 1 , 'big' )	call the method operator.methodcaller with 3 arguments: string 'to_bytes', integer 1 and string 'big', substitute the result for int2byte.
byte2int = operator . itemgetter ( 0 )	call te method operator.itemgetter with an argument integer 0, substitute the result for byte2int.
indexbytes = operator . getitem	substitute operator.getitem for indexbytes.
iterbytes = iter	substitute iter for iterbytes.
import io	import io.
StringIO = io . StringIO	substitute io.StringIO for StringIO.
BytesIO = io . BytesIO	substitute io.BytesIO for BytesIO.
else :	if not,
def b ( s ) :	define the function b with an argument s.
return s	return s.
def u ( s ) :	define the function u with an argument s.
\return unicode ( s . replace ( r'\\\\' , r'\\\\\\\\' ) , 'unicode_escape' )\	\replace every occurrence of raw string '\\\\' in s with a raw string '\\\\\\\\', use the result and string 'unicode_escape',\
unichr = unichr	as arguments for the call to the unicode function, return the result.  substitute unichr for unichr.
int2byte = chr	substitute chr for int2byte.
def byte2int ( bs ) :	define the function byte2int with an argument bs.
return ord ( bs [ 0 ] )	get the integer representation of the first element of bs, return it.
def indexbytes ( buf , i ) :	define the function indexbytes with 2 arguments buf and i.
return ord ( buf [ i ] )	get the integer representation of the i-th element of buf, return it.
def iterbytes ( buf ) :	define the function iterbytes with an argument buf.
return ( ord ( byte ) for byte in buf )	convert byte to its integer representation, return all of the results for every byte in buf.
import StringIO	import StringIO.
StringIO = BytesIO = StringIO . StringIO	assign StringIO.StringIO to StringIO and BytesIO.
_add_doc ( b , '''Byte literal''' )	call the function _add_doc with 2 arguments: b and string '''Byte literal'''.
_add_doc ( u , '''Text literal''' )	call the function _add_doc with 2 arguments: u and string '''Text literal'''.
if PY3 :	if PY3 is true,
exec_ = getattr ( moves . builtins , 'exec' )	get 'exec' attribute from the moves.builtins object, substitute it for exec_.
def reraise ( tp , value , tb = None ) :	define the function reraise with 3 arguments: tp, value and tb set to None.
if value . __traceback__ is not tb :	if value.__traceback__ is not tb,
raise value . with_traceback ( tb )	raise an value.with_traceback exception with an argument tb.
raise value	raise an exception value.
else :	if not,
def exec_ ( _code_ , _globs_ = None , _locs_ = None ) :	define the function exec with 3 arguments: _code_, _globs_ set to None and _locs_ set to None.
if _globs_ is None :	if _globs_ is None,
frame = sys . _getframe ( 1 )	call the method sys._getframe with an argument 1, substitute the result for frame.
_globs_ = frame . f_globals	substitute frame.f_globals for _globs_.
if _locs_ is None :	if _locs_ is None,
_locs_ = frame . f_locals	substitute if _locs_ is None for _locs_.
del frame	delete frame.
elif _locs_ is None :	otherwise if _locs_ is None,
_locs_ = _globs_	substitute _globs_ with an argument _locs_.
exec ( '''exec _code_ in _globs_, _locs_''' )	execute code statement '''exec _code_ in _globs_, _locs_'''.
exec_ ( '''def reraise(tp, value, tb=None):     raise tp, value, tb ''' )	call the function exec_ with an argument string '''def reraise(tp, value, tb=None):    raise tp, value, tb'''.
print_ = getattr ( moves . builtins , 'print' , None )	get attribute 'print' from the moves.builtins object, if it exists substitute it for print_, if not print_ is None.
if print_ is None :	if print_ is None,
def print_ ( * args , ** kwargs ) :	define the function print_ with 2 arguments: unpacked list args and unpacked dictionary kwargs.
fp = kwargs . pop ( 'file' , sys . stdout )	remover 'file' key from the kwargs dictionary, if it exists substitute it for fp, if not substitute sys.stdout for fp.
if fp is None :	if fp is None,
return	return nothing.
def write ( data ) :	define the function write with an argument data.
if not isinstance ( data , basestring ) :	if data is not an instance of basestring,
data = str ( data )	convert data to string, substitute it for data.
if ( isinstance ( fp , file ) and  isinstance ( data , unicode ) and  fp . encoding is not None ) :	if fp is an instance of file and data is an instance of unicode and fp.encoding is not None,
errors = getattr ( fp , 'errors' , None )	get 'errors' attribute from fp object, substitute it for errors if it exists, if not errors is None.
if errors is None :	if errors is None,
errors = 'strict'	errors is a string 'strict'.
data = data . encode ( fp . encoding , errors )	call the method data.encode with 2 arguments: fp.encoding and errors, substitute the result for data.
fp . write ( data )	write data to fp.
want_unicode = False	want_unicode is boolean False.
sep = kwargs . pop ( 'sep' , None )	remove 'sep' key from the kwargs dictionary, if it exists substitute it for sep, if not sep is None.
if sep is not None :	if sep is not None,
if isinstance ( sep , unicode ) :	if sep is an instance of unicode,
want_unicode = True	want_unicode is boolean True.
elif not isinstance ( sep , str ) :	otherwise if sep is not an instance of string type,
raise TypeError ( 'sep must be None or a string' )	raise an TypeError exception with an argument string 'sep must be None or a string'.
end = kwargs . pop ( 'end' , None )	remove 'end' key from the kwargs dictionary, if it exists substitute it for end, if not end is None.
if end is not None :	if end is not None,
if isinstance ( end , unicode ) :	if end is an instance of unicode,
want_unicode = True	want_unicode is boolean True.
elif not isinstance ( end , str ) :	otherwise if end is not an instance of string type,
raise TypeError ( 'end must be None or a string' )	raise an TypeError exception with an argument string 'end must be None or a string'.
if kwargs :	if kwargs is true,
raise TypeError ( 'invalid keyword arguments to print()' )	raise an TypeError exception with an argument string 'invalid keyword arguments to print()'.
if not want_unicode :	if want_unicode is false,
for arg in args :	for every arg in args,
if isinstance ( arg , unicode ) :	if arg is an instance of unicode,
want_unicode = True	want_unicode is boolean True.
break	break from the loop execution.
if want_unicode :	if want_unicode is true,
\newline = unicode ( '\\n' )\	convert newline character to unicode and substitute the result for newline.
space = unicode ( ' ' )	convert whitespace character to unicode and substitute the result for space.
else :	if not,
\newline = '\\n'\	substitute newline character for newline.
space = ' '	substitute string ' ' for space.
if sep is None :	if sep is None,
sep = space	substitute space for sep.
if end is None :	if end is None
end = newline	substitute space for end.
for i , arg in enumerate ( args ) :	for every i and arg in enumerated iterable args,
if i :	if i is true,
write ( sep )	call the function write with an argument sep.
write ( arg )	call the function write with an argument arg.
write ( end )	call the function write with an argument end.
_add_doc ( reraise , '''Reraise an exception.''' )	call the function _add_doc with 2 arguments: reraise and string '''Reraise an exception.'''.
def with_metaclass ( meta , * bases ) :	define the function with_metaclass with 2 arguments meta and unpacked list bases.
class metaclass ( meta ) :	derive the class metaclass form the meta base class.
__call__ = type . __call__	substitute type.__call__ for __call__.
__init__ = type . __init__	substitute type.__init__ for __init__.
def __new__ ( cls , name , this_bases , d ) :	define the method __new__ with 4 arguments: cls, name, this_bases and d.
if this_bases is None :	if this_bases is None,
return type . __new__ ( cls , name , ( ) , d )	call the method type.__new__ with 4 arguments: cls, name, empty tuple and d, return the result.
return meta ( name , bases , d )	call the function meta with 3 arguments: name, base and d.
return metaclass ( 'temporary_class' , None , { } )	return an instance of metaclass class, created with 3 arguments: string 'temporary_class', None and an empty dictionary.
def add_metaclass ( metaclass ) :	define the function add_metaclass with an argument metaclass.
def wrapper ( cls ) :	define the function wrapper with an argument cls.
orig_vars = cls . __dict__ . copy ( )	call the method cls.__dict__.copy substitute the result for orig_vars.
orig_vars . pop ( '__dict__' , None )	remove '__dict__' key from the orig_vars dictionary.
orig_vars . pop ( '__weakref__' , None )	remove '__weakref__' key from the orig_vars dictionary.
slots = orig_vars . get ( '__slots__' )	get the value under the '__slots__' key of the orig_vars dictionary, substitute it for slots.
if slots is not None :	if slots is not None,
if isinstance ( slots , str ) :	if slots is an instance of str,
slots = [ slots ]	slots is a list with an element, slots.
for slots_var in slots :	for every slots_var in slots,
orig_vars . pop ( slots_var )	remove slots_var key from the orig_vars dictionary.
return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )	return an instance of metaclass class, created with 3 arguments: cls.__name__, cls.__bases__ and orig_vars.
return wrapper	return wrapper.
if PY3 :	if PY3 is true,
_assertCountEqual = 'assertCountEqual'	_assertCountEqual is a strnig 'assertCountEqual'.
_assertRaisesRegex = 'assertRaisesRegex'	  _assertRaisesRegex is a strnig 'assertRaisesRegex'.
_assertRegex = 'assertRegex'	_assertRegex is a strnig 'assertRegex'.
memoryview = memoryview	substitute memoryview for memoryview.
buffer_types = ( bytes , bytearray , memoryview )	buffer_types is a tuple with 3 elements: bytes, bytearray and memoryview.
else :	if not,
_assertCountEqual = 'assertItemsEqual'	_assertCountEqual is a strnig 'assertItemsEqual'.
_assertRaisesRegex = 'assertRaisesRegexp'	_assertRaisesRegex is a strnig 'assertRaisesRegexp'.
_assertRegex = 'assertRegexpMatches'	_assertRegex is a strnig 'assertRegexpMatches'.
if sys . platform . startswith ( 'java' ) :	if sys.platform starts with a string 'java',
memoryview = memoryview	substitute memoryview for memoryview.
else :	if not,
memoryview = buffer	substitute buffer for memoryview.
buffer_types = ( bytearray , memoryview )	buffer_types is a tuple with 2 elements bytearray and memoryview.
def assertCountEqual ( self , * args , ** kwargs ) :	define the function assertCountEqual with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
return getattr ( self , _assertCountEqual ) ( * args , ** kwargs )	get _assertCountEqual attribute of the self object, call the result with 2 arguments: unpacked list args,
def assertRaisesRegex ( self , * args , ** kwargs ) :	and unpacked dictionary kwargs, return the result.   define the function assertRaisesRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
return getattr ( self , _assertRaisesRegex ) ( * args , ** kwargs )	get _assertRaisesRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
def assertRegex ( self , * args , ** kwargs ) :	and unpacked dictionary kwargs, return the result.   define the function assertRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
return getattr ( self , _assertRegex ) ( * args , ** kwargs )	get _assertRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
add_move ( MovedModule ( '_dummy_thread' , 'dummy_thread' ) )	and unpacked dictionary kwargs, return the result.   call the function MovedModule with 2 arguments: strings '_dummy_thread' and 'dummy_thread',
add_move ( MovedModule ( '_thread' , 'thread' ) )	use the result as an argument for the call to the add_move function.   call the function MovedModule with 2 arguments: strings '_thread' and 'thread',
import contextlib	import module contextlib.
try :	try,
import threading	import threading.
except ImportError :	except ImportError.
import dummy_threading as threading	import dummy_threading as threading.
class RWLock ( object ) :	derive the class RWLock from the object base class.
def __init__ ( self ) :	define the method __init__ with an argument self.
self . mutex = threading . RLock ( )	call the method threading.RLock, substitute the result for self.mutex.
self . can_read = threading . Semaphore ( 0 )	call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_read.
self . can_write = threading . Semaphore ( 0 )	call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_write.
self . active_readers = 0	self.active_readers is an integer 0.
self . active_writers = 0	self.active_writers is an integer 0.
self . waiting_readers = 0	self.waiting_readers is an integer 0.
self . waiting_writers = 0	self.waiting_writers is an integer 0.
def reader_enters ( self ) :	define the method reader_enters with an argument self.
with self . mutex :	with self.mutex perform,
if self . active_writers == 0 and self . waiting_writers == 0 :	if self.active_writers and self.waiting_writers both equal to integer 0,
self . active_readers += 1	increment self.active_readers by 1.
self . can_read . release ( )	call the method self.can_read.release.
else :	if not,
self . waiting_readers += 1	increment self.waiting_readers by 1.
self . can_read . acquire ( )	call the method self.can_read.acquire.
def reader_leaves ( self ) :	define the method reader_leaves with an argument self.
with self . mutex :	with self.mutex perform,
self . active_readers -= 1	decrement self.active_readers by integer 1,
if self . active_readers == 0 and self . waiting_writers != 0 :	if self.active_readers equals integer 0 and self.waiting_writers is not equal to integer 0,
self . active_writers += 1	increment self.active_writers by 1.
self . waiting_writers -= 1	decrement self.waiting_writers by integer 1,
self . can_write . release ( )	call the method self.can_write.release.
@ contextlib . contextmanager	contextlib.contextmanager decorator,
def reader ( self ) :	define the method reader with an argument self.
self . reader_enters ( )	call the method self.reader_enters.
try :	try,
yield	yield nothing.
finally :	finally perform,
self . reader_leaves ( )	call the method self.reader_leaves.
def writer_enters ( self ) :	define the method writer_enters with an argument self.
with self . mutex :	with self.mutex perform,
if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :	if self.active_writers equals integer 0 and self.waiting_writers equals integer 0 and self.active_readers equals integer 0,
self . active_writers += 1	increment self.active_writers by integer 1,
self . can_write . release ( )	call the method self.can_write.release.
else :	if not,
self . waiting_writers += 1	increment self.waiting_writers by integer 1,
self . can_write . acquire ( )	call the method self.can_write.acquire.
def writer_leaves ( self ) :	define the method writer_leaves with an argument self.
with self . mutex :	  with self.mutex perform,
self . active_writers -= 1	decrement self.active_writers by integer 1,
if self . waiting_writers != 0 :	if self.waiting_writers is not equal to integer 0,
self . active_writers += 1	increment self.active_writers by integer 1,
self . waiting_writers -= 1	decrement self.waiting_writers by integer 1,
self . can_write . release ( )	call the method self.can_write.release.
elif self . waiting_readers != 0 :	otherwise if self.waiting_readers is not equal to integer 0,
t = self . waiting_readers	substitute self.waiting_readers for t.
self . waiting_readers = 0	self.waiting_readers is integer 0.
self . active_readers += t	increment self.active_readers by t.
while t > 0 :	while t is greater than integer 0,
self . can_read . release ( )	call the method self.can_read.release.
t -= 1	decrement t by integer 1,
@ contextlib . contextmanager	contextlib.contextmanager decorator,
def writer ( self ) :	define the method writer with an argument self.
self . writer_enters ( )	call the method self.writer_enters.
try :	try,
yield	yield nothing.
finally :	finally perform,
self . writer_leaves ( )	call the method self.writer_leaves.
from django . utils import six	from django.utils import six into default name space.
color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )	color_names is a tuple with 8 elements: strings 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'.
foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )	foreground is a dictionary created with elements: x appended to a string '3' for value under the key x of color_names dictionary,
background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )	for every x in sequence of integers from 0 to 7.   background is a dictionary created with elements: x appended to a string '4' for value under the key x of color_names dictionary,
RESET = '0'	for every x in sequence of integers from 0 to 7.   RESET is a string '0'.
opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }	opt_dict is an dictionary with 5 elements: '1' for 'bold', '4' for 'underscore', '5' for 'blink', '7' for 'reverse',
def colorize ( text = '' , opts = ( ) , ** kwargs ) :	and '8' for 'conceal'.   define the method colorize with 3 arguments: text set to an empty string, opts set to an empty tuple and unpacked dictionary kwargs.
code_list = [ ]	code_list is an empty list.
if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :	if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
\return '\\x1b[%sm' % RESET\	\format string '\\x1b[%sm' with RESET, return the result.\
for k , v in six . iteritems ( kwargs ) :	call the function six.iteritems with an argument kwargs, for every k and v in the result,
if k == 'fg' :	if k equals a string 'fg',
code_list . append ( foreground [ v ] )	append value under the key v of foreground dictionary to code_list.
elif k == 'bg' :	otherwise if k equals a string 'bg',
code_list . append ( background [ v ] )	append value under the key v of background dictionary to code_list.
for o in opts :	for every o in opts,
if o in opt_dict :	if o is contained in opt_dict,
code_list . append ( opt_dict [ o ] )	append value under the 0 key of the opt_dict dictionary to code_list.
if 'noreset' not in opts :	if string 'noreset' is not contained in opts,
\text = '%s\\x1b[%sm' % ( text or '' , RESET )\	\if text is true format with it and RESET a string '%s\\x1b[%sm', if not format it with an empty string and RESET, substitute the result for text.\
\return '%s%s' % ( ( '\\x1b[%sm' % ';' . join ( code_list ) ) , text or '' )\	\join elements of code_list in a string, separated by ';', format string '\\x1b[%sm' with it, append text to the result if exists,\
def make_style ( opts = ( ) , ** kwargs ) :	return the string.   define the function make_style with 2 arguments: opts set to an empty tuple and unpacked dictionary kwargs.
return lambda text : colorize ( text , opts , ** kwargs )	return lambda function with text as argument and return value being result of the function colorize, called with 3 arguments: text,
NOCOLOR_PALETTE = 'nocolor'	opts and unpacked dictionary kwargs.   NOCOLOR_PALETTE is a string 'nocolor'.
DARK_PALETTE = 'dark'	DARK_PALETTE is a string 'dark'.
LIGHT_PALETTE = 'light'	LIGHT_PALETTE is a string 'light'.
PALETTES = {  NOCOLOR_PALETTE : {  'ERROR' : { } ,  'WARNING' : { } ,  'NOTICE' : { } ,  'SQL_FIELD' : { } ,  'SQL_COLTYPE' : { } ,  'SQL_KEYWORD' : { } ,  'SQL_TABLE' : { } ,  'HTTP_INFO' : { } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { } ,  'HTTP_NOT_MODIFIED' : { } ,  'HTTP_BAD_REQUEST' : { } ,  'HTTP_NOT_FOUND' : { } ,  'HTTP_SERVER_ERROR' : { } ,  'MIGRATE_HEADING' : { } ,  'MIGRATE_LABEL' : { } ,  'MIGRATE_SUCCESS' : { } ,  'MIGRATE_FAILURE' : { } ,  } ,  DARK_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'yellow' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'cyan' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'yellow' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  } ,  LIGHT_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'blue' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'green' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'red' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  }  }	PALETTES is a dictionary containing 3 elements, a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE,
DEFAULT_PALETTE = DARK_PALETTE	a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE,   and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE.   substitute DARK_PALETTE for DEFAULT_PALETTE.
def parse_color_setting ( config_string ) :	define the function parse_color_setting with an argument config_string.
if not config_string :	if config_string is false,
return PALETTES [ DEFAULT_PALETTE ]	return value under the DEFAULT_PALETTE key of the PALETTES dictionary.
parts = config_string . lower ( ) . split ( ';' )	convert config_string to lowercase and split it by ';' character, substitute the result for parts.
palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )	get value under the config_string key of the PALETTES dictionary, call the copy method on the result and substitute it for palette.
for part in parts :	for every part in parts,
if part in PALETTES :	if part is contained in PALETTES,
palette . update ( PALETTES [ part ] )	get the value under the part key of the PALETTES dictionary, update with it palette dictionary.
elif '=' in part :	otherwise if '=' is contained in part,
definition = { }	definition is an empty dictionary,
role , instructions = part . split ( '=' )	split part by '=' character, substitute the result for role and instructions, respectively.
role = role . upper ( )	convert role to uppercase.
styles = instructions . split ( ',' )	split instructions by ',' character, substitute the result for styles.
styles . reverse ( )	reverse the order of elements of styles.
colors = styles . pop ( ) . split ( '/' )	remove first element from styles, split it by the '/' character, substitute the result for colors.
colors . reverse ( )	reverse the order of colors elements,
fg = colors . pop ( )	remove the first element from colors, substitute it for fg.
if fg in color_names :	if fg is contained in color_names,
definition [ 'fg' ] = fg	substitute fg for value under the 'fg' key of definition dictionary.
if colors and colors [ - 1 ] in color_names :	if colors is true and last element of colors is contained in color_names,
definition [ 'bg' ] = colors [ - 1 ]	substitute last element of colors for value under the 'bg' key of definition dictionary.
opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )	opts is a tuple created out of elements s, for every s in styles is s is in the keys of the opt_dict dictionary.
if opts :	if opts is true,
definition [ 'opts' ] = opts	substitute opts for value under the 'opts' key of definition dictionary.
if role in PALETTES [ NOCOLOR_PALETTE ] and definition :	if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true,
palette [ role ] = definition	substitute definition for value under the role key of palette dictionary.
if palette == PALETTES [ NOCOLOR_PALETTE ] :	if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary,
return None	return None.
return palette	return palette.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import re	import module re.
import unicodedata	import module unicodedata.
from gzip import GzipFile	from gzip import GzipFile into default name space.
from io import BytesIO	from io import BytesIO into default name space.
import warnings	import module warnings.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
from django . utils . encoding import force_text	from django.utils.encoding import force_text into default name space.
from django . utils . functional import allow_lazy , SimpleLazyObject	from django.utils.functional import allow_lazy and SimpleLazyObject into default name space.
from django . utils import six	from django.utils import six into default name space.
from django . utils . six . moves import html_entities	from django.utils.six.moves import html_entities into default name space.
from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext	from django.utils.translation import ugettext_lazy,  ugettext as _ and pgettext into default name space.
from django . utils . safestring import mark_safe	from django.utils.safestring import mark_safe into default name space.
if six . PY2 :	if six.PY2 is true,
from django . utils . encoding import force_unicode	from django.utils.encoding import force_unicode.
capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]	if identity lambda function returns false, substitute the x for capfirst, if not call the function force_text with an argument x,
capfirst = allow_lazy ( capfirst , six . text_type )	convert the first element of the result to uppercase, append to it the rest of the result, substitute it for capfirst.   call the function allow_lazy with 3 arguments: capfirst and six.text_type.
\re_words = re . compile ( r'<.*?>|((?:\\w[-\\w]*|&.*?;)+)' , re . U | re . S )\	\call the function re.compile with 2 arguments: raw string '<.*?>|((?:\\w[-\\w]*|&.*?;)+)' and bitwise OR performed with 2 operands,\
re_chars = re . compile ( r'<.*?>|(.)' , re . U | re . S )	re.U and re.S, substitute the result for re_words.   call the function re.compile with 2 arguments: raw string '<.*?>|(.)' and bitwise OR performed with 2 operands,
\re_tag = re . compile ( r'<(/)?([^ ]+?)(?:(\\s*/)| .*?)?>' , re . S )\	\re.U and re.S, substitute the result for re_chars.   call the function re.compile with 2 arguments: raw string '<(/)?([^ ]+?)(?:(\\s*/)| .*?)?>' and bitwise OR performed with 2 operands,\
\re_newlines = re . compile ( r'\\r\\n|\\r' )\	\re.U and re.S, substitute the result for re_chars.   call the function re.compile with an argument raw string '\\r\\n|\\r', substitute the result for re_newlines.\
re_camel_case = re . compile ( r'(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))' )	call the function re.compile with an argument raw string '(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', substitute the result for re_camel_case.
def wrap ( text , width ) :	define the function wrap with 2 arguments text and width.
text = force_text ( text )	call the function force_text with an argument text, substitute the result for text.
def _generator ( ) :	define the function _generator.
for line in text . splitlines ( True ) :	call the method text.splitlines with an argument boolean True, for every line in the result,
\max_width = min ( ( line . endswith ( '\\n' ) and width + 1 or width ) , width )\	if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
while len ( line ) > max_width :	while length of line is grater than max_width,
space = line [ : max_width + 1 ] . rfind ( ' ' ) + 1	get fist max_width incremented by 1 elements from line, find index of the first occurrenece of whitespace from the right side,
if space == 0 :	add integer 1 to it, substitute the result for space.   if space equals integer 0,
space = line . find ( ' ' ) + 1	find first index of whitespace occurrence in line, add integer 1 to it, substitute the result for space.
if space == 0 :	if space equals integer 0,
    yield line	yield line.
line = ''	line is an empty string.
break	break from the loop execution
\yield '%s\\n' % line [ : space - 1 ]\	get the first space decremented with integer 1 elements from string line, append newline character to it, and yield the result.
line = line [ space : ]	remove all the elements from space index of line.
\max_width = min ( ( line . endswith ( '\\n' ) and width + 1 or width ) , width )\	if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
if line :	if line is true,
yield line	yield line.
return '' . join ( _generator ( ) )	call the function _generator, join the result into a string, return the result.
wrap = allow_lazy ( wrap , six . text_type )	call the function allow_lazy with 2 arguments: wrap and six.text_type, substitute the result for wrap.
class Truncator ( SimpleLazyObject ) :	derive the class Truncator form the SimpleLazyObject class.
def __init__ ( self , text ) :	define the method __init__ with 2 arguments: self and text.
super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )	call the method __init__ from the base class of the class Truncator,
def add_truncation_text ( self , text , truncate = None ) :	called with with an argument lambda function which returns result of the force_text function called with an argument text.   define the method add_truncation_text with 3 arguments: self, text and truncate set to None.
if truncate is None :	if truncate is None,
truncate = pgettext (  'String to return when truncating text' ,  '%(truncated_text)s...' )	call the function pgettext with an argument 'String to return when truncating text', '%(truncated_text)s...', substitute the result for truncate.
truncate = force_text ( truncate )	call the function force_text with an argument truncate, substitute the result for truncate.
if '%(truncated_text)s' in truncate :	if string '%(truncated_text)s' is contained in truncate,
return truncate % { 'truncated_text' : text }	format truncate with a dictionary with an element: text for 'truncated_text', return the result.
if text . endswith ( truncate ) :	if text ends with truncate,
return text	return text.
return '%s%s' % ( text , truncate )	append truncate to text, return the result.
def chars ( self , num , truncate = None , html = False ) :	define the method chars with 4 arguments: self, num, truncate set to None, html set to boolean False.
length = int ( num )	convert num to an integer, substitute it for length.
text = unicodedata . normalize ( 'NFC' , self . _wrapped )	call the function unicodedata.normalize with 2 arguments: string 'NFC' and self._wrapped, substitute the result for text.
truncate_len = length	substitute length for truncate_len.
for char in self . add_truncation_text ( '' , truncate ) :	for every char in result of the self.add_truncation_text, called with 2 arguments: an empty string and truncate.
if not unicodedata . combining ( char ) :	call the method unicodedata.combining with an argument char, if it evaluates to false,
truncate_len -= 1	decrement truncate_len by integer 1.
if truncate_len == 0 :	if truncate_len equals integer 0.
break	break from the loop execution.
if html :	if html is true,
return self . _truncate_html ( length , truncate , text , truncate_len , False )	call the function self._truncate_html with 5 arguments: length, truncate, text, truncate_len and boolean False, return the result.
return self . _text_chars ( length , truncate , text , truncate_len )	call the method self._text_chars with 4 arguments: length, truncate, text and truncate_len, return the result.
chars = allow_lazy ( chars )	call the function allow_lazy with an argument chars, substitute the result for chars.
def _text_chars ( self , length , truncate , text , truncate_len ) :	define the method _text_chars with 5 arguments: self, length, truncate, text and truncate_len.
s_len = 0	s_len is integer 0.
end_index = None	end_index is None.
for i , char in enumerate ( text ) :	for every i and char in enumerated text,
if unicodedata . combining ( char ) :	call the function unicodedata.combining with an argument char, if it evaluates to true,
continue	skip this loop iteration,s
s_len += 1	increment s_len by integer 1,
if end_index is None and s_len > truncate_len :	if end_index is None and s_len is greater than truncate_len,
end_index = i	substitute i for end_index.
if s_len > length :	if s_len is greater than length,
return self . add_truncation_text ( text [ : end_index or 0 ] ,  truncate )	call the method self.add_truncation_text with 2 arguments: if end_index is greater than zero, first end_index elements of text,
return text	if not an empty string, and truncate, return the result.   return text.
def words ( self , num , truncate = None , html = False ) :	define the method words with 4 arguments: self, num, truncate set to None, html set to boolean False.
length = int ( num )	convert num to an integer, substitute the result for length.
if html :	if html is true,
return self . _truncate_html ( length , truncate , self . _wrapped , length , True )	call the method self._truncate_html with 5 arguments: length, truncate, self._wrapped, length and boolean True, return the result.
return self . _text_words ( length , truncate )	call the method self._text_words with 2 arguments length and truncate, return the result.
words = allow_lazy ( words )	call the function allow_lazy with an argument words, substitute the result for words.
def _text_words ( self , length , truncate ) :	define the method _text_words with 3 arguments: self, length and truncate.
words = self . _wrapped . split ( )	split self._wrapped into words, substitute the result for words.
if len ( words ) > length :	if length of words is greater than length,
words = words [ : length ]	substitute first length elements of words for words.
return self . add_truncation_text ( ' ' . join ( words ) , truncate )	call the method self.add_truncation_text with 2 arguments: elements of words joined in a string, separated with whitespaces,
return ' ' . join ( words )	and truncate, return the result.   return elements of words joined in a string, separated with whitespaces.
def _truncate_html ( self , length , truncate , text , truncate_len , words ) :	define the method _truncate_html with 6 arguments: self, length, truncate, text, truncate_len and words.
if words and length <= 0 :	if words is not empty and length is smaller than or equal to integer 0,
return ''	return an empty string.
html4_singlets = (  'br' , 'col' , 'link' , 'base' , 'img' ,  'param' , 'area' , 'hr' , 'input'  )	html4_singlets is a tuple with 9 elements: strings 'br', 'col', 'link', 'base', 'img', 'param', 'area', 'hr' and 'input'.
pos = 0	pos is equal to integer 0.
end_text_pos = 0	end_text_pos is equal to integer 0.
current_len = 0	current_len is equal to integer 0.
open_tags = [ ]	open_tags is an empty list.
regex = re_words if words else re_chars	if words is true, substitute re_words for regex, if not substitute re_chars for regex.
while current_len <= length :	while current_len is smaller than or equal to length,
m = regex . search ( text , pos )	call the method regex.search with 2 arguments: text and pos.
if not m :	if m is false,
break	break from the loop execution,
pos = m . end ( 0 )	call the method m.end with an argument integer 0, substitute the result for pos.
if m . group ( 1 ) :	call the function m.group, if the result evaluates to true,
current_len += 1	increment current_len by integer 1,
if current_len == truncate_len :	if current_len equals truncate_len,
end_text_pos = pos	substitute pos for end_text_pos.
continue	skip this loop iteration.
tag = re_tag . match ( m . group ( 0 ) )	call the method m.group with an argument integer 0, use it as an argument for the call to the re_tag.match function,
if not tag or current_len >= truncate_len :	substitute the result for tag.   if tag is false or current_len is greater or equal to truncate_len,
continue	skip this loop iteration.
closing_tag , tagname , self_closing = tag . groups ( )	call the method tag.groups, substitute the result for closing_tag, tagname and self_closing, respectively.
tagname = tagname . lower ( )	convert tagname to lowercase, substitute it for tagname.
if self_closing or tagname in html4_singlets :	if self_closing is true or tagname is contained in html4_singlets,
pass	do nothing.
elif closing_tag :	otherwise if closing_tag is true,
try :	try,
i = open_tags . index ( tagname )	get the index of the first occurrence of tagname, substitute it for i.
except ValueError :	if ValueError exception is caught,
pass	do nothing.
else :	if not,
  open_tags = open_tags [ i + 1 : ]	create a list out of open_tags elements form (i+1)-th index to the end, substitute it for open_tags.
else :	if not,
open_tags . insert ( 0 , tagname )	insert tagname at the beginning of open_tags.
if current_len <= length :	if current_len is smaller than or equal to length,
return text	return text.
out = text [ : end_text_pos ]	create a list out of fist end_text_pos text elemnts, substitue it for out.
truncate_text = self . add_truncation_text ( '' , truncate )	call the method self.add_truncation_text with 2 arguments: an empty string and truncate, substitute it for truncate_text.
if truncate_text :	if truncate_text is true,
out += truncate_text	append truncate_text to out.
for tag in open_tags :	for every tag in open_tags,
out += '</%s>' % tag	replace '%s' in string '</%s>' with tag, append the result to out.
return out	return out.
def get_valid_filename ( s ) :	define the function get_valid_filename with an argument s.
s = force_text ( s ) . strip ( ) . replace ( ' ' , '_' )	call the function force_text with an argument s, strip the result of whitespaces from both ends,
\return re . sub ( r'(?u)[^-\\w.]' , '' , s )\	\replace every occurrence of whitespaces in the previous result for '_', substitute the result for s.   call the function re.sub with 3 arguments: raw string '(?u)[^-\\w.]', an empty string and s, return the result.\
get_valid_filename = allow_lazy ( get_valid_filename , six . text_type )	call the function allow_lazy with 2 arguments: get_valid_filename and six.text_type, substitute the result for get_valid_filename.
def get_text_list ( list_ , last_word = ugettext_lazy ( 'or' ) ) :	define the function get_text_list with 2 arguments: list_ and last_word set to result of the function ugettext_lazy called with an argument string 'or'.
if len ( list_ ) == 0 :	is length of list_ equals integer 0,
return ''	return an empty string.
if len ( list_ ) == 1 :	if length of list_ equals integer 1,
return force_text ( list_ [ 0 ] )	call the function force_text with first element of list_ as an argument, return the result.
return '%s %s %s' % (   _ ( ', ' ) . join ( force_text ( i ) for i in list_ [ : - 1 ] ) ,  force_text ( last_word ) , force_text ( list_ [ - 1 ] ) )	return a string '%s %s %s' formated with 3 elements: result of the function force_text called with an argument i,
get_text_list = allow_lazy ( get_text_list , six . text_type )	separated by result of the function _ called with an argument string ', ', for every i in list_ without last element,   result of the function force_text called with an argument last_word, result of the function force_text called with an argument:   last element of list_.   call the function allow_lazy with 2 arguments: get_text_list and six.text_type, substitute the result for get_text_list.
def normalize_newlines ( text ) :	define the function normalize_newlines with an argument text.
text = force_text ( text )	call the function force_text with an argument text, substitute the result for text.
\return re_newlines . sub ( '\\n' , text )\	\call the method re_newlines.sub with 2 arguments: '\\n' and text, return the result.\
normalize_newlines = allow_lazy ( normalize_newlines , six . text_type )	call the function allow_lazy with 2 arguments: normalize_newlines and six.text_type, substitute the result for normalize_newlines.
def phone2numeric ( phone ) :	define the function phone2numeric with an argument phone.
char2number = { 'a' : '2' , 'b' : '2' , 'c' : '2' , 'd' : '3' , 'e' : '3' , 'f' : '3' ,  'g' : '4' , 'h' : '4' , 'i' : '4' , 'j' : '5' , 'k' : '5' , 'l' : '5' , 'm' : '6' ,  'n' : '6' , 'o' : '6' , 'p' : '7' , 'q' : '7' , 'r' : '7' , 's' : '7' , 't' : '8' ,  'u' : '8' , 'v' : '8' , 'w' : '9' , 'x' : '9' , 'y' : '9' , 'z' : '9' }	char2number is an dictionary, with 26 elements: 2 for 'a', 2 for 'b', 2 for 'c', 3 for 'd', 3 for 'e', 3 for 'f', 4 for 'g',
return '' . join ( char2number . get ( c , c ) for c in phone . lower ( ) )	4 for 'h', 4 for 'i', 4 for 'j', 5 for 'k', 5 for 'l', 5 for 'm', 6 for 'n', 6 for 'o', 6 for 'p', 7 for 'q', 7 for 'r', 7 for 'r',   7 for 's', 7 for 't', 8 for 't', 8 for 'u', 8 for 'v', 9 for 'w', 9 for 'x', 9 for 'y' and 9 for 'z'.   for every c in phone converted to lowercase, join the value under the c key of the char2number dictionary into a string, return it.
phone2numeric = allow_lazy ( phone2numeric )	call the function allow_lazy with an argument phone2numeric, substitute the result for phone2numeric.
def compress_string ( s ) :	define the function compress_string with an argument s.
zbuf = BytesIO ( )	zbuf is an instance of BytesIO class.
zfile = GzipFile ( mode = 'wb' , compresslevel = 6 , fileobj = zbuf )	zfile is an instance of GzipFile class, created with 3 arguments: mode set to string 'wb', compresslevel set to integer 6,
zfile . write ( s )	and fileobj set to zbuf.   call the method zfile.write with an argument s.
zfile . close ( )	call the method zfile.close.
return zbuf . getvalue ( )	call the method zbuf.getvalue, return the result.
class StreamingBuffer ( object ) :	derive the class StreamingBuffer from the object base class.
def __init__ ( self ) :	define the method __init__ with an argument self.
self . vals = [ ]	self.vals is an empty list.
def write ( self , val ) :	define the method write with 2 arguments: self and val.
self . vals . append ( val )	append val to self.vals.
def read ( self ) :	define the method read with an argument self.
ret = b'' . join ( self . vals )	join elements of self.vals into a bytes string, substitute the result for ret.
self . vals = [ ]	self.vals is an empty list.
return ret	return ret.
def flush ( self ) :	define the method flush with an argument self.
return	return nothing.
def close ( self ) :	define the method close with an argument self.
return	return nothing.
def compress_sequence ( sequence ) :	define the function compress_sequence with an argument sequence.
buf = StreamingBuffer ( )	buf is an instance of StreamingBuffer class.
zfile = GzipFile ( mode = 'wb' , compresslevel = 6 , fileobj = buf )	zfile is an instance of GzipFile class, created with 3 arguments: mode set to string 'wb', compresslevel set to integer 6,
yield buf . read ( )	and fileobj set to buf.   read data from buf file stream, yield the result.
for item in sequence :	for every item in sequence,
zfile . write ( item )	write item to zfile stream.
zfile . flush ( )	flush zfile stream buffer.
yield buf . read ( )	read data from buf, yield the result.
zfile . close ( )	close zfile stream.
yield buf . read ( )	read data from buf, yield the result.
\ustring_re = re . compile ( '([\\u0080-\\uffff])' )\	\call the function re.compile with an argument string '([\\u0080-\\uffff])', substitute the result for ustring_re.\
def javascript_quote ( s , quote_double_quotes = False ) :	define the function javascript_quote with 2 arguments: s and quote_double_quotes set to boolean False.
msg = (  'django.utils.text.javascript_quote() is deprecated. '  'Use django.utils.html.escapejs() instead.'  )	msg is an string 'django.utils.text.javascript_quote() is deprecated. Use django.utils.html.escapejs() instead.'.
warnings . warn ( msg , RemovedInDjango19Warning , stacklevel = 2 )	call the function warnings.warn with 3 arguments: msg, RemovedInDjango19Warning and stacklevel as integer 2.
def fix ( match ) :	define the function fix with an argument match.
\return '\\\\u%04x' % ord ( match . group ( 1 ) )\	\get the unicode representation of result of the method match.group called with an integer 1, format with in a string '\\\\u%04x',\
if type ( s ) == bytes :	return the result.   if type of s equals bytes,
s = s . decode ( 'utf-8' )	call the method s.decode with an argument string 'utf-8', substitute the result for s.
elif type ( s ) != six . text_type :	otherwise if, type of s doesnt equal to six.text_type,
raise TypeError ( s )	raise an TypeError with an argument s.
\s = s . replace ( '\\\\' , '\\\\\\\\' )\	\replace every occurrence of '\\\\' in s with '\\\\\\\\'.\
\s = s . replace ( '\\r' , '\\\\r' )\	\replace every occurrence of '\\r' in s with '\\\\r'.\
\s = s . replace ( '\\n' , '\\\\n' )\	\replace every occurrence of '\\n' in s with '\\\\n'.\
\s = s . replace ( '\\t' , '\\\\t' )\	\replace every occurrence of '\\t' in s with '\\\\t'.\
\s = s . replace ( '</' , '<\\\\/' )\	\replace every occurrence of '</' in s with '<\\\\/'.\
if quote_double_quotes :	if quote_double_quotes is true,
return ustring_re . sub ( fix , s )	call the method ustring_re.sub with 2 arguments: fix and s, return the result.
javascript_quote = allow_lazy ( javascript_quote , six . text_type )	call the function allow_lazy with 2 arguments: javascript_quote and six.text_type, substitute the result for javascript_quote.
def smart_split ( text ) :	and re.VERBOSE, substitute the result for smart_split_re.   define the function smart_split with an argument text.
text = force_text ( text )	call the function force_text with an argument text, substitute the result for text.
for bit in smart_split_re . finditer ( text ) :	call the method smart_split_re.finditer with an argument text, for every bit in result,
yield bit . group ( 0 )	call the method bit.group with an argument integer 0, yield the result.
def _replace_entity ( match ) :	define the function _replace_entity with an argument match.
text = match . group ( 1 )	call the method match.group with an argument integer 1, substitute the result for text.
if text [ 0 ] == '#' :	if first element of text equals '#',
text = text [ 1 : ]	remove first element of text.
try :	try,
if text [ 0 ] in 'xX' :	if first element of text is contained in 'xX'.
c = int ( text [ 1 : ] , 16 )	convert text without first element to hexadecimal integer, substitute it for c.
else :	if nor,
c = int ( text )	convert text to an integer, substitute it for c.
return six . unichr ( c )	call the method six.unichr with an argument c, return the result.
except ValueError :	if ValueError exception is caught,
return match . group ( 0 )	call the method match.group with an argument integer 0, return the result.
else :	if not,
try :	try,
return six . unichr ( html_entities . name2codepoint [ text ] )	call the function six.unichr with value under the text key of the html_entities.name2codepoint dictionary, return the result.
except ( ValueError , KeyError ) :	if OverflowError or ValueError exceptions are caught,
return match . group ( 0 )	call the method match.group with an argument integer 0, return the result.
\_entity_re = re . compile ( r'&(#?[xX]?(?:[0-9a-fA-F]+|\\w{1,8}));' )\	\call the method re.compile with an argument raw string '&(#?[xX]?(?:[0-9a-fA-F]+|\\w{1,8}));', substitute the result for _entity_re.\
def unescape_entities ( text ) :	define the function unescape_entities with an argument text.
return _entity_re . sub ( _replace_entity , text )	call the method _entity_re.sub with 2 arguments: _replace_entity and text, return the result.
unescape_entities = allow_lazy ( unescape_entities , six . text_type )	call the function allow_lazy with 2 arguments: unescape_entities and six.text_type, substitute the result for unescape_entities.
def unescape_string_literal ( s ) :	define the function unescape_string_literal with an argument s.
raise ValueError ( 'Not a string literal: %r' % s )	raise an ValueError exception wit an argument string 'Not a string literal: %r', where '%r' is replaced with s.
quote = s [ 0 ]	substitute first element of s for quote.
\return s [ 1 : - 1 ] . replace ( r'\\%s' % quote , quote ) . replace ( r'\\\\' , '\\\\' )\	\remove first and last elements of s, replace every occurrence of string '\\%s' formated with quote with quote,\
unescape_string_literal = allow_lazy ( unescape_string_literal )	\replace every occurrence of raw string '\\\\' in the result with string '\\\\', return the result.   call the function allow_lazy with an argument unescape_string_literal, substitute the result for unescape_string_literal.\
def slugify ( value ) :	define the function slugify with an argument value.
value = unicodedata . normalize ( 'NFKD' , value ) . encode ( 'ascii' , 'ignore' ) . decode ( 'ascii' )	call the method unicodedata.normalize with 2 arguments: string 'NFKD' and value, encode the result with 2 arguments: string 'ascii',
\value = re . sub ( '[^\\w\\s-]' , '' , value ) . strip ( ) . lower ( )\	\and string 'ignore', call the method decode on the result with an argument string 'ascii', substitute the result for value.   call the method re.sub with 3 arguments: string '[^\\w\\s-]', empty string and value, strip the result of whitespaces from both ends,\
\return mark_safe ( re . sub ( '[-\\s]+' , '-' , value ) )\	\and convert it to lowercase, substitute the result for value.   call the function re.sub with 3 arguments: string '[-\\s]+', string '-' and value, use the result as an argument for the call to the,\
slugify = allow_lazy ( slugify , six . text_type )	mark_safe function, return the result.   call the function allow_lazy with 2 arguments: slugify and six.text_type, substitute the result slugify.
def camel_case_to_spaces ( value ) :	define the function camel_case_to_spaces with an argument value.
\return re_camel_case . sub ( r' \\1' , value ) . strip ( ) . lower ( )\	\call the method re_camel_case.sub with 2 arguments: raw string ' \\1' and value, strip the result of whitespaces from both ends,\
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import datetime	import module datetime.
from django . utils . html import avoid_wrapping	from django.utils.html import avoid_wrapping into default name space.
from django . utils . timezone import is_aware , utc	from django.utils.timezone import is_aware and utc into default name space.
from django . utils . translation import ugettext , ungettext_lazy	from django.utils.translation import ugettext and ungettext_lazy into default name space.
def timesince ( d , now = None , reversed = False ) :	define the function timesince with d, now defaulting to None, reversed defaulting to False as arguments.
chunks = (  ( 60 * 60 * 24 * 365 , ungettext_lazy ( '%d year' , '%d years' ) ) ,  ( 60 * 60 * 24 * 30 , ungettext_lazy ( '%d month' , '%d months' ) ) ,  ( 60 * 60 * 24 * 7 , ungettext_lazy ( '%d week' , '%d weeks' ) ) ,  ( 60 * 60 * 24 , ungettext_lazy ( '%d day' , '%d days' ) ) ,  ( 60 * 60 , ungettext_lazy ( '%d hour' , '%d hours' ) ) ,  ( 60 , ungettext_lazy ( '%d minute' , '%d minutes' ) )  )	chunks is a tuple containing 6 initial tuples:
if not isinstance ( d , datetime . datetime ) :	result of multiplication of integers: 60,60,24,365, and return value of ungettext_lazy with 2 arguments: '%d year', '%d years',   result of multiplication of integers: 60,60,24,30, and return value of ungettext_lazy with 2 arguments: '%d month', '%d month',   result of multiplication of integers: 60,60,24,7, and return value of ungettext_lazy with 2 arguments: '%d weeks', '%d weeks',   result of multiplication of integers: 60,60,24, and return value of ungettext_lazy with 2 arguments: '%d days', '%d days',   result of multiplication of integers: 60,60, and return value of ungettext_lazy with 2 arguments: '%d hours', '%d hours',   result of multiplication of integers: 60, and return value of ungettext_lazy with 2 arguments: '%d minutes', '%d minutes',   if d is not an instance of datetime.datetime,
d = datetime . datetime ( d . year , d . month , d . day )	call the function datetime.datetime with 3 arguments, d.year, d.month and d.day, substitute the result for d.
if now and not isinstance ( now , datetime . datetime ) :	if now equals to boolean True and now is not an instance of datetime.datetime,
now = datetime . datetime ( now . year , now . month , now . day )	call the function datetime.datetime with 3 arguments, now.year, now.month and now.day, substitute the result for now.
if not now :	if now is false,
now = datetime . datetime . now ( utc if is_aware ( d ) else None )	call the function datetime.datetime with utc as argument if call to the is_aware(d) returns True, if not None is the argument, store the result in now.
delta = ( d - now ) if reversed else ( now - d )	if reversed is True substitute difference of d and now for delta, if not substitute the difference of now and d for delta.
since = delta . days * 24 * 60 * 60 + delta . seconds	multiply delta.days, integer 24, integer 60 and integer 60 add delta.seconds to it, substitute the result for since.
if since <= 0 :	if since is lesser or equal to integer 0,
return avoid_wrapping ( ugettext ( '0 minutes' ) )	call the function ugettext with '0 minutes' as argument, use the result as the argument for the call to the avoid_wrapping function, return the result.
for i , ( seconds , name ) in enumerate ( chunks ) :	for every i and tuple containing 2 elements: seconds and name, in enumerated chunks,
count = since // seconds	divide since by seconds, store the floored result in count.
if count != 0 :	if count does not equals to integer 0,
break	break the execution of the smallest enclosing loop.
result = avoid_wrapping ( name % count )	use the remainder of the division of name by count as the argument for the call to the avoid_wrapping function, store the result in result.
if i + 1 < len ( chunks ) :	if i incremented by 1 is lesser than length of chunks,
seconds2 , name2 = chunks [ i + 1 ]	get the element of chunks at the (i+1)-the index, assign it to the seconds2 and name2, respectively.
count2 = ( since - ( seconds * count ) ) // seconds2	multiply seconds by count, subtract it from since, divide the result by seconds2, store the floored result in count2.
if count2 != 0 :	if count2 does not equals to integer 0,
result += ugettext ( ', ' ) + avoid_wrapping ( name2 % count2 )	call avoid_wrapping function with name2 modulus count2 as argument, call the ugettext with ', ' as argument, add previous 2 results, increment variable result by it.
return result	return result.
def timeuntil ( d , now = None ) :	define the function timeuntil with 2 arguments, d and now defaulting to none.
return timesince ( d , now , reversed = True )	evaluate the function timesince with d, now and reversed set to boolean true as arguments, return the result.
from datetime import datetime , timedelta , tzinfo	from datetime import datetime,  timedelta and tzinfo into default name space.
from threading import local	from threading import local into default name space.
import sys	import module sys.
import time as _time	import module time as _time.
try :	try,
import pytz	import pytz.
except ImportError :	if ImportError exception is caught,
pytz = None	pytz is None.
from django . conf import settings	from django.conf import settings into default name space.
from django . utils import six	from django.utils import six into default name space.
__all__ = [  'utc' , 'get_fixed_timezone' ,  'get_default_timezone' , 'get_default_timezone_name' ,  'get_current_timezone' , 'get_current_timezone_name' ,  'activate' , 'deactivate' , 'override' ,  'localtime' , 'now' ,  'is_aware' , 'is_naive' , 'make_aware' , 'make_naive' ,  ]	__all__ is a list with 15 elements: strings 'utc', 'get_fixed_timezone', 'get_default_timezone', 'get_default_timezone_name',
ZERO = timedelta ( 0 )	'get_current_timezone', 'get_current_timezone_name', 'activate', 'deactivate', 'override', 'localtime', 'now', 'is_aware',   'is_naive', 'make_aware' and 'make_naive'.   call the function timedelta with an argument integer 0, substitute the result for ZERO.
class UTC ( tzinfo ) :	derive the class UTC from the tzinfo base class.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return '<UTC>'	return a string '<UTC>'.
def utcoffset ( self , dt ) :	define the method utcoffset with 2 arguments self and dt.
return ZERO	return ZERO.
def tzname ( self , dt ) :	define the method tzname with 2 arguments self and dt.
return 'UTC'	return a string 'UTC'.
def dst ( self , dt ) :	define the method dst with 2 arguments self and dt.
return ZERO	return ZERO.
class FixedOffset ( tzinfo ) :	derive the class FixedOffset from the tzinfo base class.
def __init__ ( self , offset = None , name = None ) :	define the method __init__ with 3 arguments: self, offset set to None, name set to None.
if offset is not None :	if offset is not None,
self . __offset = timedelta ( minutes = offset )	call the function timedelta with an argument minutes set to offset, substitute the result for self.__offset.
if name is not None :	if name is not None,
self . __name = name	substitute name for self.__name.
def utcoffset ( self , dt ) :	define the method utcoffset with 2 arguments: self and dt.
return self . __offset	return self.__offset.
def tzname ( self , dt ) :	define the method tzname with 2 arguments: self and dt.
return self . __name	return self.__name.
def dst ( self , dt ) :	define the method dst with 2 arguments: self and dt.
return ZERO	return ZERO.
class ReferenceLocalTimezone ( tzinfo ) :	derive the class ReferenceLocalTimezone from the tzinfo base class.
def __init__ ( self ) :	define the method __init__ with an argument self.
self . STDOFFSET = timedelta ( seconds = - _time . timezone )	call the function timedelta with an argument seconds set to negative _time.timezone, substitute the result for self.STDOFFSET.
if _time . daylight :	if _time.daylight is true,
self . DSTOFFSET = timedelta ( seconds = - _time . altzone )	call the function timedelta with an argument seconds set to negative _time.altzone, substitute the result for self.DSTOFFSET.
else :	if not,
self . DSTOFFSET = self . STDOFFSET	substitute self.STDOFFSET for self.DSTOFFSET.
self . DSTDIFF = self . DSTOFFSET - self . STDOFFSET	subtract self.STDOFFSET with self.DSTOFFSET, substitute the result for self.DSTDIFF.
tzinfo . __init__ ( self )	call the method tzinfo.__init__ with an argument self.
def utcoffset ( self , dt ) :	define the method utcoffset with 2 arguments: self and dt.
if self . _isdst ( dt ) :	call the method self._isdst with an argument dt, if it evaluates to true,
return self . DSTOFFSET	return self.DSTOFFSET.
else :	if not,
return self . STDOFFSET	return self.STDOFFSET.
def dst ( self , dt ) :	define the method utcoffset with 2 arguments: self and dt.
if self . _isdst ( dt ) :	call the method self._isdst with an argument dt, if it evaluates to true,
return self . DSTDIFF	return self.DSTDIFF.
else :	if not,
return ZERO	return ZERO.
def tzname ( self , dt ) :	define the method tzname with 2 arguments: self and dt.
return _time . tzname [ self . _isdst ( dt ) ]	call the method self._isdst with an argument dt, use it as an key to get the value from the _time.tzname dictionary, return it.
def _isdst ( self , dt ) :	define the method _isdst with 2 arguments: self and dt.
tt = ( dt . year , dt . month , dt . day ,  dt . hour , dt . minute , dt . second ,  dt . weekday ( ) , 0 , 0 )	tt is a tuple with 9 elements: dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, result of the method dt.weekday,
stamp = _time . mktime ( tt )	ingeter 0 and integer 0.   call the method _time.mktime with an argument tt, substitute the result for stamp.
tt = _time . localtime ( stamp )	call the method _time.localtime with an argument stamp, substitute the result for tt.
return tt . tm_isdst > 0	if tt.tm_isdst is greater than integer 0, return the result.
class LocalTimezone ( ReferenceLocalTimezone ) :	derive the class LocalTimezone from the ReferenceLocalTimezone base class.
def tzname ( self , dt ) :	define the method tzname with 2 arguments: self and dt.
is_dst = False if dt is None else self . _isdst ( dt )	if dt is None, is_dst is boolean False, otherwise call the method _isdst with an argument dt, substitute the result for is_dst.
return _time . tzname [ is_dst ]	return the value under the is_dst key of the _time.tzname dictionary.
def _isdst ( self , dt ) :	define the method _isdst with 2 arguments: self and dt.
try :	try,
return super ( LocalTimezone , self ) . _isdst ( dt )	call the method _isdst with an argument dt from the base class of the class LocalTimezone, return the result.
except ( OverflowError , ValueError ) as exc :	if OverflowError or ValueError, renamed to exc, exceptions are caught,
exc_type = type ( exc )	get the type of the exc object, substitute it for exc_type.
exc_value = exc_type (  'Unsupported value: %r. You should install pytz.' % dt )	call the function exc_type with an argument string 'Unsupported value: %r. You should install pytz.', replace '%s' with dt,
exc_value . __cause__ = exc	substitute the result for exc_value.   substitute exc for exc_value.__cause__.
six . reraise ( exc_type , exc_value , sys . exc_info ( ) [ 2 ] )	call the function six.reraise with 3 arguments: exc_type, exc_value and third element of the result of the method sys.exc_info.
utc = pytz . utc if pytz else UTC ( )	if pytz is true, substitute pytz.utc for utc, otherwise substitute result of the function UTC for utc.
def get_fixed_timezone ( offset ) :	define the function get_fixed_timezone with an argument offset.
if isinstance ( offset , timedelta ) :	if offset is an instance of timedelta class,
offset = offset . seconds // 60	substitute offset.seconds for offset.
sign = '-' if offset < 0 else '+'	if offset is smaller than integer 0, sign is '-', otherwise sign is '+'.
hhmm = '%02d%02d' % divmod ( abs ( offset ) , 60 )	divide absolute offset by module 60, use the result to format string '%02d%02d', substitute it for hhmm.
name = sign + hhmm	sum sign and hhmm, substitute the result for name.
return FixedOffset ( offset , name )	return an instance of FixedOffset class, created with 2 arguments: offset and name.
_localtime = None	_localtime is None.
def get_default_timezone ( ) :	define the function get_default_timezone.
global _localtime	use global variable _localtime.
if _localtime is None :	if _localtime is None,
if isinstance ( settings . TIME_ZONE , six . string_types ) and pytz is not None :	if settings.TIME_ZONE is an instance of six.string_types and pytz is not None,
_localtime = pytz . timezone ( settings . TIME_ZONE )	call the method pytz.timezone with an argument settings.TIME_ZONE, substitute the result for _localtime.
else :	if not,
_localtime = LocalTimezone ( )	_localtime is an instance of LocalTimezone class.
return _localtime	return _localtime.
def get_default_timezone_name ( ) :	define the function get_default_timezone_name.
return _get_timezone_name ( get_default_timezone ( ) )	call the function get_default_timezone, use the result as an argument for the call to the function _get_timezone_name, return the result.
_active = local ( )	call the method local, substitute the result for _active.
def get_current_timezone ( ) :	define the function get_current_timezone.
return getattr ( _active , 'value' , get_default_timezone ( ) )	get 'value' attribute of the _active object, if it exists return it, if not, call the function get_default_timezone and return the result.
def get_current_timezone_name ( ) :	define the function get_current_timezone_name.
return _get_timezone_name ( get_current_timezone ( ) )	call the function get_current_timezone, use the result as an argument for the call to the function _get_timezone_name, return the result.
def _get_timezone_name ( timezone ) :	define the function _get_timezone_name with an argument timezone.
try :	try,
return timezone . zone	return timezone.zone.
except AttributeError :	if AttributeError exception is caught,
return timezone . tzname ( None )	call the method timezone.tzname with an argument None, return the result.
def activate ( timezone ) :	define the function activate with an argument timezone.
if isinstance ( timezone , tzinfo ) :	if timezone is an instance of tzinfo,
_active . value = timezone	substitute timezone for _active.value.
elif isinstance ( timezone , six . string_types ) and pytz is not None :	otherwise if timezone is an instance of six.string_types and pytz is not None,
_active . value = pytz . timezone ( timezone )	call the method pytz.timezone with an argument timezone, substitute the result for _active.value.
else :	if not,
raise ValueError ( 'Invalid timezone: %r' % timezone )	raise an ValueError with an argument string 'Invalid timezone: %r', substitute '%r' with timezone.
def deactivate ( ) :	define the function deactivate.
if hasattr ( _active , 'value' ) :	if active has an attribute 'value',
del _active . value	delete _active.value.
class override ( object ) :	derive the class override from the object base class.
def __init__ ( self , timezone ) :	define the method __init__ with 2 arguments: self and timezone.
self . timezone = timezone	substitute timezone for self.timezone.
self . old_timezone = getattr ( _active , 'value' , None )	get 'value' attribute of the _active object
def __enter__ ( self ) :	define the method __enter__ with an argument self.
if self . timezone is None :	if self.timezone is None,
deactivate ( )	call the method deactivate.
else :	if not,
activate ( self . timezone )	call the method activate with an argument self.timezone.
def __exit__ ( self , exc_type , exc_value , traceback ) :	define the method __exit__ with 4 arguments self, exc_type, exc_value and traceback.
if self . old_timezone is None :	if self.old_timezone is None,
deactivate ( )	call the method deactivate.
else :	if not,
_active . value = self . old_timezone	substitute self.old_timezone for _active.value.
def template_localtime ( value , use_tz = None ) :	define the function template_localtime with 2 arguments: value and use_tz set to None.
should_convert = ( isinstance ( value , datetime )  and ( settings . USE_TZ if use_tz is None else use_tz )  and not is_naive ( value )  and getattr ( value , 'convert_to_local_time' , True ) )	if value is an instance of datetime and settings.USE_TZ if use_tz is None else use_tz and call to the function is_naive,
return localtime ( value ) if should_convert else value	with an argument value evaluates to false, and if 'convert_to_local_time' attribute of value object doesnt exists,   or is it does is boolean True, should_convert is boolean True, otherwise is boolean False.   if should_convert is true, call the function localtime with an argument value and return the result, otherwise return value.
def localtime ( value , timezone = None ) :	define the function localtime with 2 arguments: value and timezone set to None.
if timezone is None :	if timezone is None,
timezone = get_current_timezone ( )	call the function get_current_timezone, substitute the result for timezone.
value = value . astimezone ( timezone )	call the method value.astimezone with an argument timezone, substitute the result for value.
if hasattr ( timezone , 'normalize' ) :	if timezone has an attribute 'normalize',
value = timezone . normalize ( value )	call the method timezone.normalize with an argument value, substitute the result for value.
return value	return value.
def now ( ) :	define the function now.
if settings . USE_TZ :	if settings.USE_TZ is true,
return datetime . utcnow ( ) . replace ( tzinfo = utc )	call the method datetime.utcnow, on the result call the method replace with an argument tzinfo set to utc, return the result.
else :	if not,
return datetime . now ( )	call the method datetime.now, return the result.
def is_aware ( value ) :	define the function is_aware with an argument value.
return value . tzinfo is not None and value . tzinfo . utcoffset ( value ) is not None	if value.tzinfo is not None and call to the method value.tzinfo.utcoffset called with an argument value evaluates to not None,
def is_naive ( value ) :	return boolean True, otherwise return boolean False.   define the function is_naive with an argument value.
return value . tzinfo is None or value . tzinfo . utcoffset ( value ) is None	if value.tzinfo is None and call to the method value.tzinfo.utcoffset called with an argument value evaluates to None,
def make_aware ( value , timezone ) :	return boolean True, otherwise return boolean False.   define the function make_aware with 2 arguments: value and timezone.
if hasattr ( timezone , 'localize' ) :	if timezone has an attribute 'localize',
return timezone . localize ( value , is_dst = None )	call the method timezone.localize with 2 arguments: value and is_dst as None, return the result.
else :	if not,
if is_aware ( value ) :	call the function is_aware with an argument value, if it evaluates to true,
raise ValueError (  'make_aware expects a naive datetime, got %s' % value )	raise an ValueError exception with an argument string 'make_aware expects a naive datetime, got %s', where '%s' is replaced with value.
return value . replace ( tzinfo = timezone )	call the method value.replace with an argument tzinfo as timezone, return the result.
def make_naive ( value , timezone ) :	define the function make_naive with 2 arguments: value and timezone.
value = value . astimezone ( timezone )	call the method value.astimezone with an argument timezone, substitute the result for value.
if hasattr ( timezone , 'normalize' ) :	if timezone has an attribute 'normalize',
value = timezone . normalize ( value )	call the method timezone.normalize with an argument value, substitute the result for value.
return value . replace ( tzinfo = None )	call the method value.replace with an arugment tzinfo set to None, return the result.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import re	import module re.
from django . utils . encoding import force_text	from django.utils.encoding import force_text into default name space.
from django . utils . functional import lazy	from django.utils.functional import lazy into default name space.
from django . utils import six	from django.utils import six into default name space.
__all__ = [  'activate' , 'deactivate' , 'override' , 'deactivate_all' ,  'get_language' , 'get_language_from_request' ,  'get_language_info' , 'get_language_bidi' ,  'check_for_language' , 'to_locale' , 'templatize' , 'string_concat' ,  'gettext' , 'gettext_lazy' , 'gettext_noop' ,  'ugettext' , 'ugettext_lazy' , 'ugettext_noop' ,  'ngettext' , 'ngettext_lazy' ,  'ungettext' , 'ungettext_lazy' ,  'pgettext' , 'pgettext_lazy' ,  'npgettext' , 'npgettext_lazy' ,  'LANGUAGE_SESSION_KEY' ,  ]	__all__ is an list containing strings: 'activate', 'deactivate', 'override', 'deactivate_all', 'get_language',
LANGUAGE_SESSION_KEY = '_language'	'get_language_from_request', 'get_language_info', 'get_language_bidi', 'check_for_language', 'to_locale', 'templatize',   'string_concat', 'gettext', 'gettext_lazy', 'gettext_noop', 'ugettext', 'ugettext_lazy', 'ugettext_noop', 'ngettext', 'ngettext_lazy',   'ungettext', 'ungettext_lazy', 'pgettext', 'pgettext_lazy', 'npgettext', 'npgettext_lazy' and 'LANGUAGE_SESSION_KEY'.   LANGUAGE_SESSION_KEY is an string '_language'.
class TranslatorCommentWarning ( SyntaxWarning ) :	derive the class TranslatorCommentWarning from the SyntaxWarning base class.
pass	do nothing.
class Trans ( object ) :	derive the class Trans from the object base class.
def __getattr__ ( self , real_name ) :	define the method __getattr__ with 2 arguments: self and real_name.
from django . conf import settings	from django.conf import settings.
if settings . USE_I18N :	if settings.USE_I18N is true,
from django . utils . translation import trans_real as trans	from django.utils.translation import trans_real as trans.
else :	if not,
from django . utils . translation import trans_null as trans	from django.utils.translation import trans_null as trans.
setattr ( self , real_name , getattr ( trans , real_name ) )	set real_name attribute of the self object to value of real_name attribute of trans object.
return getattr ( trans , real_name )	get attribute real_name from the trans object, return it.
_trans = Trans ( )	_trans is an instance of Trans class.
del Trans	delete Trans.
def gettext_noop ( message ) :	define the function gettext_noop with an argument message.
return _trans . gettext_noop ( message )	call the method _trans.gettext_noop with an argument message.
ugettext_noop = gettext_noop	substitute gettext_noop for ugettext_noop.
def gettext ( message ) :	define the function gettext_noop with an argument message.
return _trans . gettext ( message )	call the method _trans.gettext with an argument message.
def ngettext ( singular , plural , number ) :	define the function ngettext with 3 arguments: singular, plural and number.
return _trans . ngettext ( singular , plural , number )	call the method _trans.ngettext with 3 arguments singular, plural and number.
def ugettext ( message ) :	define the method ugettext with an argument message.
return _trans . ugettext ( message )	call the method _trans.gettext_noop with an argument message.
def ungettext ( singular , plural , number ) :	define the function ungettext with 3 arguments: singular, plural and number.
return _trans . ungettext ( singular , plural , number )	call the method _trans.ungettext with 3 arguments singular, plural and number.
def pgettext ( context , message ) :	define the function pgettext with 2 arguments: context and message.
return _trans . pgettext ( context , message )	call the method _trans.pgettext with 2 arguments context and message.
def npgettext ( context , singular , plural , number ) :	define the function npgettext with 4 arguments: context, singular, plural and number.
return _trans . npgettext ( context , singular , plural , number )	call the method _trans.npgettext with 4 arguments context, singular, plural and number.
gettext_lazy = lazy ( gettext , str )	call the function lazy with 2 arguments: gettext and str, substitute gettext_lazy.
ugettext_lazy = lazy ( ugettext , six . text_type )	call the function lazy with 2 arguments: ugettext and six.text_type, substitute ugettext_lazy.
pgettext_lazy = lazy ( pgettext , six . text_type )	call the function lazy with 2 arguments: pgettext and six.text_type, substitute pgettext_lazy.
def lazy_number ( func , resultclass , number = None , ** kwargs ) :	define the function lazy_number with 4 arguments: func, resultclass, number set to None and unpacked dictionary kwargs.
if isinstance ( number , int ) :	if number is an instance of int type.
kwargs [ 'number' ] = number	substitute number for value under the 'number' key of the kwargs dictionary.
proxy = lazy ( func , resultclass ) ( ** kwargs )	call the function lazy with 2 arguments: func and resultclass, call the result with an argument, unpacked dictionary kwargs,
else :	substitute the result for proxy.   if not,
class NumberAwareString ( resultclass ) :	derive the class NumberAwareString from the resultclass base class.
def __mod__ ( self , rhs ) :	define the method __mod__ with 2 arguments: self and rhs.
if isinstance ( rhs , dict ) and number :	if rhs is an instance of dict type and number is true,
try :	try,
    number_value = rhs [ number ]	substitute value under the number key of the rhs dictionary for number_value.
except KeyError :	if KeyError exception is caught,
\    raise KeyError ( 'Your dictionary lacks key \\'%s\\'. '  'Please provide it, because it is required to '  'determine whether string is singular or plural.'  % number )\	\raise an KeyError with an argument string 'Your dictionary lacks key \\'%s\\'. Please provide it, because it is required to '\
else :	'determine whether string is singular or plural.', where '%s' is replaced with number.   if not,
number_value = rhs	substitute rhs for number_value.
kwargs [ 'number' ] = number_value	substitute number_value for kwargs dictionary value under the 'number' key.
translated = func ( ** kwargs )	call the function func with unpacked dictionary kwargs as an argument, substitute the result for translated.
try :	try,
translated = translated % rhs	format translated with rhs, substitute the result for translated.
except TypeError :	if TypeError exception is caught,
  pass	do nothing.
return translated	return translated.
proxy = lazy ( lambda ** kwargs : NumberAwareString ( ) , NumberAwareString ) ( ** kwargs )	call the function lazy with 2 arguments: lambda function with unpacked dictionary kwargs as an argument and return value an instance of NumberAwareString class and NumberAwareString, call the result with an argument unpacked dictionary kwargs, substitute the result for proxy.
return proxy	return proxy.
def ngettext_lazy ( singular , plural , number = None ) :	define the function ngettext_lazy with 3 arguments: singular, plural and number set to None.
return lazy_number ( ngettext , str , singular = singular , plural = plural , number = number )	call the function lazy_number with 5 arguments: ngettext, str, singular set to singular, plural set to plural,
def ungettext_lazy ( singular , plural , number = None ) :	and number set to number, return the result.   define the function ungettext_lazy with 3 arguments: singular, plural and number set to None.
return lazy_number ( ungettext , six . text_type , singular = singular , plural = plural , number = number )	call the function lazy_number with 5 arguments: ungettext, six.text_type, singular set to singular, plural set to plural,
def npgettext_lazy ( context , singular , plural , number = None ) :	and number set to number, return the result.   define the function npgettext_lazy with 4 arguments: context, singular, plural and number set to None.
return lazy_number ( npgettext , six . text_type , context = context , singular = singular , plural = plural , number = number )	call the function lazy_number with 6 arguments: npgettext, six.text_type, context set to context, singular set to singular,
def activate ( language ) :	plural set to plural and number set to number, return the result.   define the function activate with an argument language.
return _trans . activate ( language )	call the function _trans.activate with an argument language, return the result.
def deactivate ( ) :	define the function deactivate.
return _trans . deactivate ( )	call the function _trans.deactivate, return the result.
class override ( object ) :	derive the class override from the object base class.
def __init__ ( self , language , deactivate = False ) :	define the method __init__ with 3 arguments: self, language and deactivate set to boolean False.
self . language = language	substitute language for self.language.
self . deactivate = deactivate	substitute deactivate for self.deactivate.
self . old_language = get_language ( )	call the function get_language, substitute the result for self.old_language.
def __enter__ ( self ) :	define the method __enter__ with an argument self.
if self . language is not None :	if self.language is not None,
activate ( self . language )	call the function activate with an argument self.language.
else :	if not,
deactivate_all ( )	call the function deactivate_all.
def __exit__ ( self , exc_type , exc_value , traceback ) :	define the method __exit__ with 4 arguments: self, exc_type, exc_value and traceback.
if self . deactivate :	if self.deactivate is true,
deactivate ( )	call the method deactivate.
else :	if not,
activate ( self . old_language )	call the method activate with an argument self.old_language.
def get_language ( ) :	define the function get_language.
return _trans . get_language ( )	call the function _trans.get_language, return the result.
def get_language_bidi ( ) :	define the function get_language_bidi.
return _trans . get_language_bidi ( )	call the function _trans.get_language_bidi, return the result.
def check_for_language ( lang_code ) :	define the function check_for_language with an argument lang_code.
return _trans . check_for_language ( lang_code )	call the function _trans.check_for_language with an argument lang_code, return the result.
def to_locale ( language ) :	define the function to_locale with an argument language.
return _trans . to_locale ( language )	call the function _trans.to_locale with an argument language, return the result.
def get_language_from_request ( request , check_path = False ) :	define the function get_language_from_request with 2 arguments: request and check_path set to boolean False.
return _trans . get_language_from_request ( request , check_path )	call the function _trans.get_language_from_request with 2 arguments: request and check_path, return the result.
def get_language_from_path ( path ) :	define the function get_language_from_path with an argument path.
return _trans . get_language_from_path ( path )	call the function _trans.get_language_from_path with an argument path, return the result.
def templatize ( src , origin = None ) :	define the function templatize with 2 arguments: src and origin set to None.
return _trans . templatize ( src , origin )	call the function _trans.templatize with 2 arguments: src and origin, return the result.
def deactivate_all ( ) :	define the function deactivate_all.
return _trans . deactivate_all ( )	call the function _trans.deactivate_all, return the result.
def _string_concat ( * strings ) :	define the function _string_concat with an argument unpacked list strings.
return '' . join ( force_text ( s ) for s in strings )	for every s in strings, call the function force_text with an argument s, join the results in a string, return the result.
string_concat = lazy ( _string_concat , six . text_type )	call the function lazy with 2 arguments: _string_concat and six.text_type, substitute the result for string_concat.
def get_language_info ( lang_code ) :	define the function get_language_info with an argument lang_code.
from django . conf . locale import LANG_INFO	from django.conf.locale import LANG_INFO.
try :	try,
return LANG_INFO [ lang_code ]	get the value under the lang_code key of the LANG_INFO dictionary, return it.
except KeyError :	if KeyError exception is caught,
if '-' not in lang_code :	if character '-' is not contained  in lang_code,
raise KeyError ( 'Unknown language code %s.' % lang_code )	raise an KeyError with an argument 'Unknown language code %s.', where '%s' is replaced with lang_code.
generic_lang_code = lang_code . split ( '-' ) [ 0 ]	split lang_code by character '-', substitute the first element of the result for generic_lang_code.
try :	try,
return LANG_INFO [ generic_lang_code ]	get the LANG_INFO dictionary value under the generic_lang_code key, return the result.
except KeyError :	if KeyError exception is caught,
raise KeyError ( 'Unknown language code %s and %s.' % ( lang_code , generic_lang_code ) )	raise an KeyError with an argument string 'Unknown language code %s and %s.', where '%s' is replaced with lang_code,
\trim_whitespace_re = re . compile ( '\\s*\\n\\s*' )\	\and generic_lang_code.   call the function re.compile with an argument string '\\s*\\n\\s*', substitute the result for trim_whitespace_re.\
def trim_whitespace ( s ) :	define the function trim_whitespace with an argument s.
return trim_whitespace_re . sub ( ' ' , s . strip ( ) )	call strip s of the surrounding whitespaces, substitute every occurrence of the whitespace in the trim_whitespace_re with previous result, return the result.
from django . conf import settings	from django.conf import settings into default name space.
from django . utils . encoding import force_text	from django.utils.encoding import force_text into default name space.
from django . utils . safestring import mark_safe , SafeData	from django.utils.safestring import mark_safe and SafeData into default name space.
def ngettext ( singular , plural , number ) :	define the function ngettext with 3 arguments: singular, plural and number.
if number == 1 :	if number equals integer 1,
return singular	return singular.
return plural	return plural.
ngettext_lazy = ngettext	substitute ngettext for ngettext_lazy.
def ungettext ( singular , plural , number ) :	define the function ungettext with 3 arguments: singular, plural and number.
return force_text ( ngettext ( singular , plural , number ) )	call the function ngettext with 3 arguments: singular, plural and number, use the result as an argument for the call to the force_text,
def pgettext ( context , message ) :	return the result.   define the function pgettext with 2 arguments: context and message.
return ugettext ( message )	call the function ugettext with an argument message.
def npgettext ( context , singular , plural , number ) :	define the function ngettext with 4 arguments: context, singular, plural and number.
return ungettext ( singular , plural , number )	call the function ungettext with 3 arguments: singular, plural and number, return the result.
activate = lambda x : None	activate is a lambda function which returns None for any argument x.
deactivate = deactivate_all = lambda : None	deactivate and deactivate_all are lambda functions returning None.
get_language = lambda : settings . LANGUAGE_CODE	get_language is a lambda function returning settings.LANGUAGE_CODE.
get_language_bidi = lambda : settings . LANGUAGE_CODE in settings . LANGUAGES_BIDI	get_language_bidi is lambda function returning boolean True if settings.LANGUAGE_CODE is contained in settings.LANGUAGES_BIDI.
check_for_language = lambda x : True	check_for_language is lambda function that returns boolean True for every argument x.
def gettext ( message ) :	define the function gettext with an argument message.
if isinstance ( message , SafeData ) :	if message is an instance of SafeData.
return mark_safe ( message )	call the function mark_safe with an argument message, return the result.
return message	return message.
def ugettext ( message ) :	define the function ugettext with an argument message.
return force_text ( gettext ( message ) )	call the function gettext with an argument message, use the result as an argument for the call to the force_text function, return the result.
gettext_noop = gettext_lazy = _ = gettext	substitute gettext for gettext_noop, gettext_lazy and _.
def to_locale ( language ) :	define the function to_locale with an argument language.
p = language . find ( '-' )	find position of '-' in the index of the language, substitute the result for p.
if p >= 0 :	if p is greater or equal to integer 0,
return language [ : p ] . lower ( ) + '_' + language [ p + 1 : ] . upper ( )	append '_' to string created from first p elements of languages converted to lowercase,
else :	convert slice of language string from (p+1)-th index to the end to uppercase, append it to the previous result, return the resulting string.   if not,
return language . lower ( )	convert language to lowercase and return it.
def get_language_from_request ( request , check_path = False ) :	define the function get_language_from_request with 2 arguments: request and check_path set to boolean False.
return settings . LANGUAGE_CODE	return settings.LANGUAGE_CODE.
def get_language_from_path ( request ) :	define the function get_language_from_path with an argument request.
return None	return None.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from collections import OrderedDict	from collections import OrderedDict into default name space.
import os	import module os.
import re	import module re.
import sys	import module sys.
import gettext as gettext_module	import module gettext as gettext_module.
from threading import local	from threading import local into default name space.
import warnings	import module warnings.
from django . apps import apps	from django.apps import apps into default name space.
from django . conf import settings	from django.conf import settings into default name space.
from django . core . exceptions import AppRegistryNotReady	from django.core.exceptions import AppRegistryNotReady into default name space.
from django . dispatch import receiver	from django.dispatch import receiver into default name space.
from django . test . signals import setting_changed	from django.test.signals import setting_changed into default name space.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
from django . utils . encoding import force_text	from django.utils.encoding import force_text into default name space.
from django . utils . _os import upath	from django.utils._os import upath into default name space.
from django . utils . safestring import mark_safe , SafeData	from django.utils.safestring import mark_safe and SafeData into default name space.
from django . utils import six , lru_cache	from django.utils import six and lru_cache into default name space.
from django . utils . six import StringIO	from django.utils.six import StringIO into default name space.
from django . utils . translation import TranslatorCommentWarning , trim_whitespace , LANGUAGE_SESSION_KEY	from django.utils.translation import TranslatorCommentWarning, trim_whitespace and LANGUAGE_SESSION_KEY into default name space.
_translations = { }	_translations is an empty dictionary.
_active = local ( )	call the function local, substitute the result for _active.
_default = None	_default is None.
_supported = None	_supported is None.
\CONTEXT_SEPARATOR = '\\x04'\	\CONTEXT_SEPARATOR is a string '\\x04'.\
\accept_language_re = re . compile ( r'''         ([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\\*)      # 'en', 'en-au', 'x-y-z', 'es-419', '*'         (?:\\s*;\\s*q=(0(?:\\.\\d{,3})?|1(?:.0{,3})?))?   # Optional 'q=1.00', 'q=0.8'         (?:\\s*,\\s*|$)                                 # Multiple accepts per header.         ''' , re . VERBOSE )\	\call the function re.compile with 2 arguments: raw string '([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\\*)(?:\\s*;\\s*q=(0(?:\\.\\d{,3})?|1(?:.0{,3})?))?(?:\\s*,\\s*|$)',\
language_code_re = re . compile ( r'^[a-z]{1,8}(?:-[a-z0-9]{1,8})*$' , re . IGNORECASE )	and re.VERBOSE, substitute the result for accept_language_re.   call the function re.compile with 2 arguments: raw string '^[a-z]{1,8}(?:-[a-z0-9]{1,8})*$' and re.IGNORECASE,
\language_code_prefix_re = re . compile ( r'^/([\\w-]+)(/|$)' )\	\substitute the result for language_code_re.   call the function re.compile with an argument raw string '^/([\\w-]+)(/|$)', substitute the result for language_code_prefix_re.\
_BROWSERS_DEPRECATED_LOCALES = {  'zh-cn' : 'zh-hans' ,  'zh-tw' : 'zh-hant' ,  }	_BROWSERS_DEPRECATED_LOCALES is an dictionary with 2 initial entries: 'zh-hans' for 'zh-cn' and 'zh-hant' for 'zh-tw'.
_DJANGO_DEPRECATED_LOCALES = _BROWSERS_DEPRECATED_LOCALES	substitute _BROWSERS_DEPRECATED_LOCALES for _DJANGO_DEPRECATED_LOCALES.
@ receiver ( setting_changed )	decorator function receiver with an argument setting_changed,
def reset_cache ( ** kwargs ) :	define the function reset_cache with an argument unpacked dictionary kwargs.
if kwargs [ 'setting' ] in ( 'LANGUAGES' , 'LANGUAGE_CODE' ) :	if value under the 'setting' key of the kwargs dictionary is equal to string 'LANGUAGES' or strnig 'LANGUAGE_CODE',
global _supported	use global variable _supported.
_supported = None	_supported is None.
check_for_language . cache_clear ( )	call the method check_for_language.cache_clear.
get_supported_language_variant . cache_clear ( )	call the method get_supported_language_variant.cache_clear.
def to_locale ( language , to_lower = False ) :	define the function to_locale with 2 arguments language and to_lower set to boolean False.
p = language . find ( '-' )	find first index of occurrence of character '-' in language, substitute it for p.
if p >= 0 :	if p is greater or equal to integer 0,
if to_lower :	if to_lower is true,
return language [ : p ] . lower ( ) + '_' + language [ p + 1 : ] . lower ( )	convert fist p elements of language to lowercase, append '_' to it,
else :	covert to lowercase language elements from (p+1)-th index to the end, append it to the previous result, return it.   if not,
if len ( language [ p + 1 : ] ) > 2 :	slice language from (p+1)-th index to the end, calculate the length of the obtained segment, if it is greater than integer 2,
return language [ : p ] . lower ( ) + '_' + language [ p + 1 ] . upper ( ) + language [ p + 2 : ] . lower ( )	convert fist p elements of language to lowercase, append '_' to it,
return language [ : p ] . lower ( ) + '_' + language [ p + 1 : ] . upper ( )	covert to lowercase language element at (p+1)-th index, append it to the previous result,   covert to lowercase language elements from (p+2)-th index to the end, append it to the previous result, return it.   convert fist p elements of language to lowercase, append '_' to it,
else :	covert to uppercase language elements from (p+1)-th index to the end, append it to the previous result, return it.   if not,
return language . lower ( )	convert language to lowercase, return it.
def to_language ( locale ) :	define the function to_language with an argument locale.
p = locale . find ( '_' )	find first index of occurrence of character '-' in locale, substitute it for p.
if p >= 0 :	if p is greater or equal to integer 0,
return locale [ : p ] . lower ( ) + '-' + locale [ p + 1 : ] . lower ( )	convert fist p elements of locale to lowercase, append '_' to it,
else :	covert to lowercase locale elements from (p+1)-th index to the end, append it to the previous result, return it.   if not,
return locale . lower ( )	convert locale to lowercase and return it.
class DjangoTranslation ( gettext_module . GNUTranslations ) :	derive the class DjangoTranslation from gettext_module.GNUTranslations base class.
def __init__ ( self , language ) :	define the method __init__ with 2 arguments: self and language.
gettext_module . GNUTranslations . __init__ ( self )	call the method gettext_module.GNUTranslations.__init__ with an argument self.
self . __language = language	substitute language for self.__language.
self . __to_language = to_language ( language )	call the function to_language with an argument language, substitute it for self.__to_language.
self . __locale = to_locale ( language )	call the function to_locale with an argument language, substitute it for self.__locale.
self . plural = lambda n : int ( n != 1 )	self.plural is an lambda function with an argument n, which returns result of boolean expression n not equal to integer 1,
self . _init_translation_catalog ( )	converted to an integer.   call the method self._init_translation_catalog.
self . _add_installed_apps_translations ( )	call the method self._add_installed_apps_translations.
self . _add_local_translations ( )	call the method self._add_local_translations.
self . _add_fallback ( )	call the method self._add_fallback.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return '<DjangoTranslation lang:%s>' % self . __language	return a string '<DjangoTranslation lang:%s>', where '%s' is replaced with self.__language.
def _new_gnu_trans ( self , localedir , use_null_fallback = True ) :	define the method _new_gnu_trans with 3 arguments: self, localedir and use_null_fallback set to boolean True.
translation = gettext_module . translation (  domain = 'django' ,  localedir = localedir ,  languages = [ self . __locale ] ,  codeset = 'utf-8' ,  fallback = use_null_fallback )	call the method gettext_module.translation with 5 arguments: domain set to string 'django', localedir set to localedir,
if not hasattr ( translation , '_catalog' ) :	languages set to a list with an element self.__locale, codeset set to a string 'utf-8' and fallback set to use_null_fallback,   substitute the result for translation.   if translation has an attribute '_catalog',
translation . _catalog = { }	translation._catalog is an empty dictionary.
translation . _info = { }	translation._info is an empty dictionary.
return translation	return translation.
def _init_translation_catalog ( self ) :	define the method _init_translation_catalog with an argument self.
settingsfile = upath ( sys . modules [ settings . __module__ ] . __file__ )	get the value under the settings.__module__ key of the sys.modules dictionary,
localedir = os . path . join ( os . path . dirname ( settingsfile ) , 'locale' )	use its __file__ field as an argument for the call to the function upath, substitute the result for settingsfile.   call the function os.path.dirname with an argument settingsfile, join the result an string 'locale' into a file path,
use_null_fallback = True	substitute it for localedir.   use_null_fallback is boolean True.
if self . __language == settings . LANGUAGE_CODE :	if self.__language equals settings.LANGUAGE_CODE,
use_null_fallback = False	use_null_fallback is boolean False.
translation = self . _new_gnu_trans ( localedir , use_null_fallback )	call the function self._new_gnu_trans with 2 arguments: localedir and use_null_fallback, substitute the result for translation.
self . _info = translation . _info . copy ( )	call the method translation._info.copy, substitute the result for self._info.
self . _catalog = translation . _catalog . copy ( )	call the method translation._catalog.copy, substitute the result for self._catalog.
def _add_installed_apps_translations ( self ) :	define the method _add_installed_apps_translations with an argument self.
try :	try,
app_configs = reversed ( list ( apps . get_app_configs ( ) ) )	call the method apps.get_app_configs, convert the result in a list, reverse the order of elements, substitute the result for app_configs.
except AppRegistryNotReady :	if AppRegistryNotReady exception is caught,
raise AppRegistryNotReady (  'The translation infrastructure cannot be initialized before the '  'apps registry is ready. Check that you don't make non-lazy '  'gettext calls at import time.' )	rais an AppRegistryNotReady exception with an argument string 'The translation infrastructure cannot be initialized before the '
for app_config in app_configs :	apps registry is ready. Check that you don't make non-lazy gettext calls at import time..   for every app_config in app_configs,
localedir = os . path . join ( app_config . path , 'locale' )	join app_config.path and string 'locale' into a file path, substitute it for localedir.
translation = self . _new_gnu_trans ( localedir )	call the method self._new_gnu_trans with an argument localedir, substitute the result for translation.
self . merge ( translation )	call the method self.merge with an argument translation.
def _add_local_translations ( self ) :	define the method _add_local_translations with an argument self.
for localedir in reversed ( settings . LOCALE_PATHS ) :	reverse settings.LOCALE_PATHS element order, for every localedir in the result,
translation = self . _new_gnu_trans ( localedir )	call the function self._new_gnu_trans with an argument localedir, substitute the result for translation.
self . merge ( translation )	call the method self.merge with an argument translation.
def _add_fallback ( self ) :	define the method _add_fallback with an argument self.
if self . __language == settings . LANGUAGE_CODE or self . __language == 'en-us' :	if self.__language equals settings.LANGUAGE_CODE or self.__language equals a string 'en-us',
return	return.
default_translation = translation ( settings . LANGUAGE_CODE )	call the function translation with an argument settings.LANGUAGE_CODE, substitute the result for default_translation.
self . add_fallback ( default_translation )	call the method self.add_fallback with an argument default_translation.
def merge ( self , other ) :	define the method merge with 2 arguments self and other.
self . _catalog . update ( other . _catalog )	update the self._catalog dictionary with other._catalog.
def language ( self ) :	define the method language with an argument self.
return self . __language	return self.__language.
def to_language ( self ) :	define the method to_language with an argument self.
return self . __to_language	return self.__to_language.
def translation ( language ) :	define the function translation with an argument language.
global _translations	use global variable _translations.
if language not in _translations :	if language is not contained in _translations,
_translations [ language ] = DjangoTranslation ( language )	_translations dictionary value, under the language key is an instance of DjangoTranslation class, created with an argument language.
return _translations [ language ]	return _translations dictionary value, under the language key.
def activate ( language ) :	define the function activate with an argument language.
if language in _DJANGO_DEPRECATED_LOCALES :	if language is contained in _DJANGO_DEPRECATED_LOCALES,
msg = ( 'The use of the language code '%s' is deprecated. '  'Please use the '%s' translation instead.' )	msg is a string 'The use of the language code '%s' is deprecated. Please use the '%s' translation instead.'.
warnings . warn ( msg % ( language , _DJANGO_DEPRECATED_LOCALES [ language ] ) ,  RemovedInDjango19Warning , stacklevel = 2 )	call the method call the function warnings.warn with 3 arguments: msg formatted with language and value under the language key,
_active . value = translation ( language )	of the _DJANGO_DEPRECATED_LOCALES dictionary, RemovedInDjango19Warning and stacklevel set to integer 2.   call the function translation with an argument language, substitute the result for _active.value.
def deactivate ( ) :	define the function deactivate.
if hasattr ( _active , 'value' ) :	if _active has an attribute 'value',
del _active . value	delete _active.value.
def deactivate_all ( ) :	define the function deactivate_all.
_active . value = gettext_module . NullTranslations ( )	call the method gettext_module.NullTranslations, substitute the result for _active.value.
def get_language ( ) :	define the function get_language.
t = getattr ( _active , 'value' , None )	get 'value' attribute of the _active object, if it exists substitute it for t, if not t is None.
if t is not None :	if t is not None,
try :	try,
return t . to_language ( )	call the method t.to_language, return the result.
except AttributeError :	if AttributeError exception is caught,
pass	do nothing.
return settings . LANGUAGE_CODE	return settings.LANGUAGE_CODE.
def get_language_bidi ( ) :	define the function get_language_bidi.
base_lang = get_language ( ) . split ( '-' ) [ 0 ]	call the function get_language, split the result by '-', substitute the first element of the result for base_lang.
return base_lang in settings . LANGUAGES_BIDI	if base_lang is contained in settings.LANGUAGES_BIDI, return boolean True, if not, return boolean False.
def catalog ( ) :	define the function catalog.
global _default	use global variable _default.
t = getattr ( _active , 'value' , None )	get 'value' attribute of the _active object, if it exists substitute it for t, if not t is None.
if t is not None :	if t is not None
return t	return t.
if _default is None :	if _default is None
_default = translation ( settings . LANGUAGE_CODE )	call the function translation with an argument settings.LANGUAGE_CODE, substitute the result for _default.
return _default	return _default.
def do_translate ( message , translation_function ) :	define the function do_translate with 2 arguments: message and translation_function.
global _default	use global variable _default.
\eol_message = message . replace ( str ( '\\r\\n' ) , str ( '\\n' ) ) . replace ( str ( '\\r' ) , str ( '\\n' ) )\	\replace every occurrence of string '\\r\\n' in message with '\\n', replace every occurrence of string '\\r',\
t = getattr ( _active , 'value' , None )	\in the previous result for with string '\\n', substitute the result for eol_message.   get 'value' attribute of the _active object, if it exists substitute it for t, if not t is None.\
if t is not None :	if t is not None,
result = getattr ( t , translation_function ) ( eol_message )	get translation_function attribute of the object t, call the result with an argument eol_message, substitute the result for result.
else :	if not,
if _default is None :	if _default is None,
_default = translation ( settings . LANGUAGE_CODE )	call the function translation with an argument settings.LANGUAGE_CODE, substitute the result for _default.
result = getattr ( _default , translation_function ) ( eol_message )	get translation_function attribute of the object _default, call the result with an argument eol_message, substitute the result for result.
if isinstance ( message , SafeData ) :	if message is an instance of SafeData,
return mark_safe ( result )	call the function mark_safe with an argument result, return it.
return result	return result.
def gettext ( message ) :	define the function gettext with an argument message.
return do_translate ( message , 'gettext' )	call the function do_translate with 2 arguments: message and string 'gettext', return the result.
if six . PY3 :	if six.PY3 is true,
ugettext = gettext	substitute gettext for ugettext.
else :	if not,
def ugettext ( message ) :	define the function ugettext with an argument message.
return do_translate ( message , 'ugettext' )	call the function do_translate with 2 arguments: message and string 'ugettext', return the result.
def pgettext ( context , message ) :	define the function pgettext with 2 arguments: context and message.
msg_with_ctxt = '%s%s%s' % ( context , CONTEXT_SEPARATOR , message )	convert to strings and concatenate context, CONTEXT_SEPARATOR and message, substitute the result for msg_with_ctxt.
result = ugettext ( msg_with_ctxt )	call the function ugettext with an argument msg_with_ctxt, substitute the result for result.
if CONTEXT_SEPARATOR in result :	if CONTEXT_SEPARATOR is contained in result,
result = force_text ( message )	call the function force_text with an argument message, return the result.
return result	return result.
def gettext_noop ( message ) :	define the function locale with an argument locale.
return message	return message.
def do_ntranslate ( singular , plural , number , translation_function ) :	define the function do_ntranslate with 4 arguments: singular, plural, number and translation_function.
global _default	use global variable _default.
t = getattr ( _active , 'value' , None )	get 'value' attribute of the _active object, if it exists substitute it for t, if not t is None.
if t is not None :	if t is not None,
return getattr ( t , translation_function ) ( singular , plural , number )	get translation_function attribute of the t object, call the result with 3 arguments: singular, plural and number, return the result.
if _default is None :	if _default is None,
_default = translation ( settings . LANGUAGE_CODE )	call the function translation with an argument settings.LANGUAGE_CODE, substitute the result for _default.
return getattr ( _default , translation_function ) ( singular , plural , number )	get translation_function attribute of the _default object, call the result with 3 arguments: singular, plural and number, return the result.
def ngettext ( singular , plural , number ) :	define the function ngettext with 3 arguments: singular, plural and number.
return do_ntranslate ( singular , plural , number , 'ngettext' )	call the function do_ntranslate with 3 arguments: singular, plural, number and string 'ngettext', return the result.
if six . PY3 :	if six.PY3 is true,
ungettext = ngettext	substitute ngettext for ungettext.
else :	if not,
def ungettext ( singular , plural , number ) :	define the function ungettext with 3 arguments: singular, plural and number.
return do_ntranslate ( singular , plural , number , 'ungettext' )	call the function do_ntranslate with 3 arguments: singular, plural, number and string 'ngettext', return the result.
def npgettext ( context , singular , plural , number ) :	define the function npgettext with 4 arguments: context, singular, plural and number.
msgs_with_ctxt = ( '%s%s%s' % ( context , CONTEXT_SEPARATOR , singular ) ,  '%s%s%s' % ( context , CONTEXT_SEPARATOR , plural ) ,  number )	msgs_with_ctxt is a tuple containing 2 elements: string created by concatenating context, CONTEXT_SEPARATOR and singular,
result = ungettext ( * msgs_with_ctxt )	string created by concatenating context, CONTEXT_SEPARATOR and plural and number.   call the function ungettext with unpacked dictionary msgs_with_ctxt, substitute the result for result.
if CONTEXT_SEPARATOR in result :	if CONTEXT_SEPARATOR is contained in result,
result = ungettext ( singular , plural , number )	call the function ungettext with 3 arguments: singular, plural and number, substitute the result for result.
return result	return result.
def all_locale_paths ( ) :	define the function all_locale_paths.
globalpath = os . path . join (  os . path . dirname ( upath ( sys . modules [ settings . __module__ ] . __file__ ) ) , 'locale' )	get the value under the settings.__module__ key of the sys.modules dictionary, use its __file__ field as an argument,
return [ globalpath ] + list ( settings . LOCALE_PATHS )	for the call to the function upath, get the directory name of the resulting system path, join the result and string 'locale',   into a valid file path, substitute it for globalpath.   append settings.LOCALE_PATHS converted into a list to a list containing an element globalpath, return it.
@ lru_cache . lru_cache ( maxsize = 1000 )	decorator function lru_cache.lru_cache with an argument maxsize set to integer 1000.
def check_for_language ( lang_code ) :	define the function check_for_language with an argument lang_code.
if not language_code_re . search ( lang_code ) :	call the method language_code_re.search with an argument lang_code, if it evaluates to false,
return False	return boolean False.
for path in all_locale_paths ( ) :	call the function all_locale_paths, for every path is the result,
if gettext_module . find ( 'django' , path , [ to_locale ( lang_code ) ] ) is not None :	call the method gettext_module.find with 3 arguments: string 'django', path and list with an element: result of the function,
return True	to_locale called with an argument lang_code, if the result is not None,   return boolean True.
return False	return boolean False.
@ lru_cache . lru_cache ( maxsize = 1000 )	decorator function lru_cache.lru_cache with an argument maxsize set to integer 1000.
def get_supported_language_variant ( lang_code , strict = False ) :	define the function get_supported_language_variant with 2 arguments: lang_code and strict set to boolean False.
global _supported	use global variable _supported.
if _supported is None :	if _supported is None,
_supported = OrderedDict ( settings . LANGUAGES )	_supported is an instance of OrderedDict class, created with an argument settings.LANGUAGES.
if lang_code :	if lang_code is true,
replacement = _BROWSERS_DEPRECATED_LOCALES . get ( lang_code )	get the value under the lang_code key of the _BROWSERS_DEPRECATED_LOCALES dictionary, substitute it for replacement.
if lang_code not in _supported and replacement in _supported :	if lang_code is not contained in _supported and replacement is contained in _supported,
return replacement	return replacement.
generic_lang_code = lang_code . split ( '-' ) [ 0 ]	split lang_code by '-', substitute the first element of the result for generic_lang_code.
for code in ( lang_code , generic_lang_code ) :	for every code in tuple with 2 elements: lang_code and generic_lang_code,
if code in _supported and check_for_language ( code ) :	if code is contained in _supported and call to the function check_for_language with an argument code evaluates to true,
return code	return code.
if not strict :	if strict is false,
for supported_code in _supported :	for every supported_code in _supported,
if supported_code . startswith ( generic_lang_code + '-' ) :	append '-' to generic_lang_code, if supported_code starts with it,
return supported_code	return supported_code.
raise LookupError ( lang_code )	raise an LookupError with an argument lang_code.
def get_language_from_path ( path , strict = False ) :	define the function get_language_from_path with 2 arguments: path and strict set to boolean False.
regex_match = language_code_prefix_re . match ( path )	call the function language_code_prefix_re.match with an argument path, substitute it for regex_match.
if not regex_match :	if regex_match is false,
return None	return None.
lang_code = regex_match . group ( 1 )	call the method regex_match.group with an argument integer 1, substitute the result for lang_code.
try :	try,
return get_supported_language_variant ( lang_code , strict = strict )	call the function get_supported_language_variant with 2 arguments: lang_code and strict set to strict, return the result.
except LookupError :	if LookupError exception is caught,
return None	return None.
def get_language_from_request ( request , check_path = False ) :	define the function get_language_from_request with 2 arguments: request and check_path set to boolean False.
global _supported	use global variable _supported.
if _supported is None :	if _supported is None,
_supported = OrderedDict ( settings . LANGUAGES )	_supported is an instance of OrderedDict class, created with an argument settings.LANGUAGES.
if check_path :	if check_path is true,
lang_code = get_language_from_path ( request . path_info )	call the function get_language_from_path with an argument request.path_info, substitute it for lang_code.
if lang_code is not None :	if lang_code is not None,
return lang_code	return lang_code.
if hasattr ( request , 'session' ) :	if request has an attribute 'session',
lang_code = request . session . get ( LANGUAGE_SESSION_KEY )	get the value under the LANGUAGE_SESSION_KEY key of the request.session dictionary, substitute it for lang_code.
if lang_code in _supported and lang_code is not None and check_for_language ( lang_code ) :	if lang_code is contained in _supported and lang_code is not None and result of the function check_for_language,
return lang_code	called with an argument lang_code is true,   return lang_code.
lang_code = request . COOKIES . get ( settings . LANGUAGE_COOKIE_NAME )	get the value under the settings.LANGUAGE_COOKIE_NAME key of the request.COOKIES dictionary, substitute it for lang_code.
try :	try,
return get_supported_language_variant ( lang_code )	call the function get_supported_language_variant with an argument lang_code, return the result.
except LookupError :	if LookupError exception is caught,
pass	do nothing.
accept = request . META . get ( 'HTTP_ACCEPT_LANGUAGE' , '' )	get the value under the 'HTTP_ACCEPT_LANGUAGE' key of the request.META dictionary, if it exists substitute it for accept,
for accept_lang , unused in parse_accept_lang_header ( accept ) :	if not accept is an empty string.   call the function parse_accept_lang_header with an argument accept, for every accept_lang and unused in the result,
if accept_lang == '*' :	if accept_lang equals '*',
break	break from the loop execution.
if not language_code_re . search ( accept_lang ) :	call the method language_code_re.search with an argument accept_lang, if it evaluates to false,
continue	skip this loop iteration.
try :	try,
return get_supported_language_variant ( accept_lang )	call the function get_supported_language_variant with an argument accept_lang, return the result.
except LookupError :	if LookupError exception is caught,
continue	skip this loop iteration.
try :	try,
return get_supported_language_variant ( settings . LANGUAGE_CODE )	call the function get_supported_language_variant with an argument settings.LANGUAGE_CODE, return the result.
except LookupError :	if LookupError exception is caught,
return settings . LANGUAGE_CODE	return settings.LANGUAGE_CODE.
\dot_re = re . compile ( r'\\S' )\	\call the function re.compile with an argument raw string '\\S', substitute it for dot_re.\
def blankout ( src , char ) :	define the function blankout with 2 arguments: src and char.
return dot_re . sub ( char , src )	call the method dot_re.sub with 2 arguments: char and src, return the result.
\context_re = re . compile ( r'''^\\s+.*context\\s+((?:'[^']*?')|(?:'[^']*?'))\\s*''' )\	\call the function re.compile with an argument raw string '^\\s+.*context\\s+((?:'[^']*?')|(?:'[^']*?'))\\s*', substitute the result for context_re.\
\inline_re = re . compile ( r'''^\\s*trans\\s+((?:'[^']*?')|(?:'[^']*?'))(\\s+.*context\\s+((?:'[^']*?')|(?:'[^']*?')))?\\s*''' )\	\call the function re.compile with an argument string '^\\s*trans\\s+((?:'[^']*?')|(?:'[^']*?'))(\\s+.*context\\s+((?:'[^']*?')|(?:'[^']*?')))?\\s*', substitute the result for inline_re.\
\block_re = re . compile ( r'''^\\s*blocktrans(\\s+.*context\\s+((?:'[^']*?')|(?:'[^']*?')))?(?:\\s+|$)''' )\	\call the function re.compile with an argument raw string '^\\s*blocktrans(\\s+.*context\\s+((?:'[^']*?')|(?:'[^']*?')))?(?:\\s+|$)',\
\endblock_re = re . compile ( r'''^\\s*endblocktrans$''' )\	\substitute the result for block_re.   call the function re.compile with an argument raw string '^\\s*endblocktrans$', substitute the result for endblock_re.\
\plural_re = re . compile ( r'''^\\s*plural$''' )\	\call the function re.compile with an argument raw string '^\\s*plural$', substitute the result for plural_re.\
\constant_re = re . compile ( r'''_\\(((?:'.*?')|(?:'.*?'))\\)''' )\	\call the function re.compile with an argument raw string '_\\(((?:'.*?')|(?:'.*?'))\\)', substitute the result for constant_re.\
one_percent_re = re . compile ( r'''(?<!%)%(?!%)''' )	call the function re.compile with an argument raw string '(?<!%)%(?!%)', substitute the result for one_percent_re.
def templatize ( src , origin = None ) :	define the function templatize with 2 arguments: src and origin set to None.
from django . template import ( Lexer , TOKEN_TEXT , TOKEN_VAR , TOKEN_BLOCK ,  TOKEN_COMMENT , TRANSLATOR_COMMENT_MARK )	from django.template import Lexer, TOKEN_TEXT, TOKEN_VAR, TOKEN_BLOCK, TOKEN_COMMENT and TRANSLATOR_COMMENT_MARK.
src = force_text ( src , settings . FILE_CHARSET )	call the function force_text with 2 arguments: src and settings.FILE_CHARSET.
out = StringIO ( '' )	out is an instance of StringIO class, created with an empty string as an argument.
message_context = None	message_context is None.
intrans = False	intrans is boolean False.
inplural = False	inplural is boolean False.
trimmed = False	trimmed is boolean False.
singular = [ ]	singular is an empty list.
plural = [ ]	plural is an empty list.
incomment = False	incomment is boolean False.
comment = [ ]	comment is an empty list.
lineno_comment_map = { }	lineno_comment_map is an dictionary.
comment_lineno_cache = None	comment_lineno_cache is None.
def join_tokens ( tokens , trim = False ) :	define the function join_tokens with 2 arguments: tokens and trim set to boolean False.
message = '' . join ( tokens )	join tokens elements into a string, substitute it for message.
if trim :	if trim is true,
message = trim_whitespace ( message )	call the function trim_whitespace with an argument message, substitute the result for message.
return message	return message.
for t in Lexer ( src , origin ) . tokenize ( ) :	instantiate Lexer class with 2 argumets src and origin, call the method tokenize from it, for every t in the result,
if incomment :	if incomment is true,
if t . token_type == TOKEN_BLOCK and t . contents == 'endcomment' :	if t.token_type equals TOKEN_BLOCK and t.contents equals 'endcomment',
content = '' . join ( comment )	join comment elements into a string, substitute it for content.
translators_comment_start = None	translators_comment_start is None.
for lineno , line in enumerate ( content . splitlines ( True ) ) :	for every lineno and line is enumerated result of the method content.splitlines, called with an argument boolean True,
if line . lstrip ( ) . startswith ( TRANSLATOR_COMMENT_MARK ) :	call the method line.lstrip, if the result starts with TRANSLATOR_COMMENT_MARK,
    translators_comment_start = lineno	substitute lineno for translators_comment_start.
for lineno , line in enumerate ( content . splitlines ( True ) ) :	for every lineno and line is enumerated result of the method content.splitlines, called with an argument boolean True,
if translators_comment_start is not None and lineno >= translators_comment_start :	if translators_comment_start is not None and lineno is greater than or equal to translators_comment_start,
    out . write ( ' # %s' % line )	substitute '%s' in string ' # %s' with line, write it to out file.
else :	if not,
\    out . write ( ' #\\n' )\	\write string ' #\\n' to out file.\
incomment = False	incomment is boolean False.
comment = [ ]	comment is an empty list.
else :	if not,
comment . append ( t . contents )	append t.contents to comment.
elif intrans :	otherwise if intrans is true,
if t . token_type == TOKEN_BLOCK :	if t.token_type equals TOKEN_BLOCK,
endbmatch = endblock_re . match ( t . contents )	call the function endblock_re.match with an argument t.contents, substitute the result for endbmatch.
pluralmatch = plural_re . match ( t . contents )	call the function plural_re.match with an argument t.contents, substitute the result for pluralmatch.
if endbmatch :	if endbmatch is true,
if inplural :	if inplural is true,
    if message_context :	if message_context is true,
        out . write ( ' npgettext(%r, %r, %r,count) ' % (  message_context ,  join_tokens ( singular , trimmed ) ,  join_tokens ( plural , trimmed ) ) )	substitute '%r' in string ' npgettext(%r, %r, %r,count) ' with message_context, result of the function join_tokens,
else :	called with 2 arguments: singular and trimmed and result of the function join_tokens called with 2 arguments: plural and trimmed,   write the result to out.   if not,
        out . write ( ' ngettext(%r, %r, count) ' % (  join_tokens ( singular , trimmed ) ,  join_tokens ( plural , trimmed ) ) )	substitute '%r' in string ' ngettext(%r, %r, count) ' with result of the function join_tokens, called with 2 arguments: singular,
for part in singular :	and trimmed and result of the function join_tokens called with 2 arguments: plural and trimmed, write the result to out.   for every part in singular,
        out . write ( blankout ( part , 'S' ) )	call the method blankout with 2 arguments: part and 'S', write the result to out.
for part in plural :	for every part in plural,
        out . write ( blankout ( part , 'P' ) )	call the method blankout with 2 arguments: part and 'P', write the result to out.
else :	if not,
    if message_context :	if message_context is true,
        out . write ( ' pgettext(%r, %r) ' % (  message_context ,  join_tokens ( singular , trimmed ) ) )	substitute '%r' in string ' pgettext(%r, %r) ' with message_context and result of the function join_tokens,
else :	called with 2 arguments: singular and trimmed, write the result to out.   if not,
        out . write ( ' gettext(%r) ' % join_tokens ( singular ,  trimmed ) )	substitute '%r' in string ' gettext(%r) ' with  result of the function join_tokens, called with 2 arguments: singular,
for part in singular :	and trimmed, write the result to out.   for every part in singular,
        out . write ( blankout ( part , 'S' ) )	call the method blankout with 2 arguments: part and 'S', write the result to out.
message_context = None	message_context is None.
intrans = False	intrans is boolean False.
inplural = False	inplural is boolean False.
singular = [ ]	singular is an empty list.
plural = [ ]	plural is an empty list.
elif pluralmatch :	otherwise if pluralmatch is true,
inplural = True	inplural is boolean True.
else :	if not,
filemsg = ''	filemsg is an empty string.
if origin :	if origin is true,
    filemsg = 'file %s, ' % origin	filemsg is a string 'file %s, ', where '%s' is replaced with origin.
raise SyntaxError ( 'Translation blocks must not include other block tags: %s (%sline %d)' % ( t . contents , filemsg , t . lineno ) )	raise an SyntaxError with an argument string 'Translation blocks must not include other block tags: %s (%sline %d)',
elif t . token_type == TOKEN_VAR :	formated with t.contents, filemsg and t.lineno.   otherwise if t.token_type equals TOKEN_VAR,
if inplural :	if inplural is true,
plural . append ( '%%(%s)s' % t . contents )	append string '%%(%s)s' to plural, where '%s' is replaced with t.contents.
else :	if not,
singular . append ( '%%(%s)s' % t . contents )	append string '%%(%s)s' to singular, where '%s' is replaced with t.contents.
elif t . token_type == TOKEN_TEXT :	if t.token_type == TOKEN_TEXT:
contents = one_percent_re . sub ( '%%' , t . contents )	call the method one_percent_re.sub with 2 arguments: string '%%' and t.contents, substitute the result for contents.
if inplural :	if inplural is true,
plural . append ( contents )	append contents to plural.
else :	if not,
singular . append ( contents )	append contents to singular.
else :	if not,
if comment_lineno_cache is not None :	if comment_lineno_cache is not None,
\cur_lineno = t . lineno + t . contents . count ( '\\n' )\	\count occurrences of '\\n' in t.contents, add the result to t.lineno, substitute the result for cur_lineno.\
if comment_lineno_cache == cur_lineno :	if comment_lineno_cache equals cur_lineno.
if t . token_type != TOKEN_COMMENT :	if t.token_type is not equal to TOKEN_COMMENT,
    for c in lineno_comment_map [ comment_lineno_cache ] :	for every c in lineno_comment_map dictionary value under the comment_lineno_cache key,
        filemsg = ''	filemsg is an empty string.
if origin :	if origin is true,
            filemsg = 'file %s, ' % origin	filemsg is a string 'file %s, ', where '%s' is replaced with origin.
warn_msg = ( 'The translator-targeted comment '%s' '  '(%sline %d) was ignored, because it wasn't the last item '  'on the line.' ) % ( c , filemsg , comment_lineno_cache )	warn_msg is a string 'The translator-targeted comment '%s' (%sline %d) was ignored, because it wasn't the last item on the line.',
warnings . warn ( warn_msg , TranslatorCommentWarning )	formated with c, filemsg and comment_lineno_cache.   call the function warnings.warn with 2 arguments: warn_msg and TranslatorCommentWarning.
lineno_comment_map [ comment_lineno_cache ] = [ ]	value under the comment_lineno_cache key of the lineno_comment_map dictionary is an empty string.
else :	if not,
out . write ( '# %s' % ' | ' . join ( lineno_comment_map [ comment_lineno_cache ] ) )	join lineno_comment_map dictionary value under the comment_lineno_cache key into a string, separated with ' | ',
comment_lineno_cache = None	format with it a string '# %s', write it to out.   comment_lineno_cache is None,
if t . token_type == TOKEN_BLOCK :	  if t.token_type equals TOKEN_BLOCK,
imatch = inline_re . match ( t . contents )	call the function inline_re.match with an argument t.contents, substitute the result for imatch.
bmatch = block_re . match ( t . contents )	call the function block_re.match with an argument t.contents, substitute the result for bmatch.
cmatches = constant_re . findall ( t . contents )	call the function constant_re.findall with an argument t.contents, substitute the result for cmatches.
if imatch :	if imatch is true,
g = imatch . group ( 1 )	call the method imatch.group with an argument integer 1, substitute the result for g.
g = one_percent_re . sub ( '%%' , g )	call the method one_percent_re.sub with 2 arguments: string '%%' and g, substitute the result for .
if imatch . group ( 2 ) :	call the method imatch.group with an argument integer 1, if it evaluates to true,
      context_match = context_re . match ( imatch . group ( 2 ) )	call the method imatch.group with an argument integer 2, use the result as an argument for the call to the method context_re.match,
message_context = context_match . group ( 1 )	substitute the result for context_match.   call the method context_match.group with an argument integer 1, substitute the result for message_context.
out . write ( ' pgettext(%r, %r) ' % ( message_context , g ) )	format string ' pgettext(%r, %r) ' with message_context and g, write it to out.
message_context = None	message_context is None.
else :	if not,
    out . write ( ' gettext(%r) ' % g )	format string ' gettext(%r) ' with g, write it to out.
elif bmatch :	otherwise if bmatch is true,
for fmatch in constant_re . findall ( t . contents ) :	call the method constant_re.findall with an argument t.contents, for every fmatch in the result,
    out . write ( ' _(%s) ' % fmatch )	format string ' _(%s) ', with fmatch, write it to out.
if bmatch . group ( 1 ) :	call the method bmatch.group with an argument integer 1, if it evaluates to true,
      context_match = context_re . match ( bmatch . group ( 1 ) )	call the method bmatch.group with an argument integer 1, use the result as an argument for the call to the function context_re.match,
message_context = context_match . group ( 1 )	substitute the result for context_match.   call the method context_match.group with an argument integer 1, substitute the result for message_context.
intrans = True	intrans is boolean True.
inplural = False	inplural is boolean False.
trimmed = 'trimmed' in t . split_contents ( )	if string 'trimmed' is contained in result of the method t.split_contents, trimmed is boolean True, otherwise is boolean False.
singular = [ ]	singular is an empty list.
plural = [ ]	plural is an empty list.
elif cmatches :	otherwise if cmatches is true,
for cmatch in cmatches :	for every cmatch in cmatches,
    out . write ( ' _(%s) ' % cmatch )	format string ' _(%s) ', with fmatch, write it to out.
elif t . contents == 'comment' :	otherwise if t.contents equals a string 'comment',
incomment = True	incomment is boolean True.
else :	if not,
out . write ( blankout ( t . contents , 'B' ) )	call the function blankout with 2 arguments: t.contents and 'B', write the result to out.
elif t . token_type == TOKEN_VAR :	otherwise if t.token_type equals TOKEN_VAR,
parts = t . contents . split ( '|' )	split t.contents by '|' symbol, substitute the result for parts,
cmatch = constant_re . match ( parts [ 0 ] )	call the method constant_re.match with first element of parts as an argument, substitute the result for cmatch.
if cmatch :	if cmatch is true,
out . write ( ' _(%s) ' % cmatch . group ( 1 ) )	call the method cmatch.group with an argument integer 1, format with the result string ' _(%s) ', write it to out.
for p in parts [ 1 : ] :	for every p in parts without the first element,
if p . find ( ':_(' ) >= 0 :	find index of the occurrence of string ':_(' in p, if its greater or equal to integer 0,
    out . write ( ' %s ' % p . split ( ':' , 1 ) [ 1 ] )	split p into two parts at the first ':', use the second element of the result to format string ' _(%s) ', write it to out.
else :	if not,
    out . write ( blankout ( p , 'F' ) )	call the function blankout with 2 arguments: p and 'F', write the result to out.
elif t . token_type == TOKEN_COMMENT :	otherwise if t.token_type equals TOKEN_COMMENT,
if t . contents . lstrip ( ) . startswith ( TRANSLATOR_COMMENT_MARK ) :	strip t.contents from the left side of whitespaces, if the result starts with TRANSLATOR_COMMENT_MARK,
lineno_comment_map . setdefault ( t . lineno ,  [ ] ) . append ( t . contents )	call the method lineno_comment_map.setdefault with 2 arguments: t.lineno and an empty list, append t.contents to the result.
comment_lineno_cache = t . lineno	substitute t.lineno for comment_lineno_cache.
else :	if not,
out . write ( blankout ( t . contents , 'X' ) )	call the function blankout with 2 arguments: t.contents and 'X', write the result to out.
return out . getvalue ( )	call the method out.getvalue, return the result.
def parse_accept_lang_header ( lang_string ) :	define the function parse_accept_lang_header with an argument lang_string.
result = [ ]	result is an empty list.
pieces = accept_language_re . split ( lang_string . lower ( ) )	convert lang_string to lowercase, split by the result string accept_language_re, substitute the result for pieces.
if pieces [ - 1 ] :	if last element of pieces is true,
return [ ]	return an empty list.
for i in range ( 0 , len ( pieces ) - 1 , 3 ) :	for every i in range of integers from integer 0 to the length of pieces decremented by one, with step of integer 3,
first , lang , priority = pieces [ i : i + 3 ]	substitute 3 successive elements starting from the i-th index of pieces for first, lang and priority, respectively.
if first :	if first is true,
return [ ]	return an empty list.
if priority :	if priority is true,
try :	try,
priority = float ( priority )	convert priority into a floating point integer, substitute it for priority.
except ValueError :	if ValueError exception is caught,
return [ ]	return an empty list.
if not priority :	if priority is false,
priority = 1.0	priority is floating point number 1.0.
result . append ( ( lang , priority ) )	append a tuple with 2 entries lang and priority to result.
result . sort ( key = lambda k : k [ 1 ] , reverse = True )	sort result in reversed order by the key as lambda function with an argument k and reeturn value second element of k.
return result	return result.
import copy	import module copy.
class Node ( object ) :	derive the class Node from object base class.
default = 'DEFAULT'	default is a string 'DEFAULT'.
def __init__ ( self , children = None , connector = None , negated = False ) :	define the method __init__ with 4 arguments: self, children set to None, connector set to None and negated set to boolean False.
self . children = children [ : ] if children else [ ]	if children is true, copy children list to self.children, otherwise self.children is an empty list.
self . connector = connector or self . default	if connector is true, substitute it for self.connector, otherwise substitute self.default for self.connector.
self . negated = negated	substitute negated for self.negated.
@ classmethod	decorator classmethod,
def _new_instance ( cls , children = None , connector = None , negated = False ) :	define the method _new_instance with 4 arguments: (cls, children set to None, connector set to None and negated set to boolean False.
obj = Node ( children , connector , negated )	obj is an instance of Node class, created with 3 arguments: children, connector and negated.
obj . __class__ = cls	substitute cls for obj.__class__.
return obj	return obj.
def __str__ ( self ) :	define the method __str__ with an argument self.
if self . negated :	if self.negated,
return '(NOT (%s: %s))' % ( self . connector , ', ' . join ( [ str ( c ) for c  in self . children ] ) )	return string '(NOT (%s: %s))', formated with self.connector and string created by joining c into a string, separated by ', ',
return '(%s: %s)' % ( self . connector , ', ' . join ( [ str ( c ) for c in  self . children ] ) )	for every c in self.children.   return string '(%s: %s)', formated with self.connector and string created by joining c into a string, separated by ', ',
def __repr__ ( self ) :	for every c in self.children.   define the method __repr__ with an argument self.
return '<%s: %s>' % ( self . __class__ . __name__ , self )	return string '<%s: %s>', formated with self.__class__.__name__ and self.
def __deepcopy__ ( self , memodict ) :	define the method __deepcopy__ with 2 arguments: self and memodict.
obj = Node ( connector = self . connector , negated = self . negated )	obj is an instance of Node class, created with 2 arguments: connector set to self.connector and negated set to self.negated.
obj . __class__ = self . __class__	substitute self.__class__ for obj.__class__.
obj . children = copy . deepcopy ( self . children , memodict )	call the function copy.deepcopy with 2 arguments: self.children and memodict, substitute the result for obj.children.
return obj	return obj.
def __len__ ( self ) :	define the method __len__ with an argument self.
return len ( self . children )	return the length of self.children.
def __bool__ ( self ) :	define the method __bool__ with an argument self.
return bool ( self . children )	convert self.children into an boolean, return it.
def __nonzero__ ( self ) :	define the method __nonzero__ with an argument self.
return type ( self ) . __bool__ ( self )	get the type of the self object, on the result call the __bool__ method with an argument self, return the result.
def __contains__ ( self , other ) :	define the method __contains__ with 2 arguments: self and other.
return other in self . children	if other is contained in self.children, return boolean True, otherwise return boolean False.
def _prepare_data ( self , data ) :	define the method _prepare_data with 2 arguments: self and data.
return data	return data.
def add ( self , data , conn_type , squash = True ) :	define the method add with 4 arguments: self, data, conn_type and squash set to boolean True.
if data in self . children :	if data is contained in self.children,
return data	return data.
data = self . _prepare_data ( data )	call the method self._prepare_data with an argument data, substitute the result for data.
if not squash :	if squash is false,
self . children . append ( data )	append data to self.children.
return data	return data.
if self . connector == conn_type :	if self.connector equals conn_type,
if ( isinstance ( data , Node ) and not data . negated  and ( data . connector == conn_type or len ( data ) == 1 ) ) :	if data is instance of Node and data.negated is false, and if data.connector equals conn_type or length of data equals integer 1,
  self . children . extend ( data . children )	extend self.children list with data.children.
return self	return self.
else :	if not,
self . children . append ( data )	append data to self.children.
return data	return data.
else :	if not,
obj = self . _new_instance ( self . children , self . connector ,  self . negated )	call the method self._new_instance with 3 arguments: self.children, self.connector and self.negated, substitute the result for obj.
self . connector = conn_type	substitute conn_type for self.connector.
self . children = [ obj , data ]	self.children is an list with 2 elements: obj and data.
return data	return data.
def negate ( self ) :	define the method negate with an argument self.
self . negated = not self . negated	invert self.negated.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
from datetime import timedelta , tzinfo	from datetime import timedelta and tzinfo into default name space.
import time	import module time.
import warnings	import module warnings.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
from django . utils . encoding import force_str , force_text , DEFAULT_LOCALE_ENCODING	from django.utils.encoding import force_str,  force_text and DEFAULT_LOCALE_ENCODING into default name space.
warnings . warn (  'django.utils.tzinfo will be removed in Django 1.9. '  'Use django.utils.timezone instead.' ,  RemovedInDjango19Warning , stacklevel = 2 )	call the function warnings.warn with 3 arguments: string 'django.utils.tzinfo will be removed in Django 1.9. '
class FixedOffset ( tzinfo ) :	Use django.utils.timezone instead., RemovedInDjango19Warning and stacklevel set to 2.   derive the class FixedOffset from the tzinfo base class.
def __init__ ( self , offset ) :	define the method __init__ with 2 arguments: self and offset.
warnings . warn (  'django.utils.tzinfo.FixedOffset will be removed in Django 1.9. '  'Use django.utils.timezone.get_fixed_timezone instead.' ,  RemovedInDjango19Warning )	call the function warnings.warn with 2 arguments: 'django.utils.tzinfo.FixedOffset will be removed in Django 1.9. '
if isinstance ( offset , timedelta ) :	Use django.utils.timezone.get_fixed_timezone instead. and RemovedInDjango19Warning.   if offset is an instance of timedelta class,
self . __offset = offset	substitute offset for self.__offset.
offset = self . __offset . seconds // 60	substitute self.__offset.seconds for offset.
else :	if not,
self . __offset = timedelta ( minutes = offset )	call the function timedelta with an argument minutes set to offset, substitute the result for self.__offset.
sign = '-' if offset < 0 else '+'	if offset is lesser than integer 0, sign is set to '-', otherwise sign is '+',
self . __name = '%s%02d%02d' % ( sign , abs ( offset ) / 60. , abs ( offset ) % 60 )	self.__name is a string '%s%02d%02d', replace '%s' with sign, '%02d' is replaced with absolute value of offset divided by 60,
def __repr__ ( self ) :	and placed into 2 character spaces, and '%02d' is replaced with reminder of the division of absolute offset by integer 60,   and placed into 2 character spaces.   define the method __repr__ with an argument self.
return self . __name	return self.__name.
def __getinitargs__ ( self ) :	define the method __getinitargs__ with an argument self.
return self . __offset ,	return a tuple with an element self.__offset.
def utcoffset ( self , dt ) :	define the method utcoffset with 2 arguments self and dt.
return self . __offset	return self.__offset.
def tzname ( self , dt ) :	define the method tzname with 2 arguments self and dt.
return self . __name	return self.__name.
def dst ( self , dt ) :	define the method dst with 2 arguments self and dt.
return timedelta ( 0 )	call the function timedelta with an argument integer 0, return the result.
class LocalTimezone ( tzinfo ) :	derive the class LocalTimezone from the tzinfo base class.
def __init__ ( self , dt ) :	define the method __init__ with 2 arguments self and dt.
warnings . warn (  'django.utils.tzinfo.LocalTimezone will be removed in Django 1.9. '  'Use django.utils.timezone.get_default_timezone instead.' ,  RemovedInDjango19Warning )	call the function warnings.warn with 2 arguments: string 'django.utils.tzinfo.LocalTimezone will be removed in Django 1.9. '
tzinfo . __init__ ( self )	Use django.utils.timezone.get_default_timezone instead. and RemovedInDjango19Warning.   call the method tzinfo.__init__ with an argument self.
self . __dt = dt	substitute dt for self.__dt.
self . _tzname = self . tzname ( dt )	call the method self.tzname with an argument dt, substitute the result for self._tzname.
def __repr__ ( self ) :	define the method __repr__ with an argument self.
return force_str ( self . _tzname )	call the function force_str with an argument self._tzname, return the result.
def __getinitargs__ ( self ) :	define the method __getinitargs__ with an argument self.
return self . __dt ,	return a tuple with an element self.__dt.
def utcoffset ( self , dt ) :	define the method utcoffset with 2 arguments self and dt.
if self . _isdst ( dt ) :	call the nethod self._isdst with an argument dt, if it evaluates to true,
return timedelta ( seconds = - time . altzone )	call the function timedelta with an argument seconds as negative time.altzone, return the result.
else :	if not,
return timedelta ( seconds = - time . timezone )	call the function timedelta with an argument seconds as negative time.timezone, return the result.
def dst ( self , dt ) :	define the method dst with 2 arguments self and dt.
if self . _isdst ( dt ) :	call the nethod self._isdst with an argument dt, if it evaluates to true,
return timedelta ( seconds = - time . altzone ) - timedelta ( seconds = - time . timezone )	call the function timedelta with an argument seconds as negative time.timezone, subtract the result from the result of the call,
else :	to the function timedelta called with an argument seconds as negative time.altzone, return the result.   if not,
return timedelta ( 0 )	call the function timedelta with an argument integer 0, return the result.
def tzname ( self , dt ) :	define the method tzname with 2 arguments self and dt.
is_dst = False if dt is None else self . _isdst ( dt )	if dt is None is_dst is boolean False, otherwise call the method self._isdst with an argument dt, substitute the result for is_dst.
try :	try,
return force_text ( time . tzname [ is_dst ] , DEFAULT_LOCALE_ENCODING )	call the function force_text with 2 arguments: value under the is_dst key of the time.tzname and DEFAULT_LOCALE_ENCODING,
except UnicodeDecodeError :	return the result.   if UnicodeDecodeError exception is caught,
return None	return None.
def _isdst ( self , dt ) :	define the method _isdst with 2 arguments self and dt.
tt = ( dt . year , dt . month , dt . day ,  dt . hour , dt . minute , dt . second ,  dt . weekday ( ) , 0 , 0 )	tt is an tuple with 9 elements: dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, result of the function dt.weekday,
try :	integer 0 and integer 0.   try,
stamp = time . mktime ( tt )	call the method time.mktime with an argument tt, substitute the result for stamp.
except ( OverflowError , ValueError ) :	if OverflowError or ValueError exceptions are caught,
  tt = ( 2037 , ) + tt [ 1 : ]	create a tuple out a tuple with an element integer 2037 and a list tt elements without the first element, substitute the result for tt.
stamp = time . mktime ( tt )	call the method time.mktime with an argument tt, substitute the result for stamp.
tt = time . localtime ( stamp )	call the method time.localtime with an argument stamp, substitute the result for tt.
return tt . tm_isdst > 0	if tt.tm_isdst is greater than intger 0, return boolean True, otherwise return boolean False.
from __future__ import absolute_import	from __future__ import absolute_import into default name space.
import warnings	import module warnings.
from django . utils . deprecation import RemovedInDjango19Warning	from django.utils.deprecation import RemovedInDjango19Warning into default name space.
warnings . warn ( 'django.utils.unittest will be removed in Django 1.9.' ,  RemovedInDjango19Warning , stacklevel = 2 )	call the function warnings.warn with 3 arguments: string 'django.utils.unittest will be removed in Django 1.9.',
try :	RemovedInDjango19Warning and stacklevel as integer 2.   try,
from unittest2 import *	from unittest2 import everything.
except ImportError :	if ImportError exception is caught,
from unittest import *	from unittest import import everything.
from __future__ import unicode_literals	from __future__ import unicode_literals into default name space.
import datetime	import module datetime.
import os	import module os.
import subprocess	import module subprocess.
def get_version ( version = None ) :	define the function get_version with version set to None as argument.
version = get_complete_version ( version )	call the get_complete_version function with version as argument, store the result in version.
major = get_major_version ( version )	call the get_major_version wit version as argument, store the result in major.
sub = ''	sub is an empty string.
if version [ 3 ] == 'alpha' and version [ 4 ] == 0 :	if fourth element of version equals to string 'alpha' and fight element of version equals to integer 0,
git_changeset = get_git_changeset ( )	call the function get_git_changeset, store the result in git_changeset.
if git_changeset :	if git_changeset is true,
sub = '.dev%s' % git_changeset	convert git_changeset to string, append it to the string '.dev', replace it for sub.
elif version [ 3 ] != 'final' :	otherwise if fourth element of version does not equals to 'final',
mapping = { 'alpha' : 'a' , 'beta' : 'b' , 'rc' : 'c' }	mapping is a dictionary with 3 initial entries: 'a' for 'alpha', 'b' for 'beta' and 'c' for 'rc'.
sub = mapping [ version [ 3 ] ] + str ( version [ 4 ] )	use fourth element of version as a key to get the value from mapping dictionary, append to it fourth element of version converted to string, substitute it for sub.
return str ( major + sub )	sum major and sub, return the result converted to string.
def get_major_version ( version = None ) :	define the function get_major_version with an argument version defaulting to None.
version = get_complete_version ( version )	call the get_complete_version with an argument version, store the result in version.
parts = 2 if version [ 2 ] == 0 else 3	assign integer 2 to parts if third element of version equals to zero, otherwise assign it integer 3.
major = '.' . join ( str ( x ) for x in version [ : parts ] )	convert x into a string for every x in list of version elements up to the parts index, join the previous into a string separated by '.', assign the result to major.
return major	return major.
def get_complete_version ( version = None ) :	define the function get_complete_version with in argument version, defaulting to None.
if version is None :	if version is None,
from django import VERSION as version	from django import VERSION as version into default name space.
else :	if not,
assert len ( version ) == 5	if length of version does not equals to integer 5, raise an exception.
assert version [ 3 ] in ( 'alpha' , 'beta' , 'rc' , 'final' )	if fourth element of version does not equals to string 'alpha' or 'beta' or 'rc' or 'final', raise an exception.
return version	return version
def get_git_changeset ( ) :	define the function get_git_changeset.
if hasattr ( get_git_changeset , 'cache' ) :	if get_git_changeset has an attribute 'cache',
return get_git_changeset . cache	return get_git_changeset.cache.
repo_dir = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) )	get the absolute path of the __file__, repo_dir is name of the directory two leveles above it.
git_log = subprocess . Popen ( 'git log --pretty=format:%ct --quiet -1 HEAD' ,  stdout = subprocess . PIPE , stderr = subprocess . PIPE ,  shell = True , cwd = repo_dir , universal_newlines = True )	call the subprocess.Popen function with, 'git log --pretty=format:%ct --quiet -1 HEAD', stdout set to subprocess.PIPE,
timestamp = git_log . communicate ( ) [ 0 ]	stderr set to subprocess.PIPE, shell set to boolean True, cwd set to repo_dir and universal_newlines set to boolean True,   as arguments, substitute the result for git_log.   evaluate the method git_log.communicate, substitute first element of the result for timestamp.
try :	try
timestamp = datetime . datetime . utcfromtimestamp ( int ( timestamp ) )	call the datetime.datetime.utcfromtimestamp with timestamp converted to an integer as argument, substitute result for timestamp.
except ValueError :	if ValueError exception is caught,
changeset = None	changeset is None.
else :	if not,
changeset = timestamp . strftime ( '%Y%m%d%H%M%S' )	call the timestamp.strftime with string '%Y%m%d%H%M%S' as an argument, substitute the result for changeset.
get_git_changeset . cache = changeset	substitute changeset for get_git_changeset.cache.
return changeset	return changeset.
from xml . sax . saxutils import XMLGenerator	from xml.sax.saxutils import XMLGenerator into default name space.
class SimplerXMLGenerator ( XMLGenerator ) :	derive the class SimplerXMLGenerator form the XMLGenerator base class.
def addQuickElement ( self , name , contents = None , attrs = None ) :	define the method addQuickElement with 4 arguments: self, name, contents set to None and attrs set to None.
if attrs is None :	if attrs is None,
attrs = { }	attrs is an empty dictionary.
self . startElement ( name , attrs )	cal the method self.startElement with 2 arguments: name and attrs.
if contents is not None :	if contents is not None,
self . characters ( contents )	call the method self.characters with an argument contents.
self . endElement ( name )	call the method self.endElement with an argument name.
